/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/obsidian-dataview/lib/index.js
var require_lib = __commonJS({
  "node_modules/obsidian-dataview/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    require("obsidian");
    var LuxonError = class extends Error {
    };
    var InvalidDateTimeError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid DateTime: ${reason.toMessage()}`);
      }
    };
    var InvalidIntervalError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Interval: ${reason.toMessage()}`);
      }
    };
    var InvalidDurationError = class extends LuxonError {
      constructor(reason) {
        super(`Invalid Duration: ${reason.toMessage()}`);
      }
    };
    var ConflictingSpecificationError = class extends LuxonError {
    };
    var InvalidUnitError = class extends LuxonError {
      constructor(unit) {
        super(`Invalid unit ${unit}`);
      }
    };
    var InvalidArgumentError = class extends LuxonError {
    };
    var ZoneIsAbstractError = class extends LuxonError {
      constructor() {
        super("Zone is an abstract class");
      }
    };
    var n2 = "numeric";
    var s3 = "short";
    var l3 = "long";
    var DATE_SHORT = {
      year: n2,
      month: n2,
      day: n2
    };
    var DATE_MED = {
      year: n2,
      month: s3,
      day: n2
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n2,
      month: s3,
      day: n2,
      weekday: s3
    };
    var DATE_FULL = {
      year: n2,
      month: l3,
      day: n2
    };
    var DATE_HUGE = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3
    };
    var TIME_SIMPLE = {
      hour: n2,
      minute: n2
    };
    var TIME_WITH_SECONDS = {
      hour: n2,
      minute: n2,
      second: n2
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s3
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l3
    };
    var TIME_24_SIMPLE = {
      hour: n2,
      minute: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: s3
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n2,
      minute: n2,
      second: n2,
      hourCycle: "h23",
      timeZoneName: l3
    };
    var DATETIME_SHORT = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n2,
      month: n2,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED = {
      year: n2,
      month: s3,
      day: n2,
      hour: n2,
      minute: n2
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n2,
      month: s3,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n2,
      month: s3,
      day: n2,
      weekday: s3,
      hour: n2,
      minute: n2
    };
    var DATETIME_FULL = {
      year: n2,
      month: l3,
      day: n2,
      hour: n2,
      minute: n2,
      timeZoneName: s3
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n2,
      month: l3,
      day: n2,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: s3
    };
    var DATETIME_HUGE = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3,
      hour: n2,
      minute: n2,
      timeZoneName: l3
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n2,
      month: l3,
      day: n2,
      weekday: l3,
      hour: n2,
      minute: n2,
      second: n2,
      timeZoneName: l3
    };
    var Zone = class {
      /**
       * The type of zone
       * @abstract
       * @type {string}
       */
      get type() {
        throw new ZoneIsAbstractError();
      }
      /**
       * The name of this zone.
       * @abstract
       * @type {string}
       */
      get name() {
        throw new ZoneIsAbstractError();
      }
      get ianaName() {
        return this.name;
      }
      /**
       * Returns whether the offset is known to be fixed for the whole year.
       * @abstract
       * @type {boolean}
       */
      get isUniversal() {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      formatOffset(ts, format) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      offset(ts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      equals(otherZone) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      get isValid() {
        throw new ZoneIsAbstractError();
      }
    };
    var singleton$1 = null;
    var SystemZone = class extends Zone {
      /**
       * Get a singleton instance of the local zone
       * @return {SystemZone}
       */
      static get instance() {
        if (singleton$1 === null) {
          singleton$1 = new SystemZone();
        }
        return singleton$1;
      }
      /** @override **/
      get type() {
        return "system";
      }
      /** @override **/
      get name() {
        return new Intl.DateTimeFormat().resolvedOptions().timeZone;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var dtfCache = {};
    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          era: "short"
        });
      }
      return dtfCache[zone];
    }
    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      era: 3,
      hour: 4,
      minute: 5,
      second: 6
    };
    function hackyOffset(dtf, date) {
      const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
      return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
    }
    function partsOffset(dtf, date) {
      const formatted = dtf.formatToParts(date);
      const filled = [];
      for (let i3 = 0; i3 < formatted.length; i3++) {
        const { type, value } = formatted[i3];
        const pos = typeToPos[type];
        if (type === "era") {
          filled[pos] = value;
        } else if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }
      return filled;
    }
    var ianaZoneCache = {};
    var IANAZone = class extends Zone {
      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      static create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone(name);
        }
        return ianaZoneCache[name];
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
       * @return {boolean}
       */
      static isValidSpecifier(s4) {
        return this.isValidZone(s4);
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      static isValidZone(zone) {
        if (!zone) {
          return false;
        }
        try {
          new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
          return true;
        } catch (e3) {
          return false;
        }
      }
      constructor(name) {
        super();
        this.zoneName = name;
        this.valid = IANAZone.isValidZone(name);
      }
      /** @override **/
      get type() {
        return "iana";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName(ts, { format, locale }) {
        return parseZoneInfo(ts, format, locale, this.name);
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      offset(ts) {
        const date = new Date(ts);
        if (isNaN(date))
          return NaN;
        const dtf = makeDTF(this.name);
        let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
        if (adOrBc === "BC") {
          year = -Math.abs(year) + 1;
        }
        const adjustedHour = hour === 24 ? 0 : hour;
        const asUTC = objToLocalTS({
          year,
          month,
          day,
          hour: adjustedHour,
          minute,
          second,
          millisecond: 0
        });
        let asTS = +date;
        const over = asTS % 1e3;
        asTS -= over >= 0 ? over : 1e3 + over;
        return (asUTC - asTS) / (60 * 1e3);
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /** @override **/
      get isValid() {
        return this.valid;
      }
    };
    var intlLFCache = {};
    function getCachedLF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlLFCache[key];
      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }
      return dtf;
    }
    var intlDTCache = {};
    function getCachedDTF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let dtf = intlDTCache[key];
      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }
      return dtf;
    }
    var intlNumCache = {};
    function getCachedINF(locString, opts = {}) {
      const key = JSON.stringify([locString, opts]);
      let inf = intlNumCache[key];
      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }
      return inf;
    }
    var intlRelCache = {};
    function getCachedRTF(locString, opts = {}) {
      const { base, ...cacheKeyOpts } = opts;
      const key = JSON.stringify([locString, cacheKeyOpts]);
      let inf = intlRelCache[key];
      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }
      return inf;
    }
    var sysLocaleCache = null;
    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }
    function parseLocaleString(localeStr) {
      const xIndex = localeStr.indexOf("-x-");
      if (xIndex !== -1) {
        localeStr = localeStr.substring(0, xIndex);
      }
      const uIndex = localeStr.indexOf("-u-");
      if (uIndex === -1) {
        return [localeStr];
      } else {
        let options;
        let selectedStr;
        try {
          options = getCachedDTF(localeStr).resolvedOptions();
          selectedStr = localeStr;
        } catch (e3) {
          const smaller = localeStr.substring(0, uIndex);
          options = getCachedDTF(smaller).resolvedOptions();
          selectedStr = smaller;
        }
        const { numberingSystem, calendar } = options;
        return [selectedStr, numberingSystem, calendar];
      }
    }
    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        if (!localeStr.includes("-u-")) {
          localeStr += "-u";
        }
        if (outputCalendar) {
          localeStr += `-ca-${outputCalendar}`;
        }
        if (numberingSystem) {
          localeStr += `-nu-${numberingSystem}`;
        }
        return localeStr;
      } else {
        return localeStr;
      }
    }
    function mapMonths(f3) {
      const ms = [];
      for (let i3 = 1; i3 <= 12; i3++) {
        const dt = DateTime2.utc(2009, i3, 1);
        ms.push(f3(dt));
      }
      return ms;
    }
    function mapWeekdays(f3) {
      const ms = [];
      for (let i3 = 1; i3 <= 7; i3++) {
        const dt = DateTime2.utc(2016, 11, 13 + i3);
        ms.push(f3(dt));
      }
      return ms;
    }
    function listStuff(loc, length, englishFn, intlFn) {
      const mode = loc.listingMode();
      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }
    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    var PolyNumberFormatter = class {
      constructor(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;
        const { padTo, floor, ...otherOpts } = opts;
        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          const intlOpts = { useGrouping: false, ...opts };
          if (opts.padTo > 0)
            intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }
      format(i3) {
        if (this.inf) {
          const fixed = this.floor ? Math.floor(i3) : i3;
          return this.inf.format(fixed);
        } else {
          const fixed = this.floor ? Math.floor(i3) : roundTo(i3, 3);
          return padStart3(fixed, this.padTo);
        }
      }
    };
    var PolyDateFormatter = class {
      constructor(dt, intl, opts) {
        this.opts = opts;
        this.originalZone = void 0;
        let z3 = void 0;
        if (this.opts.timeZone) {
          this.dt = dt;
        } else if (dt.zone.type === "fixed") {
          const gmtOffset = -1 * (dt.offset / 60);
          const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z3 = offsetZ;
            this.dt = dt;
          } else {
            z3 = "UTC";
            this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
            this.originalZone = dt.zone;
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else if (dt.zone.type === "iana") {
          this.dt = dt;
          z3 = dt.zone.name;
        } else {
          z3 = "UTC";
          this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
        const intlOpts = { ...this.opts };
        intlOpts.timeZone = intlOpts.timeZone || z3;
        this.dtf = getCachedDTF(intl, intlOpts);
      }
      format() {
        if (this.originalZone) {
          return this.formatToParts().map(({ value }) => value).join("");
        }
        return this.dtf.format(this.dt.toJSDate());
      }
      formatToParts() {
        const parts = this.dtf.formatToParts(this.dt.toJSDate());
        if (this.originalZone) {
          return parts.map((part) => {
            if (part.type === "timeZoneName") {
              const offsetName = this.originalZone.offsetName(this.dt.ts, {
                locale: this.dt.locale,
                format: this.opts.timeZoneName
              });
              return {
                ...part,
                value: offsetName
              };
            } else {
              return part;
            }
          });
        }
        return parts;
      }
      resolvedOptions() {
        return this.dtf.resolvedOptions();
      }
    };
    var PolyRelFormatter = class {
      constructor(intl, isEnglish, opts) {
        this.opts = { style: "long", ...opts };
        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }
      format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      }
      formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      }
    };
    var Locale = class {
      static fromOpts(opts) {
        return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      }
      static create(locale, numberingSystem, outputCalendar, defaultToEN = false) {
        const specifiedLocale = locale || Settings.defaultLocale;
        const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
        const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
        return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      }
      static resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      }
      static fromObject({ locale, numberingSystem, outputCalendar } = {}) {
        return Locale.create(locale, numberingSystem, outputCalendar);
      }
      constructor(locale, numbering, outputCalendar, specifiedLocale) {
        const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = { format: {}, standalone: {} };
        this.monthsCache = { format: {}, standalone: {} };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }
      get fastNumbers() {
        if (this.fastNumbersCached == null) {
          this.fastNumbersCached = supportsFastNumbers(this);
        }
        return this.fastNumbersCached;
      }
      listingMode() {
        const isActuallyEn = this.isEnglish();
        const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      }
      clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale.create(
            alts.locale || this.specifiedLocale,
            alts.numberingSystem || this.numberingSystem,
            alts.outputCalendar || this.outputCalendar,
            alts.defaultToEN || false
          );
        }
      }
      redefaultToEN(alts = {}) {
        return this.clone({ ...alts, defaultToEN: true });
      }
      redefaultToSystem(alts = {}) {
        return this.clone({ ...alts, defaultToEN: false });
      }
      months(length, format = false) {
        return listStuff(this, length, months, () => {
          const intl = format ? { month: length, day: "numeric" } : { month: length }, formatStr = format ? "format" : "standalone";
          if (!this.monthsCache[formatStr][length]) {
            this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
          }
          return this.monthsCache[formatStr][length];
        });
      }
      weekdays(length, format = false) {
        return listStuff(this, length, weekdays, () => {
          const intl = format ? { weekday: length, year: "numeric", month: "long", day: "numeric" } : { weekday: length }, formatStr = format ? "format" : "standalone";
          if (!this.weekdaysCache[formatStr][length]) {
            this.weekdaysCache[formatStr][length] = mapWeekdays(
              (dt) => this.extract(dt, intl, "weekday")
            );
          }
          return this.weekdaysCache[formatStr][length];
        });
      }
      meridiems() {
        return listStuff(
          this,
          void 0,
          () => meridiems,
          () => {
            if (!this.meridiemCache) {
              const intl = { hour: "numeric", hourCycle: "h12" };
              this.meridiemCache = [DateTime2.utc(2016, 11, 13, 9), DateTime2.utc(2016, 11, 13, 19)].map(
                (dt) => this.extract(dt, intl, "dayperiod")
              );
            }
            return this.meridiemCache;
          }
        );
      }
      eras(length) {
        return listStuff(this, length, eras, () => {
          const intl = { era: length };
          if (!this.eraCache[length]) {
            this.eraCache[length] = [DateTime2.utc(-40, 1, 1), DateTime2.utc(2017, 1, 1)].map(
              (dt) => this.extract(dt, intl, "era")
            );
          }
          return this.eraCache[length];
        });
      }
      extract(dt, intlOpts, field) {
        const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m3) => m3.type.toLowerCase() === field);
        return matching ? matching.value : null;
      }
      numberFormatter(opts = {}) {
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      }
      dtFormatter(dt, intlOpts = {}) {
        return new PolyDateFormatter(dt, this.intl, intlOpts);
      }
      relFormatter(opts = {}) {
        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      }
      listFormatter(opts = {}) {
        return getCachedLF(this.intl, opts);
      }
      isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      }
      equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      }
    };
    var singleton = null;
    var FixedOffsetZone = class extends Zone {
      /**
       * Get a singleton instance of UTC
       * @return {FixedOffsetZone}
       */
      static get utcInstance() {
        if (singleton === null) {
          singleton = new FixedOffsetZone(0);
        }
        return singleton;
      }
      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      static instance(offset2) {
        return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      static parseSpecifier(s4) {
        if (s4) {
          const r3 = s4.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
          if (r3) {
            return new FixedOffsetZone(signedOffset(r3[1], r3[2]));
          }
        }
        return null;
      }
      constructor(offset2) {
        super();
        this.fixed = offset2;
      }
      /** @override **/
      get type() {
        return "fixed";
      }
      /** @override **/
      get name() {
        return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
      }
      get ianaName() {
        if (this.fixed === 0) {
          return "Etc/UTC";
        } else {
          return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
        }
      }
      /** @override **/
      offsetName() {
        return this.name;
      }
      /** @override **/
      formatOffset(ts, format) {
        return formatOffset(this.fixed, format);
      }
      /** @override **/
      get isUniversal() {
        return true;
      }
      /** @override **/
      offset() {
        return this.fixed;
      }
      /** @override **/
      equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /** @override **/
      get isValid() {
        return true;
      }
    };
    var InvalidZone = class extends Zone {
      constructor(zoneName) {
        super();
        this.zoneName = zoneName;
      }
      /** @override **/
      get type() {
        return "invalid";
      }
      /** @override **/
      get name() {
        return this.zoneName;
      }
      /** @override **/
      get isUniversal() {
        return false;
      }
      /** @override **/
      offsetName() {
        return null;
      }
      /** @override **/
      formatOffset() {
        return "";
      }
      /** @override **/
      offset() {
        return NaN;
      }
      /** @override **/
      equals() {
        return false;
      }
      /** @override **/
      get isValid() {
        return false;
      }
    };
    function normalizeZone(input, defaultZone2) {
      if (isUndefined(input) || input === null) {
        return defaultZone2;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString(input)) {
        const lowered = input.toLowerCase();
        if (lowered === "default")
          return defaultZone2;
        else if (lowered === "local" || lowered === "system")
          return SystemZone.instance;
        else if (lowered === "utc" || lowered === "gmt")
          return FixedOffsetZone.utcInstance;
        else
          return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
      } else if (isNumber2(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
        return input;
      } else {
        return new InvalidZone(input);
      }
    }
    var now = () => Date.now();
    var defaultZone = "system";
    var defaultLocale = null;
    var defaultNumberingSystem = null;
    var defaultOutputCalendar = null;
    var twoDigitCutoffYear = 60;
    var throwOnInvalid;
    var Settings = class {
      /**
       * Get the callback for returning the current timestamp.
       * @type {function}
       */
      static get now() {
        return now;
      }
      /**
       * Set the callback for returning the current timestamp.
       * The function should return a number, which will be interpreted as an Epoch millisecond count
       * @type {function}
       * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
       * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
       */
      static set now(n3) {
        now = n3;
      }
      /**
       * Set the default time zone to create DateTimes in. Does not affect existing instances.
       * Use the value "system" to reset this value to the system's time zone.
       * @type {string}
       */
      static set defaultZone(zone) {
        defaultZone = zone;
      }
      /**
       * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
       * The default value is the system's time zone (the one set on the machine that runs this code).
       * @type {Zone}
       */
      static get defaultZone() {
        return normalizeZone(defaultZone, SystemZone.instance);
      }
      /**
       * Get the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultLocale() {
        return defaultLocale;
      }
      /**
       * Set the default locale to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultLocale(locale) {
        defaultLocale = locale;
      }
      /**
       * Get the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultNumberingSystem() {
        return defaultNumberingSystem;
      }
      /**
       * Set the default numbering system to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultNumberingSystem(numberingSystem) {
        defaultNumberingSystem = numberingSystem;
      }
      /**
       * Get the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static get defaultOutputCalendar() {
        return defaultOutputCalendar;
      }
      /**
       * Set the default output calendar to create DateTimes with. Does not affect existing instances.
       * @type {string}
       */
      static set defaultOutputCalendar(outputCalendar) {
        defaultOutputCalendar = outputCalendar;
      }
      /**
       * Get the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       */
      static get twoDigitCutoffYear() {
        return twoDigitCutoffYear;
      }
      /**
       * Set the cutoff year after which a string encoding a year as two digits is interpreted to occur in the current century.
       * @type {number}
       * @example Settings.twoDigitCutoffYear = 0 // cut-off year is 0, so all 'yy' are interpreted as current century
       * @example Settings.twoDigitCutoffYear = 50 // '49' -> 1949; '50' -> 2050
       * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
       * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
       */
      static set twoDigitCutoffYear(cutoffYear) {
        twoDigitCutoffYear = cutoffYear % 100;
      }
      /**
       * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static get throwOnInvalid() {
        return throwOnInvalid;
      }
      /**
       * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
       * @type {boolean}
       */
      static set throwOnInvalid(t3) {
        throwOnInvalid = t3;
      }
      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      static resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      }
    };
    function isUndefined(o2) {
      return typeof o2 === "undefined";
    }
    function isNumber2(o2) {
      return typeof o2 === "number";
    }
    function isInteger(o2) {
      return typeof o2 === "number" && o2 % 1 === 0;
    }
    function isString(o2) {
      return typeof o2 === "string";
    }
    function isDate2(o2) {
      return Object.prototype.toString.call(o2) === "[object Date]";
    }
    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e3) {
        return false;
      }
    }
    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return void 0;
      }
      return arr.reduce((best, next) => {
        const pair = [by(next), next];
        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce((a3, k3) => {
        a3[k3] = obj[k3];
        return a3;
      }, {});
    }
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    function integerBetween(thing, bottom, top) {
      return isInteger(thing) && thing >= bottom && thing <= top;
    }
    function floorMod(x4, n3) {
      return x4 - n3 * Math.floor(x4 / n3);
    }
    function padStart3(input, n3 = 2) {
      const isNeg = input < 0;
      let padded;
      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n3, "0");
      } else {
        padded = ("" + input).padStart(n3, "0");
      }
      return padded;
    }
    function parseInteger(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating(string) {
      if (isUndefined(string) || string === null || string === "") {
        return void 0;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis(fraction) {
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return void 0;
      } else {
        const f3 = parseFloat("0." + fraction) * 1e3;
        return Math.floor(f3);
      }
    }
    function roundTo(number, digits, towardZero = false) {
      const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    }
    function isLeapYear2(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear2(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
      if (modMonth === 2) {
        return isLeapYear2(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    }
    function objToLocalTS(obj) {
      let d2 = Date.UTC(
        obj.year,
        obj.month - 1,
        obj.day,
        obj.hour,
        obj.minute,
        obj.second,
        obj.millisecond
      );
      if (obj.year < 100 && obj.year >= 0) {
        d2 = new Date(d2);
        d2.setUTCFullYear(obj.year, obj.month - 1, obj.day);
      }
      return +d2;
    }
    function weeksInWeekYear(weekYear) {
      const p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7, last = weekYear - 1, p22 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p22 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else
        return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
    }
    function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
      const date = new Date(ts), intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };
      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }
      const modified = { timeZoneName: offsetFormat, ...intlOpts };
      const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m3) => m3.type.toLowerCase() === "timezonename");
      return parsed ? parsed.value : null;
    }
    function signedOffset(offHourStr, offMinuteStr) {
      let offHour = parseInt(offHourStr, 10);
      if (Number.isNaN(offHour)) {
        offHour = 0;
      }
      const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    }
    function asNumber(value) {
      const numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue))
        throw new InvalidArgumentError(`Invalid unit value ${value}`);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      const normalized = {};
      for (const u3 in obj) {
        if (hasOwnProperty2(obj, u3)) {
          const v3 = obj[u3];
          if (v3 === void 0 || v3 === null)
            continue;
          normalized[normalizer(u3)] = asNumber(v3);
        }
      }
      return normalized;
    }
    function formatOffset(offset2, format) {
      const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
      switch (format) {
        case "short":
          return `${sign}${padStart3(hours, 2)}:${padStart3(minutes, 2)}`;
        case "narrow":
          return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
        case "techie":
          return `${sign}${padStart3(hours, 2)}${padStart3(minutes, 2)}`;
        default:
          throw new RangeError(`Value format ${format} is out of range for property format`);
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var monthsLong = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    var monthsShort = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months(length) {
      switch (length) {
        case "narrow":
          return [...monthsNarrow];
        case "short":
          return [...monthsShort];
        case "long":
          return [...monthsLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
        default:
          return null;
      }
    }
    var weekdaysLong = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [...weekdaysNarrow];
        case "short":
          return [...weekdaysShort];
        case "long":
          return [...weekdaysLong];
        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];
        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [...erasNarrow];
        case "short":
          return [...erasShort];
        case "long":
          return [...erasLong];
        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
      const units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
      if (numeric === "auto" && lastable) {
        const isDay = unit === "days";
        switch (count) {
          case 1:
            return isDay ? "tomorrow" : `next ${units[unit][0]}`;
          case -1:
            return isDay ? "yesterday" : `last ${units[unit][0]}`;
          case 0:
            return isDay ? "today" : `this ${units[unit][0]}`;
        }
      }
      const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
    }
    function stringifyTokens(splits, tokenToString) {
      let s4 = "";
      for (const token of splits) {
        if (token.literal) {
          s4 += token.val;
        } else {
          s4 += tokenToString(token.val);
        }
      }
      return s4;
    }
    var macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    var Formatter = class {
      static create(locale, opts = {}) {
        return new Formatter(locale, opts);
      }
      static parseFormat(fmt) {
        let current = null, currentFull = "", bracketed = false;
        const splits = [];
        for (let i3 = 0; i3 < fmt.length; i3++) {
          const c3 = fmt.charAt(i3);
          if (c3 === "'") {
            if (currentFull.length > 0) {
              splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
            }
            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c3;
          } else if (c3 === current) {
            currentFull += c3;
          } else {
            if (currentFull.length > 0) {
              splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
            }
            currentFull = c3;
            current = c3;
          }
        }
        if (currentFull.length > 0) {
          splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
        }
        return splits;
      }
      static macroTokenToFormatOpts(token) {
        return macroTokenToFormatOpts[token];
      }
      constructor(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }
      formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }
        const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
        return df.format();
      }
      dtFormatter(dt, opts = {}) {
        return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
      }
      formatDateTime(dt, opts) {
        return this.dtFormatter(dt, opts).format();
      }
      formatDateTimeParts(dt, opts) {
        return this.dtFormatter(dt, opts).formatToParts();
      }
      formatInterval(interval, opts) {
        const df = this.dtFormatter(interval.start, opts);
        return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
      }
      resolvedOptions(dt, opts) {
        return this.dtFormatter(dt, opts).resolvedOptions();
      }
      num(n3, p3 = 0) {
        if (this.opts.forceSimple) {
          return padStart3(n3, p3);
        }
        const opts = { ...this.opts };
        if (p3 > 0) {
          opts.padTo = p3;
        }
        return this.loc.numberFormatter(opts).format(n3);
      }
      formatDateTimeFromString(dt, fmt) {
        const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }
          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string(standalone ? { month: length } : { month: length, day: "numeric" }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string(
          standalone ? { weekday: length } : { weekday: length, month: "long", day: "numeric" },
          "weekday"
        ), maybeMacro = (token) => {
          const formatOpts = Formatter.macroTokenToFormatOpts(token);
          if (formatOpts) {
            return this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string({ era: length }, "era"), tokenToString = (token) => {
          switch (token) {
            case "S":
              return this.num(dt.millisecond);
            case "u":
            case "SSS":
              return this.num(dt.millisecond, 3);
            case "s":
              return this.num(dt.second);
            case "ss":
              return this.num(dt.second, 2);
            case "uu":
              return this.num(Math.floor(dt.millisecond / 10), 2);
            case "uuu":
              return this.num(Math.floor(dt.millisecond / 100));
            case "m":
              return this.num(dt.minute);
            case "mm":
              return this.num(dt.minute, 2);
            case "h":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
            case "hh":
              return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
            case "H":
              return this.num(dt.hour);
            case "HH":
              return this.num(dt.hour, 2);
            case "Z":
              return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
            case "ZZ":
              return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
            case "ZZZ":
              return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
            case "ZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
            case "ZZZZZ":
              return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
            case "z":
              return dt.zoneName;
            case "a":
              return meridiem();
            case "d":
              return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
            case "dd":
              return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
            case "c":
              return this.num(dt.weekday);
            case "ccc":
              return weekday("short", true);
            case "cccc":
              return weekday("long", true);
            case "ccccc":
              return weekday("narrow", true);
            case "E":
              return this.num(dt.weekday);
            case "EEE":
              return weekday("short", false);
            case "EEEE":
              return weekday("long", false);
            case "EEEEE":
              return weekday("narrow", false);
            case "L":
              return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
            case "LL":
              return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
            case "LLL":
              return month("short", true);
            case "LLLL":
              return month("long", true);
            case "LLLLL":
              return month("narrow", true);
            case "M":
              return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
            case "MM":
              return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
            case "MMM":
              return month("short", false);
            case "MMMM":
              return month("long", false);
            case "MMMMM":
              return month("narrow", false);
            case "y":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
            case "yy":
              return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
            case "yyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
            case "yyyyyy":
              return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
            case "G":
              return era("short");
            case "GG":
              return era("long");
            case "GGGGG":
              return era("narrow");
            case "kk":
              return this.num(dt.weekYear.toString().slice(-2), 2);
            case "kkkk":
              return this.num(dt.weekYear, 4);
            case "W":
              return this.num(dt.weekNumber);
            case "WW":
              return this.num(dt.weekNumber, 2);
            case "o":
              return this.num(dt.ordinal);
            case "ooo":
              return this.num(dt.ordinal, 3);
            case "q":
              return this.num(dt.quarter);
            case "qq":
              return this.num(dt.quarter, 2);
            case "X":
              return this.num(Math.floor(dt.ts / 1e3));
            case "x":
              return this.num(dt.ts);
            default:
              return maybeMacro(token);
          }
        };
        return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
      }
      formatDurationFromString(dur, fmt) {
        const tokenToField = (token) => {
          switch (token[0]) {
            case "S":
              return "millisecond";
            case "s":
              return "second";
            case "m":
              return "minute";
            case "h":
              return "hour";
            case "d":
              return "day";
            case "w":
              return "week";
            case "M":
              return "month";
            case "y":
              return "year";
            default:
              return null;
          }
        }, tokenToString = (lildur) => (token) => {
          const mapped = tokenToField(token);
          if (mapped) {
            return this.num(lildur.get(mapped), token.length);
          } else {
            return token;
          }
        }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce(
          (found, { literal, val }) => literal ? found : found.concat(val),
          []
        ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t3) => t3));
        return stringifyTokens(tokens, tokenToString(collapsed));
      }
    };
    var Invalid = class {
      constructor(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }
      toMessage() {
        if (this.explanation) {
          return `${this.reason}: ${this.explanation}`;
        } else {
          return this.reason;
        }
      }
    };
    var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
    function combineRegexes(...regexes) {
      const full = regexes.reduce((f3, r3) => f3 + r3.source, "");
      return RegExp(`^${full}$`);
    }
    function combineExtractors(...extractors) {
      return (m3) => extractors.reduce(
        ([mergedVals, mergedZone, cursor], ex) => {
          const [val, zone, next] = ex(m3, cursor);
          return [{ ...mergedVals, ...val }, zone || mergedZone, next];
        },
        [{}, null, 1]
      ).slice(0, 2);
    }
    function parse3(s4, ...patterns) {
      if (s4 == null) {
        return [null, null];
      }
      for (const [regex, extractor] of patterns) {
        const m3 = regex.exec(s4);
        if (m3) {
          return extractor(m3);
        }
      }
      return [null, null];
    }
    function simpleParse(...keys) {
      return (match2, cursor) => {
        const ret = {};
        let i3;
        for (i3 = 0; i3 < keys.length; i3++) {
          ret[keys[i3]] = parseInteger(match2[cursor + i3]);
        }
        return [ret, null, cursor + i3];
      };
    }
    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
    var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
    var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
    var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
    var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
    var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
    var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
    var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
    var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
    var extractISOOrdinalData = simpleParse("year", "ordinal");
    var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
    var sqlTimeRegex = RegExp(
      `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
    );
    var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
    function int(match2, pos, fallback) {
      const m3 = match2[pos];
      return isUndefined(m3) ? fallback : parseInteger(m3);
    }
    function extractISOYmd(match2, cursor) {
      const item = {
        year: int(match2, cursor),
        month: int(match2, cursor + 1, 1),
        day: int(match2, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }
    function extractISOTime(match2, cursor) {
      const item = {
        hours: int(match2, cursor, 0),
        minutes: int(match2, cursor + 1, 0),
        seconds: int(match2, cursor + 2, 0),
        milliseconds: parseMillis(match2[cursor + 3])
      };
      return [item, null, cursor + 4];
    }
    function extractISOOffset(match2, cursor) {
      const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }
    function extractIANAZone(match2, cursor) {
      const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
      return [{}, zone, cursor + 1];
    }
    var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
    var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
    function extractISODuration(match2) {
      const [s4, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
      const hasNegativePrefix = s4[0] === "-";
      const negativeSeconds = secondStr && secondStr[0] === "-";
      const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
      return [
        {
          years: maybeNegate(parseFloating(yearStr)),
          months: maybeNegate(parseFloating(monthStr)),
          weeks: maybeNegate(parseFloating(weekStr)),
          days: maybeNegate(parseFloating(dayStr)),
          hours: maybeNegate(parseFloating(hourStr)),
          minutes: maybeNegate(parseFloating(minuteStr)),
          seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
          milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
        }
      ];
    }
    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      const result = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr)
        result.second = parseInteger(secondStr);
      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }
      return result;
    }
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
    function extractRFC2822(match2) {
      const [
        ,
        weekdayStr,
        dayStr,
        monthStr,
        yearStr,
        hourStr,
        minuteStr,
        secondStr,
        obsOffset,
        milOffset,
        offHourStr,
        offMinuteStr
      ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      let offset2;
      if (obsOffset) {
        offset2 = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset2 = 0;
      } else {
        offset2 = signedOffset(offHourStr, offMinuteStr);
      }
      return [result, new FixedOffsetZone(offset2)];
    }
    function preprocessRFC2822(s4) {
      return s4.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    }
    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
    var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
    var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
    function extractRFC1123Or850(match2) {
      const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    function extractASCII(match2) {
      const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }
    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(
      extractISOYmd,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOWeekTimeAndOffset = combineExtractors(
      extractISOWeekData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOOrdinalDateAndTime = combineExtractors(
      extractISOOrdinalData,
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    var extractISOTimeAndOffset = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseISODate(s4) {
      return parse3(
        s4,
        [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
        [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
        [isoTimeCombinedRegex, extractISOTimeAndOffset]
      );
    }
    function parseRFC2822Date(s4) {
      return parse3(preprocessRFC2822(s4), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s4) {
      return parse3(
        s4,
        [rfc1123, extractRFC1123Or850],
        [rfc850, extractRFC1123Or850],
        [ascii, extractASCII]
      );
    }
    function parseISODuration(s4) {
      return parse3(s4, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s4) {
      return parse3(s4, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(
      extractISOTime,
      extractISOOffset,
      extractIANAZone
    );
    function parseSQL(s4) {
      return parse3(
        s4,
        [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
        [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
      );
    }
    var INVALID$2 = "Invalid Duration";
    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1e3
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1e3
      },
      hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
      minutes: { seconds: 60, milliseconds: 60 * 1e3 },
      seconds: { milliseconds: 1e3 }
    };
    var casualMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1e3
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var daysInYearAccurate = 146097 / 400;
    var daysInMonthAccurate = 146097 / 4800;
    var accurateMatrix = {
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
      },
      ...lowOrderMatrix
    };
    var orderedUnits$1 = [
      "years",
      "quarters",
      "months",
      "weeks",
      "days",
      "hours",
      "minutes",
      "seconds",
      "milliseconds"
    ];
    var reverseUnits = orderedUnits$1.slice(0).reverse();
    function clone$1(dur, alts, clear = false) {
      const conf = {
        values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
        matrix: alts.matrix || dur.matrix
      };
      return new Duration(conf);
    }
    function durationToMillis(matrix, vals) {
      var _a;
      let sum = (_a = vals.milliseconds) != null ? _a : 0;
      for (const unit of reverseUnits.slice(1)) {
        if (vals[unit]) {
          sum += vals[unit] * matrix[unit]["milliseconds"];
        }
      }
      return sum;
    }
    function normalizeValues(matrix, vals) {
      const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
      orderedUnits$1.reduceRight((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            const previousVal = vals[previous] * factor;
            const conv = matrix[current][previous];
            const rollUp = Math.floor(previousVal / conv);
            vals[current] += rollUp * factor;
            vals[previous] -= rollUp * conv * factor;
          }
          return current;
        } else {
          return previous;
        }
      }, null);
      orderedUnits$1.reduce((previous, current) => {
        if (!isUndefined(vals[current])) {
          if (previous) {
            const fraction = vals[previous] % 1;
            vals[previous] -= fraction;
            vals[current] += fraction * matrix[previous][current];
          }
          return current;
        } else {
          return previous;
        }
      }, null);
    }
    function removeZeroes(vals) {
      const newVals = {};
      for (const [key, value] of Object.entries(vals)) {
        if (value !== 0) {
          newVals[key] = value;
        }
      }
      return newVals;
    }
    var Duration = class {
      /**
       * @private
       */
      constructor(config2) {
        const accurate = config2.conversionAccuracy === "longterm" || false;
        let matrix = accurate ? accurateMatrix : casualMatrix;
        if (config2.matrix) {
          matrix = config2.matrix;
        }
        this.values = config2.values;
        this.loc = config2.loc || Locale.create();
        this.conversionAccuracy = accurate ? "longterm" : "casual";
        this.invalid = config2.invalid || null;
        this.matrix = matrix;
        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      static fromMillis(count, opts) {
        return Duration.fromObject({ milliseconds: count }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the custom conversion system to use
       * @return {Duration}
       */
      static fromObject(obj, opts = {}) {
        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError(
            `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
          );
        }
        return new Duration({
          values: normalizeObject(obj, Duration.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy,
          matrix: opts.matrix
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      static fromDurationLike(durationLike) {
        if (isNumber2(durationLike)) {
          return Duration.fromMillis(durationLike);
        } else if (Duration.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError(
            `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
          );
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the preset conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      static fromISO(text, opts) {
        const [parsed] = parseISODuration(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
       * @param {string} [opts.matrix=Object] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      static fromISOTime(text, opts) {
        const [parsed] = parseISOTimeOnly(text);
        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDurationError(invalid);
        } else {
          return new Duration({ invalid });
        }
      }
      /**
       * @private
       */
      static normalizeUnit(unit) {
        const normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized)
          throw new InvalidUnitError(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDuration(o2) {
        return o2 && o2.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `w` for weeks
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * Tokens can be escaped by wrapping with single quotes.
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        const fmtOpts = {
          ...opts,
          floor: opts.round !== false && opts.floor !== false
        };
        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      }
      /**
       * Returns a string representation of a Duration with all units included.
       * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat
       * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
       * @example
       * ```js
       * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
       * ```
       */
      toHuman(opts = {}) {
        if (!this.isValid)
          return INVALID$2;
        const l4 = orderedUnits$1.map((unit) => {
          const val = this.values[unit];
          if (isUndefined(val)) {
            return null;
          }
          return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
        }).filter((n3) => n3);
        return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l4);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      toObject() {
        if (!this.isValid)
          return {};
        return { ...this.values };
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      toISO() {
        if (!this.isValid)
          return null;
        let s4 = "P";
        if (this.years !== 0)
          s4 += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0)
          s4 += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0)
          s4 += this.weeks + "W";
        if (this.days !== 0)
          s4 += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
          s4 += "T";
        if (this.hours !== 0)
          s4 += this.hours + "H";
        if (this.minutes !== 0)
          s4 += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0)
          s4 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
        if (s4 === "P")
          s4 += "T0S";
        return s4;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      toISOTime(opts = {}) {
        if (!this.isValid)
          return null;
        const millis = this.toMillis();
        if (millis < 0 || millis >= 864e5)
          return null;
        opts = {
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended",
          ...opts,
          includeOffset: false
        };
        const dateTime = DateTime2.fromMillis(millis, { zone: "UTC" });
        return dateTime.toISOTime(opts);
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      toString() {
        return this.toISO();
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      toMillis() {
        if (!this.isValid)
          return NaN;
        return durationToMillis(this.matrix, this.values);
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration), result = {};
        for (const k3 of orderedUnits$1) {
          if (hasOwnProperty2(dur.values, k3) || hasOwnProperty2(this.values, k3)) {
            result[k3] = dur.get(k3) + this.get(k3);
          }
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      mapUnits(fn) {
        if (!this.isValid)
          return this;
        const result = {};
        for (const k3 of Object.keys(this.values)) {
          result[k3] = asNumber(fn(this.values[k3], k3));
        }
        return clone$1(this, { values: result }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      get(unit) {
        return this[Duration.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const mixed = { ...this.values, ...normalizeObject(values, Duration.normalizeUnit) };
        return clone$1(this, { values: mixed });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem });
        const opts = { loc, matrix, conversionAccuracy };
        return clone$1(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * Assuming the overall value of the Duration is positive, this means:
       * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
       * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
       *   the overall value would be negative, see second example)
       * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
       *
       * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
       * @return {Duration}
       */
      normalize() {
        if (!this.isValid)
          return this;
        const vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Rescale units to its largest representation
       * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
       * @return {Duration}
       */
      rescale() {
        if (!this.isValid)
          return this;
        const vals = removeZeroes(this.normalize().shiftToAll().toObject());
        return clone$1(this, { values: vals }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      shiftTo(...units) {
        if (!this.isValid)
          return this;
        if (units.length === 0) {
          return this;
        }
        units = units.map((u3) => Duration.normalizeUnit(u3));
        const built = {}, accumulated = {}, vals = this.toObject();
        let lastUnit;
        for (const k3 of orderedUnits$1) {
          if (units.indexOf(k3) >= 0) {
            lastUnit = k3;
            let own = 0;
            for (const ak in accumulated) {
              own += this.matrix[ak][k3] * accumulated[ak];
              accumulated[ak] = 0;
            }
            if (isNumber2(vals[k3])) {
              own += vals[k3];
            }
            const i3 = Math.trunc(own);
            built[k3] = i3;
            accumulated[k3] = (own * 1e3 - i3 * 1e3) / 1e3;
          } else if (isNumber2(vals[k3])) {
            accumulated[k3] = vals[k3];
          }
        }
        for (const key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }
        normalizeValues(this.matrix, built);
        return clone$1(this, { values: built }, true);
      }
      /**
       * Shift this Duration to all available units.
       * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
       * @return {Duration}
       */
      shiftToAll() {
        if (!this.isValid)
          return this;
        return this.shiftTo(
          "years",
          "months",
          "weeks",
          "days",
          "hours",
          "minutes",
          "seconds",
          "milliseconds"
        );
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      negate() {
        if (!this.isValid)
          return this;
        const negated = {};
        for (const k3 of Object.keys(this.values)) {
          negated[k3] = this.values[k3] === 0 ? 0 : -this.values[k3];
        }
        return clone$1(this, { values: negated }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      get years() {
        return this.isValid ? this.values.years || 0 : NaN;
      }
      /**
       * Get the quarters.
       * @type {number}
       */
      get quarters() {
        return this.isValid ? this.values.quarters || 0 : NaN;
      }
      /**
       * Get the months.
       * @type {number}
       */
      get months() {
        return this.isValid ? this.values.months || 0 : NaN;
      }
      /**
       * Get the weeks
       * @type {number}
       */
      get weeks() {
        return this.isValid ? this.values.weeks || 0 : NaN;
      }
      /**
       * Get the days.
       * @type {number}
       */
      get days() {
        return this.isValid ? this.values.days || 0 : NaN;
      }
      /**
       * Get the hours.
       * @type {number}
       */
      get hours() {
        return this.isValid ? this.values.hours || 0 : NaN;
      }
      /**
       * Get the minutes.
       * @type {number}
       */
      get minutes() {
        return this.isValid ? this.values.minutes || 0 : NaN;
      }
      /**
       * Get the seconds.
       * @return {number}
       */
      get seconds() {
        return this.isValid ? this.values.seconds || 0 : NaN;
      }
      /**
       * Get the milliseconds.
       * @return {number}
       */
      get milliseconds() {
        return this.isValid ? this.values.milliseconds || 0 : NaN;
      }
      /**
       * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
       * on invalid DateTimes or Intervals.
       * @return {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this Duration became invalid, or null if the Duration is valid
       * @return {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        if (!this.loc.equals(other.loc)) {
          return false;
        }
        function eq(v1, v22) {
          if (v1 === void 0 || v1 === 0)
            return v22 === void 0 || v22 === 0;
          return v1 === v22;
        }
        for (const u3 of orderedUnits$1) {
          if (!eq(this.values[u3], other.values[u3])) {
            return false;
          }
        }
        return true;
      }
    };
    var INVALID$1 = "Invalid Interval";
    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid(
          "end before start",
          `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`
        );
      } else {
        return null;
      }
    }
    var Interval = class {
      /**
       * @private
       */
      constructor(config2) {
        this.s = config2.start;
        this.e = config2.end;
        this.invalid = config2.invalid || null;
        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidIntervalError(invalid);
        } else {
          return new Interval({ invalid });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      static fromDateTimes(start, end) {
        const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
        const validateError = validateStartEnd(builtStart, builtEnd);
        if (validateError == null) {
          return new Interval({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static after(start, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
        return Interval.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      static before(end, duration) {
        const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
        return Interval.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      static fromISO(text, opts) {
        const [s4, e3] = (text || "").split("/", 2);
        if (s4 && e3) {
          let start, startIsValid;
          try {
            start = DateTime2.fromISO(s4, opts);
            startIsValid = start.isValid;
          } catch (e4) {
            startIsValid = false;
          }
          let end, endIsValid;
          try {
            end = DateTime2.fromISO(e3, opts);
            endIsValid = end.isValid;
          } catch (e4) {
            endIsValid = false;
          }
          if (startIsValid && endIsValid) {
            return Interval.fromDateTimes(start, end);
          }
          if (startIsValid) {
            const dur = Duration.fromISO(e3, opts);
            if (dur.isValid) {
              return Interval.after(start, dur);
            }
          } else if (endIsValid) {
            const dur = Duration.fromISO(s4, opts);
            if (dur.isValid) {
              return Interval.before(end, dur);
            }
          }
        }
        return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isInterval(o2) {
        return o2 && o2.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      get start() {
        return this.isValid ? this.s : null;
      }
      /**
       * Returns the end of the Interval
       * @type {DateTime}
       */
      get end() {
        return this.isValid ? this.e : null;
      }
      /**
       * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
       * @type {boolean}
       */
      get isValid() {
        return this.invalidReason === null;
      }
      /**
       * Returns an error code if this Interval is invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      length(unit = "milliseconds") {
        return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @return {number}
       */
      count(unit = "milliseconds") {
        if (!this.isValid)
          return NaN;
        const start = this.start.startOf(unit), end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isAfter(dateTime) {
        if (!this.isValid)
          return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      isBefore(dateTime) {
        if (!this.isValid)
          return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      contains(dateTime) {
        if (!this.isValid)
          return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      set({ start, end } = {}) {
        if (!this.isValid)
          return this;
        return Interval.fromDateTimes(start || this.s, end || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      splitAt(...dateTimes) {
        if (!this.isValid)
          return [];
        const sorted = dateTimes.map(friendlyDateTime).filter((d2) => this.contains(d2)).sort(), results = [];
        let { s: s4 } = this, i3 = 0;
        while (s4 < this.e) {
          const added = sorted[i3] || this.e, next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s4, next));
          s4 = next;
          i3 += 1;
        }
        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      splitBy(duration) {
        const dur = Duration.fromDurationLike(duration);
        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }
        let { s: s4 } = this, idx = 1, next;
        const results = [];
        while (s4 < this.e) {
          const added = this.start.plus(dur.mapUnits((x4) => x4 * idx));
          next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s4, next));
          s4 = next;
          idx += 1;
        }
        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      divideEqually(numberOfParts) {
        if (!this.isValid)
          return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsStart(other) {
        if (!this.isValid)
          return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      abutsEnd(other) {
        if (!this.isValid)
          return false;
        return +other.e === +this.s;
      }
      /**
       * Return whether this Interval engulfs the start and end of the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      engulfs(other) {
        if (!this.isValid)
          return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }
        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      intersection(other) {
        if (!this.isValid)
          return this;
        const s4 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
        if (s4 >= e3) {
          return null;
        } else {
          return Interval.fromDateTimes(s4, e3);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      union(other) {
        if (!this.isValid)
          return this;
        const s4 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
        return Interval.fromDateTimes(s4, e3);
      }
      /**
       * Merge an array of Intervals into a equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static merge(intervals) {
        const [found, final] = intervals.sort((a3, b3) => a3.s - b3.s).reduce(
          ([sofar, current], item) => {
            if (!current) {
              return [sofar, item];
            } else if (current.overlaps(item) || current.abutsStart(item)) {
              return [sofar, current.union(item)];
            } else {
              return [sofar.concat([current]), item];
            }
          },
          [[], null]
        );
        if (final) {
          found.push(final);
        }
        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      static xor(intervals) {
        let start = null, currentCount = 0;
        const results = [], ends = intervals.map((i3) => [
          { time: i3.s, type: "s" },
          { time: i3.e, type: "e" }
        ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a3, b3) => a3.time - b3.time);
        for (const i3 of arr) {
          currentCount += i3.type === "s" ? 1 : -1;
          if (currentCount === 1) {
            start = i3.time;
          } else {
            if (start && +start !== +i3.time) {
              results.push(Interval.fromDateTimes(start, i3.time));
            }
            start = null;
          }
        }
        return Interval.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      difference(...intervals) {
        return Interval.xor([this].concat(intervals)).map((i3) => this.intersection(i3)).filter((i3) => i3 && !i3.isEmpty());
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      toString() {
        if (!this.isValid)
          return INVALID$1;
        return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
      }
      /**
       * Returns a localized string representing this Interval. Accepts the same options as the
       * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
       * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
       * is browser-specific, but in general it will return an appropriate representation of the
       * Interval in the assigned locale. Defaults to the system's locale if no locale has been
       * specified.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
       * Intl.DateTimeFormat constructor options.
       * @param {Object} opts - Options to override the configuration of the start DateTime.
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
       * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
       * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISO(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      toISODate() {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISODate()}/${this.e.toISODate()}`;
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      toISOTime(opts) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format
       * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
       * formatting tool.
       * @param {string} dateFormat - The format string. This string formats the start and end time.
       * See {@link DateTime#toFormat} for details.
       * @param {Object} opts - Options.
       * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
       * representations.
       * @return {string}
       */
      toFormat(dateFormat, { separator = " \u2013 " } = {}) {
        if (!this.isValid)
          return INVALID$1;
        return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }
        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      mapEndpoints(mapFn) {
        return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
      }
    };
    var Info = class {
      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      static hasDST(zone = Settings.defaultZone) {
        const proto = DateTime2.now().setZone(zone).set({ month: 12 });
        return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      static isValidIANAZone(zone) {
        return IANAZone.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      static normalizeZone(input) {
        return normalizeZone(input, Settings.defaultZone);
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
       * @return {Array}
       */
      static months(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      static monthsFormat(length = "long", { locale = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
       * @return {Array}
       */
      static weekdays(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      static weekdaysFormat(length = "long", { locale = null, numberingSystem = null, locObj = null } = {}) {
        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
       * @return {Array}
       */
      static meridiems({ locale = null } = {}) {
        return Locale.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
       * @return {Array}
       */
      static eras(length = "short", { locale = null } = {}) {
        return Locale.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * @example Info.features() //=> { relative: false }
       * @return {Object}
       */
      static features() {
        return { relative: hasRelative() };
      }
    };
    function dayDiff(earlier, later) {
      const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
      return Math.floor(Duration.fromMillis(ms).as("days"));
    }
    function highOrderDiffs(cursor, later, units) {
      const differs = [
        ["years", (a3, b3) => b3.year - a3.year],
        ["quarters", (a3, b3) => b3.quarter - a3.quarter + (b3.year - a3.year) * 4],
        ["months", (a3, b3) => b3.month - a3.month + (b3.year - a3.year) * 12],
        [
          "weeks",
          (a3, b3) => {
            const days = dayDiff(a3, b3);
            return (days - days % 7) / 7;
          }
        ],
        ["days", dayDiff]
      ];
      const results = {};
      const earlier = cursor;
      let lowestOrder, highWater;
      for (const [unit, differ] of differs) {
        if (units.indexOf(unit) >= 0) {
          lowestOrder = unit;
          results[unit] = differ(cursor, later);
          highWater = earlier.plus(results);
          if (highWater > later) {
            results[unit]--;
            cursor = earlier.plus(results);
            if (cursor > later) {
              highWater = cursor;
              results[unit]--;
              cursor = earlier.plus(results);
            }
          } else {
            cursor = highWater;
          }
        }
      }
      return [cursor, results, highWater, lowestOrder];
    }
    function diff(earlier, later, units, opts) {
      let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
      const remainingMillis = later - cursor;
      const lowerOrderUnits = units.filter(
        (u3) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u3) >= 0
      );
      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          highWater = cursor.plus({ [lowestOrder]: 1 });
        }
        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }
      const duration = Duration.fromObject(results, opts);
      if (lowerOrderUnits.length > 0) {
        return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }
    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str) {
      let value = parseInt(str, 10);
      if (isNaN(value)) {
        value = "";
        for (let i3 = 0; i3 < str.length; i3++) {
          const code = str.charCodeAt(i3);
          if (str[i3].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i3]);
          } else {
            for (const key in numberingSystemsUTF16) {
              const [min, max] = numberingSystemsUTF16[key];
              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }
        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex({ numberingSystem }, append = "") {
      return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
    }
    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
    function intUnit(regex, post = (i3) => i3) {
      return { regex, deser: ([s4]) => post(parseDigits(s4)) };
    }
    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = `[ ${NBSP}]`;
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
    function fixListRegex(s4) {
      return s4.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }
    function stripInsensitivities(s4) {
      return s4.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
    }
    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: ([s4]) => strings.findIndex((i3) => stripInsensitivities(s4) === stripInsensitivities(i3)) + startIndex
        };
      }
    }
    function offset(regex, groups) {
      return { regex, deser: ([, h3, m3]) => signedOffset(h3, m3), groups };
    }
    function simple(regex) {
      return { regex, deser: ([s4]) => s4 };
    }
    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }
    function unitForToken(token, loc) {
      const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal = (t3) => ({ regex: RegExp(escapeToken(t3.val)), deser: ([s4]) => s4, literal: true }), unitate = (t3) => {
        if (token.literal) {
          return literal(t3);
        }
        switch (t3.val) {
          case "G":
            return oneOf(loc.eras("short"), 0);
          case "GG":
            return oneOf(loc.eras("long"), 0);
          case "y":
            return intUnit(oneToSix);
          case "yy":
            return intUnit(twoToFour, untruncateYear);
          case "yyyy":
            return intUnit(four);
          case "yyyyy":
            return intUnit(fourToSix);
          case "yyyyyy":
            return intUnit(six);
          case "M":
            return intUnit(oneOrTwo);
          case "MM":
            return intUnit(two);
          case "MMM":
            return oneOf(loc.months("short", true), 1);
          case "MMMM":
            return oneOf(loc.months("long", true), 1);
          case "L":
            return intUnit(oneOrTwo);
          case "LL":
            return intUnit(two);
          case "LLL":
            return oneOf(loc.months("short", false), 1);
          case "LLLL":
            return oneOf(loc.months("long", false), 1);
          case "d":
            return intUnit(oneOrTwo);
          case "dd":
            return intUnit(two);
          case "o":
            return intUnit(oneToThree);
          case "ooo":
            return intUnit(three);
          case "HH":
            return intUnit(two);
          case "H":
            return intUnit(oneOrTwo);
          case "hh":
            return intUnit(two);
          case "h":
            return intUnit(oneOrTwo);
          case "mm":
            return intUnit(two);
          case "m":
            return intUnit(oneOrTwo);
          case "q":
            return intUnit(oneOrTwo);
          case "qq":
            return intUnit(two);
          case "s":
            return intUnit(oneOrTwo);
          case "ss":
            return intUnit(two);
          case "S":
            return intUnit(oneToThree);
          case "SSS":
            return intUnit(three);
          case "u":
            return simple(oneToNine);
          case "uu":
            return simple(oneOrTwo);
          case "uuu":
            return intUnit(one);
          case "a":
            return oneOf(loc.meridiems(), 0);
          case "kkkk":
            return intUnit(four);
          case "kk":
            return intUnit(twoToFour, untruncateYear);
          case "W":
            return intUnit(oneOrTwo);
          case "WW":
            return intUnit(two);
          case "E":
          case "c":
            return intUnit(one);
          case "EEE":
            return oneOf(loc.weekdays("short", false), 1);
          case "EEEE":
            return oneOf(loc.weekdays("long", false), 1);
          case "ccc":
            return oneOf(loc.weekdays("short", true), 1);
          case "cccc":
            return oneOf(loc.weekdays("long", true), 1);
          case "Z":
          case "ZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
          case "ZZZ":
            return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);
          case " ":
            return simple(/[^\S\n\r]/);
          default:
            return literal(t3);
        }
      };
      const unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }
    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour12: {
        numeric: "h",
        "2-digit": "hh"
      },
      hour24: {
        numeric: "H",
        "2-digit": "HH"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      },
      timeZoneName: {
        long: "ZZZZZ",
        short: "ZZZ"
      }
    };
    function tokenForPart(part, formatOpts, resolvedOpts) {
      const { type, value } = part;
      if (type === "literal") {
        const isSpace = /^\s+$/.test(value);
        return {
          literal: !isSpace,
          val: isSpace ? " " : value
        };
      }
      const style = formatOpts[type];
      let actualType = type;
      if (type === "hour") {
        if (formatOpts.hour12 != null) {
          actualType = formatOpts.hour12 ? "hour12" : "hour24";
        } else if (formatOpts.hourCycle != null) {
          if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
            actualType = "hour12";
          } else {
            actualType = "hour24";
          }
        } else {
          actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
        }
      }
      let val = partTypeStyleToTokenVal[actualType];
      if (typeof val === "object") {
        val = val[style];
      }
      if (val) {
        return {
          literal: false,
          val
        };
      }
      return void 0;
    }
    function buildRegex(units) {
      const re = units.map((u3) => u3.regex).reduce((f3, r3) => `${f3}(${r3.source})`, "");
      return [`^${re}$`, units];
    }
    function match(input, regex, handlers) {
      const matches = input.match(regex);
      if (matches) {
        const all = {};
        let matchIndex = 1;
        for (const i3 in handlers) {
          if (hasOwnProperty2(handlers, i3)) {
            const h3 = handlers[i3], groups = h3.groups ? h3.groups + 1 : 1;
            if (!h3.literal && h3.token) {
              all[h3.token.val[0]] = h3.deser(matches.slice(matchIndex, matchIndex + groups));
            }
            matchIndex += groups;
          }
        }
        return [matches, all];
      } else {
        return [matches, {}];
      }
    }
    function dateTimeFromMatches(matches) {
      const toField = (token) => {
        switch (token) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
          case "H":
            return "hour";
          case "d":
            return "day";
          case "o":
            return "ordinal";
          case "L":
          case "M":
            return "month";
          case "y":
            return "year";
          case "E":
          case "c":
            return "weekday";
          case "W":
            return "weekNumber";
          case "k":
            return "weekYear";
          case "q":
            return "quarter";
          default:
            return null;
        }
      };
      let zone = null;
      let specificOffset;
      if (!isUndefined(matches.z)) {
        zone = IANAZone.create(matches.z);
      }
      if (!isUndefined(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches.Z);
        }
        specificOffset = matches.Z;
      }
      if (!isUndefined(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }
      if (!isUndefined(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }
      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }
      if (!isUndefined(matches.u)) {
        matches.S = parseMillis(matches.u);
      }
      const vals = Object.keys(matches).reduce((r3, k3) => {
        const f3 = toField(k3);
        if (f3) {
          r3[f3] = matches[k3];
        }
        return r3;
      }, {});
      return [vals, zone, specificOffset];
    }
    var dummyDateTimeCache = null;
    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime2.fromMillis(1555555555555);
      }
      return dummyDateTimeCache;
    }
    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }
      const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
      const tokens = formatOptsToTokens(formatOpts, locale);
      if (tokens == null || tokens.includes(void 0)) {
        return token;
      }
      return tokens;
    }
    function expandMacroTokens(tokens, locale) {
      return Array.prototype.concat(...tokens.map((t3) => maybeExpandMacroToken(t3, locale)));
    }
    function explainFromTokens(locale, input, format) {
      const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t3) => unitForToken(t3, locale)), disqualifyingUnit = units.find((t3) => t3.invalidReason);
      if (disqualifyingUnit) {
        return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
      } else {
        const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, void 0];
        if (hasOwnProperty2(matches, "a") && hasOwnProperty2(matches, "H")) {
          throw new ConflictingSpecificationError(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return { input, tokens, regex, rawMatches, matches, result, zone, specificOffset };
      }
    }
    function parseFromTokens(locale, input, format) {
      const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale, input, format);
      return [result, zone, specificOffset, invalidReason];
    }
    function formatOptsToTokens(formatOpts, locale) {
      if (!formatOpts) {
        return null;
      }
      const formatter = Formatter.create(locale, formatOpts);
      const df = formatter.dtFormatter(getDummyDateTime());
      const parts = df.formatToParts();
      const resolvedOpts = df.resolvedOptions();
      return parts.map((p3) => tokenForPart(p3, formatOpts, resolvedOpts));
    }
    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
    var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    function unitOutOfRange(unit, value) {
      return new Invalid(
        "unit out of range",
        `you specified ${value} (of type ${typeof value}) as a ${unit}, which is invalid`
      );
    }
    function dayOfWeek(year, month, day) {
      const d2 = new Date(Date.UTC(year, month - 1, day));
      if (year < 100 && year >= 0) {
        d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
      }
      const js = d2.getUTCDay();
      return js === 0 ? 7 : js;
    }
    function computeOrdinal(year, month, day) {
      return day + (isLeapYear2(year) ? leapLadder : nonLeapLadder)[month - 1];
    }
    function uncomputeOrdinal(year, ordinal) {
      const table = isLeapYear2(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i3) => i3 < ordinal), day = ordinal - table[month0];
      return { month: month0 + 1, day };
    }
    function gregorianToWeek(gregObj) {
      const { year, month, day } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = dayOfWeek(year, month, day);
      let weekNumber = Math.floor((ordinal - weekday + 10) / 7), weekYear;
      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }
      return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
    }
    function weekToGregorian(weekData) {
      const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = dayOfWeek(weekYear, 1, 4), yearInDays = daysInYear(weekYear);
      let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3, year;
      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(weekData) };
    }
    function gregorianToOrdinal(gregData) {
      const { year, month, day } = gregData;
      const ordinal = computeOrdinal(year, month, day);
      return { year, ordinal, ...timeObject(gregData) };
    }
    function ordinalToGregorian(ordinalData) {
      const { year, ordinal } = ordinalData;
      const { month, day } = uncomputeOrdinal(year, ordinal);
      return { year, month, day, ...timeObject(ordinalData) };
    }
    function hasInvalidWeekData(obj) {
      const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)), validWeekday = integerBetween(obj.weekday, 1, 7);
      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else
        return false;
    }
    function hasInvalidOrdinalData(obj) {
      const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else
        return false;
    }
    function hasInvalidGregorianData(obj) {
      const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else
        return false;
    }
    function hasInvalidTimeData(obj) {
      const { hour, minute, second, millisecond } = obj;
      const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else
        return false;
    }
    var INVALID = "Invalid DateTime";
    var MAX_DATE = 864e13;
    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
    }
    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }
      return dt.weekData;
    }
    function clone2(inst, alts) {
      const current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime2({ ...current, ...alts, old: current });
    }
    function fixOffset(localTS, o2, tz) {
      let utcGuess = localTS - o2 * 60 * 1e3;
      const o22 = tz.offset(utcGuess);
      if (o2 === o22) {
        return [utcGuess, o2];
      }
      utcGuess -= (o22 - o2) * 60 * 1e3;
      const o3 = tz.offset(utcGuess);
      if (o22 === o3) {
        return [utcGuess, o22];
      }
      return [localTS - Math.min(o22, o3) * 60 * 1e3, Math.max(o22, o3)];
    }
    function tsToObj(ts, offset2) {
      ts += offset2 * 60 * 1e3;
      const d2 = new Date(ts);
      return {
        year: d2.getUTCFullYear(),
        month: d2.getUTCMonth() + 1,
        day: d2.getUTCDate(),
        hour: d2.getUTCHours(),
        minute: d2.getUTCMinutes(),
        second: d2.getUTCSeconds(),
        millisecond: d2.getUTCMilliseconds()
      };
    }
    function objToTS(obj, offset2, zone) {
      return fixOffset(objToLocalTS(obj), offset2, zone);
    }
    function adjustTime(inst, dur) {
      const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c3 = {
        ...inst.c,
        year,
        month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }, millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"), localTS = objToLocalTS(c3);
      let [ts, o2] = fixOffset(localTS, oPre, inst.zone);
      if (millisToAdd !== 0) {
        ts += millisToAdd;
        o2 = inst.zone.offset(ts);
      }
      return { ts, o: o2 };
    }
    function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
      const { setZone, zone } = opts;
      if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
        const interpretationZone = parsedZone || zone, inst = DateTime2.fromObject(parsed, {
          ...opts,
          zone: interpretationZone,
          specificOffset
        });
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime2.invalid(
          new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`)
        );
      }
    }
    function toTechFormat(dt, format, allowZ = true) {
      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }
    function toISODate(o2, extended) {
      const longFormat = o2.c.year > 9999 || o2.c.year < 0;
      let c3 = "";
      if (longFormat && o2.c.year >= 0)
        c3 += "+";
      c3 += padStart3(o2.c.year, longFormat ? 6 : 4);
      if (extended) {
        c3 += "-";
        c3 += padStart3(o2.c.month);
        c3 += "-";
        c3 += padStart3(o2.c.day);
      } else {
        c3 += padStart3(o2.c.month);
        c3 += padStart3(o2.c.day);
      }
      return c3;
    }
    function toISOTime(o2, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
      let c3 = padStart3(o2.c.hour);
      if (extended) {
        c3 += ":";
        c3 += padStart3(o2.c.minute);
        if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
          c3 += ":";
        }
      } else {
        c3 += padStart3(o2.c.minute);
      }
      if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
        c3 += padStart3(o2.c.second);
        if (o2.c.millisecond !== 0 || !suppressMilliseconds) {
          c3 += ".";
          c3 += padStart3(o2.c.millisecond, 3);
        }
      }
      if (includeOffset) {
        if (o2.isOffsetFixed && o2.offset === 0 && !extendedZone) {
          c3 += "Z";
        } else if (o2.o < 0) {
          c3 += "-";
          c3 += padStart3(Math.trunc(-o2.o / 60));
          c3 += ":";
          c3 += padStart3(Math.trunc(-o2.o % 60));
        } else {
          c3 += "+";
          c3 += padStart3(Math.trunc(o2.o / 60));
          c3 += ":";
          c3 += padStart3(Math.trunc(o2.o % 60));
        }
      }
      if (extendedZone) {
        c3 += "[" + o2.zone.ianaName + "]";
      }
      return c3;
    }
    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    };
    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
    var orderedWeekUnits = [
      "weekYear",
      "weekNumber",
      "weekday",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
    function normalizeUnit(unit) {
      const normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    function quickDT(obj, opts) {
      const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
      let ts, o2;
      if (!isUndefined(obj.year)) {
        for (const u3 of orderedUnits) {
          if (isUndefined(obj[u3])) {
            obj[u3] = defaultUnitValues[u3];
          }
        }
        const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const offsetProvis = zone.offset(tsNow);
        [ts, o2] = objToTS(obj, offsetProvis, zone);
      } else {
        ts = tsNow;
      }
      return new DateTime2({ ts, zone, loc, o: o2 });
    }
    function diffRelative(start, end, opts) {
      const round = isUndefined(opts.round) ? true : opts.round, format = (c3, unit) => {
        c3 = roundTo(c3, round || opts.calendary ? 0 : 2, true);
        const formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c3, unit);
      }, differ = (unit) => {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else
            return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };
      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }
      for (const unit of opts.units) {
        const count = differ(unit);
        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }
      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }
    function lastOpts(argList) {
      let opts = {}, args;
      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }
      return [opts, args];
    }
    var DateTime2 = class {
      /**
       * @access private
       */
      constructor(config2) {
        const zone = config2.zone || Settings.defaultZone;
        let invalid = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        this.ts = isUndefined(config2.ts) ? Settings.now() : config2.ts;
        let c3 = null, o2 = null;
        if (!invalid) {
          const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
          if (unchanged) {
            [c3, o2] = [config2.old.c, config2.old.o];
          } else {
            const ot = zone.offset(this.ts);
            c3 = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c3.year) ? new Invalid("invalid input") : null;
            c3 = invalid ? null : c3;
            o2 = invalid ? null : ot;
          }
        }
        this._zone = zone;
        this.loc = config2.loc || Locale.create();
        this.invalid = invalid;
        this.weekData = null;
        this.c = c3;
        this.o = o2;
        this.isLuxonDateTime = true;
      }
      // CONSTRUCT
      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */
      static now() {
        return new DateTime2({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      static local() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      static utc() {
        const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({ year, month, day, hour, minute, second, millisecond }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      static fromJSDate(date, options = {}) {
        const ts = isDate2(date) ? date.valueOf() : NaN;
        if (Number.isNaN(ts)) {
          return DateTime2.invalid("invalid input");
        }
        const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        return new DateTime2({
          ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromMillis(milliseconds, options = {}) {
        if (!isNumber2(milliseconds)) {
          throw new InvalidArgumentError(
            `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
          );
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          return DateTime2.invalid("Timestamp out of range");
        } else {
          return new DateTime2({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromSeconds(seconds, options = {}) {
        if (!isNumber2(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime2({
            ts: seconds * 1e3,
            zone: normalizeZone(options.zone, Settings.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @return {DateTime}
       */
      static fromObject(obj, opts = {}) {
        obj = obj || {};
        const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
        if (!zoneToUse.isValid) {
          return DateTime2.invalid(unsupportedZone(zoneToUse));
        }
        const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), normalized = normalizeObject(obj, normalizeUnit), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber, loc = Locale.fromObject(opts);
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
        let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        }
        let foundFirst = false;
        for (const u3 of units) {
          const v3 = normalized[u3];
          if (!isUndefined(v3)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u3] = defaultValues[u3];
          } else {
            normalized[u3] = objNow[u3];
          }
        }
        const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
        if (invalid) {
          return DateTime2.invalid(invalid);
        }
        const gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime2({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc
        });
        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime2.invalid(
            "mismatched weekday",
            `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
          );
        }
        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      static fromISO(text, opts = {}) {
        const [vals, parsedZone] = parseISODate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      static fromRFC2822(text, opts = {}) {
        const [vals, parsedZone] = parseRFC2822Date(text);
        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      static fromHTTP(text, opts = {}) {
        const [vals, parsedZone] = parseHTTPDate(text);
        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      static fromFormat(text, fmt, opts = {}) {
        if (isUndefined(text) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }
        const { locale = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
        if (invalid) {
          return DateTime2.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      static fromString(text, fmt, opts = {}) {
        return DateTime2.fromFormat(text, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      static fromSQL(text, opts = {}) {
        const [vals, parsedZone] = parseSQL(text);
        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
      }
      /**
       * Create an invalid DateTime.
       * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      static invalid(reason, explanation = null) {
        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }
        const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
        if (Settings.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid);
        } else {
          return new DateTime2({ invalid });
        }
      }
      /**
       * Check if an object is an instance of DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      static isDateTime(o2) {
        return o2 && o2.isLuxonDateTime || false;
      }
      /**
       * Produce the format string for a set of options
       * @param formatOpts
       * @param localeOpts
       * @returns {string}
       */
      static parseFormatForOpts(formatOpts, localeOpts = {}) {
        const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
        return !tokenList ? null : tokenList.map((t3) => t3 ? t3.val : null).join("");
      }
      /**
       * Produce the the fully expanded format token for the locale
       * Does NOT quote characters, so quoted tokens will not round trip correctly
       * @param fmt
       * @param localeOpts
       * @returns {string}
       */
      static expandFormat(fmt, localeOpts = {}) {
        const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
        return expanded.map((t3) => t3.val).join("");
      }
      // INFO
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      get isValid() {
        return this.invalid === null;
      }
      /**
       * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidReason() {
        return this.invalid ? this.invalid.reason : null;
      }
      /**
       * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
       * @type {string}
       */
      get invalidExplanation() {
        return this.invalid ? this.invalid.explanation : null;
      }
      /**
       * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
       *
       * @type {string}
       */
      get locale() {
        return this.isValid ? this.loc.locale : null;
      }
      /**
       * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
       *
       * @type {string}
       */
      get numberingSystem() {
        return this.isValid ? this.loc.numberingSystem : null;
      }
      /**
       * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
       *
       * @type {string}
       */
      get outputCalendar() {
        return this.isValid ? this.loc.outputCalendar : null;
      }
      /**
       * Get the time zone associated with this DateTime.
       * @type {Zone}
       */
      get zone() {
        return this._zone;
      }
      /**
       * Get the name of the time zone.
       * @type {string}
       */
      get zoneName() {
        return this.isValid ? this.zone.name : null;
      }
      /**
       * Get the year
       * @example DateTime.local(2017, 5, 25).year //=> 2017
       * @type {number}
       */
      get year() {
        return this.isValid ? this.c.year : NaN;
      }
      /**
       * Get the quarter
       * @example DateTime.local(2017, 5, 25).quarter //=> 2
       * @type {number}
       */
      get quarter() {
        return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
      }
      /**
       * Get the month (1-12).
       * @example DateTime.local(2017, 5, 25).month //=> 5
       * @type {number}
       */
      get month() {
        return this.isValid ? this.c.month : NaN;
      }
      /**
       * Get the day of the month (1-30ish).
       * @example DateTime.local(2017, 5, 25).day //=> 25
       * @type {number}
       */
      get day() {
        return this.isValid ? this.c.day : NaN;
      }
      /**
       * Get the hour of the day (0-23).
       * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
       * @type {number}
       */
      get hour() {
        return this.isValid ? this.c.hour : NaN;
      }
      /**
       * Get the minute of the hour (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
       * @type {number}
       */
      get minute() {
        return this.isValid ? this.c.minute : NaN;
      }
      /**
       * Get the second of the minute (0-59).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
       * @type {number}
       */
      get second() {
        return this.isValid ? this.c.second : NaN;
      }
      /**
       * Get the millisecond of the second (0-999).
       * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
       * @type {number}
       */
      get millisecond() {
        return this.isValid ? this.c.millisecond : NaN;
      }
      /**
       * Get the week year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
       * @type {number}
       */
      get weekYear() {
        return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
      }
      /**
       * Get the week number of the week year (1-52ish).
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
       * @type {number}
       */
      get weekNumber() {
        return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
      }
      /**
       * Get the day of the week.
       * 1 is Monday and 7 is Sunday
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2014, 11, 31).weekday //=> 4
       * @type {number}
       */
      get weekday() {
        return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
      }
      /**
       * Get the ordinal (meaning the day of the year)
       * @example DateTime.local(2017, 5, 25).ordinal //=> 145
       * @type {number|DateTime}
       */
      get ordinal() {
        return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
      }
      /**
       * Get the human readable short month name, such as 'Oct'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
       * @type {string}
       */
      get monthShort() {
        return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable long month name, such as 'October'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).monthLong //=> October
       * @type {string}
       */
      get monthLong() {
        return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
      }
      /**
       * Get the human readable short weekday, such as 'Mon'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
       * @type {string}
       */
      get weekdayShort() {
        return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the human readable long weekday, such as 'Monday'.
       * Defaults to the system's locale if no locale has been specified
       * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
       * @type {string}
       */
      get weekdayLong() {
        return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
      }
      /**
       * Get the UTC offset of this DateTime in minutes
       * @example DateTime.now().offset //=> -240
       * @example DateTime.utc().offset //=> 0
       * @type {number}
       */
      get offset() {
        return this.isValid ? +this.o : NaN;
      }
      /**
       * Get the short human name for the zone's current offset, for example "EST" or "EDT".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameShort() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "short",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
       * Defaults to the system's locale if no locale has been specified
       * @type {string}
       */
      get offsetNameLong() {
        if (this.isValid) {
          return this.zone.offsetName(this.ts, {
            format: "long",
            locale: this.locale
          });
        } else {
          return null;
        }
      }
      /**
       * Get whether this zone's offset ever changes, as in a DST.
       * @type {boolean}
       */
      get isOffsetFixed() {
        return this.isValid ? this.zone.isUniversal : null;
      }
      /**
       * Get whether the DateTime is in a DST.
       * @type {boolean}
       */
      get isInDST() {
        if (this.isOffsetFixed) {
          return false;
        } else {
          return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
        }
      }
      /**
       * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
       * in this DateTime's zone. During DST changes local time can be ambiguous, for example
       * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
       * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
       * @returns {DateTime[]}
       */
      getPossibleOffsets() {
        if (!this.isValid || this.isOffsetFixed) {
          return [this];
        }
        const dayMs = 864e5;
        const minuteMs = 6e4;
        const localTS = objToLocalTS(this.c);
        const oEarlier = this.zone.offset(localTS - dayMs);
        const oLater = this.zone.offset(localTS + dayMs);
        const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
        const o2 = this.zone.offset(localTS - oLater * minuteMs);
        if (o1 === o2) {
          return [this];
        }
        const ts1 = localTS - o1 * minuteMs;
        const ts2 = localTS - o2 * minuteMs;
        const c1 = tsToObj(ts1, o1);
        const c22 = tsToObj(ts2, o2);
        if (c1.hour === c22.hour && c1.minute === c22.minute && c1.second === c22.second && c1.millisecond === c22.millisecond) {
          return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
        }
        return [this];
      }
      /**
       * Returns true if this DateTime is in a leap year, false otherwise
       * @example DateTime.local(2016).isInLeapYear //=> true
       * @example DateTime.local(2013).isInLeapYear //=> false
       * @type {boolean}
       */
      get isInLeapYear() {
        return isLeapYear2(this.year);
      }
      /**
       * Returns the number of days in this DateTime's month
       * @example DateTime.local(2016, 2).daysInMonth //=> 29
       * @example DateTime.local(2016, 3).daysInMonth //=> 31
       * @type {number}
       */
      get daysInMonth() {
        return daysInMonth(this.year, this.month);
      }
      /**
       * Returns the number of days in this DateTime's year
       * @example DateTime.local(2016).daysInYear //=> 366
       * @example DateTime.local(2013).daysInYear //=> 365
       * @type {number}
       */
      get daysInYear() {
        return this.isValid ? daysInYear(this.year) : NaN;
      }
      /**
       * Returns the number of weeks in this DateTime's year
       * @see https://en.wikipedia.org/wiki/ISO_week_date
       * @example DateTime.local(2004).weeksInWeekYear //=> 53
       * @example DateTime.local(2013).weeksInWeekYear //=> 52
       * @type {number}
       */
      get weeksInWeekYear() {
        return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
      }
      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      resolvedLocaleOptions(opts = {}) {
        const { locale, numberingSystem, calendar } = Formatter.create(
          this.loc.clone(opts),
          opts
        ).resolvedOptions(this);
        return { locale, numberingSystem, outputCalendar: calendar };
      }
      // TRANSFORM
      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      toUTC(offset2 = 0, opts = {}) {
        return this.setZone(FixedOffsetZone.instance(offset2), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      toLocal() {
        return this.setZone(Settings.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
        zone = normalizeZone(zone, Settings.defaultZone);
        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime2.invalid(unsupportedZone(zone));
        } else {
          let newTS = this.ts;
          if (keepLocalTime || keepCalendarTime) {
            const offsetGuess = zone.offset(this.ts);
            const asObj = this.toObject();
            [newTS] = objToTS(asObj, offsetGuess, zone);
          }
          return clone2(this, { ts: newTS, zone });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      reconfigure({ locale, numberingSystem, outputCalendar } = {}) {
        const loc = this.loc.clone({ locale, numberingSystem, outputCalendar });
        return clone2(this, { loc });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      setLocale(locale) {
        return this.reconfigure({ locale });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      set(values) {
        if (!this.isValid)
          return this;
        const normalized = normalizeObject(values, normalizeUnit), settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError(
            "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
          );
        }
        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }
        let mixed;
        if (settingWeekStuff) {
          mixed = weekToGregorian({ ...gregorianToWeek(this.c), ...normalized });
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
        } else {
          mixed = { ...this.toObject(), ...normalized };
          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }
        const [ts, o2] = objToTS(mixed, this.o, this.zone);
        return clone2(this, { ts, o: o2 });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      plus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration);
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      minus(duration) {
        if (!this.isValid)
          return this;
        const dur = Duration.fromDurationLike(duration).negate();
        return clone2(this, adjustTime(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      startOf(unit) {
        if (!this.isValid)
          return this;
        const o2 = {}, normalizedUnit = Duration.normalizeUnit(unit);
        switch (normalizedUnit) {
          case "years":
            o2.month = 1;
          case "quarters":
          case "months":
            o2.day = 1;
          case "weeks":
          case "days":
            o2.hour = 0;
          case "hours":
            o2.minute = 0;
          case "minutes":
            o2.second = 0;
          case "seconds":
            o2.millisecond = 0;
            break;
        }
        if (normalizedUnit === "weeks") {
          o2.weekday = 1;
        }
        if (normalizedUnit === "quarters") {
          const q3 = Math.ceil(this.month / 3);
          o2.month = (q3 - 1) * 3 + 1;
        }
        return this.set(o2);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      endOf(unit) {
        return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit).minus(1) : this;
      }
      // OUTPUT
      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      toFormat(fmt, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      toLocaleParts(opts = {}) {
        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @return {string}
       */
      toISO({
        format = "extended",
        suppressSeconds = false,
        suppressMilliseconds = false,
        includeOffset = true,
        extendedZone = false
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        const ext = format === "extended";
        let c3 = toISODate(this, ext);
        c3 += "T";
        c3 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
        return c3;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @return {string}
       */
      toISODate({ format = "extended" } = {}) {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, format === "extended");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @return {string}
       */
      toISOTime({
        suppressMilliseconds = false,
        suppressSeconds = false,
        includeOffset = true,
        includePrefix = false,
        extendedZone = false,
        format = "extended"
      } = {}) {
        if (!this.isValid) {
          return null;
        }
        let c3 = includePrefix ? "T" : "";
        return c3 + toISOTime(
          this,
          format === "extended",
          suppressSeconds,
          suppressMilliseconds,
          includeOffset,
          extendedZone
        );
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string}
       */
      toSQLDate() {
        if (!this.isValid) {
          return null;
        }
        return toISODate(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
        let fmt = "HH:mm:ss.SSS";
        if (includeZone || includeOffset) {
          if (includeOffsetSpace) {
            fmt += " ";
          }
          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }
        return toTechFormat(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      toSQL(opts = {}) {
        if (!this.isValid) {
          return null;
        }
        return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      toString() {
        return this.isValid ? this.toISO() : INVALID;
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds of this DateTime.
       * @return {number}
       */
      toSeconds() {
        return this.isValid ? this.ts / 1e3 : NaN;
      }
      /**
       * Returns the epoch seconds (as a whole number) of this DateTime.
       * @return {number}
       */
      toUnixInteger() {
        return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      toObject(opts = {}) {
        if (!this.isValid)
          return {};
        const base = { ...this.c };
        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }
        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      }
      // COMPARE
      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      diff(otherDateTime, unit = "milliseconds", opts = {}) {
        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }
        const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
        const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      diffNow(unit = "milliseconds", opts = {}) {
        return this.diff(DateTime2.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval}
       */
      until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      hasSame(otherDateTime, unit) {
        if (!this.isValid)
          return false;
        const inputMs = otherDateTime.valueOf();
        const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      }
      /**
       * Equality check
       * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds down by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      toRelative(options = {}) {
        if (!this.isValid)
          return null;
        const base = options.base || DateTime2.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        let units = ["years", "months", "days", "hours", "minutes", "seconds"];
        let unit = options.unit;
        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = void 0;
        }
        return diffRelative(base, this.plus(padding), {
          ...options,
          numeric: "always",
          units,
          unit
        });
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      toRelativeCalendar(options = {}) {
        if (!this.isValid)
          return null;
        return diffRelative(options.base || DateTime2.fromObject({}, { zone: this.zone }), this, {
          ...options,
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        });
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      static min(...dateTimes) {
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i3) => i3.valueOf(), Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      static max(...dateTimes) {
        if (!dateTimes.every(DateTime2.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }
        return bestBy(dateTimes, (i3) => i3.valueOf(), Math.max);
      }
      // MISC
      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      static fromFormatExplain(text, fmt, options = {}) {
        const { locale = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
          locale,
          numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      static fromStringExplain(text, fmt, options = {}) {
        return DateTime2.fromFormatExplain(text, fmt, options);
      }
      // FORMAT PRESETS
      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      static get DATE_SHORT() {
        return DATE_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED() {
        return DATE_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
       * @type {Object}
       */
      static get DATE_MED_WITH_WEEKDAY() {
        return DATE_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983'
       * @type {Object}
       */
      static get DATE_FULL() {
        return DATE_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
       * @type {Object}
       */
      static get DATE_HUGE() {
        return DATE_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_SIMPLE() {
        return TIME_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SECONDS() {
        return TIME_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_SHORT_OFFSET() {
        return TIME_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get TIME_WITH_LONG_OFFSET() {
        return TIME_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_SIMPLE() {
        return TIME_24_SIMPLE;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SECONDS() {
        return TIME_24_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_SHORT_OFFSET() {
        return TIME_24_WITH_SHORT_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
       * @type {Object}
       */
      static get TIME_24_WITH_LONG_OFFSET() {
        return TIME_24_WITH_LONG_OFFSET;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT() {
        return DATETIME_SHORT;
      }
      /**
       * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_SHORT_WITH_SECONDS() {
        return DATETIME_SHORT_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED() {
        return DATETIME_MED;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_SECONDS() {
        return DATETIME_MED_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_MED_WITH_WEEKDAY() {
        return DATETIME_MED_WITH_WEEKDAY;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL() {
        return DATETIME_FULL;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_FULL_WITH_SECONDS() {
        return DATETIME_FULL_WITH_SECONDS;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE() {
        return DATETIME_HUGE;
      }
      /**
       * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
       * @type {Object}
       */
      static get DATETIME_HUGE_WITH_SECONDS() {
        return DATETIME_HUGE_WITH_SECONDS;
      }
    };
    function friendlyDateTime(dateTimeish) {
      if (DateTime2.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber2(dateTimeish.valueOf())) {
        return DateTime2.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime2.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError(
          `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
        );
      }
    }
    var DEFAULT_QUERY_SETTINGS = {
      renderNullAs: "\\-",
      taskCompletionTracking: false,
      taskCompletionUseEmojiShorthand: false,
      taskCompletionText: "completion",
      taskCompletionDateFormat: "yyyy-MM-dd",
      recursiveSubTaskCompletion: false,
      warnOnEmptyResult: true,
      refreshEnabled: true,
      refreshInterval: 2500,
      defaultDateFormat: "MMMM dd, yyyy",
      defaultDateTimeFormat: "h:mm a - MMMM dd, yyyy",
      maxRecursiveRenderDepth: 4,
      tableIdColumnName: "File",
      tableGroupColumnName: "Group",
      showResultCount: true
    };
    var DEFAULT_EXPORT_SETTINGS = {
      allowHtml: true
    };
    ({
      ...DEFAULT_QUERY_SETTINGS,
      ...DEFAULT_EXPORT_SETTINGS,
      ...{
        inlineQueryPrefix: "=",
        inlineJsQueryPrefix: "$=",
        inlineQueriesInCodeblocks: true,
        enableInlineDataview: true,
        enableDataviewJs: false,
        enableInlineDataviewJs: false,
        prettyRenderInlineFields: true,
        prettyRenderInlineFieldsInLivePreview: true,
        dataviewJsKeyword: "dataviewjs"
      }
    });
    var Success = class {
      constructor(value) {
        __publicField(this, "value");
        __publicField(this, "successful");
        this.value = value;
        this.successful = true;
      }
      map(f3) {
        return new Success(f3(this.value));
      }
      flatMap(f3) {
        return f3(this.value);
      }
      mapErr(f3) {
        return this;
      }
      bimap(succ, _fail) {
        return this.map(succ);
      }
      orElse(_value) {
        return this.value;
      }
      cast() {
        return this;
      }
      orElseThrow(_message) {
        return this.value;
      }
    };
    var Failure = class {
      constructor(error) {
        __publicField(this, "error");
        __publicField(this, "successful");
        this.error = error;
        this.successful = false;
      }
      map(_f) {
        return this;
      }
      flatMap(_f) {
        return this;
      }
      mapErr(f3) {
        return new Failure(f3(this.error));
      }
      bimap(_succ, fail) {
        return this.mapErr(fail);
      }
      orElse(value) {
        return value;
      }
      cast() {
        return this;
      }
      orElseThrow(message) {
        if (message)
          throw new Error(message(this.error));
        else
          throw new Error("" + this.error);
      }
    };
    var Result;
    (function(Result2) {
      function success(value) {
        return new Success(value);
      }
      Result2.success = success;
      function failure(error) {
        return new Failure(error);
      }
      Result2.failure = failure;
      function flatMap2(first, second, f3) {
        if (first.successful) {
          if (second.successful)
            return f3(first.value, second.value);
          else
            return failure(second.error);
        } else {
          return failure(first.error);
        }
      }
      Result2.flatMap2 = flatMap2;
      function map2(first, second, f3) {
        return flatMap2(first, second, (a3, b3) => success(f3(a3, b3)));
      }
      Result2.map2 = map2;
    })(Result || (Result = {}));
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    var parsimmon_umd_min = { exports: {} };
    parsimmon_umd_min.exports;
    (function(module3, exports2) {
      !function(n3, t3) {
        module3.exports = t3();
      }("undefined" != typeof self ? self : commonjsGlobal, function() {
        return function(n3) {
          var t3 = {};
          function r3(e3) {
            if (t3[e3])
              return t3[e3].exports;
            var u3 = t3[e3] = { i: e3, l: false, exports: {} };
            return n3[e3].call(u3.exports, u3, u3.exports, r3), u3.l = true, u3.exports;
          }
          return r3.m = n3, r3.c = t3, r3.d = function(n4, t4, e3) {
            r3.o(n4, t4) || Object.defineProperty(n4, t4, { configurable: false, enumerable: true, get: e3 });
          }, r3.r = function(n4) {
            Object.defineProperty(n4, "__esModule", { value: true });
          }, r3.n = function(n4) {
            var t4 = n4 && n4.__esModule ? function() {
              return n4.default;
            } : function() {
              return n4;
            };
            return r3.d(t4, "a", t4), t4;
          }, r3.o = function(n4, t4) {
            return Object.prototype.hasOwnProperty.call(n4, t4);
          }, r3.p = "", r3(r3.s = 0);
        }([function(n3, t3, r3) {
          function e3(n4) {
            if (!(this instanceof e3))
              return new e3(n4);
            this._ = n4;
          }
          var u3 = e3.prototype;
          function o2(n4, t4) {
            for (var r4 = 0; r4 < n4; r4++)
              t4(r4);
          }
          function i3(n4, t4, r4) {
            return function(n5, t5) {
              o2(t5.length, function(r5) {
                n5(t5[r5], r5, t5);
              });
            }(function(r5, e4, u4) {
              t4 = n4(t4, r5, e4, u4);
            }, r4), t4;
          }
          function a3(n4, t4) {
            return i3(function(t5, r4, e4, u4) {
              return t5.concat([n4(r4, e4, u4)]);
            }, [], t4);
          }
          function f3(n4, t4) {
            var r4 = { v: 0, buf: t4 };
            return o2(n4, function() {
              var n5;
              r4 = { v: r4.v << 1 | (n5 = r4.buf, n5[0] >> 7), buf: function(n6) {
                var t5 = i3(function(n7, t6, r5, e4) {
                  return n7.concat(r5 === e4.length - 1 ? Buffer.from([t6, 0]).readUInt16BE(0) : e4.readUInt16BE(r5));
                }, [], n6);
                return Buffer.from(a3(function(n7) {
                  return (n7 << 1 & 65535) >> 8;
                }, t5));
              }(r4.buf) };
            }), r4;
          }
          function c3() {
            return "undefined" != typeof Buffer;
          }
          function s4() {
            if (!c3())
              throw new Error("Buffer global does not exist; please use webpack if you need to parse Buffers in the browser.");
          }
          function l4(n4) {
            s4();
            var t4 = i3(function(n5, t5) {
              return n5 + t5;
            }, 0, n4);
            if (t4 % 8 != 0)
              throw new Error("The bits [" + n4.join(", ") + "] add up to " + t4 + " which is not an even number of bytes; the total should be divisible by 8");
            var r4, u4 = t4 / 8, o3 = (r4 = function(n5) {
              return n5 > 48;
            }, i3(function(n5, t5) {
              return n5 || (r4(t5) ? t5 : n5);
            }, null, n4));
            if (o3)
              throw new Error(o3 + " bit range requested exceeds 48 bit (6 byte) Number max.");
            return new e3(function(t5, r5) {
              var e4 = u4 + r5;
              return e4 > t5.length ? x4(r5, u4.toString() + " bytes") : b3(e4, i3(function(n5, t6) {
                var r6 = f3(t6, n5.buf);
                return { coll: n5.coll.concat(r6.v), buf: r6.buf };
              }, { coll: [], buf: t5.slice(r5, e4) }, n4).coll);
            });
          }
          function h3(n4, t4) {
            return new e3(function(r4, e4) {
              return s4(), e4 + t4 > r4.length ? x4(e4, t4 + " bytes for " + n4) : b3(e4 + t4, r4.slice(e4, e4 + t4));
            });
          }
          function p3(n4, t4) {
            if ("number" != typeof (r4 = t4) || Math.floor(r4) !== r4 || t4 < 0 || t4 > 6)
              throw new Error(n4 + " requires integer length in range [0, 6].");
            var r4;
          }
          function d2(n4) {
            return p3("uintBE", n4), h3("uintBE(" + n4 + ")", n4).map(function(t4) {
              return t4.readUIntBE(0, n4);
            });
          }
          function v3(n4) {
            return p3("uintLE", n4), h3("uintLE(" + n4 + ")", n4).map(function(t4) {
              return t4.readUIntLE(0, n4);
            });
          }
          function g4(n4) {
            return p3("intBE", n4), h3("intBE(" + n4 + ")", n4).map(function(t4) {
              return t4.readIntBE(0, n4);
            });
          }
          function m3(n4) {
            return p3("intLE", n4), h3("intLE(" + n4 + ")", n4).map(function(t4) {
              return t4.readIntLE(0, n4);
            });
          }
          function y3(n4) {
            return n4 instanceof e3;
          }
          function E2(n4) {
            return "[object Array]" === {}.toString.call(n4);
          }
          function w4(n4) {
            return c3() && Buffer.isBuffer(n4);
          }
          function b3(n4, t4) {
            return { status: true, index: n4, value: t4, furthest: -1, expected: [] };
          }
          function x4(n4, t4) {
            return E2(t4) || (t4 = [t4]), { status: false, index: -1, value: null, furthest: n4, expected: t4 };
          }
          function B3(n4, t4) {
            if (!t4)
              return n4;
            if (n4.furthest > t4.furthest)
              return n4;
            var r4 = n4.furthest === t4.furthest ? function(n5, t5) {
              if (function() {
                if (void 0 !== e3._supportsSet)
                  return e3._supportsSet;
                var n6 = "undefined" != typeof Set;
                return e3._supportsSet = n6, n6;
              }() && Array.from) {
                for (var r5 = new Set(n5), u4 = 0; u4 < t5.length; u4++)
                  r5.add(t5[u4]);
                var o3 = Array.from(r5);
                return o3.sort(), o3;
              }
              for (var i4 = {}, a4 = 0; a4 < n5.length; a4++)
                i4[n5[a4]] = true;
              for (var f4 = 0; f4 < t5.length; f4++)
                i4[t5[f4]] = true;
              var c4 = [];
              for (var s5 in i4)
                ({}).hasOwnProperty.call(i4, s5) && c4.push(s5);
              return c4.sort(), c4;
            }(n4.expected, t4.expected) : t4.expected;
            return { status: n4.status, index: n4.index, value: n4.value, furthest: t4.furthest, expected: r4 };
          }
          var j4 = {};
          function S2(n4, t4) {
            if (w4(n4))
              return { offset: t4, line: -1, column: -1 };
            n4 in j4 || (j4[n4] = {});
            for (var r4 = j4[n4], e4 = 0, u4 = 0, o3 = 0, i4 = t4; i4 >= 0; ) {
              if (i4 in r4) {
                e4 = r4[i4].line, 0 === o3 && (o3 = r4[i4].lineStart);
                break;
              }
              ("\n" === n4.charAt(i4) || "\r" === n4.charAt(i4) && "\n" !== n4.charAt(i4 + 1)) && (u4++, 0 === o3 && (o3 = i4 + 1)), i4--;
            }
            var a4 = e4 + u4, f4 = t4 - o3;
            return r4[t4] = { line: a4, lineStart: o3 }, { offset: t4, line: a4 + 1, column: f4 + 1 };
          }
          function _3(n4) {
            if (!y3(n4))
              throw new Error("not a parser: " + n4);
          }
          function L3(n4, t4) {
            return "string" == typeof n4 ? n4.charAt(t4) : n4[t4];
          }
          function O2(n4) {
            if ("number" != typeof n4)
              throw new Error("not a number: " + n4);
          }
          function k3(n4) {
            if ("function" != typeof n4)
              throw new Error("not a function: " + n4);
          }
          function P3(n4) {
            if ("string" != typeof n4)
              throw new Error("not a string: " + n4);
          }
          var q3 = 2, A3 = 3, I3 = 8, F4 = 5 * I3, M2 = 4 * I3, z3 = "  ";
          function R(n4, t4) {
            return new Array(t4 + 1).join(n4);
          }
          function U2(n4, t4, r4) {
            var e4 = t4 - n4.length;
            return e4 <= 0 ? n4 : R(r4, e4) + n4;
          }
          function W2(n4, t4, r4, e4) {
            return { from: n4 - t4 > 0 ? n4 - t4 : 0, to: n4 + r4 > e4 ? e4 : n4 + r4 };
          }
          function D3(n4, t4) {
            var r4, e4, u4, o3, f4, c4 = t4.index, s5 = c4.offset, l5 = 1;
            if (s5 === n4.length)
              return "Got the end of the input";
            if (w4(n4)) {
              var h4 = s5 - s5 % I3, p4 = s5 - h4, d3 = W2(h4, F4, M2 + I3, n4.length), v4 = a3(function(n5) {
                return a3(function(n6) {
                  return U2(n6.toString(16), 2, "0");
                }, n5);
              }, function(n5, t5) {
                var r5 = n5.length, e5 = [], u5 = 0;
                if (r5 <= t5)
                  return [n5.slice()];
                for (var o4 = 0; o4 < r5; o4++)
                  e5[u5] || e5.push([]), e5[u5].push(n5[o4]), (o4 + 1) % t5 == 0 && u5++;
                return e5;
              }(n4.slice(d3.from, d3.to).toJSON().data, I3));
              o3 = function(n5) {
                return 0 === n5.from && 1 === n5.to ? { from: n5.from, to: n5.to } : { from: n5.from / I3, to: Math.floor(n5.to / I3) };
              }(d3), e4 = h4 / I3, r4 = 3 * p4, p4 >= 4 && (r4 += 1), l5 = 2, u4 = a3(function(n5) {
                return n5.length <= 4 ? n5.join(" ") : n5.slice(0, 4).join(" ") + "  " + n5.slice(4).join(" ");
              }, v4), (f4 = (8 * (o3.to > 0 ? o3.to - 1 : o3.to)).toString(16).length) < 2 && (f4 = 2);
            } else {
              var g5 = n4.split(/\r\n|[\n\r\u2028\u2029]/);
              r4 = c4.column - 1, e4 = c4.line - 1, o3 = W2(e4, q3, A3, g5.length), u4 = g5.slice(o3.from, o3.to), f4 = o3.to.toString().length;
            }
            var m4 = e4 - o3.from;
            return w4(n4) && (f4 = (8 * (o3.to > 0 ? o3.to - 1 : o3.to)).toString(16).length) < 2 && (f4 = 2), i3(function(t5, e5, u5) {
              var i4, a4 = u5 === m4, c5 = a4 ? "> " : z3;
              return i4 = w4(n4) ? U2((8 * (o3.from + u5)).toString(16), f4, "0") : U2((o3.from + u5 + 1).toString(), f4, " "), [].concat(t5, [c5 + i4 + " | " + e5], a4 ? [z3 + R(" ", f4) + " | " + U2("", r4, " ") + R("^", l5)] : []);
            }, [], u4).join("\n");
          }
          function N3(n4, t4) {
            return ["\n", "-- PARSING FAILED " + R("-", 50), "\n\n", D3(n4, t4), "\n\n", (r4 = t4.expected, 1 === r4.length ? "Expected:\n\n" + r4[0] : "Expected one of the following: \n\n" + r4.join(", ")), "\n"].join("");
            var r4;
          }
          function G3(n4) {
            return void 0 !== n4.flags ? n4.flags : [n4.global ? "g" : "", n4.ignoreCase ? "i" : "", n4.multiline ? "m" : "", n4.unicode ? "u" : "", n4.sticky ? "y" : ""].join("");
          }
          function C3() {
            for (var n4 = [].slice.call(arguments), t4 = n4.length, r4 = 0; r4 < t4; r4 += 1)
              _3(n4[r4]);
            return e3(function(r5, e4) {
              for (var u4, o3 = new Array(t4), i4 = 0; i4 < t4; i4 += 1) {
                if (!(u4 = B3(n4[i4]._(r5, e4), u4)).status)
                  return u4;
                o3[i4] = u4.value, e4 = u4.index;
              }
              return B3(b3(e4, o3), u4);
            });
          }
          function J2() {
            var n4 = [].slice.call(arguments);
            if (0 === n4.length)
              throw new Error("seqMap needs at least one argument");
            var t4 = n4.pop();
            return k3(t4), C3.apply(null, n4).map(function(n5) {
              return t4.apply(null, n5);
            });
          }
          function T4() {
            var n4 = [].slice.call(arguments), t4 = n4.length;
            if (0 === t4)
              return Y("zero alternates");
            for (var r4 = 0; r4 < t4; r4 += 1)
              _3(n4[r4]);
            return e3(function(t5, r5) {
              for (var e4, u4 = 0; u4 < n4.length; u4 += 1)
                if ((e4 = B3(n4[u4]._(t5, r5), e4)).status)
                  return e4;
              return e4;
            });
          }
          function V3(n4, t4) {
            return H3(n4, t4).or(X2([]));
          }
          function H3(n4, t4) {
            return _3(n4), _3(t4), J2(n4, t4.then(n4).many(), function(n5, t5) {
              return [n5].concat(t5);
            });
          }
          function K2(n4) {
            P3(n4);
            var t4 = "'" + n4 + "'";
            return e3(function(r4, e4) {
              var u4 = e4 + n4.length, o3 = r4.slice(e4, u4);
              return o3 === n4 ? b3(u4, o3) : x4(e4, t4);
            });
          }
          function Q2(n4, t4) {
            !function(n5) {
              if (!(n5 instanceof RegExp))
                throw new Error("not a regexp: " + n5);
              for (var t5 = G3(n5), r5 = 0; r5 < t5.length; r5++) {
                var e4 = t5.charAt(r5);
                if ("i" !== e4 && "m" !== e4 && "u" !== e4 && "s" !== e4)
                  throw new Error('unsupported regexp flag "' + e4 + '": ' + n5);
              }
            }(n4), arguments.length >= 2 ? O2(t4) : t4 = 0;
            var r4 = function(n5) {
              return RegExp("^(?:" + n5.source + ")", G3(n5));
            }(n4), u4 = "" + n4;
            return e3(function(n5, e4) {
              var o3 = r4.exec(n5.slice(e4));
              if (o3) {
                if (0 <= t4 && t4 <= o3.length) {
                  var i4 = o3[0], a4 = o3[t4];
                  return b3(e4 + i4.length, a4);
                }
                return x4(e4, "valid match group (0 to " + o3.length + ") in " + u4);
              }
              return x4(e4, u4);
            });
          }
          function X2(n4) {
            return e3(function(t4, r4) {
              return b3(r4, n4);
            });
          }
          function Y(n4) {
            return e3(function(t4, r4) {
              return x4(r4, n4);
            });
          }
          function Z2(n4) {
            if (y3(n4))
              return e3(function(t4, r4) {
                var e4 = n4._(t4, r4);
                return e4.index = r4, e4.value = "", e4;
              });
            if ("string" == typeof n4)
              return Z2(K2(n4));
            if (n4 instanceof RegExp)
              return Z2(Q2(n4));
            throw new Error("not a string, regexp, or parser: " + n4);
          }
          function $3(n4) {
            return _3(n4), e3(function(t4, r4) {
              var e4 = n4._(t4, r4), u4 = t4.slice(r4, e4.index);
              return e4.status ? x4(r4, 'not "' + u4 + '"') : b3(r4, null);
            });
          }
          function nn2(n4) {
            return k3(n4), e3(function(t4, r4) {
              var e4 = L3(t4, r4);
              return r4 < t4.length && n4(e4) ? b3(r4 + 1, e4) : x4(r4, "a character/byte matching " + n4);
            });
          }
          function tn2(n4, t4) {
            arguments.length < 2 && (t4 = n4, n4 = void 0);
            var r4 = e3(function(n5, e4) {
              return r4._ = t4()._, r4._(n5, e4);
            });
            return n4 ? r4.desc(n4) : r4;
          }
          function rn() {
            return Y("fantasy-land/empty");
          }
          u3.parse = function(n4) {
            if ("string" != typeof n4 && !w4(n4))
              throw new Error(".parse must be called with a string or Buffer as its argument");
            var t4, r4 = this.skip(an)._(n4, 0);
            return t4 = r4.status ? { status: true, value: r4.value } : { status: false, index: S2(n4, r4.furthest), expected: r4.expected }, delete j4[n4], t4;
          }, u3.tryParse = function(n4) {
            var t4 = this.parse(n4);
            if (t4.status)
              return t4.value;
            var r4 = N3(n4, t4), e4 = new Error(r4);
            throw e4.type = "ParsimmonError", e4.result = t4, e4;
          }, u3.assert = function(n4, t4) {
            return this.chain(function(r4) {
              return n4(r4) ? X2(r4) : Y(t4);
            });
          }, u3.or = function(n4) {
            return T4(this, n4);
          }, u3.trim = function(n4) {
            return this.wrap(n4, n4);
          }, u3.wrap = function(n4, t4) {
            return J2(n4, this, t4, function(n5, t5) {
              return t5;
            });
          }, u3.thru = function(n4) {
            return n4(this);
          }, u3.then = function(n4) {
            return _3(n4), C3(this, n4).map(function(n5) {
              return n5[1];
            });
          }, u3.many = function() {
            var n4 = this;
            return e3(function(t4, r4) {
              for (var e4 = [], u4 = void 0; ; ) {
                if (!(u4 = B3(n4._(t4, r4), u4)).status)
                  return B3(b3(r4, e4), u4);
                if (r4 === u4.index)
                  throw new Error("infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause");
                r4 = u4.index, e4.push(u4.value);
              }
            });
          }, u3.tieWith = function(n4) {
            return P3(n4), this.map(function(t4) {
              if (function(n5) {
                if (!E2(n5))
                  throw new Error("not an array: " + n5);
              }(t4), t4.length) {
                P3(t4[0]);
                for (var r4 = t4[0], e4 = 1; e4 < t4.length; e4++)
                  P3(t4[e4]), r4 += n4 + t4[e4];
                return r4;
              }
              return "";
            });
          }, u3.tie = function() {
            return this.tieWith("");
          }, u3.times = function(n4, t4) {
            var r4 = this;
            return arguments.length < 2 && (t4 = n4), O2(n4), O2(t4), e3(function(e4, u4) {
              for (var o3 = [], i4 = void 0, a4 = void 0, f4 = 0; f4 < n4; f4 += 1) {
                if (a4 = B3(i4 = r4._(e4, u4), a4), !i4.status)
                  return a4;
                u4 = i4.index, o3.push(i4.value);
              }
              for (; f4 < t4 && (a4 = B3(i4 = r4._(e4, u4), a4), i4.status); f4 += 1)
                u4 = i4.index, o3.push(i4.value);
              return B3(b3(u4, o3), a4);
            });
          }, u3.result = function(n4) {
            return this.map(function() {
              return n4;
            });
          }, u3.atMost = function(n4) {
            return this.times(0, n4);
          }, u3.atLeast = function(n4) {
            return J2(this.times(n4), this.many(), function(n5, t4) {
              return n5.concat(t4);
            });
          }, u3.map = function(n4) {
            k3(n4);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status ? B3(b3(u4.index, n4(u4.value)), u4) : u4;
            });
          }, u3.contramap = function(n4) {
            k3(n4);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4.parse(n4(r4.slice(e4)));
              return u4.status ? b3(e4 + r4.length, u4.value) : u4;
            });
          }, u3.promap = function(n4, t4) {
            return k3(n4), k3(t4), this.contramap(n4).map(t4);
          }, u3.skip = function(n4) {
            return C3(this, n4).map(function(n5) {
              return n5[0];
            });
          }, u3.mark = function() {
            return J2(en2, this, en2, function(n4, t4, r4) {
              return { start: n4, value: t4, end: r4 };
            });
          }, u3.node = function(n4) {
            return J2(en2, this, en2, function(t4, r4, e4) {
              return { name: n4, value: r4, start: t4, end: e4 };
            });
          }, u3.sepBy = function(n4) {
            return V3(this, n4);
          }, u3.sepBy1 = function(n4) {
            return H3(this, n4);
          }, u3.lookahead = function(n4) {
            return this.skip(Z2(n4));
          }, u3.notFollowedBy = function(n4) {
            return this.skip($3(n4));
          }, u3.desc = function(n4) {
            E2(n4) || (n4 = [n4]);
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status || (u4.expected = n4), u4;
            });
          }, u3.fallback = function(n4) {
            return this.or(X2(n4));
          }, u3.ap = function(n4) {
            return J2(n4, this, function(n5, t4) {
              return n5(t4);
            });
          }, u3.chain = function(n4) {
            var t4 = this;
            return e3(function(r4, e4) {
              var u4 = t4._(r4, e4);
              return u4.status ? B3(n4(u4.value)._(r4, u4.index), u4) : u4;
            });
          }, u3.concat = u3.or, u3.empty = rn, u3.of = X2, u3["fantasy-land/ap"] = u3.ap, u3["fantasy-land/chain"] = u3.chain, u3["fantasy-land/concat"] = u3.concat, u3["fantasy-land/empty"] = u3.empty, u3["fantasy-land/of"] = u3.of, u3["fantasy-land/map"] = u3.map;
          var en2 = e3(function(n4, t4) {
            return b3(t4, S2(n4, t4));
          }), un = e3(function(n4, t4) {
            return t4 >= n4.length ? x4(t4, "any character/byte") : b3(t4 + 1, L3(n4, t4));
          }), on = e3(function(n4, t4) {
            return b3(n4.length, n4.slice(t4));
          }), an = e3(function(n4, t4) {
            return t4 < n4.length ? x4(t4, "EOF") : b3(t4, null);
          }), fn = Q2(/[0-9]/).desc("a digit"), cn = Q2(/[0-9]*/).desc("optional digits"), sn = Q2(/[a-z]/i).desc("a letter"), ln = Q2(/[a-z]*/i).desc("optional letters"), hn = Q2(/\s*/).desc("optional whitespace"), pn = Q2(/\s+/).desc("whitespace"), dn = K2("\r"), vn = K2("\n"), gn = K2("\r\n"), mn = T4(gn, vn, dn).desc("newline"), yn = T4(mn, an);
          e3.all = on, e3.alt = T4, e3.any = un, e3.cr = dn, e3.createLanguage = function(n4) {
            var t4 = {};
            for (var r4 in n4)
              ({}).hasOwnProperty.call(n4, r4) && function(r5) {
                t4[r5] = tn2(function() {
                  return n4[r5](t4);
                });
              }(r4);
            return t4;
          }, e3.crlf = gn, e3.custom = function(n4) {
            return e3(n4(b3, x4));
          }, e3.digit = fn, e3.digits = cn, e3.empty = rn, e3.end = yn, e3.eof = an, e3.fail = Y, e3.formatError = N3, e3.index = en2, e3.isParser = y3, e3.lazy = tn2, e3.letter = sn, e3.letters = ln, e3.lf = vn, e3.lookahead = Z2, e3.makeFailure = x4, e3.makeSuccess = b3, e3.newline = mn, e3.noneOf = function(n4) {
            return nn2(function(t4) {
              return n4.indexOf(t4) < 0;
            }).desc("none of '" + n4 + "'");
          }, e3.notFollowedBy = $3, e3.of = X2, e3.oneOf = function(n4) {
            for (var t4 = n4.split(""), r4 = 0; r4 < t4.length; r4++)
              t4[r4] = "'" + t4[r4] + "'";
            return nn2(function(t5) {
              return n4.indexOf(t5) >= 0;
            }).desc(t4);
          }, e3.optWhitespace = hn, e3.Parser = e3, e3.range = function(n4, t4) {
            return nn2(function(r4) {
              return n4 <= r4 && r4 <= t4;
            }).desc(n4 + "-" + t4);
          }, e3.regex = Q2, e3.regexp = Q2, e3.sepBy = V3, e3.sepBy1 = H3, e3.seq = C3, e3.seqMap = J2, e3.seqObj = function() {
            for (var n4, t4 = {}, r4 = 0, u4 = (n4 = arguments, Array.prototype.slice.call(n4)), o3 = u4.length, i4 = 0; i4 < o3; i4 += 1) {
              var a4 = u4[i4];
              if (!y3(a4)) {
                if (E2(a4) && 2 === a4.length && "string" == typeof a4[0] && y3(a4[1])) {
                  var f4 = a4[0];
                  if (Object.prototype.hasOwnProperty.call(t4, f4))
                    throw new Error("seqObj: duplicate key " + f4);
                  t4[f4] = true, r4++;
                  continue;
                }
                throw new Error("seqObj arguments must be parsers or [string, parser] array pairs.");
              }
            }
            if (0 === r4)
              throw new Error("seqObj expects at least one named parser, found zero");
            return e3(function(n5, t5) {
              for (var r5, e4 = {}, i5 = 0; i5 < o3; i5 += 1) {
                var a5, f5;
                if (E2(u4[i5]) ? (a5 = u4[i5][0], f5 = u4[i5][1]) : (a5 = null, f5 = u4[i5]), !(r5 = B3(f5._(n5, t5), r5)).status)
                  return r5;
                a5 && (e4[a5] = r5.value), t5 = r5.index;
              }
              return B3(b3(t5, e4), r5);
            });
          }, e3.string = K2, e3.succeed = X2, e3.takeWhile = function(n4) {
            return k3(n4), e3(function(t4, r4) {
              for (var e4 = r4; e4 < t4.length && n4(L3(t4, e4)); )
                e4++;
              return b3(e4, t4.slice(r4, e4));
            });
          }, e3.test = nn2, e3.whitespace = pn, e3["fantasy-land/empty"] = rn, e3["fantasy-land/of"] = X2, e3.Binary = { bitSeq: l4, bitSeqObj: function(n4) {
            s4();
            var t4 = {}, r4 = 0, e4 = a3(function(n5) {
              if (E2(n5)) {
                var e5 = n5;
                if (2 !== e5.length)
                  throw new Error("[" + e5.join(", ") + "] should be length 2, got length " + e5.length);
                if (P3(e5[0]), O2(e5[1]), Object.prototype.hasOwnProperty.call(t4, e5[0]))
                  throw new Error("duplicate key in bitSeqObj: " + e5[0]);
                return t4[e5[0]] = true, r4++, e5;
              }
              return O2(n5), [null, n5];
            }, n4);
            if (r4 < 1)
              throw new Error("bitSeqObj expects at least one named pair, got [" + n4.join(", ") + "]");
            var u4 = a3(function(n5) {
              return n5[0];
            }, e4);
            return l4(a3(function(n5) {
              return n5[1];
            }, e4)).map(function(n5) {
              return i3(function(n6, t5) {
                return null !== t5[0] && (n6[t5[0]] = t5[1]), n6;
              }, {}, a3(function(t5, r5) {
                return [t5, n5[r5]];
              }, u4));
            });
          }, byte: function(n4) {
            if (s4(), O2(n4), n4 > 255)
              throw new Error("Value specified to byte constructor (" + n4 + "=0x" + n4.toString(16) + ") is larger in value than a single byte.");
            var t4 = (n4 > 15 ? "0x" : "0x0") + n4.toString(16);
            return e3(function(r4, e4) {
              var u4 = L3(r4, e4);
              return u4 === n4 ? b3(e4 + 1, u4) : x4(e4, t4);
            });
          }, buffer: function(n4) {
            return h3("buffer", n4).map(function(n5) {
              return Buffer.from(n5);
            });
          }, encodedString: function(n4, t4) {
            return h3("string", t4).map(function(t5) {
              return t5.toString(n4);
            });
          }, uintBE: d2, uint8BE: d2(1), uint16BE: d2(2), uint32BE: d2(4), uintLE: v3, uint8LE: v3(1), uint16LE: v3(2), uint32LE: v3(4), intBE: g4, int8BE: g4(1), int16BE: g4(2), int32BE: g4(4), intLE: m3, int8LE: m3(1), int16LE: m3(2), int32LE: m3(4), floatBE: h3("floatBE", 4).map(function(n4) {
            return n4.readFloatBE(0);
          }), floatLE: h3("floatLE", 4).map(function(n4) {
            return n4.readFloatLE(0);
          }), doubleBE: h3("doubleBE", 8).map(function(n4) {
            return n4.readDoubleBE(0);
          }), doubleLE: h3("doubleLE", 8).map(function(n4) {
            return n4.readDoubleLE(0);
          }) }, n3.exports = e3;
        }]);
      });
    })(parsimmon_umd_min, parsimmon_umd_min.exports);
    var parsimmon_umd_minExports = parsimmon_umd_min.exports;
    var emojiRegex = () => {
      return /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC3\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC08\uDC26](?:\u200D\u2B1B)?|[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF-\uDDB3\uDDBC\uDDBD]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
    };
    function normalizeDuration(dur) {
      if (dur === void 0 || dur === null)
        return dur;
      return dur.shiftToAll().normalize();
    }
    function getFileTitle(path) {
      if (path.includes("/"))
        path = path.substring(path.lastIndexOf("/") + 1);
      if (path.endsWith(".md"))
        path = path.substring(0, path.length - 3);
      return path;
    }
    parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u).map((str) => str.toLocaleLowerCase()), parsimmon_umd_minExports.whitespace.map((_3) => "-"), parsimmon_umd_minExports.any.map((_3) => "")).many().map((result) => result.join(""));
    var HEADER_CANONICALIZER = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regex(new RegExp(emojiRegex(), "")), parsimmon_umd_minExports.regex(/[0-9\p{Letter}_-]+/u), parsimmon_umd_minExports.whitespace.map((_3) => " "), parsimmon_umd_minExports.any.map((_3) => " ")).many().map((result) => {
      return result.join("").split(/\s+/).join(" ").trim();
    });
    function normalizeHeaderForLink(header) {
      return HEADER_CANONICALIZER.tryParse(header);
    }
    function renderMinimalDuration(dur) {
      dur = normalizeDuration(dur);
      dur = Duration.fromObject(Object.fromEntries(Object.entries(dur.toObject()).filter(([, quantity]) => quantity != 0)));
      return dur.toHuman();
    }
    var Values;
    (function(Values2) {
      function toString(field, setting = DEFAULT_QUERY_SETTINGS, recursive = false) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return setting.renderNullAs;
        switch (wrapped.type) {
          case "null":
            return setting.renderNullAs;
          case "string":
            return wrapped.value;
          case "number":
          case "boolean":
            return "" + wrapped.value;
          case "html":
            return wrapped.value.outerHTML;
          case "widget":
            return wrapped.value.markdown();
          case "link":
            return wrapped.value.markdown();
          case "function":
            return "<function>";
          case "array":
            let result = "";
            if (recursive)
              result += "[";
            result += wrapped.value.map((f3) => toString(f3, setting, true)).join(", ");
            if (recursive)
              result += "]";
            return result;
          case "object":
            return "{ " + Object.entries(wrapped.value).map((e3) => e3[0] + ": " + toString(e3[1], setting, true)).join(", ") + " }";
          case "date":
            if (wrapped.value.second == 0 && wrapped.value.hour == 0 && wrapped.value.minute == 0) {
              return wrapped.value.toFormat(setting.defaultDateFormat);
            }
            return wrapped.value.toFormat(setting.defaultDateTimeFormat);
          case "duration":
            return renderMinimalDuration(wrapped.value);
        }
      }
      Values2.toString = toString;
      function wrapValue(val) {
        if (isNull(val))
          return { type: "null", value: val };
        else if (isNumber3(val))
          return { type: "number", value: val };
        else if (isString2(val))
          return { type: "string", value: val };
        else if (isBoolean(val))
          return { type: "boolean", value: val };
        else if (isDuration(val))
          return { type: "duration", value: val };
        else if (isDate3(val))
          return { type: "date", value: val };
        else if (isWidget(val))
          return { type: "widget", value: val };
        else if (isArray2(val))
          return { type: "array", value: val };
        else if (isLink(val))
          return { type: "link", value: val };
        else if (isFunction(val))
          return { type: "function", value: val };
        else if (isHtml(val))
          return { type: "html", value: val };
        else if (isObject2(val))
          return { type: "object", value: val };
        else
          return void 0;
      }
      Values2.wrapValue = wrapValue;
      function mapLeaves(val, func) {
        if (isObject2(val)) {
          let result = {};
          for (let [key, value] of Object.entries(val))
            result[key] = mapLeaves(value, func);
          return result;
        } else if (isArray2(val)) {
          let result = [];
          for (let value of val)
            result.push(mapLeaves(value, func));
          return result;
        } else {
          return func(val);
        }
      }
      Values2.mapLeaves = mapLeaves;
      function compareValue(val1, val2, linkNormalizer) {
        var _a, _b;
        if (val1 === void 0)
          val1 = null;
        if (val2 === void 0)
          val2 = null;
        if (val1 === null && val2 === null)
          return 0;
        else if (val1 === null)
          return -1;
        else if (val2 === null)
          return 1;
        let wrap1 = wrapValue(val1);
        let wrap2 = wrapValue(val2);
        if (wrap1 === void 0 && wrap2 === void 0)
          return 0;
        else if (wrap1 === void 0)
          return -1;
        else if (wrap2 === void 0)
          return 1;
        if (wrap1.type != wrap2.type)
          return wrap1.type.localeCompare(wrap2.type);
        if (wrap1.value === wrap2.value)
          return 0;
        switch (wrap1.type) {
          case "string":
            return wrap1.value.localeCompare(wrap2.value);
          case "number":
            if (wrap1.value < wrap2.value)
              return -1;
            else if (wrap1.value == wrap2.value)
              return 0;
            return 1;
          case "null":
            return 0;
          case "boolean":
            if (wrap1.value == wrap2.value)
              return 0;
            else
              return wrap1.value ? 1 : -1;
          case "link":
            let link1 = wrap1.value;
            let link2 = wrap2.value;
            let normalize = linkNormalizer != null ? linkNormalizer : (x4) => x4;
            let pathCompare = normalize(link1.path).localeCompare(normalize(link2.path));
            if (pathCompare != 0)
              return pathCompare;
            let typeCompare = link1.type.localeCompare(link2.type);
            if (typeCompare != 0)
              return typeCompare;
            if (link1.subpath && !link2.subpath)
              return 1;
            if (!link1.subpath && link2.subpath)
              return -1;
            if (!link1.subpath && !link2.subpath)
              return 0;
            return ((_a = link1.subpath) != null ? _a : "").localeCompare((_b = link2.subpath) != null ? _b : "");
          case "date":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "duration":
            return wrap1.value < wrap2.value ? -1 : wrap1.value.equals(wrap2.value) ? 0 : 1;
          case "array":
            let f1 = wrap1.value;
            let f22 = wrap2.value;
            for (let index8 = 0; index8 < Math.min(f1.length, f22.length); index8++) {
              let comp = compareValue(f1[index8], f22[index8]);
              if (comp != 0)
                return comp;
            }
            return f1.length - f22.length;
          case "object":
            let o1 = wrap1.value;
            let o2 = wrap2.value;
            let k1 = Array.from(Object.keys(o1));
            let k22 = Array.from(Object.keys(o2));
            k1.sort();
            k22.sort();
            let keyCompare = compareValue(k1, k22);
            if (keyCompare != 0)
              return keyCompare;
            for (let key of k1) {
              let comp = compareValue(o1[key], o2[key]);
              if (comp != 0)
                return comp;
            }
            return 0;
          case "widget":
          case "html":
          case "function":
            return 0;
        }
      }
      Values2.compareValue = compareValue;
      function typeOf(val) {
        var _a;
        return (_a = wrapValue(val)) == null ? void 0 : _a.type;
      }
      Values2.typeOf = typeOf;
      function isTruthy2(field) {
        let wrapped = wrapValue(field);
        if (!wrapped)
          return false;
        switch (wrapped.type) {
          case "number":
            return wrapped.value != 0;
          case "string":
            return wrapped.value.length > 0;
          case "boolean":
            return wrapped.value;
          case "link":
            return !!wrapped.value.path;
          case "date":
            return wrapped.value.toMillis() != 0;
          case "duration":
            return wrapped.value.as("seconds") != 0;
          case "object":
            return Object.keys(wrapped.value).length > 0;
          case "array":
            return wrapped.value.length > 0;
          case "null":
            return false;
          case "html":
          case "widget":
          case "function":
            return true;
        }
      }
      Values2.isTruthy = isTruthy2;
      function deepCopy(field) {
        if (field === null || field === void 0)
          return field;
        if (Values2.isArray(field)) {
          return [].concat(field.map((v3) => deepCopy(v3)));
        } else if (Values2.isObject(field)) {
          let result = {};
          for (let [key, value] of Object.entries(field))
            result[key] = deepCopy(value);
          return result;
        } else {
          return field;
        }
      }
      Values2.deepCopy = deepCopy;
      function isString2(val) {
        return typeof val == "string";
      }
      Values2.isString = isString2;
      function isNumber3(val) {
        return typeof val == "number";
      }
      Values2.isNumber = isNumber3;
      function isDate3(val) {
        return val instanceof DateTime2;
      }
      Values2.isDate = isDate3;
      function isDuration(val) {
        return val instanceof Duration;
      }
      Values2.isDuration = isDuration;
      function isNull(val) {
        return val === null || val === void 0;
      }
      Values2.isNull = isNull;
      function isArray2(val) {
        return Array.isArray(val);
      }
      Values2.isArray = isArray2;
      function isBoolean(val) {
        return typeof val === "boolean";
      }
      Values2.isBoolean = isBoolean;
      function isLink(val) {
        return val instanceof Link;
      }
      Values2.isLink = isLink;
      function isWidget(val) {
        return val instanceof Widget;
      }
      Values2.isWidget = isWidget;
      function isHtml(val) {
        if (typeof HTMLElement !== "undefined") {
          return val instanceof HTMLElement;
        } else {
          return false;
        }
      }
      Values2.isHtml = isHtml;
      function isObject2(val) {
        return typeof val == "object" && !isHtml(val) && !isWidget(val) && !isArray2(val) && !isDuration(val) && !isDate3(val) && !isLink(val) && val !== void 0 && !isNull(val);
      }
      Values2.isObject = isObject2;
      function isFunction(val) {
        return typeof val == "function";
      }
      Values2.isFunction = isFunction;
    })(Values || (Values = {}));
    var Groupings;
    (function(Groupings2) {
      function isElementGroup(entry) {
        return Values.isObject(entry) && Object.keys(entry).length == 2 && "key" in entry && "rows" in entry;
      }
      Groupings2.isElementGroup = isElementGroup;
      function isGrouping(entry) {
        for (let element of entry)
          if (!isElementGroup(element))
            return false;
        return true;
      }
      Groupings2.isGrouping = isGrouping;
      function count(elements) {
        if (isGrouping(elements)) {
          let result = 0;
          for (let subgroup of elements)
            result += count(subgroup.rows);
          return result;
        } else {
          return elements.length;
        }
      }
      Groupings2.count = count;
    })(Groupings || (Groupings = {}));
    var Link = class {
      constructor(fields) {
        /** The file path this link points to. */
        __publicField(this, "path");
        /** The display name associated with the link. */
        __publicField(this, "display");
        /** The block ID or header this link points to within a file, if relevant. */
        __publicField(this, "subpath");
        /** Is this link an embedded link (!)? */
        __publicField(this, "embed");
        /** The type of this link, which determines what 'subpath' refers to, if anything. */
        __publicField(this, "type");
        Object.assign(this, fields);
      }
      /** Create a link to a specific file. */
      static file(path, embed = false, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: void 0,
          type: "file"
        });
      }
      static infer(linkpath, embed = false, display2) {
        if (linkpath.includes("#^")) {
          let split2 = linkpath.split("#^");
          return Link.block(split2[0], split2[1], embed, display2);
        } else if (linkpath.includes("#")) {
          let split2 = linkpath.split("#");
          return Link.header(split2[0], split2[1], embed, display2);
        } else
          return Link.file(linkpath, embed, display2);
      }
      /** Create a link to a specific file and header in that file. */
      static header(path, header, embed, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: normalizeHeaderForLink(header),
          type: "header"
        });
      }
      /** Create a link to a specific file and block in that file. */
      static block(path, blockId, embed, display2) {
        return new Link({
          path,
          embed,
          display: display2,
          subpath: blockId,
          type: "block"
        });
      }
      static fromObject(object) {
        return new Link(object);
      }
      /** Checks for link equality (i.e., that the links are pointing to the same exact location). */
      equals(other) {
        if (other == void 0 || other == null)
          return false;
        return this.path == other.path && this.type == other.type && this.subpath == other.subpath;
      }
      /** Convert this link to it's markdown representation. */
      toString() {
        return this.markdown();
      }
      /** Convert this link to a raw object which is serialization-friendly. */
      toObject() {
        return { path: this.path, type: this.type, subpath: this.subpath, display: this.display, embed: this.embed };
      }
      /** Update this link with a new path. */
      //@ts-ignore; error appeared after updating Obsidian to 0.15.4; it also updated other packages but didn't say which
      withPath(path) {
        return new Link(Object.assign({}, this, { path }));
      }
      /** Return a new link which points to the same location but with a new display value. */
      withDisplay(display2) {
        return new Link(Object.assign({}, this, { display: display2 }));
      }
      /** Convert a file link into a link to a specific header. */
      withHeader(header) {
        return Link.header(this.path, header, this.embed, this.display);
      }
      /** Convert any link into a link to its file. */
      toFile() {
        return Link.file(this.path, this.embed, this.display);
      }
      /** Convert this link into an embedded link. */
      toEmbed() {
        if (this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = true;
          return link;
        }
      }
      /** Convert this link into a non-embedded link. */
      fromEmbed() {
        if (!this.embed) {
          return this;
        } else {
          let link = new Link(this);
          link.embed = false;
          return link;
        }
      }
      /** Convert this link to markdown so it can be rendered. */
      markdown() {
        let result = (this.embed ? "!" : "") + "[[" + this.obsidianLink();
        if (this.display) {
          result += "|" + this.display;
        } else {
          result += "|" + getFileTitle(this.path);
          if (this.type == "header" || this.type == "block")
            result += " > " + this.subpath;
        }
        result += "]]";
        return result;
      }
      /** Convert the inner part of the link to something that Obsidian can open / understand. */
      obsidianLink() {
        var _a, _b;
        const escaped = this.path.replaceAll("|", "\\|");
        if (this.type == "header")
          return escaped + "#" + ((_a = this.subpath) == null ? void 0 : _a.replaceAll("|", "\\|"));
        if (this.type == "block")
          return escaped + "#^" + ((_b = this.subpath) == null ? void 0 : _b.replaceAll("|", "\\|"));
        else
          return escaped;
      }
      /** The stripped name of the file this link points to. */
      fileName() {
        return getFileTitle(this.path).replace(".md", "");
      }
    };
    var Widget = class {
      constructor($widget) {
        __publicField(this, "$widget");
        this.$widget = $widget;
      }
    };
    var ListPairWidget = class extends Widget {
      constructor(key, value) {
        super("dataview:list-pair");
        __publicField(this, "key");
        __publicField(this, "value");
        this.key = key;
        this.value = value;
      }
      markdown() {
        return `${Values.toString(this.key)}: ${Values.toString(this.value)}`;
      }
    };
    var ExternalLinkWidget = class extends Widget {
      constructor(url, display2) {
        super("dataview:external-link");
        __publicField(this, "url");
        __publicField(this, "display");
        this.url = url;
        this.display = display2;
      }
      markdown() {
        var _a;
        return `[${(_a = this.display) != null ? _a : this.url}](${this.url})`;
      }
    };
    var Widgets;
    (function(Widgets2) {
      function listPair(key, value) {
        return new ListPairWidget(key, value);
      }
      Widgets2.listPair = listPair;
      function externalLink(url, display2) {
        return new ExternalLinkWidget(url, display2);
      }
      Widgets2.externalLink = externalLink;
      function isListPair(widget) {
        return widget.$widget === "dataview:list-pair";
      }
      Widgets2.isListPair = isListPair;
      function isExternalLink(widget) {
        return widget.$widget === "dataview:external-link";
      }
      Widgets2.isExternalLink = isExternalLink;
      function isBuiltin(widget) {
        return isListPair(widget) || isExternalLink(widget);
      }
      Widgets2.isBuiltin = isBuiltin;
    })(Widgets || (Widgets = {}));
    var Fields;
    (function(Fields2) {
      function variable(name) {
        return { type: "variable", name };
      }
      Fields2.variable = variable;
      function literal(value) {
        return { type: "literal", value };
      }
      Fields2.literal = literal;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Fields2.binaryOp = binaryOp;
      function index8(obj, index9) {
        return { type: "index", object: obj, index: index9 };
      }
      Fields2.index = index8;
      function indexVariable(name) {
        let parts = name.split(".");
        let result = Fields2.variable(parts[0]);
        for (let index9 = 1; index9 < parts.length; index9++) {
          result = Fields2.index(result, Fields2.literal(parts[index9]));
        }
        return result;
      }
      Fields2.indexVariable = indexVariable;
      function lambda(args, value) {
        return { type: "lambda", arguments: args, value };
      }
      Fields2.lambda = lambda;
      function func(func2, args) {
        return { type: "function", func: func2, arguments: args };
      }
      Fields2.func = func;
      function list(values) {
        return { type: "list", values };
      }
      Fields2.list = list;
      function object(values) {
        return { type: "object", values };
      }
      Fields2.object = object;
      function negate(child) {
        return { type: "negated", child };
      }
      Fields2.negate = negate;
      function isCompareOp(op) {
        return op == "<=" || op == "<" || op == ">" || op == ">=" || op == "!=" || op == "=";
      }
      Fields2.isCompareOp = isCompareOp;
      Fields2.NULL = Fields2.literal(null);
    })(Fields || (Fields = {}));
    var Sources;
    (function(Sources2) {
      function tag(tag2) {
        return { type: "tag", tag: tag2 };
      }
      Sources2.tag = tag;
      function csv(path) {
        return { type: "csv", path };
      }
      Sources2.csv = csv;
      function folder(prefix) {
        return { type: "folder", folder: prefix };
      }
      Sources2.folder = folder;
      function link(file, incoming) {
        return { type: "link", file, direction: incoming ? "incoming" : "outgoing" };
      }
      Sources2.link = link;
      function binaryOp(left, op, right) {
        return { type: "binaryop", left, op, right };
      }
      Sources2.binaryOp = binaryOp;
      function and(left, right) {
        return { type: "binaryop", left, op: "&", right };
      }
      Sources2.and = and;
      function or(left, right) {
        return { type: "binaryop", left, op: "|", right };
      }
      Sources2.or = or;
      function negate(child) {
        return { type: "negate", child };
      }
      Sources2.negate = negate;
      function empty2() {
        return { type: "empty" };
      }
      Sources2.empty = empty2;
    })(Sources || (Sources = {}));
    var EMOJI_REGEX = new RegExp(emojiRegex(), "");
    var DURATION_TYPES = {
      year: Duration.fromObject({ years: 1 }),
      years: Duration.fromObject({ years: 1 }),
      yr: Duration.fromObject({ years: 1 }),
      yrs: Duration.fromObject({ years: 1 }),
      month: Duration.fromObject({ months: 1 }),
      months: Duration.fromObject({ months: 1 }),
      mo: Duration.fromObject({ months: 1 }),
      mos: Duration.fromObject({ months: 1 }),
      week: Duration.fromObject({ weeks: 1 }),
      weeks: Duration.fromObject({ weeks: 1 }),
      wk: Duration.fromObject({ weeks: 1 }),
      wks: Duration.fromObject({ weeks: 1 }),
      w: Duration.fromObject({ weeks: 1 }),
      day: Duration.fromObject({ days: 1 }),
      days: Duration.fromObject({ days: 1 }),
      d: Duration.fromObject({ days: 1 }),
      hour: Duration.fromObject({ hours: 1 }),
      hours: Duration.fromObject({ hours: 1 }),
      hr: Duration.fromObject({ hours: 1 }),
      hrs: Duration.fromObject({ hours: 1 }),
      h: Duration.fromObject({ hours: 1 }),
      minute: Duration.fromObject({ minutes: 1 }),
      minutes: Duration.fromObject({ minutes: 1 }),
      min: Duration.fromObject({ minutes: 1 }),
      mins: Duration.fromObject({ minutes: 1 }),
      m: Duration.fromObject({ minutes: 1 }),
      second: Duration.fromObject({ seconds: 1 }),
      seconds: Duration.fromObject({ seconds: 1 }),
      sec: Duration.fromObject({ seconds: 1 }),
      secs: Duration.fromObject({ seconds: 1 }),
      s: Duration.fromObject({ seconds: 1 })
    };
    var DATE_SHORTHANDS = {
      now: () => DateTime2.local(),
      today: () => DateTime2.local().startOf("day"),
      yesterday: () => DateTime2.local().startOf("day").minus(Duration.fromObject({ days: 1 })),
      tomorrow: () => DateTime2.local().startOf("day").plus(Duration.fromObject({ days: 1 })),
      sow: () => DateTime2.local().startOf("week"),
      "start-of-week": () => DateTime2.local().startOf("week"),
      eow: () => DateTime2.local().endOf("week"),
      "end-of-week": () => DateTime2.local().endOf("week"),
      soy: () => DateTime2.local().startOf("year"),
      "start-of-year": () => DateTime2.local().startOf("year"),
      eoy: () => DateTime2.local().endOf("year"),
      "end-of-year": () => DateTime2.local().endOf("year"),
      som: () => DateTime2.local().startOf("month"),
      "start-of-month": () => DateTime2.local().startOf("month"),
      eom: () => DateTime2.local().endOf("month"),
      "end-of-month": () => DateTime2.local().endOf("month")
    };
    var KEYWORDS = ["FROM", "WHERE", "LIMIT", "GROUP", "FLATTEN"];
    function splitOnUnescapedPipe(link) {
      let pipe = -1;
      while ((pipe = link.indexOf("|", pipe + 1)) >= 0) {
        if (pipe > 0 && link[pipe - 1] == "\\")
          continue;
        return [link.substring(0, pipe).replace(/\\\|/g, "|"), link.substring(pipe + 1)];
      }
      return [link.replace(/\\\|/g, "|"), void 0];
    }
    function parseInnerLink(rawlink) {
      let [link, display2] = splitOnUnescapedPipe(rawlink);
      return Link.infer(link, false, display2);
    }
    function createBinaryParser(child, sep, combine2) {
      return parsimmon_umd_minExports.seqMap(child, parsimmon_umd_minExports.seq(parsimmon_umd_minExports.optWhitespace, sep, parsimmon_umd_minExports.optWhitespace, child).many(), (first, rest) => {
        if (rest.length == 0)
          return first;
        let node = combine2(first, rest[0][1], rest[0][3]);
        for (let index8 = 1; index8 < rest.length; index8++) {
          node = combine2(node, rest[index8][1], rest[index8][3]);
        }
        return node;
      });
    }
    function chainOpt(base, ...funcs) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i3) => {
          let result = base._(input, i3);
          if (!result.status)
            return result;
          for (let func of funcs) {
            let next = func(result.value)._(input, result.index);
            if (!next.status)
              return result;
            result = next;
          }
          return result;
        };
      });
    }
    var EXPRESSION = parsimmon_umd_minExports.createLanguage({
      // A floating point number; the decimal point is optional.
      number: (q3) => parsimmon_umd_minExports.regexp(/-?[0-9]+(\.[0-9]+)?/).map((str) => Number.parseFloat(str)).desc("number"),
      // A quote-surrounded string which supports escape characters ('\').
      string: (q3) => parsimmon_umd_minExports.string('"').then(parsimmon_umd_minExports.alt(q3.escapeCharacter, parsimmon_umd_minExports.noneOf('"\\')).atLeast(0).map((chars) => chars.join(""))).skip(parsimmon_umd_minExports.string('"')).desc("string"),
      escapeCharacter: (_3) => parsimmon_umd_minExports.string("\\").then(parsimmon_umd_minExports.any).map((escaped) => {
        if (escaped === '"')
          return '"';
        if (escaped === "\\")
          return "\\";
        else
          return "\\" + escaped;
      }),
      // A boolean true/false value.
      bool: (_3) => parsimmon_umd_minExports.regexp(/true|false|True|False/).map((str) => str.toLowerCase() == "true").desc("boolean ('true' or 'false')"),
      // A tag of the form '#stuff/hello-there'.
      tag: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("#"), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]/).desc("text")).many(), (start, rest) => start + rest.join("")).desc("tag ('#hello/stuff')"),
      // A variable identifier, which is alphanumeric and must start with a letter or... emoji.
      identifier: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/\p{Letter}/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")), parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/[0-9\p{Letter}_-]/u), parsimmon_umd_minExports.regexp(EMOJI_REGEX).desc("text")).many(), (first, rest) => first + rest.join("")).desc("variable identifier"),
      // An Obsidian link of the form [[<link>]].
      link: (_3) => parsimmon_umd_minExports.regexp(/\[\[([^\[\]]*?)\]\]/u, 1).map((linkInner) => parseInnerLink(linkInner)).desc("file link"),
      // An embeddable link which can start with '!'. This overlaps with the normal negation operator, so it is only
      // provided for metadata parsing.
      embedLink: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!").atMost(1), q3.link, (p3, l4) => {
        if (p3.length > 0)
          l4.embed = true;
        return l4;
      }).desc("file link"),
      // Binary plus or minus operator.
      binaryPlusMinus: (_3) => parsimmon_umd_minExports.regexp(/\+|-/).map((str) => str).desc("'+' or '-'"),
      // Binary times or divide operator.
      binaryMulDiv: (_3) => parsimmon_umd_minExports.regexp(/\*|\/|%/).map((str) => str).desc("'*' or '/' or '%'"),
      // Binary comparison operator.
      binaryCompareOp: (_3) => parsimmon_umd_minExports.regexp(/>=|<=|!=|>|<|=/).map((str) => str).desc("'>=' or '<=' or '!=' or '=' or '>' or '<'"),
      // Binary boolean combination operator.
      binaryBooleanOp: (_3) => parsimmon_umd_minExports.regexp(/and|or|&|\|/i).map((str) => {
        if (str.toLowerCase() == "and")
          return "&";
        else if (str.toLowerCase() == "or")
          return "|";
        else
          return str;
      }).desc("'and' or 'or'"),
      // A date which can be YYYY-MM[-DDTHH:mm:ss].
      rootDate: (_3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/\d{4}/), parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (year, _4, month) => {
        return DateTime2.fromObject({ year: Number.parseInt(year), month: Number.parseInt(month) });
      }).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      dateShorthand: (_3) => parsimmon_umd_minExports.alt(...Object.keys(DATE_SHORTHANDS).sort((a3, b3) => b3.length - a3.length).map(parsimmon_umd_minExports.string)),
      date: (q3) => chainOpt(q3.rootDate, (ym) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, day) => ym.set({ day: Number.parseInt(day) })), (ymd) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("T"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, hour) => ymd.set({ hour: Number.parseInt(hour) })), (ymdh) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, minute) => ymdh.set({ minute: Number.parseInt(minute) })), (ymdhm) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string(":"), parsimmon_umd_minExports.regexp(/\d{2}/), (_3, second) => ymdhm.set({ second: Number.parseInt(second) })), (ymdhms) => parsimmon_umd_minExports.alt(
        parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), parsimmon_umd_minExports.regexp(/\d{3}/), (_3, millisecond) => ymdhms.set({ millisecond: Number.parseInt(millisecond) })),
        parsimmon_umd_minExports.succeed(ymdhms)
        // pass
      ), (dt) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("+").or(parsimmon_umd_minExports.string("-")), parsimmon_umd_minExports.regexp(/\d{1,2}(:\d{2})?/), (pm, hr) => dt.setZone("UTC" + pm + hr, { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("Z"), () => dt.setZone("utc", { keepLocalTime: true })), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.regexp(/[0-9A-Za-z+-\/]+/u), parsimmon_umd_minExports.string("]"), (_a, zone, _b) => dt.setZone(zone, { keepLocalTime: true })))).assert((dt) => dt.isValid, "valid date").desc("date in format YYYY-MM[-DDTHH-MM-SS.MS]"),
      // A date, plus various shorthand times of day it could be.
      datePlus: (q3) => parsimmon_umd_minExports.alt(q3.dateShorthand.map((d2) => DATE_SHORTHANDS[d2]()), q3.date).desc("date in format YYYY-MM[-DDTHH-MM-SS.MS] or in shorthand"),
      // A duration of time.
      durationType: (_3) => parsimmon_umd_minExports.alt(...Object.keys(DURATION_TYPES).sort((a3, b3) => b3.length - a3.length).map(parsimmon_umd_minExports.string)),
      duration: (q3) => parsimmon_umd_minExports.seqMap(q3.number, parsimmon_umd_minExports.optWhitespace, q3.durationType, (count, _3, t3) => DURATION_TYPES[t3].mapUnits((x4) => x4 * count)).sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).or(parsimmon_umd_minExports.optWhitespace)).map((durations) => durations.reduce((p3, c3) => p3.plus(c3))).desc("duration like 4hr2min"),
      // A raw null value.
      rawNull: (_3) => parsimmon_umd_minExports.string("null"),
      // Source parsing.
      tagSource: (q3) => q3.tag.map((tag) => Sources.tag(tag)),
      csvSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("csv(").skip(parsimmon_umd_minExports.optWhitespace), q3.string, parsimmon_umd_minExports.string(")"), (_1, path, _22) => Sources.csv(path)),
      linkIncomingSource: (q3) => q3.link.map((link) => Sources.link(link.path, true)),
      linkOutgoingSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("outgoing(").skip(parsimmon_umd_minExports.optWhitespace), q3.link, parsimmon_umd_minExports.string(")"), (_1, link, _22) => Sources.link(link.path, false)),
      folderSource: (q3) => q3.string.map((str) => Sources.folder(str)),
      parensSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.source, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _22, field, _3, _4) => field),
      negateSource: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.alt(parsimmon_umd_minExports.string("-"), parsimmon_umd_minExports.string("!")), q3.atomSource, (_3, source) => Sources.negate(source)),
      atomSource: (q3) => parsimmon_umd_minExports.alt(q3.parensSource, q3.negateSource, q3.linkOutgoingSource, q3.linkIncomingSource, q3.folderSource, q3.tagSource, q3.csvSource),
      binaryOpSource: (q3) => createBinaryParser(q3.atomSource, q3.binaryBooleanOp.map((s4) => s4), Sources.binaryOp),
      source: (q3) => q3.binaryOpSource,
      // Field parsing.
      variableField: (q3) => q3.identifier.chain((r3) => {
        if (KEYWORDS.includes(r3.toUpperCase())) {
          return parsimmon_umd_minExports.fail("Variable fields cannot be a keyword (" + KEYWORDS.join(" or ") + ")");
        } else {
          return parsimmon_umd_minExports.succeed(Fields.variable(r3));
        }
      }).desc("variable"),
      numberField: (q3) => q3.number.map((val) => Fields.literal(val)).desc("number"),
      stringField: (q3) => q3.string.map((val) => Fields.literal(val)).desc("string"),
      boolField: (q3) => q3.bool.map((val) => Fields.literal(val)).desc("boolean"),
      dateField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("date("), parsimmon_umd_minExports.optWhitespace, q3.datePlus, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, date, _22, postfix) => Fields.literal(date)).desc("date"),
      durationField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("dur("), parsimmon_umd_minExports.optWhitespace, q3.duration, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (prefix, _1, dur, _22, postfix) => Fields.literal(dur)).desc("duration"),
      nullField: (q3) => q3.rawNull.map((_3) => Fields.NULL),
      linkField: (q3) => q3.link.map((f3) => Fields.literal(f3)),
      listField: (q3) => q3.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("[").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("]"))).map((l4) => Fields.list(l4)).desc("list ('[1, 2, 3]')"),
      objectField: (q3) => parsimmon_umd_minExports.seqMap(q3.identifier.or(q3.string), parsimmon_umd_minExports.string(":").trim(parsimmon_umd_minExports.optWhitespace), q3.field, (name, _sep, value) => {
        return { name, value };
      }).sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("{").skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.optWhitespace.then(parsimmon_umd_minExports.string("}"))).map((vals) => {
        let res = {};
        for (let entry of vals)
          res[entry.name] = entry.value;
        return Fields.object(res);
      }).desc("object ('{ a: 1, b: 2 }')"),
      atomInlineField: (q3) => parsimmon_umd_minExports.alt(q3.date, q3.duration.map((d2) => normalizeDuration(d2)), q3.string, q3.tag, q3.embedLink, q3.bool, q3.number, q3.rawNull),
      inlineFieldList: (q3) => q3.atomInlineField.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace).lookahead(q3.atomInlineField)),
      inlineField: (q3) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.seqMap(q3.atomInlineField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace), q3.inlineFieldList, (f3, _s, l4) => [f3].concat(l4)), q3.atomInlineField),
      atomField: (q3) => parsimmon_umd_minExports.alt(
        // Place embed links above negated fields as they are the special parser case '![[thing]]' and are generally unambigious.
        q3.embedLink.map((l4) => Fields.literal(l4)),
        q3.negatedField,
        q3.linkField,
        q3.listField,
        q3.objectField,
        q3.lambdaField,
        q3.parensField,
        q3.boolField,
        q3.numberField,
        q3.stringField,
        q3.dateField,
        q3.durationField,
        q3.nullField,
        q3.variableField
      ),
      indexField: (q3) => parsimmon_umd_minExports.seqMap(q3.atomField, parsimmon_umd_minExports.alt(q3.dotPostfix, q3.indexPostfix, q3.functionPostfix).many(), (obj, postfixes) => {
        let result = obj;
        for (let post of postfixes) {
          switch (post.type) {
            case "dot":
              result = Fields.index(result, Fields.literal(post.field));
              break;
            case "index":
              result = Fields.index(result, post.field);
              break;
            case "function":
              result = Fields.func(result, post.fields);
              break;
          }
        }
        return result;
      }),
      negatedField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("!"), q3.indexField, (_3, field) => Fields.negate(field)).desc("negated field"),
      parensField: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_1, _22, field, _3, _4) => field),
      lambdaField: (q3) => parsimmon_umd_minExports.seqMap(q3.identifier.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)).wrap(parsimmon_umd_minExports.string("(").trim(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.string(")").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.string("=>").trim(parsimmon_umd_minExports.optWhitespace), q3.field, (ident, _ignore, value) => {
        return { type: "lambda", arguments: ident, value };
      }),
      dotPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("."), q3.identifier, (_3, field) => {
        return { type: "dot", field };
      }),
      indexPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("["), parsimmon_umd_minExports.optWhitespace, q3.field, parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string("]"), (_3, _22, field, _32, _4) => {
        return { type: "index", field };
      }),
      functionPostfix: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.string("("), parsimmon_umd_minExports.optWhitespace, q3.field.sepBy(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), parsimmon_umd_minExports.optWhitespace, parsimmon_umd_minExports.string(")"), (_3, _1, fields, _22, _32) => {
        return { type: "function", fields };
      }),
      // The precedence hierarchy of operators - multiply/divide, add/subtract, compare, and then boolean operations.
      binaryMulDivField: (q3) => createBinaryParser(q3.indexField, q3.binaryMulDiv, Fields.binaryOp),
      binaryPlusMinusField: (q3) => createBinaryParser(q3.binaryMulDivField, q3.binaryPlusMinus, Fields.binaryOp),
      binaryCompareField: (q3) => createBinaryParser(q3.binaryPlusMinusField, q3.binaryCompareOp, Fields.binaryOp),
      binaryBooleanField: (q3) => createBinaryParser(q3.binaryCompareField, q3.binaryBooleanOp, Fields.binaryOp),
      binaryOpField: (q3) => q3.binaryBooleanField,
      field: (q3) => q3.binaryOpField
    });
    function parseField(text) {
      try {
        return Result.success(EXPRESSION.field.tryParse(text));
      } catch (error) {
        return Result.failure("" + error);
      }
    }
    var QueryFields;
    (function(QueryFields2) {
      function named(name, field) {
        return { name, field };
      }
      QueryFields2.named = named;
      function sortBy(field, dir) {
        return { field, direction: dir };
      }
      QueryFields2.sortBy = sortBy;
    })(QueryFields || (QueryFields = {}));
    function captureRaw(base) {
      return parsimmon_umd_minExports.custom((success, failure) => {
        return (input, i3) => {
          let result = base._(input, i3);
          if (!result.status)
            return result;
          return Object.assign({}, result, { value: [result.value, input.substring(i3, result.index)] });
        };
      });
    }
    function stripNewlines(text) {
      return text.split(/[\r\n]+/).map((t3) => t3.trim()).join("");
    }
    function precededByWhitespaceIfNotEof(if_eof, parser) {
      return parsimmon_umd_minExports.eof.map(if_eof).or(parsimmon_umd_minExports.whitespace.then(parser));
    }
    var QUERY_LANGUAGE = parsimmon_umd_minExports.createLanguage({
      // Simple atom parsing, like words, identifiers, numbers.
      queryType: (q3) => parsimmon_umd_minExports.alt(parsimmon_umd_minExports.regexp(/TABLE|LIST|TASK|CALENDAR/i)).map((str) => str.toLowerCase()).desc("query type ('TABLE', 'LIST', 'TASK', or 'CALENDAR')"),
      explicitNamedField: (q3) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.whitespace), parsimmon_umd_minExports.regexp(/AS/i).skip(parsimmon_umd_minExports.whitespace), EXPRESSION.identifier.or(EXPRESSION.string), (field, _as, ident) => QueryFields.named(ident, field)),
      comment: () => parsimmon_umd_minExports.Parser((input, i3) => {
        let line = input.substring(i3);
        if (!line.startsWith("//"))
          return parsimmon_umd_minExports.makeFailure(i3, "Not a comment");
        line = line.split("\n")[0];
        let comment = line.substring(2).trim();
        return parsimmon_umd_minExports.makeSuccess(i3 + line.length, comment);
      }),
      namedField: (q3) => parsimmon_umd_minExports.alt(q3.explicitNamedField, captureRaw(EXPRESSION.field).map(([value, text]) => QueryFields.named(stripNewlines(text), value))),
      sortField: (q3) => parsimmon_umd_minExports.seqMap(EXPRESSION.field.skip(parsimmon_umd_minExports.optWhitespace), parsimmon_umd_minExports.regexp(/ASCENDING|DESCENDING|ASC|DESC/i).atMost(1), (field, dir) => {
        let direction = dir.length == 0 ? "ascending" : dir[0].toLowerCase();
        if (direction == "desc")
          direction = "descending";
        if (direction == "asc")
          direction = "ascending";
        return {
          field,
          direction
        };
      }),
      headerClause: (q3) => q3.queryType.chain((type) => {
        switch (type) {
          case "table": {
            return precededByWhitespaceIfNotEof(() => ({ type, fields: [], showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), parsimmon_umd_minExports.sepBy(q3.namedField, parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (withoutId, fields) => {
              return { type, fields, showId: withoutId.length == 0 };
            }));
          }
          case "list":
            return precededByWhitespaceIfNotEof(() => ({ type, format: void 0, showId: true }), parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WITHOUT\s+ID/i).skip(parsimmon_umd_minExports.optWhitespace).atMost(1), EXPRESSION.field.atMost(1), (withoutId, format) => {
              return {
                type,
                format: format.length == 1 ? format[0] : void 0,
                showId: withoutId.length == 0
              };
            }));
          case "task":
            return parsimmon_umd_minExports.succeed({ type });
          case "calendar":
            return parsimmon_umd_minExports.whitespace.then(parsimmon_umd_minExports.seqMap(q3.namedField, (field) => {
              return {
                type,
                showId: true,
                field
              };
            }));
          default:
            return parsimmon_umd_minExports.fail(`Unrecognized query type '${type}'`);
        }
      }).desc("TABLE or LIST or TASK or CALENDAR"),
      fromClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FROM/i), parsimmon_umd_minExports.whitespace, EXPRESSION.source, (_1, _22, source) => source),
      whereClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/WHERE/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (where, _3, field) => {
        return { type: "where", clause: field };
      }).desc("WHERE <expression>"),
      sortByClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/SORT/i), parsimmon_umd_minExports.whitespace, q3.sortField.sepBy1(parsimmon_umd_minExports.string(",").trim(parsimmon_umd_minExports.optWhitespace)), (sort2, _1, fields) => {
        return { type: "sort", fields };
      }).desc("SORT field [ASC/DESC]"),
      limitClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/LIMIT/i), parsimmon_umd_minExports.whitespace, EXPRESSION.field, (limit, _1, field) => {
        return { type: "limit", amount: field };
      }).desc("LIMIT <value>"),
      flattenClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/FLATTEN/i).skip(parsimmon_umd_minExports.whitespace), q3.namedField, (_3, field) => {
        return { type: "flatten", field };
      }).desc("FLATTEN <value> [AS <name>]"),
      groupByClause: (q3) => parsimmon_umd_minExports.seqMap(parsimmon_umd_minExports.regexp(/GROUP BY/i).skip(parsimmon_umd_minExports.whitespace), q3.namedField, (_3, field) => {
        return { type: "group", field };
      }).desc("GROUP BY <value> [AS <name>]"),
      // Full query parsing.
      clause: (q3) => parsimmon_umd_minExports.alt(q3.fromClause, q3.whereClause, q3.sortByClause, q3.limitClause, q3.groupByClause, q3.flattenClause),
      query: (q3) => parsimmon_umd_minExports.seqMap(q3.headerClause.trim(optionalWhitespaceOrComment), q3.fromClause.trim(optionalWhitespaceOrComment).atMost(1), q3.clause.trim(optionalWhitespaceOrComment).many(), (header, from, clauses) => {
        return {
          header,
          source: from.length == 0 ? Sources.folder("") : from[0],
          operations: clauses,
          settings: DEFAULT_QUERY_SETTINGS
        };
      })
    });
    var optionalWhitespaceOrComment = parsimmon_umd_minExports.alt(parsimmon_umd_minExports.whitespace, QUERY_LANGUAGE.comment).many().map((arr) => arr.join(""));
    var getAPI2 = (app) => {
      var _a;
      if (app)
        return (_a = app.plugins.plugins.dataview) == null ? void 0 : _a.api;
      else
        return window.DataviewAPI;
    };
    var isPluginEnabled = (app) => app.plugins.enabledPlugins.has("dataview");
    exports.DATE_SHORTHANDS = DATE_SHORTHANDS;
    exports.DURATION_TYPES = DURATION_TYPES;
    exports.EXPRESSION = EXPRESSION;
    exports.KEYWORDS = KEYWORDS;
    exports.QUERY_LANGUAGE = QUERY_LANGUAGE;
    exports.getAPI = getAPI2;
    exports.isPluginEnabled = isPluginEnabled;
    exports.parseField = parseField;
  }
});

// node_modules/ical.js/build/ical.js
var require_ical = __commonJS({
  "node_modules/ical.js/build/ical.js"(exports, module2) {
    var ICAL2;
    (function() {
      if (typeof module2 === "object") {
        ICAL2 = module2.exports;
      } else if (typeof HTMLScriptElement !== "undefined" && "noModule" in HTMLScriptElement.prototype) {
        window.ICAL = ICAL2 = {};
      } else if (typeof ICAL2 !== "object") {
        ICAL2 = {};
      }
    })();
    ICAL2.foldLength = 75;
    ICAL2.newLineChar = "\r\n";
    ICAL2.helpers = {
      /**
       * Compiles a list of all referenced TZIDs in all subcomponents and
       * removes any extra VTIMEZONE subcomponents. In addition, if any TZIDs
       * are referenced by a component, but a VTIMEZONE does not exist,
       * an attempt will be made to generate a VTIMEZONE using ICAL.TimezoneService.
       *
       * @param {ICAL.Component} vcal     The top-level VCALENDAR component.
       * @return {ICAL.Component}         The ICAL.Component that was passed in.
       */
      updateTimezones: function(vcal) {
        var allsubs, properties, vtimezones, reqTzid, i3, tzid;
        if (!vcal || vcal.name !== "vcalendar") {
          return vcal;
        }
        allsubs = vcal.getAllSubcomponents();
        properties = [];
        vtimezones = {};
        for (i3 = 0; i3 < allsubs.length; i3++) {
          if (allsubs[i3].name === "vtimezone") {
            tzid = allsubs[i3].getFirstProperty("tzid").getFirstValue();
            vtimezones[tzid] = allsubs[i3];
          } else {
            properties = properties.concat(allsubs[i3].getAllProperties());
          }
        }
        reqTzid = {};
        for (i3 = 0; i3 < properties.length; i3++) {
          if (tzid = properties[i3].getParameter("tzid")) {
            reqTzid[tzid] = true;
          }
        }
        for (i3 in vtimezones) {
          if (vtimezones.hasOwnProperty(i3) && !reqTzid[i3]) {
            vcal.removeSubcomponent(vtimezones[i3]);
          }
        }
        for (i3 in reqTzid) {
          if (reqTzid.hasOwnProperty(i3) && !vtimezones[i3] && ICAL2.TimezoneService.has(i3)) {
            vcal.addSubcomponent(ICAL2.TimezoneService.get(i3).component);
          }
        }
        return vcal;
      },
      /**
       * Checks if the given type is of the number type and also NaN.
       *
       * @param {Number} number     The number to check
       * @return {Boolean}          True, if the number is strictly NaN
       */
      isStrictlyNaN: function(number) {
        return typeof number === "number" && isNaN(number);
      },
      /**
       * Parses a string value that is expected to be an integer, when the valid is
       * not an integer throws a decoration error.
       *
       * @param {String} string     Raw string input
       * @return {Number}           Parsed integer
       */
      strictParseInt: function(string) {
        var result = parseInt(string, 10);
        if (ICAL2.helpers.isStrictlyNaN(result)) {
          throw new Error(
            'Could not extract integer from "' + string + '"'
          );
        }
        return result;
      },
      /**
       * Creates or returns a class instance of a given type with the initialization
       * data if the data is not already an instance of the given type.
       *
       * @example
       * var time = new ICAL.Time(...);
       * var result = ICAL.helpers.formatClassType(time, ICAL.Time);
       *
       * (result instanceof ICAL.Time)
       * // => true
       *
       * result = ICAL.helpers.formatClassType({}, ICAL.Time);
       * (result isntanceof ICAL.Time)
       * // => true
       *
       *
       * @param {Object} data       object initialization data
       * @param {Object} type       object type (like ICAL.Time)
       * @return {?}                An instance of the found type.
       */
      formatClassType: function formatClassType(data, type) {
        if (typeof data === "undefined") {
          return void 0;
        }
        if (data instanceof type) {
          return data;
        }
        return new type(data);
      },
      /**
       * Identical to indexOf but will only match values when they are not preceded
       * by a backslash character.
       *
       * @param {String} buffer         String to search
       * @param {String} search         Value to look for
       * @param {Number} pos            Start position
       * @return {Number}               The position, or -1 if not found
       */
      unescapedIndexOf: function(buffer, search, pos) {
        while ((pos = buffer.indexOf(search, pos)) !== -1) {
          if (pos > 0 && buffer[pos - 1] === "\\") {
            pos += 1;
          } else {
            return pos;
          }
        }
        return -1;
      },
      /**
       * Find the index for insertion using binary search.
       *
       * @param {Array} list            The list to search
       * @param {?} seekVal             The value to insert
       * @param {function(?,?)} cmpfunc The comparison func, that can
       *                                  compare two seekVals
       * @return {Number}               The insert position
       */
      binsearchInsert: function(list, seekVal, cmpfunc) {
        if (!list.length)
          return 0;
        var low = 0, high = list.length - 1, mid, cmpval;
        while (low <= high) {
          mid = low + Math.floor((high - low) / 2);
          cmpval = cmpfunc(seekVal, list[mid]);
          if (cmpval < 0)
            high = mid - 1;
          else if (cmpval > 0)
            low = mid + 1;
          else
            break;
        }
        if (cmpval < 0)
          return mid;
        else if (cmpval > 0)
          return mid + 1;
        else
          return mid;
      },
      /**
       * Convenience function for debug output
       * @private
       */
      dumpn: (
        /* istanbul ignore next */
        function() {
          if (!ICAL2.debug) {
            return;
          }
          if (typeof console !== "undefined" && "log" in console) {
            ICAL2.helpers.dumpn = function consoleDumpn(input) {
              console.log(input);
            };
          } else {
            ICAL2.helpers.dumpn = function geckoDumpn(input) {
              dump(input + "\n");
            };
          }
          ICAL2.helpers.dumpn(arguments[0]);
        }
      ),
      /**
       * Clone the passed object or primitive. By default a shallow clone will be
       * executed.
       *
       * @param {*} aSrc            The thing to clone
       * @param {Boolean=} aDeep    If true, a deep clone will be performed
       * @return {*}                The copy of the thing
       */
      clone: function(aSrc, aDeep) {
        if (!aSrc || typeof aSrc != "object") {
          return aSrc;
        } else if (aSrc instanceof Date) {
          return new Date(aSrc.getTime());
        } else if ("clone" in aSrc) {
          return aSrc.clone();
        } else if (Array.isArray(aSrc)) {
          var arr = [];
          for (var i3 = 0; i3 < aSrc.length; i3++) {
            arr.push(aDeep ? ICAL2.helpers.clone(aSrc[i3], true) : aSrc[i3]);
          }
          return arr;
        } else {
          var obj = {};
          for (var name in aSrc) {
            if (Object.prototype.hasOwnProperty.call(aSrc, name)) {
              if (aDeep) {
                obj[name] = ICAL2.helpers.clone(aSrc[name], true);
              } else {
                obj[name] = aSrc[name];
              }
            }
          }
          return obj;
        }
      },
      /**
       * Performs iCalendar line folding. A line ending character is inserted and
       * the next line begins with a whitespace.
       *
       * @example
       * SUMMARY:This line will be fold
       *  ed right in the middle of a word.
       *
       * @param {String} aLine      The line to fold
       * @return {String}           The folded line
       */
      foldline: function foldline(aLine) {
        var result = "";
        var line = aLine || "", pos = 0, line_length = 0;
        while (line.length) {
          var cp = line.codePointAt(pos);
          if (cp < 128)
            ++line_length;
          else if (cp < 2048)
            line_length += 2;
          else if (cp < 65536)
            line_length += 3;
          else
            line_length += 4;
          if (line_length < ICAL2.foldLength + 1)
            pos += cp > 65535 ? 2 : 1;
          else {
            result += ICAL2.newLineChar + " " + line.substring(0, pos);
            line = line.substring(pos);
            pos = line_length = 0;
          }
        }
        return result.substr(ICAL2.newLineChar.length + 1);
      },
      /**
       * Pads the given string or number with zeros so it will have at least two
       * characters.
       *
       * @param {String|Number} data    The string or number to pad
       * @return {String}               The number padded as a string
       */
      pad2: function pad(data) {
        if (typeof data !== "string") {
          if (typeof data === "number") {
            data = parseInt(data);
          }
          data = String(data);
        }
        var len = data.length;
        switch (len) {
          case 0:
            return "00";
          case 1:
            return "0" + data;
          default:
            return data;
        }
      },
      /**
       * Truncates the given number, correctly handling negative numbers.
       *
       * @param {Number} number     The number to truncate
       * @return {Number}           The truncated number
       */
      trunc: function trunc(number) {
        return number < 0 ? Math.ceil(number) : Math.floor(number);
      },
      /**
       * Poor-man's cross-browser inheritance for JavaScript. Doesn't support all
       * the features, but enough for our usage.
       *
       * @param {Function} base     The base class constructor function.
       * @param {Function} child    The child class constructor function.
       * @param {Object} extra      Extends the prototype with extra properties
       *                              and methods
       */
      inherits: function(base, child, extra) {
        function F4() {
        }
        F4.prototype = base.prototype;
        child.prototype = new F4();
        if (extra) {
          ICAL2.helpers.extend(extra, child.prototype);
        }
      },
      /**
       * Poor-man's cross-browser object extension. Doesn't support all the
       * features, but enough for our usage. Note that the target's properties are
       * not overwritten with the source properties.
       *
       * @example
       * var child = ICAL.helpers.extend(parent, {
       *   "bar": 123
       * });
       *
       * @param {Object} source     The object to extend
       * @param {Object} target     The object to extend with
       * @return {Object}           Returns the target.
       */
      extend: function(source, target) {
        for (var key in source) {
          var descr = Object.getOwnPropertyDescriptor(source, key);
          if (descr && !Object.getOwnPropertyDescriptor(target, key)) {
            Object.defineProperty(target, key, descr);
          }
        }
        return target;
      }
    };
    ICAL2.design = function() {
      "use strict";
      var FROM_ICAL_NEWLINE = /\\\\|\\;|\\,|\\[Nn]/g;
      var TO_ICAL_NEWLINE = /\\|;|,|\n/g;
      var FROM_VCARD_NEWLINE = /\\\\|\\,|\\[Nn]/g;
      var TO_VCARD_NEWLINE = /\\|,|\n/g;
      function createTextType(fromNewline, toNewline) {
        var result = {
          matches: /.*/,
          fromICAL: function(aValue, structuredEscape) {
            return replaceNewline(aValue, fromNewline, structuredEscape);
          },
          toICAL: function(aValue, structuredEscape) {
            var regEx = toNewline;
            if (structuredEscape)
              regEx = new RegExp(regEx.source + "|" + structuredEscape);
            return aValue.replace(regEx, function(str) {
              switch (str) {
                case "\\":
                  return "\\\\";
                case ";":
                  return "\\;";
                case ",":
                  return "\\,";
                case "\n":
                  return "\\n";
                default:
                  return str;
              }
            });
          }
        };
        return result;
      }
      var DEFAULT_TYPE_TEXT = { defaultType: "text" };
      var DEFAULT_TYPE_TEXT_MULTI = { defaultType: "text", multiValue: "," };
      var DEFAULT_TYPE_TEXT_STRUCTURED = { defaultType: "text", structuredValue: ";" };
      var DEFAULT_TYPE_INTEGER = { defaultType: "integer" };
      var DEFAULT_TYPE_DATETIME_DATE = { defaultType: "date-time", allowedTypes: ["date-time", "date"] };
      var DEFAULT_TYPE_DATETIME = { defaultType: "date-time" };
      var DEFAULT_TYPE_URI = { defaultType: "uri" };
      var DEFAULT_TYPE_UTCOFFSET = { defaultType: "utc-offset" };
      var DEFAULT_TYPE_RECUR = { defaultType: "recur" };
      var DEFAULT_TYPE_DATE_ANDOR_TIME = { defaultType: "date-and-or-time", allowedTypes: ["date-time", "date", "text"] };
      function replaceNewlineReplace(string) {
        switch (string) {
          case "\\\\":
            return "\\";
          case "\\;":
            return ";";
          case "\\,":
            return ",";
          case "\\n":
          case "\\N":
            return "\n";
          default:
            return string;
        }
      }
      function replaceNewline(value, newline, structuredEscape) {
        if (value.indexOf("\\") === -1) {
          return value;
        }
        if (structuredEscape)
          newline = new RegExp(newline.source + "|\\\\" + structuredEscape);
        return value.replace(newline, replaceNewlineReplace);
      }
      var commonProperties = {
        "categories": DEFAULT_TYPE_TEXT_MULTI,
        "url": DEFAULT_TYPE_URI,
        "version": DEFAULT_TYPE_TEXT,
        "uid": DEFAULT_TYPE_TEXT
      };
      var commonValues = {
        "boolean": {
          values: ["TRUE", "FALSE"],
          fromICAL: function(aValue) {
            switch (aValue) {
              case "TRUE":
                return true;
              case "FALSE":
                return false;
              default:
                return false;
            }
          },
          toICAL: function(aValue) {
            if (aValue) {
              return "TRUE";
            }
            return "FALSE";
          }
        },
        float: {
          matches: /^[+-]?\d+\.\d+$/,
          fromICAL: function(aValue) {
            var parsed = parseFloat(aValue);
            if (ICAL2.helpers.isStrictlyNaN(parsed)) {
              return 0;
            }
            return parsed;
          },
          toICAL: function(aValue) {
            return String(aValue);
          }
        },
        integer: {
          fromICAL: function(aValue) {
            var parsed = parseInt(aValue);
            if (ICAL2.helpers.isStrictlyNaN(parsed)) {
              return 0;
            }
            return parsed;
          },
          toICAL: function(aValue) {
            return String(aValue);
          }
        },
        "utc-offset": {
          toICAL: function(aValue) {
            if (aValue.length < 7) {
              return aValue.substr(0, 3) + aValue.substr(4, 2);
            } else {
              return aValue.substr(0, 3) + aValue.substr(4, 2) + aValue.substr(7, 2);
            }
          },
          fromICAL: function(aValue) {
            if (aValue.length < 6) {
              return aValue.substr(0, 3) + ":" + aValue.substr(3, 2);
            } else {
              return aValue.substr(0, 3) + ":" + aValue.substr(3, 2) + ":" + aValue.substr(5, 2);
            }
          },
          decorate: function(aValue) {
            return ICAL2.UtcOffset.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        }
      };
      var icalParams = {
        // Although the syntax is DQUOTE uri DQUOTE, I don't think we should
        // enfoce anything aside from it being a valid content line.
        //
        // At least some params require - if multi values are used - DQUOTEs
        // for each of its values - e.g. delegated-from="uri1","uri2"
        // To indicate this, I introduced the new k/v pair
        // multiValueSeparateDQuote: true
        //
        // "ALTREP": { ... },
        // CN just wants a param-value
        // "CN": { ... }
        "cutype": {
          values: ["INDIVIDUAL", "GROUP", "RESOURCE", "ROOM", "UNKNOWN"],
          allowXName: true,
          allowIanaToken: true
        },
        "delegated-from": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        "delegated-to": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        // "DIR": { ... }, // See ALTREP
        "encoding": {
          values: ["8BIT", "BASE64"]
        },
        // "FMTTYPE": { ... }, // See ALTREP
        "fbtype": {
          values: ["FREE", "BUSY", "BUSY-UNAVAILABLE", "BUSY-TENTATIVE"],
          allowXName: true,
          allowIanaToken: true
        },
        // "LANGUAGE": { ... }, // See ALTREP
        "member": {
          valueType: "cal-address",
          multiValue: ",",
          multiValueSeparateDQuote: true
        },
        "partstat": {
          // TODO These values are actually different per-component
          values: [
            "NEEDS-ACTION",
            "ACCEPTED",
            "DECLINED",
            "TENTATIVE",
            "DELEGATED",
            "COMPLETED",
            "IN-PROCESS"
          ],
          allowXName: true,
          allowIanaToken: true
        },
        "range": {
          values: ["THISANDFUTURE"]
        },
        "related": {
          values: ["START", "END"]
        },
        "reltype": {
          values: ["PARENT", "CHILD", "SIBLING"],
          allowXName: true,
          allowIanaToken: true
        },
        "role": {
          values: [
            "REQ-PARTICIPANT",
            "CHAIR",
            "OPT-PARTICIPANT",
            "NON-PARTICIPANT"
          ],
          allowXName: true,
          allowIanaToken: true
        },
        "rsvp": {
          values: ["TRUE", "FALSE"]
        },
        "sent-by": {
          valueType: "cal-address"
        },
        "tzid": {
          matches: /^\//
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "binary",
            "boolean",
            "cal-address",
            "date",
            "date-time",
            "duration",
            "float",
            "integer",
            "period",
            "recur",
            "text",
            "time",
            "uri",
            "utc-offset"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var icalValues = ICAL2.helpers.extend(commonValues, {
        text: createTextType(FROM_ICAL_NEWLINE, TO_ICAL_NEWLINE),
        uri: {
          // TODO
          /* ... */
        },
        "binary": {
          decorate: function(aString) {
            return ICAL2.Binary.fromString(aString);
          },
          undecorate: function(aBinary) {
            return aBinary.toString();
          }
        },
        "cal-address": {
          // needs to be an uri
        },
        "date": {
          decorate: function(aValue, aProp) {
            if (design.strict) {
              return ICAL2.Time.fromDateString(aValue, aProp);
            } else {
              return ICAL2.Time.fromString(aValue, aProp);
            }
          },
          /**
           * undecorates a time object.
           */
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            if (!design.strict && aValue.length >= 15) {
              return icalValues["date-time"].fromICAL(aValue);
            } else {
              return aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2);
            }
          },
          toICAL: function(aValue) {
            var len = aValue.length;
            if (len == 10) {
              return aValue.substr(0, 4) + aValue.substr(5, 2) + aValue.substr(8, 2);
            } else if (len >= 19) {
              return icalValues["date-time"].toICAL(aValue);
            } else {
              return aValue;
            }
          }
        },
        "date-time": {
          fromICAL: function(aValue) {
            if (!design.strict && aValue.length == 8) {
              return icalValues.date.fromICAL(aValue);
            } else {
              var result = aValue.substr(0, 4) + "-" + aValue.substr(4, 2) + "-" + aValue.substr(6, 2) + "T" + aValue.substr(9, 2) + ":" + aValue.substr(11, 2) + ":" + aValue.substr(13, 2);
              if (aValue[15] && aValue[15] === "Z") {
                result += "Z";
              }
              return result;
            }
          },
          toICAL: function(aValue) {
            var len = aValue.length;
            if (len == 10 && !design.strict) {
              return icalValues.date.toICAL(aValue);
            } else if (len >= 19) {
              var result = aValue.substr(0, 4) + aValue.substr(5, 2) + // grab the (DDTHH) segment
              aValue.substr(8, 5) + // MM
              aValue.substr(14, 2) + // SS
              aValue.substr(17, 2);
              if (aValue[19] && aValue[19] === "Z") {
                result += "Z";
              }
              return result;
            } else {
              return aValue;
            }
          },
          decorate: function(aValue, aProp) {
            if (design.strict) {
              return ICAL2.Time.fromDateTimeString(aValue, aProp);
            } else {
              return ICAL2.Time.fromString(aValue, aProp);
            }
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        },
        duration: {
          decorate: function(aValue) {
            return ICAL2.Duration.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        },
        period: {
          fromICAL: function(string) {
            var parts = string.split("/");
            parts[0] = icalValues["date-time"].fromICAL(parts[0]);
            if (!ICAL2.Duration.isValueString(parts[1])) {
              parts[1] = icalValues["date-time"].fromICAL(parts[1]);
            }
            return parts;
          },
          toICAL: function(parts) {
            if (!design.strict && parts[0].length == 10) {
              parts[0] = icalValues.date.toICAL(parts[0]);
            } else {
              parts[0] = icalValues["date-time"].toICAL(parts[0]);
            }
            if (!ICAL2.Duration.isValueString(parts[1])) {
              if (!design.strict && parts[1].length == 10) {
                parts[1] = icalValues.date.toICAL(parts[1]);
              } else {
                parts[1] = icalValues["date-time"].toICAL(parts[1]);
              }
            }
            return parts.join("/");
          },
          decorate: function(aValue, aProp) {
            return ICAL2.Period.fromJSON(aValue, aProp, !design.strict);
          },
          undecorate: function(aValue) {
            return aValue.toJSON();
          }
        },
        recur: {
          fromICAL: function(string) {
            return ICAL2.Recur._stringToData(string, true);
          },
          toICAL: function(data) {
            var str = "";
            for (var k3 in data) {
              if (!Object.prototype.hasOwnProperty.call(data, k3)) {
                continue;
              }
              var val = data[k3];
              if (k3 == "until") {
                if (val.length > 10) {
                  val = icalValues["date-time"].toICAL(val);
                } else {
                  val = icalValues.date.toICAL(val);
                }
              } else if (k3 == "wkst") {
                if (typeof val === "number") {
                  val = ICAL2.Recur.numericDayToIcalDay(val);
                }
              } else if (Array.isArray(val)) {
                val = val.join(",");
              }
              str += k3.toUpperCase() + "=" + val + ";";
            }
            return str.substr(0, str.length - 1);
          },
          decorate: function decorate(aValue) {
            return ICAL2.Recur.fromData(aValue);
          },
          undecorate: function(aRecur) {
            return aRecur.toJSON();
          }
        },
        time: {
          fromICAL: function(aValue) {
            if (aValue.length < 6) {
              return aValue;
            }
            var result = aValue.substr(0, 2) + ":" + aValue.substr(2, 2) + ":" + aValue.substr(4, 2);
            if (aValue[6] === "Z") {
              result += "Z";
            }
            return result;
          },
          toICAL: function(aValue) {
            if (aValue.length < 8) {
              return aValue;
            }
            var result = aValue.substr(0, 2) + aValue.substr(3, 2) + aValue.substr(6, 2);
            if (aValue[8] === "Z") {
              result += "Z";
            }
            return result;
          }
        }
      });
      var icalProperties = ICAL2.helpers.extend(commonProperties, {
        "action": DEFAULT_TYPE_TEXT,
        "attach": { defaultType: "uri" },
        "attendee": { defaultType: "cal-address" },
        "calscale": DEFAULT_TYPE_TEXT,
        "class": DEFAULT_TYPE_TEXT,
        "comment": DEFAULT_TYPE_TEXT,
        "completed": DEFAULT_TYPE_DATETIME,
        "contact": DEFAULT_TYPE_TEXT,
        "created": DEFAULT_TYPE_DATETIME,
        "description": DEFAULT_TYPE_TEXT,
        "dtend": DEFAULT_TYPE_DATETIME_DATE,
        "dtstamp": DEFAULT_TYPE_DATETIME,
        "dtstart": DEFAULT_TYPE_DATETIME_DATE,
        "due": DEFAULT_TYPE_DATETIME_DATE,
        "duration": { defaultType: "duration" },
        "exdate": {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          multiValue: ","
        },
        "exrule": DEFAULT_TYPE_RECUR,
        "freebusy": { defaultType: "period", multiValue: "," },
        "geo": { defaultType: "float", structuredValue: ";" },
        "last-modified": DEFAULT_TYPE_DATETIME,
        "location": DEFAULT_TYPE_TEXT,
        "method": DEFAULT_TYPE_TEXT,
        "organizer": { defaultType: "cal-address" },
        "percent-complete": DEFAULT_TYPE_INTEGER,
        "priority": DEFAULT_TYPE_INTEGER,
        "prodid": DEFAULT_TYPE_TEXT,
        "related-to": DEFAULT_TYPE_TEXT,
        "repeat": DEFAULT_TYPE_INTEGER,
        "rdate": {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date", "period"],
          multiValue: ",",
          detectType: function(string) {
            if (string.indexOf("/") !== -1) {
              return "period";
            }
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        "recurrence-id": DEFAULT_TYPE_DATETIME_DATE,
        "resources": DEFAULT_TYPE_TEXT_MULTI,
        "request-status": DEFAULT_TYPE_TEXT_STRUCTURED,
        "rrule": DEFAULT_TYPE_RECUR,
        "sequence": DEFAULT_TYPE_INTEGER,
        "status": DEFAULT_TYPE_TEXT,
        "summary": DEFAULT_TYPE_TEXT,
        "transp": DEFAULT_TYPE_TEXT,
        "trigger": { defaultType: "duration", allowedTypes: ["duration", "date-time"] },
        "tzoffsetfrom": DEFAULT_TYPE_UTCOFFSET,
        "tzoffsetto": DEFAULT_TYPE_UTCOFFSET,
        "tzurl": DEFAULT_TYPE_URI,
        "tzid": DEFAULT_TYPE_TEXT,
        "tzname": DEFAULT_TYPE_TEXT
      });
      var vcardValues = ICAL2.helpers.extend(commonValues, {
        text: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
        uri: createTextType(FROM_VCARD_NEWLINE, TO_VCARD_NEWLINE),
        date: {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            if (aValue.length == 8) {
              return icalValues.date.fromICAL(aValue);
            } else if (aValue[0] == "-" && aValue.length == 6) {
              return aValue.substr(0, 4) + "-" + aValue.substr(4);
            } else {
              return aValue;
            }
          },
          toICAL: function(aValue) {
            if (aValue.length == 10) {
              return icalValues.date.toICAL(aValue);
            } else if (aValue[0] == "-" && aValue.length == 7) {
              return aValue.substr(0, 4) + aValue.substr(5);
            } else {
              return aValue;
            }
          }
        },
        time: {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString("T" + aValue, "time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            var splitzone = vcardValues.time._splitZone(aValue, true);
            var zone = splitzone[0], value = splitzone[1];
            if (value.length == 6) {
              value = value.substr(0, 2) + ":" + value.substr(2, 2) + ":" + value.substr(4, 2);
            } else if (value.length == 4 && value[0] != "-") {
              value = value.substr(0, 2) + ":" + value.substr(2, 2);
            } else if (value.length == 5) {
              value = value.substr(0, 3) + ":" + value.substr(3, 2);
            }
            if (zone.length == 5 && (zone[0] == "-" || zone[0] == "+")) {
              zone = zone.substr(0, 3) + ":" + zone.substr(3);
            }
            return value + zone;
          },
          toICAL: function(aValue) {
            var splitzone = vcardValues.time._splitZone(aValue);
            var zone = splitzone[0], value = splitzone[1];
            if (value.length == 8) {
              value = value.substr(0, 2) + value.substr(3, 2) + value.substr(6, 2);
            } else if (value.length == 5 && value[0] != "-") {
              value = value.substr(0, 2) + value.substr(3, 2);
            } else if (value.length == 6) {
              value = value.substr(0, 3) + value.substr(4, 2);
            }
            if (zone.length == 6 && (zone[0] == "-" || zone[0] == "+")) {
              zone = zone.substr(0, 3) + zone.substr(4);
            }
            return value + zone;
          },
          _splitZone: function(aValue, isFromIcal) {
            var lastChar = aValue.length - 1;
            var signChar = aValue.length - (isFromIcal ? 5 : 6);
            var sign = aValue[signChar];
            var zone, value;
            if (aValue[lastChar] == "Z") {
              zone = aValue[lastChar];
              value = aValue.substr(0, lastChar);
            } else if (aValue.length > 6 && (sign == "-" || sign == "+")) {
              zone = aValue.substr(signChar);
              value = aValue.substr(0, signChar);
            } else {
              zone = "";
              value = aValue;
            }
            return [zone, value];
          }
        },
        "date-time": {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date-time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            return vcardValues["date-and-or-time"].fromICAL(aValue);
          },
          toICAL: function(aValue) {
            return vcardValues["date-and-or-time"].toICAL(aValue);
          }
        },
        "date-and-or-time": {
          decorate: function(aValue) {
            return ICAL2.VCardTime.fromDateAndOrTimeString(aValue, "date-and-or-time");
          },
          undecorate: function(aValue) {
            return aValue.toString();
          },
          fromICAL: function(aValue) {
            var parts = aValue.split("T");
            return (parts[0] ? vcardValues.date.fromICAL(parts[0]) : "") + (parts[1] ? "T" + vcardValues.time.fromICAL(parts[1]) : "");
          },
          toICAL: function(aValue) {
            var parts = aValue.split("T");
            return vcardValues.date.toICAL(parts[0]) + (parts[1] ? "T" + vcardValues.time.toICAL(parts[1]) : "");
          }
        },
        timestamp: icalValues["date-time"],
        "language-tag": {
          matches: /^[a-zA-Z0-9-]+$/
          // Could go with a more strict regex here
        }
      });
      var vcardParams = {
        "type": {
          valueType: "text",
          multiValue: ","
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "text",
            "uri",
            "date",
            "time",
            "date-time",
            "date-and-or-time",
            "timestamp",
            "boolean",
            "integer",
            "float",
            "utc-offset",
            "language-tag"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var vcardProperties = ICAL2.helpers.extend(commonProperties, {
        "adr": { defaultType: "text", structuredValue: ";", multiValue: "," },
        "anniversary": DEFAULT_TYPE_DATE_ANDOR_TIME,
        "bday": DEFAULT_TYPE_DATE_ANDOR_TIME,
        "caladruri": DEFAULT_TYPE_URI,
        "caluri": DEFAULT_TYPE_URI,
        "clientpidmap": DEFAULT_TYPE_TEXT_STRUCTURED,
        "email": DEFAULT_TYPE_TEXT,
        "fburl": DEFAULT_TYPE_URI,
        "fn": DEFAULT_TYPE_TEXT,
        "gender": DEFAULT_TYPE_TEXT_STRUCTURED,
        "geo": DEFAULT_TYPE_URI,
        "impp": DEFAULT_TYPE_URI,
        "key": DEFAULT_TYPE_URI,
        "kind": DEFAULT_TYPE_TEXT,
        "lang": { defaultType: "language-tag" },
        "logo": DEFAULT_TYPE_URI,
        "member": DEFAULT_TYPE_URI,
        "n": { defaultType: "text", structuredValue: ";", multiValue: "," },
        "nickname": DEFAULT_TYPE_TEXT_MULTI,
        "note": DEFAULT_TYPE_TEXT,
        "org": { defaultType: "text", structuredValue: ";" },
        "photo": DEFAULT_TYPE_URI,
        "related": DEFAULT_TYPE_URI,
        "rev": { defaultType: "timestamp" },
        "role": DEFAULT_TYPE_TEXT,
        "sound": DEFAULT_TYPE_URI,
        "source": DEFAULT_TYPE_URI,
        "tel": { defaultType: "uri", allowedTypes: ["uri", "text"] },
        "title": DEFAULT_TYPE_TEXT,
        "tz": { defaultType: "text", allowedTypes: ["text", "utc-offset", "uri"] },
        "xml": DEFAULT_TYPE_TEXT
      });
      var vcard3Values = ICAL2.helpers.extend(commonValues, {
        binary: icalValues.binary,
        date: vcardValues.date,
        "date-time": vcardValues["date-time"],
        "phone-number": {
          // TODO
          /* ... */
        },
        uri: icalValues.uri,
        text: icalValues.text,
        time: icalValues.time,
        vcard: icalValues.text,
        "utc-offset": {
          toICAL: function(aValue) {
            return aValue.substr(0, 7);
          },
          fromICAL: function(aValue) {
            return aValue.substr(0, 7);
          },
          decorate: function(aValue) {
            return ICAL2.UtcOffset.fromString(aValue);
          },
          undecorate: function(aValue) {
            return aValue.toString();
          }
        }
      });
      var vcard3Params = {
        "type": {
          valueType: "text",
          multiValue: ","
        },
        "value": {
          // since the value here is a 'type' lowercase is used.
          values: [
            "text",
            "uri",
            "date",
            "date-time",
            "phone-number",
            "time",
            "boolean",
            "integer",
            "float",
            "utc-offset",
            "vcard",
            "binary"
          ],
          allowXName: true,
          allowIanaToken: true
        }
      };
      var vcard3Properties = ICAL2.helpers.extend(commonProperties, {
        fn: DEFAULT_TYPE_TEXT,
        n: { defaultType: "text", structuredValue: ";", multiValue: "," },
        nickname: DEFAULT_TYPE_TEXT_MULTI,
        photo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        bday: {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          detectType: function(string) {
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        adr: { defaultType: "text", structuredValue: ";", multiValue: "," },
        label: DEFAULT_TYPE_TEXT,
        tel: { defaultType: "phone-number" },
        email: DEFAULT_TYPE_TEXT,
        mailer: DEFAULT_TYPE_TEXT,
        tz: { defaultType: "utc-offset", allowedTypes: ["utc-offset", "text"] },
        geo: { defaultType: "float", structuredValue: ";" },
        title: DEFAULT_TYPE_TEXT,
        role: DEFAULT_TYPE_TEXT,
        logo: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        agent: { defaultType: "vcard", allowedTypes: ["vcard", "text", "uri"] },
        org: DEFAULT_TYPE_TEXT_STRUCTURED,
        note: DEFAULT_TYPE_TEXT_MULTI,
        prodid: DEFAULT_TYPE_TEXT,
        rev: {
          defaultType: "date-time",
          allowedTypes: ["date-time", "date"],
          detectType: function(string) {
            return string.indexOf("T") === -1 ? "date" : "date-time";
          }
        },
        "sort-string": DEFAULT_TYPE_TEXT,
        sound: { defaultType: "binary", allowedTypes: ["binary", "uri"] },
        class: DEFAULT_TYPE_TEXT,
        key: { defaultType: "binary", allowedTypes: ["binary", "text"] }
      });
      var icalSet = {
        value: icalValues,
        param: icalParams,
        property: icalProperties
      };
      var vcardSet = {
        value: vcardValues,
        param: vcardParams,
        property: vcardProperties
      };
      var vcard3Set = {
        value: vcard3Values,
        param: vcard3Params,
        property: vcard3Properties
      };
      var design = {
        /**
         * A designSet describes value, parameter and property data. It is used by
         * ther parser and stringifier in components and properties to determine they
         * should be represented.
         *
         * @typedef {Object} designSet
         * @memberOf ICAL.design
         * @property {Object} value       Definitions for value types, keys are type names
         * @property {Object} param       Definitions for params, keys are param names
         * @property {Object} property    Defintions for properties, keys are property names
         */
        /**
         * Can be set to false to make the parser more lenient.
         */
        strict: true,
        /**
         * The default set for new properties and components if none is specified.
         * @type {ICAL.design.designSet}
         */
        defaultSet: icalSet,
        /**
         * The default type for unknown properties
         * @type {String}
         */
        defaultType: "unknown",
        /**
         * Holds the design set for known top-level components
         *
         * @type {Object}
         * @property {ICAL.design.designSet} vcard       vCard VCARD
         * @property {ICAL.design.designSet} vevent      iCalendar VEVENT
         * @property {ICAL.design.designSet} vtodo       iCalendar VTODO
         * @property {ICAL.design.designSet} vjournal    iCalendar VJOURNAL
         * @property {ICAL.design.designSet} valarm      iCalendar VALARM
         * @property {ICAL.design.designSet} vtimezone   iCalendar VTIMEZONE
         * @property {ICAL.design.designSet} daylight    iCalendar DAYLIGHT
         * @property {ICAL.design.designSet} standard    iCalendar STANDARD
         *
         * @example
         * var propertyName = 'fn';
         * var componentDesign = ICAL.design.components.vcard;
         * var propertyDetails = componentDesign.property[propertyName];
         * if (propertyDetails.defaultType == 'text') {
         *   // Yep, sure is...
         * }
         */
        components: {
          vcard: vcardSet,
          vcard3: vcard3Set,
          vevent: icalSet,
          vtodo: icalSet,
          vjournal: icalSet,
          valarm: icalSet,
          vtimezone: icalSet,
          daylight: icalSet,
          standard: icalSet
        },
        /**
         * The design set for iCalendar (rfc5545/rfc7265) components.
         * @type {ICAL.design.designSet}
         */
        icalendar: icalSet,
        /**
         * The design set for vCard (rfc6350/rfc7095) components.
         * @type {ICAL.design.designSet}
         */
        vcard: vcardSet,
        /**
         * The design set for vCard (rfc2425/rfc2426/rfc7095) components.
         * @type {ICAL.design.designSet}
         */
        vcard3: vcard3Set,
        /**
         * Gets the design set for the given component name.
         *
         * @param {String} componentName        The name of the component
         * @return {ICAL.design.designSet}      The design set for the component
         */
        getDesignSet: function(componentName) {
          var isInDesign = componentName && componentName in design.components;
          return isInDesign ? design.components[componentName] : design.defaultSet;
        }
      };
      return design;
    }();
    ICAL2.stringify = function() {
      "use strict";
      var LINE_ENDING = "\r\n";
      var DEFAULT_VALUE_TYPE = "unknown";
      var design = ICAL2.design;
      var helpers = ICAL2.helpers;
      function stringify(jCal) {
        if (typeof jCal[0] == "string") {
          jCal = [jCal];
        }
        var i3 = 0;
        var len = jCal.length;
        var result = "";
        for (; i3 < len; i3++) {
          result += stringify.component(jCal[i3]) + LINE_ENDING;
        }
        return result;
      }
      stringify.component = function(component, designSet) {
        var name = component[0].toUpperCase();
        var result = "BEGIN:" + name + LINE_ENDING;
        var props = component[1];
        var propIdx = 0;
        var propLen = props.length;
        var designSetName = component[0];
        if (designSetName === "vcard" && component[1].length > 0 && !(component[1][0][0] === "version" && component[1][0][3] === "4.0")) {
          designSetName = "vcard3";
        }
        designSet = designSet || design.getDesignSet(designSetName);
        for (; propIdx < propLen; propIdx++) {
          result += stringify.property(props[propIdx], designSet) + LINE_ENDING;
        }
        var comps = component[2] || [];
        var compIdx = 0;
        var compLen = comps.length;
        for (; compIdx < compLen; compIdx++) {
          result += stringify.component(comps[compIdx], designSet) + LINE_ENDING;
        }
        result += "END:" + name;
        return result;
      };
      stringify.property = function(property, designSet, noFold) {
        var name = property[0].toUpperCase();
        var jsName = property[0];
        var params = property[1];
        var line = name;
        var paramName;
        for (paramName in params) {
          var value = params[paramName];
          if (params.hasOwnProperty(paramName)) {
            var multiValue = paramName in designSet.param && designSet.param[paramName].multiValue;
            if (multiValue && Array.isArray(value)) {
              if (designSet.param[paramName].multiValueSeparateDQuote) {
                multiValue = '"' + multiValue + '"';
              }
              value = value.map(stringify._rfc6868Unescape);
              value = stringify.multiValue(value, multiValue, "unknown", null, designSet);
            } else {
              value = stringify._rfc6868Unescape(value);
            }
            line += ";" + paramName.toUpperCase();
            line += "=" + stringify.propertyValue(value);
          }
        }
        if (property.length === 3) {
          return line + ":";
        }
        var valueType = property[2];
        if (!designSet) {
          designSet = design.defaultSet;
        }
        var propDetails;
        var multiValue = false;
        var structuredValue = false;
        var isDefault = false;
        if (jsName in designSet.property) {
          propDetails = designSet.property[jsName];
          if ("multiValue" in propDetails) {
            multiValue = propDetails.multiValue;
          }
          if ("structuredValue" in propDetails && Array.isArray(property[3])) {
            structuredValue = propDetails.structuredValue;
          }
          if ("defaultType" in propDetails) {
            if (valueType === propDetails.defaultType) {
              isDefault = true;
            }
          } else {
            if (valueType === DEFAULT_VALUE_TYPE) {
              isDefault = true;
            }
          }
        } else {
          if (valueType === DEFAULT_VALUE_TYPE) {
            isDefault = true;
          }
        }
        if (!isDefault) {
          line += ";VALUE=" + valueType.toUpperCase();
        }
        line += ":";
        if (multiValue && structuredValue) {
          line += stringify.multiValue(
            property[3],
            structuredValue,
            valueType,
            multiValue,
            designSet,
            structuredValue
          );
        } else if (multiValue) {
          line += stringify.multiValue(
            property.slice(3),
            multiValue,
            valueType,
            null,
            designSet,
            false
          );
        } else if (structuredValue) {
          line += stringify.multiValue(
            property[3],
            structuredValue,
            valueType,
            null,
            designSet,
            structuredValue
          );
        } else {
          line += stringify.value(property[3], valueType, designSet, false);
        }
        return noFold ? line : ICAL2.helpers.foldline(line);
      };
      stringify.propertyValue = function(value) {
        if (helpers.unescapedIndexOf(value, ",") === -1 && helpers.unescapedIndexOf(value, ":") === -1 && helpers.unescapedIndexOf(value, ";") === -1) {
          return value;
        }
        return '"' + value + '"';
      };
      stringify.multiValue = function(values, delim, type, innerMulti, designSet, structuredValue) {
        var result = "";
        var len = values.length;
        var i3 = 0;
        for (; i3 < len; i3++) {
          if (innerMulti && Array.isArray(values[i3])) {
            result += stringify.multiValue(values[i3], innerMulti, type, null, designSet, structuredValue);
          } else {
            result += stringify.value(values[i3], type, designSet, structuredValue);
          }
          if (i3 !== len - 1) {
            result += delim;
          }
        }
        return result;
      };
      stringify.value = function(value, type, designSet, structuredValue) {
        if (type in designSet.value && "toICAL" in designSet.value[type]) {
          return designSet.value[type].toICAL(value, structuredValue);
        }
        return value;
      };
      stringify._rfc6868Unescape = function(val) {
        return val.replace(/[\n^"]/g, function(x4) {
          return RFC6868_REPLACE_MAP[x4];
        });
      };
      var RFC6868_REPLACE_MAP = { '"': "^'", "\n": "^n", "^": "^^" };
      return stringify;
    }();
    ICAL2.parse = function() {
      "use strict";
      var CHAR = /[^ \t]/;
      var MULTIVALUE_DELIMITER = ",";
      var VALUE_DELIMITER = ":";
      var PARAM_DELIMITER = ";";
      var PARAM_NAME_DELIMITER = "=";
      var DEFAULT_VALUE_TYPE = "unknown";
      var DEFAULT_PARAM_TYPE = "text";
      var design = ICAL2.design;
      var helpers = ICAL2.helpers;
      function ParserError(message) {
        this.message = message;
        this.name = "ParserError";
        try {
          throw new Error();
        } catch (e3) {
          if (e3.stack) {
            var split2 = e3.stack.split("\n");
            split2.shift();
            this.stack = split2.join("\n");
          }
        }
      }
      ParserError.prototype = Error.prototype;
      function parser(input) {
        var state = {};
        var root = state.component = [];
        state.stack = [root];
        parser._eachLine(input, function(err, line) {
          parser._handleContentLine(line, state);
        });
        if (state.stack.length > 1) {
          throw new ParserError(
            "invalid ical body. component began but did not end"
          );
        }
        state = null;
        return root.length == 1 ? root[0] : root;
      }
      parser.property = function(str, designSet) {
        var state = {
          component: [[], []],
          designSet: designSet || design.defaultSet
        };
        parser._handleContentLine(str, state);
        return state.component[1][0];
      };
      parser.component = function(str) {
        return parser(str);
      };
      parser.ParserError = ParserError;
      parser._handleContentLine = function(line, state) {
        var valuePos = line.indexOf(VALUE_DELIMITER);
        var paramPos = line.indexOf(PARAM_DELIMITER);
        var lastParamIndex;
        var lastValuePos;
        var name;
        var value;
        var params = {};
        if (paramPos !== -1 && valuePos !== -1) {
          if (paramPos > valuePos) {
            paramPos = -1;
          }
        }
        var parsedParams;
        if (paramPos !== -1) {
          name = line.substring(0, paramPos).toLowerCase();
          parsedParams = parser._parseParameters(line.substring(paramPos), 0, state.designSet);
          if (parsedParams[2] == -1) {
            throw new ParserError("Invalid parameters in '" + line + "'");
          }
          params = parsedParams[0];
          lastParamIndex = parsedParams[1].length + parsedParams[2] + paramPos;
          if ((lastValuePos = line.substring(lastParamIndex).indexOf(VALUE_DELIMITER)) !== -1) {
            value = line.substring(lastParamIndex + lastValuePos + 1);
          } else {
            throw new ParserError("Missing parameter value in '" + line + "'");
          }
        } else if (valuePos !== -1) {
          name = line.substring(0, valuePos).toLowerCase();
          value = line.substring(valuePos + 1);
          if (name === "begin") {
            var newComponent = [value.toLowerCase(), [], []];
            if (state.stack.length === 1) {
              state.component.push(newComponent);
            } else {
              state.component[2].push(newComponent);
            }
            state.stack.push(state.component);
            state.component = newComponent;
            if (!state.designSet) {
              state.designSet = design.getDesignSet(state.component[0]);
            }
            return;
          } else if (name === "end") {
            state.component = state.stack.pop();
            return;
          }
        } else {
          throw new ParserError(
            'invalid line (no token ";" or ":") "' + line + '"'
          );
        }
        var valueType;
        var multiValue = false;
        var structuredValue = false;
        var propertyDetails;
        if (name in state.designSet.property) {
          propertyDetails = state.designSet.property[name];
          if ("multiValue" in propertyDetails) {
            multiValue = propertyDetails.multiValue;
          }
          if ("structuredValue" in propertyDetails) {
            structuredValue = propertyDetails.structuredValue;
          }
          if (value && "detectType" in propertyDetails) {
            valueType = propertyDetails.detectType(value);
          }
        }
        if (!valueType) {
          if (!("value" in params)) {
            if (propertyDetails) {
              valueType = propertyDetails.defaultType;
            } else {
              valueType = DEFAULT_VALUE_TYPE;
            }
          } else {
            valueType = params.value.toLowerCase();
          }
        }
        delete params.value;
        var result;
        if (multiValue && structuredValue) {
          value = parser._parseMultiValue(value, structuredValue, valueType, [], multiValue, state.designSet, structuredValue);
          result = [name, params, valueType, value];
        } else if (multiValue) {
          result = [name, params, valueType];
          parser._parseMultiValue(value, multiValue, valueType, result, null, state.designSet, false);
        } else if (structuredValue) {
          value = parser._parseMultiValue(value, structuredValue, valueType, [], null, state.designSet, structuredValue);
          result = [name, params, valueType, value];
        } else {
          value = parser._parseValue(value, valueType, state.designSet, false);
          result = [name, params, valueType, value];
        }
        if (state.component[0] === "vcard" && state.component[1].length === 0 && !(name === "version" && value === "4.0")) {
          state.designSet = design.getDesignSet("vcard3");
        }
        state.component[1].push(result);
      };
      parser._parseValue = function(value, type, designSet, structuredValue) {
        if (type in designSet.value && "fromICAL" in designSet.value[type]) {
          return designSet.value[type].fromICAL(value, structuredValue);
        }
        return value;
      };
      parser._parseParameters = function(line, start, designSet) {
        var lastParam = start;
        var pos = 0;
        var delim = PARAM_NAME_DELIMITER;
        var result = {};
        var name, lcname;
        var value, valuePos = -1;
        var type, multiValue, mvdelim;
        while (pos !== false && (pos = helpers.unescapedIndexOf(line, delim, pos + 1)) !== -1) {
          name = line.substr(lastParam + 1, pos - lastParam - 1);
          if (name.length == 0) {
            throw new ParserError("Empty parameter name in '" + line + "'");
          }
          lcname = name.toLowerCase();
          mvdelim = false;
          multiValue = false;
          if (lcname in designSet.param && designSet.param[lcname].valueType) {
            type = designSet.param[lcname].valueType;
          } else {
            type = DEFAULT_PARAM_TYPE;
          }
          if (lcname in designSet.param) {
            multiValue = designSet.param[lcname].multiValue;
            if (designSet.param[lcname].multiValueSeparateDQuote) {
              mvdelim = parser._rfc6868Escape('"' + multiValue + '"');
            }
          }
          var nextChar = line[pos + 1];
          if (nextChar === '"') {
            valuePos = pos + 2;
            pos = helpers.unescapedIndexOf(line, '"', valuePos);
            if (multiValue && pos != -1) {
              var extendedValue = true;
              while (extendedValue) {
                if (line[pos + 1] == multiValue && line[pos + 2] == '"') {
                  pos = helpers.unescapedIndexOf(line, '"', pos + 3);
                } else {
                  extendedValue = false;
                }
              }
            }
            if (pos === -1) {
              throw new ParserError(
                'invalid line (no matching double quote) "' + line + '"'
              );
            }
            value = line.substr(valuePos, pos - valuePos);
            lastParam = helpers.unescapedIndexOf(line, PARAM_DELIMITER, pos);
            if (lastParam === -1) {
              pos = false;
            }
          } else {
            valuePos = pos + 1;
            var nextPos = helpers.unescapedIndexOf(line, PARAM_DELIMITER, valuePos);
            var propValuePos = helpers.unescapedIndexOf(line, VALUE_DELIMITER, valuePos);
            if (propValuePos !== -1 && nextPos > propValuePos) {
              nextPos = propValuePos;
              pos = false;
            } else if (nextPos === -1) {
              if (propValuePos === -1) {
                nextPos = line.length;
              } else {
                nextPos = propValuePos;
              }
              pos = false;
            } else {
              lastParam = nextPos;
              pos = nextPos;
            }
            value = line.substr(valuePos, nextPos - valuePos);
          }
          value = parser._rfc6868Escape(value);
          if (multiValue) {
            var delimiter = mvdelim || multiValue;
            value = parser._parseMultiValue(value, delimiter, type, [], null, designSet);
          } else {
            value = parser._parseValue(value, type, designSet);
          }
          if (multiValue && lcname in result) {
            if (Array.isArray(result[lcname])) {
              result[lcname].push(value);
            } else {
              result[lcname] = [
                result[lcname],
                value
              ];
            }
          } else {
            result[lcname] = value;
          }
        }
        return [result, value, valuePos];
      };
      parser._rfc6868Escape = function(val) {
        return val.replace(/\^['n^]/g, function(x4) {
          return RFC6868_REPLACE_MAP[x4];
        });
      };
      var RFC6868_REPLACE_MAP = { "^'": '"', "^n": "\n", "^^": "^" };
      parser._parseMultiValue = function(buffer, delim, type, result, innerMulti, designSet, structuredValue) {
        var pos = 0;
        var lastPos = 0;
        var value;
        if (delim.length === 0) {
          return buffer;
        }
        while ((pos = helpers.unescapedIndexOf(buffer, delim, lastPos)) !== -1) {
          value = buffer.substr(lastPos, pos - lastPos);
          if (innerMulti) {
            value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
          } else {
            value = parser._parseValue(value, type, designSet, structuredValue);
          }
          result.push(value);
          lastPos = pos + delim.length;
        }
        value = buffer.substr(lastPos);
        if (innerMulti) {
          value = parser._parseMultiValue(value, innerMulti, type, [], null, designSet, structuredValue);
        } else {
          value = parser._parseValue(value, type, designSet, structuredValue);
        }
        result.push(value);
        return result.length == 1 ? result[0] : result;
      };
      parser._eachLine = function(buffer, callback) {
        var len = buffer.length;
        var lastPos = buffer.search(CHAR);
        var pos = lastPos;
        var line;
        var firstChar;
        var newlineOffset;
        do {
          pos = buffer.indexOf("\n", lastPos) + 1;
          if (pos > 1 && buffer[pos - 2] === "\r") {
            newlineOffset = 2;
          } else {
            newlineOffset = 1;
          }
          if (pos === 0) {
            pos = len;
            newlineOffset = 0;
          }
          firstChar = buffer[lastPos];
          if (firstChar === " " || firstChar === "	") {
            line += buffer.substr(
              lastPos + 1,
              pos - lastPos - (newlineOffset + 1)
            );
          } else {
            if (line)
              callback(null, line);
            line = buffer.substr(
              lastPos,
              pos - lastPos - newlineOffset
            );
          }
          lastPos = pos;
        } while (pos !== len);
        line = line.trim();
        if (line.length)
          callback(null, line);
      };
      return parser;
    }();
    ICAL2.Component = function() {
      "use strict";
      var PROPERTY_INDEX = 1;
      var COMPONENT_INDEX = 2;
      var NAME_INDEX = 0;
      function Component3(jCal, parent) {
        if (typeof jCal === "string") {
          jCal = [jCal, [], []];
        }
        this.jCal = jCal;
        this.parent = parent || null;
      }
      Component3.prototype = {
        /**
         * Hydrated properties are inserted into the _properties array at the same
         * position as in the jCal array, so it is possible that the array contains
         * undefined values for unhydrdated properties. To avoid iterating the
         * array when checking if all properties have been hydrated, we save the
         * count here.
         *
         * @type {Number}
         * @private
         */
        _hydratedPropertyCount: 0,
        /**
         * The same count as for _hydratedPropertyCount, but for subcomponents
         *
         * @type {Number}
         * @private
         */
        _hydratedComponentCount: 0,
        /**
         * The name of this component
         * @readonly
         */
        get name() {
          return this.jCal[NAME_INDEX];
        },
        /**
         * The design set for this component, e.g. icalendar vs vcard
         *
         * @type {ICAL.design.designSet}
         * @private
         */
        get _designSet() {
          var parentDesign = this.parent && this.parent._designSet;
          return parentDesign || ICAL2.design.getDesignSet(this.name);
        },
        _hydrateComponent: function(index8) {
          if (!this._components) {
            this._components = [];
            this._hydratedComponentCount = 0;
          }
          if (this._components[index8]) {
            return this._components[index8];
          }
          var comp = new Component3(
            this.jCal[COMPONENT_INDEX][index8],
            this
          );
          this._hydratedComponentCount++;
          return this._components[index8] = comp;
        },
        _hydrateProperty: function(index8) {
          if (!this._properties) {
            this._properties = [];
            this._hydratedPropertyCount = 0;
          }
          if (this._properties[index8]) {
            return this._properties[index8];
          }
          var prop = new ICAL2.Property(
            this.jCal[PROPERTY_INDEX][index8],
            this
          );
          this._hydratedPropertyCount++;
          return this._properties[index8] = prop;
        },
        /**
         * Finds first sub component, optionally filtered by name.
         *
         * @param {String=} name        Optional name to filter by
         * @return {?ICAL.Component}     The found subcomponent
         */
        getFirstSubcomponent: function(name) {
          if (name) {
            var i3 = 0;
            var comps = this.jCal[COMPONENT_INDEX];
            var len = comps.length;
            for (; i3 < len; i3++) {
              if (comps[i3][NAME_INDEX] === name) {
                var result = this._hydrateComponent(i3);
                return result;
              }
            }
          } else {
            if (this.jCal[COMPONENT_INDEX].length) {
              return this._hydrateComponent(0);
            }
          }
          return null;
        },
        /**
         * Finds all sub components, optionally filtering by name.
         *
         * @param {String=} name            Optional name to filter by
         * @return {ICAL.Component[]}       The found sub components
         */
        getAllSubcomponents: function(name) {
          var jCalLen = this.jCal[COMPONENT_INDEX].length;
          var i3 = 0;
          if (name) {
            var comps = this.jCal[COMPONENT_INDEX];
            var result = [];
            for (; i3 < jCalLen; i3++) {
              if (name === comps[i3][NAME_INDEX]) {
                result.push(
                  this._hydrateComponent(i3)
                );
              }
            }
            return result;
          } else {
            if (!this._components || this._hydratedComponentCount !== jCalLen) {
              for (; i3 < jCalLen; i3++) {
                this._hydrateComponent(i3);
              }
            }
            return this._components || [];
          }
        },
        /**
         * Returns true when a named property exists.
         *
         * @param {String} name     The property name
         * @return {Boolean}        True, when property is found
         */
        hasProperty: function(name) {
          var props = this.jCal[PROPERTY_INDEX];
          var len = props.length;
          var i3 = 0;
          for (; i3 < len; i3++) {
            if (props[i3][NAME_INDEX] === name) {
              return true;
            }
          }
          return false;
        },
        /**
         * Finds the first property, optionally with the given name.
         *
         * @param {String=} name        Lowercase property name
         * @return {?ICAL.Property}     The found property
         */
        getFirstProperty: function(name) {
          if (name) {
            var i3 = 0;
            var props = this.jCal[PROPERTY_INDEX];
            var len = props.length;
            for (; i3 < len; i3++) {
              if (props[i3][NAME_INDEX] === name) {
                var result = this._hydrateProperty(i3);
                return result;
              }
            }
          } else {
            if (this.jCal[PROPERTY_INDEX].length) {
              return this._hydrateProperty(0);
            }
          }
          return null;
        },
        /**
         * Returns first property's value, if available.
         *
         * @param {String=} name    Lowercase property name
         * @return {?String}        The found property value.
         */
        getFirstPropertyValue: function(name) {
          var prop = this.getFirstProperty(name);
          if (prop) {
            return prop.getFirstValue();
          }
          return null;
        },
        /**
         * Get all properties in the component, optionally filtered by name.
         *
         * @param {String=} name        Lowercase property name
         * @return {ICAL.Property[]}    List of properties
         */
        getAllProperties: function(name) {
          var jCalLen = this.jCal[PROPERTY_INDEX].length;
          var i3 = 0;
          if (name) {
            var props = this.jCal[PROPERTY_INDEX];
            var result = [];
            for (; i3 < jCalLen; i3++) {
              if (name === props[i3][NAME_INDEX]) {
                result.push(
                  this._hydrateProperty(i3)
                );
              }
            }
            return result;
          } else {
            if (!this._properties || this._hydratedPropertyCount !== jCalLen) {
              for (; i3 < jCalLen; i3++) {
                this._hydrateProperty(i3);
              }
            }
            return this._properties || [];
          }
        },
        _removeObjectByIndex: function(jCalIndex, cache, index8) {
          cache = cache || [];
          if (cache[index8]) {
            var obj = cache[index8];
            if ("parent" in obj) {
              obj.parent = null;
            }
          }
          cache.splice(index8, 1);
          this.jCal[jCalIndex].splice(index8, 1);
        },
        _removeObject: function(jCalIndex, cache, nameOrObject) {
          var i3 = 0;
          var objects = this.jCal[jCalIndex];
          var len = objects.length;
          var cached = this[cache];
          if (typeof nameOrObject === "string") {
            for (; i3 < len; i3++) {
              if (objects[i3][NAME_INDEX] === nameOrObject) {
                this._removeObjectByIndex(jCalIndex, cached, i3);
                return true;
              }
            }
          } else if (cached) {
            for (; i3 < len; i3++) {
              if (cached[i3] && cached[i3] === nameOrObject) {
                this._removeObjectByIndex(jCalIndex, cached, i3);
                return true;
              }
            }
          }
          return false;
        },
        _removeAllObjects: function(jCalIndex, cache, name) {
          var cached = this[cache];
          var objects = this.jCal[jCalIndex];
          var i3 = objects.length - 1;
          for (; i3 >= 0; i3--) {
            if (!name || objects[i3][NAME_INDEX] === name) {
              this._removeObjectByIndex(jCalIndex, cached, i3);
            }
          }
        },
        /**
         * Adds a single sub component.
         *
         * @param {ICAL.Component} component        The component to add
         * @return {ICAL.Component}                 The passed in component
         */
        addSubcomponent: function(component) {
          if (!this._components) {
            this._components = [];
            this._hydratedComponentCount = 0;
          }
          if (component.parent) {
            component.parent.removeSubcomponent(component);
          }
          var idx = this.jCal[COMPONENT_INDEX].push(component.jCal);
          this._components[idx - 1] = component;
          this._hydratedComponentCount++;
          component.parent = this;
          return component;
        },
        /**
         * Removes a single component by name or the instance of a specific
         * component.
         *
         * @param {ICAL.Component|String} nameOrComp    Name of component, or component
         * @return {Boolean}                            True when comp is removed
         */
        removeSubcomponent: function(nameOrComp) {
          var removed = this._removeObject(COMPONENT_INDEX, "_components", nameOrComp);
          if (removed) {
            this._hydratedComponentCount--;
          }
          return removed;
        },
        /**
         * Removes all components or (if given) all components by a particular
         * name.
         *
         * @param {String=} name            Lowercase component name
         */
        removeAllSubcomponents: function(name) {
          var removed = this._removeAllObjects(COMPONENT_INDEX, "_components", name);
          this._hydratedComponentCount = 0;
          return removed;
        },
        /**
         * Adds an {@link ICAL.Property} to the component.
         *
         * @param {ICAL.Property} property      The property to add
         * @return {ICAL.Property}              The passed in property
         */
        addProperty: function(property) {
          if (!(property instanceof ICAL2.Property)) {
            throw new TypeError("must instance of ICAL.Property");
          }
          if (!this._properties) {
            this._properties = [];
            this._hydratedPropertyCount = 0;
          }
          if (property.parent) {
            property.parent.removeProperty(property);
          }
          var idx = this.jCal[PROPERTY_INDEX].push(property.jCal);
          this._properties[idx - 1] = property;
          this._hydratedPropertyCount++;
          property.parent = this;
          return property;
        },
        /**
         * Helper method to add a property with a value to the component.
         *
         * @param {String}               name         Property name to add
         * @param {String|Number|Object} value        Property value
         * @return {ICAL.Property}                    The created property
         */
        addPropertyWithValue: function(name, value) {
          var prop = new ICAL2.Property(name);
          prop.setValue(value);
          this.addProperty(prop);
          return prop;
        },
        /**
         * Helper method that will update or create a property of the given name
         * and sets its value. If multiple properties with the given name exist,
         * only the first is updated.
         *
         * @param {String}               name         Property name to update
         * @param {String|Number|Object} value        Property value
         * @return {ICAL.Property}                    The created property
         */
        updatePropertyWithValue: function(name, value) {
          var prop = this.getFirstProperty(name);
          if (prop) {
            prop.setValue(value);
          } else {
            prop = this.addPropertyWithValue(name, value);
          }
          return prop;
        },
        /**
         * Removes a single property by name or the instance of the specific
         * property.
         *
         * @param {String|ICAL.Property} nameOrProp     Property name or instance to remove
         * @return {Boolean}                            True, when deleted
         */
        removeProperty: function(nameOrProp) {
          var removed = this._removeObject(PROPERTY_INDEX, "_properties", nameOrProp);
          if (removed) {
            this._hydratedPropertyCount--;
          }
          return removed;
        },
        /**
         * Removes all properties associated with this component, optionally
         * filtered by name.
         *
         * @param {String=} name        Lowercase property name
         * @return {Boolean}            True, when deleted
         */
        removeAllProperties: function(name) {
          var removed = this._removeAllObjects(PROPERTY_INDEX, "_properties", name);
          this._hydratedPropertyCount = 0;
          return removed;
        },
        /**
         * Returns the Object representation of this component. The returned object
         * is a live jCal object and should be cloned if modified.
         * @return {Object}
         */
        toJSON: function() {
          return this.jCal;
        },
        /**
         * The string representation of this component.
         * @return {String}
         */
        toString: function() {
          return ICAL2.stringify.component(
            this.jCal,
            this._designSet
          );
        }
      };
      Component3.fromString = function(str) {
        return new Component3(ICAL2.parse.component(str));
      };
      return Component3;
    }();
    ICAL2.Property = function() {
      "use strict";
      var NAME_INDEX = 0;
      var PROP_INDEX = 1;
      var TYPE_INDEX = 2;
      var VALUE_INDEX = 3;
      var design = ICAL2.design;
      function Property(jCal, parent) {
        this._parent = parent || null;
        if (typeof jCal === "string") {
          this.jCal = [jCal, {}, design.defaultType];
          this.jCal[TYPE_INDEX] = this.getDefaultType();
        } else {
          this.jCal = jCal;
        }
        this._updateType();
      }
      Property.prototype = {
        /**
         * The value type for this property
         * @readonly
         * @type {String}
         */
        get type() {
          return this.jCal[TYPE_INDEX];
        },
        /**
         * The name of this property, in lowercase.
         * @readonly
         * @type {String}
         */
        get name() {
          return this.jCal[NAME_INDEX];
        },
        /**
         * The parent component for this property.
         * @type {ICAL.Component}
         */
        get parent() {
          return this._parent;
        },
        set parent(p3) {
          var designSetChanged = !this._parent || p3 && p3._designSet != this._parent._designSet;
          this._parent = p3;
          if (this.type == design.defaultType && designSetChanged) {
            this.jCal[TYPE_INDEX] = this.getDefaultType();
            this._updateType();
          }
          return p3;
        },
        /**
         * The design set for this property, e.g. icalendar vs vcard
         *
         * @type {ICAL.design.designSet}
         * @private
         */
        get _designSet() {
          return this.parent ? this.parent._designSet : design.defaultSet;
        },
        /**
         * Updates the type metadata from the current jCal type and design set.
         *
         * @private
         */
        _updateType: function() {
          var designSet = this._designSet;
          if (this.type in designSet.value) {
            var designType = designSet.value[this.type];
            if ("decorate" in designSet.value[this.type]) {
              this.isDecorated = true;
            } else {
              this.isDecorated = false;
            }
            if (this.name in designSet.property) {
              this.isMultiValue = "multiValue" in designSet.property[this.name];
              this.isStructuredValue = "structuredValue" in designSet.property[this.name];
            }
          }
        },
        /**
         * Hydrate a single value. The act of hydrating means turning the raw jCal
         * value into a potentially wrapped object, for example {@link ICAL.Time}.
         *
         * @private
         * @param {Number} index        The index of the value to hydrate
         * @return {Object}             The decorated value.
         */
        _hydrateValue: function(index8) {
          if (this._values && this._values[index8]) {
            return this._values[index8];
          }
          if (this.jCal.length <= VALUE_INDEX + index8) {
            return null;
          }
          if (this.isDecorated) {
            if (!this._values) {
              this._values = [];
            }
            return this._values[index8] = this._decorate(
              this.jCal[VALUE_INDEX + index8]
            );
          } else {
            return this.jCal[VALUE_INDEX + index8];
          }
        },
        /**
         * Decorate a single value, returning its wrapped object. This is used by
         * the hydrate function to actually wrap the value.
         *
         * @private
         * @param {?} value         The value to decorate
         * @return {Object}         The decorated value
         */
        _decorate: function(value) {
          return this._designSet.value[this.type].decorate(value, this);
        },
        /**
         * Undecorate a single value, returning its raw jCal data.
         *
         * @private
         * @param {Object} value         The value to undecorate
         * @return {?}                   The undecorated value
         */
        _undecorate: function(value) {
          return this._designSet.value[this.type].undecorate(value, this);
        },
        /**
         * Sets the value at the given index while also hydrating it. The passed
         * value can either be a decorated or undecorated value.
         *
         * @private
         * @param {?} value             The value to set
         * @param {Number} index        The index to set it at
         */
        _setDecoratedValue: function(value, index8) {
          if (!this._values) {
            this._values = [];
          }
          if (typeof value === "object" && "icaltype" in value) {
            this.jCal[VALUE_INDEX + index8] = this._undecorate(value);
            this._values[index8] = value;
          } else {
            this.jCal[VALUE_INDEX + index8] = value;
            this._values[index8] = this._decorate(value);
          }
        },
        /**
         * Gets a parameter on the property.
         *
         * @param {String}        name   Parameter name (lowercase)
         * @return {Array|String}        Parameter value
         */
        getParameter: function(name) {
          if (name in this.jCal[PROP_INDEX]) {
            return this.jCal[PROP_INDEX][name];
          } else {
            return void 0;
          }
        },
        /**
         * Gets first parameter on the property.
         *
         * @param {String}        name   Parameter name (lowercase)
         * @return {String}        Parameter value
         */
        getFirstParameter: function(name) {
          var parameters = this.getParameter(name);
          if (Array.isArray(parameters)) {
            return parameters[0];
          }
          return parameters;
        },
        /**
         * Sets a parameter on the property.
         *
         * @param {String}       name     The parameter name
         * @param {Array|String} value    The parameter value
         */
        setParameter: function(name, value) {
          var lcname = name.toLowerCase();
          if (typeof value === "string" && lcname in this._designSet.param && "multiValue" in this._designSet.param[lcname]) {
            value = [value];
          }
          this.jCal[PROP_INDEX][name] = value;
        },
        /**
         * Removes a parameter
         *
         * @param {String} name     The parameter name
         */
        removeParameter: function(name) {
          delete this.jCal[PROP_INDEX][name];
        },
        /**
         * Get the default type based on this property's name.
         *
         * @return {String}     The default type for this property
         */
        getDefaultType: function() {
          var name = this.jCal[NAME_INDEX];
          var designSet = this._designSet;
          if (name in designSet.property) {
            var details = designSet.property[name];
            if ("defaultType" in details) {
              return details.defaultType;
            }
          }
          return design.defaultType;
        },
        /**
         * Sets type of property and clears out any existing values of the current
         * type.
         *
         * @param {String} type     New iCAL type (see design.*.values)
         */
        resetType: function(type) {
          this.removeAllValues();
          this.jCal[TYPE_INDEX] = type;
          this._updateType();
        },
        /**
         * Finds the first property value.
         *
         * @return {String}         First property value
         */
        getFirstValue: function() {
          return this._hydrateValue(0);
        },
        /**
         * Gets all values on the property.
         *
         * NOTE: this creates an array during each call.
         *
         * @return {Array}          List of values
         */
        getValues: function() {
          var len = this.jCal.length - VALUE_INDEX;
          if (len < 1) {
            return [];
          }
          var i3 = 0;
          var result = [];
          for (; i3 < len; i3++) {
            result[i3] = this._hydrateValue(i3);
          }
          return result;
        },
        /**
         * Removes all values from this property
         */
        removeAllValues: function() {
          if (this._values) {
            this._values.length = 0;
          }
          this.jCal.length = 3;
        },
        /**
         * Sets the values of the property.  Will overwrite the existing values.
         * This can only be used for multi-value properties.
         *
         * @param {Array} values    An array of values
         */
        setValues: function(values) {
          if (!this.isMultiValue) {
            throw new Error(
              this.name + ": does not not support mulitValue.\noverride isMultiValue"
            );
          }
          var len = values.length;
          var i3 = 0;
          this.removeAllValues();
          if (len > 0 && typeof values[0] === "object" && "icaltype" in values[0]) {
            this.resetType(values[0].icaltype);
          }
          if (this.isDecorated) {
            for (; i3 < len; i3++) {
              this._setDecoratedValue(values[i3], i3);
            }
          } else {
            for (; i3 < len; i3++) {
              this.jCal[VALUE_INDEX + i3] = values[i3];
            }
          }
        },
        /**
         * Sets the current value of the property. If this is a multi-value
         * property, all other values will be removed.
         *
         * @param {String|Object} value     New property value.
         */
        setValue: function(value) {
          this.removeAllValues();
          if (typeof value === "object" && "icaltype" in value) {
            this.resetType(value.icaltype);
          }
          if (this.isDecorated) {
            this._setDecoratedValue(value, 0);
          } else {
            this.jCal[VALUE_INDEX] = value;
          }
        },
        /**
         * Returns the Object representation of this component. The returned object
         * is a live jCal object and should be cloned if modified.
         * @return {Object}
         */
        toJSON: function() {
          return this.jCal;
        },
        /**
         * The string representation of this component.
         * @return {String}
         */
        toICALString: function() {
          return ICAL2.stringify.property(
            this.jCal,
            this._designSet,
            true
          );
        }
      };
      Property.fromString = function(str, designSet) {
        return new Property(ICAL2.parse.property(str, designSet));
      };
      return Property;
    }();
    ICAL2.UtcOffset = function() {
      function UtcOffset(aData) {
        this.fromData(aData);
      }
      UtcOffset.prototype = {
        /**
         * The hours in the utc-offset
         * @type {Number}
         */
        hours: 0,
        /**
         * The minutes in the utc-offset
         * @type {Number}
         */
        minutes: 0,
        /**
         * The sign of the utc offset, 1 for positive offset, -1 for negative
         * offsets.
         * @type {Number}
         */
        factor: 1,
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "utc-offset"
         */
        icaltype: "utc-offset",
        /**
         * Returns a clone of the utc offset object.
         *
         * @return {ICAL.UtcOffset}     The cloned object
         */
        clone: function() {
          return ICAL2.UtcOffset.fromSeconds(this.toSeconds());
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData          An object with members of the utc offset
         * @param {Number=} aData.hours   The hours for the utc offset
         * @param {Number=} aData.minutes The minutes in the utc offset
         * @param {Number=} aData.factor  The factor for the utc-offset, either -1 or 1
         */
        fromData: function(aData) {
          if (aData) {
            for (var key in aData) {
              if (aData.hasOwnProperty(key)) {
                this[key] = aData[key];
              }
            }
          }
          this._normalize();
        },
        /**
         * Sets up the current instance from the given seconds value. The seconds
         * value is truncated to the minute. Offsets are wrapped when the world
         * ends, the hour after UTC+14:00 is UTC-12:00.
         *
         * @param {Number} aSeconds         The seconds to convert into an offset
         */
        fromSeconds: function(aSeconds) {
          var secs = Math.abs(aSeconds);
          this.factor = aSeconds < 0 ? -1 : 1;
          this.hours = ICAL2.helpers.trunc(secs / 3600);
          secs -= this.hours * 3600;
          this.minutes = ICAL2.helpers.trunc(secs / 60);
          return this;
        },
        /**
         * Convert the current offset to a value in seconds
         *
         * @return {Number}                 The offset in seconds
         */
        toSeconds: function() {
          return this.factor * (60 * this.minutes + 3600 * this.hours);
        },
        /**
         * Compare this utc offset with another one.
         *
         * @param {ICAL.UtcOffset} other        The other offset to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function icaltime_compare(other) {
          var a3 = this.toSeconds();
          var b3 = other.toSeconds();
          return (a3 > b3) - (b3 > a3);
        },
        _normalize: function() {
          var secs = this.toSeconds();
          var factor = this.factor;
          while (secs < -43200) {
            secs += 97200;
          }
          while (secs > 50400) {
            secs -= 97200;
          }
          this.fromSeconds(secs);
          if (secs == 0) {
            this.factor = factor;
          }
        },
        /**
         * The iCalendar string representation of this utc-offset.
         * @return {String}
         */
        toICALString: function() {
          return ICAL2.design.icalendar.value["utc-offset"].toICAL(this.toString());
        },
        /**
         * The string representation of this utc-offset.
         * @return {String}
         */
        toString: function toString() {
          return (this.factor == 1 ? "+" : "-") + ICAL2.helpers.pad2(this.hours) + ":" + ICAL2.helpers.pad2(this.minutes);
        }
      };
      UtcOffset.fromString = function(aString) {
        var options = {};
        options.factor = aString[0] === "+" ? 1 : -1;
        options.hours = ICAL2.helpers.strictParseInt(aString.substr(1, 2));
        options.minutes = ICAL2.helpers.strictParseInt(aString.substr(4, 2));
        return new ICAL2.UtcOffset(options);
      };
      UtcOffset.fromSeconds = function(aSeconds) {
        var instance = new UtcOffset();
        instance.fromSeconds(aSeconds);
        return instance;
      };
      return UtcOffset;
    }();
    ICAL2.Binary = function() {
      function Binary(aValue) {
        this.value = aValue;
      }
      Binary.prototype = {
        /**
         * The type name, to be used in the jCal object.
         * @default "binary"
         * @constant
         */
        icaltype: "binary",
        /**
         * Base64 decode the current value
         *
         * @return {String}         The base64-decoded value
         */
        decodeValue: function decodeValue() {
          return this._b64_decode(this.value);
        },
        /**
         * Encodes the passed parameter with base64 and sets the internal
         * value to the result.
         *
         * @param {String} aValue      The raw binary value to encode
         */
        setEncodedValue: function setEncodedValue(aValue) {
          this.value = this._b64_encode(aValue);
        },
        _b64_encode: function base64_encode(data) {
          var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var o1, o2, o3, h1, h22, h3, h4, bits, i3 = 0, ac = 0, enc = "", tmp_arr = [];
          if (!data) {
            return data;
          }
          do {
            o1 = data.charCodeAt(i3++);
            o2 = data.charCodeAt(i3++);
            o3 = data.charCodeAt(i3++);
            bits = o1 << 16 | o2 << 8 | o3;
            h1 = bits >> 18 & 63;
            h22 = bits >> 12 & 63;
            h3 = bits >> 6 & 63;
            h4 = bits & 63;
            tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h22) + b64.charAt(h3) + b64.charAt(h4);
          } while (i3 < data.length);
          enc = tmp_arr.join("");
          var r3 = data.length % 3;
          return (r3 ? enc.slice(0, r3 - 3) : enc) + "===".slice(r3 || 3);
        },
        _b64_decode: function base64_decode(data) {
          var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var o1, o2, o3, h1, h22, h3, h4, bits, i3 = 0, ac = 0, dec = "", tmp_arr = [];
          if (!data) {
            return data;
          }
          data += "";
          do {
            h1 = b64.indexOf(data.charAt(i3++));
            h22 = b64.indexOf(data.charAt(i3++));
            h3 = b64.indexOf(data.charAt(i3++));
            h4 = b64.indexOf(data.charAt(i3++));
            bits = h1 << 18 | h22 << 12 | h3 << 6 | h4;
            o1 = bits >> 16 & 255;
            o2 = bits >> 8 & 255;
            o3 = bits & 255;
            if (h3 == 64) {
              tmp_arr[ac++] = String.fromCharCode(o1);
            } else if (h4 == 64) {
              tmp_arr[ac++] = String.fromCharCode(o1, o2);
            } else {
              tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
            }
          } while (i3 < data.length);
          dec = tmp_arr.join("");
          return dec;
        },
        /**
         * The string representation of this value
         * @return {String}
         */
        toString: function() {
          return this.value;
        }
      };
      Binary.fromString = function(aString) {
        return new Binary(aString);
      };
      return Binary;
    }();
    (function() {
      ICAL2.Period = function icalperiod(aData) {
        this.wrappedJSObject = this;
        if (aData && "start" in aData) {
          if (aData.start && !(aData.start instanceof ICAL2.Time)) {
            throw new TypeError(".start must be an instance of ICAL.Time");
          }
          this.start = aData.start;
        }
        if (aData && aData.end && aData.duration) {
          throw new Error("cannot accept both end and duration");
        }
        if (aData && "end" in aData) {
          if (aData.end && !(aData.end instanceof ICAL2.Time)) {
            throw new TypeError(".end must be an instance of ICAL.Time");
          }
          this.end = aData.end;
        }
        if (aData && "duration" in aData) {
          if (aData.duration && !(aData.duration instanceof ICAL2.Duration)) {
            throw new TypeError(".duration must be an instance of ICAL.Duration");
          }
          this.duration = aData.duration;
        }
      };
      ICAL2.Period.prototype = {
        /**
         * The start of the period
         * @type {ICAL.Time}
         */
        start: null,
        /**
         * The end of the period
         * @type {ICAL.Time}
         */
        end: null,
        /**
         * The duration of the period
         * @type {ICAL.Duration}
         */
        duration: null,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalperiod"
         */
        icalclass: "icalperiod",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "period"
         */
        icaltype: "period",
        /**
         * Returns a clone of the duration object.
         *
         * @return {ICAL.Period}      The cloned object
         */
        clone: function() {
          return ICAL2.Period.fromData({
            start: this.start ? this.start.clone() : null,
            end: this.end ? this.end.clone() : null,
            duration: this.duration ? this.duration.clone() : null
          });
        },
        /**
         * Calculates the duration of the period, either directly or by subtracting
         * start from end date.
         *
         * @return {ICAL.Duration}      The calculated duration
         */
        getDuration: function duration() {
          if (this.duration) {
            return this.duration;
          } else {
            return this.end.subtractDate(this.start);
          }
        },
        /**
         * Calculates the end date of the period, either directly or by adding
         * duration to start date.
         *
         * @return {ICAL.Time}          The calculated end date
         */
        getEnd: function() {
          if (this.end) {
            return this.end;
          } else {
            var end = this.start.clone();
            end.addDuration(this.duration);
            return end;
          }
        },
        /**
         * The string representation of this period.
         * @return {String}
         */
        toString: function toString() {
          return this.start + "/" + (this.end || this.duration);
        },
        /**
         * The jCal representation of this period type.
         * @return {Object}
         */
        toJSON: function() {
          return [this.start.toString(), (this.end || this.duration).toString()];
        },
        /**
         * The iCalendar string representation of this period.
         * @return {String}
         */
        toICALString: function() {
          return this.start.toICALString() + "/" + (this.end || this.duration).toICALString();
        }
      };
      ICAL2.Period.fromString = function fromString(str, prop) {
        var parts = str.split("/");
        if (parts.length !== 2) {
          throw new Error(
            'Invalid string value: "' + str + '" must contain a "/" char.'
          );
        }
        var options = {
          start: ICAL2.Time.fromDateTimeString(parts[0], prop)
        };
        var end = parts[1];
        if (ICAL2.Duration.isValueString(end)) {
          options.duration = ICAL2.Duration.fromString(end);
        } else {
          options.end = ICAL2.Time.fromDateTimeString(end, prop);
        }
        return new ICAL2.Period(options);
      };
      ICAL2.Period.fromData = function fromData(aData) {
        return new ICAL2.Period(aData);
      };
      ICAL2.Period.fromJSON = function(aData, aProp, aLenient) {
        function fromDateOrDateTimeString(aValue, aProp2) {
          if (aLenient) {
            return ICAL2.Time.fromString(aValue, aProp2);
          } else {
            return ICAL2.Time.fromDateTimeString(aValue, aProp2);
          }
        }
        if (ICAL2.Duration.isValueString(aData[1])) {
          return ICAL2.Period.fromData({
            start: fromDateOrDateTimeString(aData[0], aProp),
            duration: ICAL2.Duration.fromString(aData[1])
          });
        } else {
          return ICAL2.Period.fromData({
            start: fromDateOrDateTimeString(aData[0], aProp),
            end: fromDateOrDateTimeString(aData[1], aProp)
          });
        }
      };
    })();
    (function() {
      var DURATION_LETTERS = /([PDWHMTS]{1,1})/;
      ICAL2.Duration = function icalduration(data) {
        this.wrappedJSObject = this;
        this.fromData(data);
      };
      ICAL2.Duration.prototype = {
        /**
         * The weeks in this duration
         * @type {Number}
         * @default 0
         */
        weeks: 0,
        /**
         * The days in this duration
         * @type {Number}
         * @default 0
         */
        days: 0,
        /**
         * The days in this duration
         * @type {Number}
         * @default 0
         */
        hours: 0,
        /**
         * The minutes in this duration
         * @type {Number}
         * @default 0
         */
        minutes: 0,
        /**
         * The seconds in this duration
         * @type {Number}
         * @default 0
         */
        seconds: 0,
        /**
         * The seconds in this duration
         * @type {Boolean}
         * @default false
         */
        isNegative: false,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalduration"
         */
        icalclass: "icalduration",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "duration"
         */
        icaltype: "duration",
        /**
         * Returns a clone of the duration object.
         *
         * @return {ICAL.Duration}      The cloned object
         */
        clone: function clone2() {
          return ICAL2.Duration.fromData(this);
        },
        /**
         * The duration value expressed as a number of seconds.
         *
         * @return {Number}             The duration value in seconds
         */
        toSeconds: function toSeconds() {
          var seconds = this.seconds + 60 * this.minutes + 3600 * this.hours + 86400 * this.days + 7 * 86400 * this.weeks;
          return this.isNegative ? -seconds : seconds;
        },
        /**
         * Reads the passed seconds value into this duration object. Afterwards,
         * members like {@link ICAL.Duration#days days} and {@link ICAL.Duration#weeks weeks} will be set up
         * accordingly.
         *
         * @param {Number} aSeconds     The duration value in seconds
         * @return {ICAL.Duration}      Returns this instance
         */
        fromSeconds: function fromSeconds(aSeconds) {
          var secs = Math.abs(aSeconds);
          this.isNegative = aSeconds < 0;
          this.days = ICAL2.helpers.trunc(secs / 86400);
          if (this.days % 7 == 0) {
            this.weeks = this.days / 7;
            this.days = 0;
          } else {
            this.weeks = 0;
          }
          secs -= (this.days + 7 * this.weeks) * 86400;
          this.hours = ICAL2.helpers.trunc(secs / 3600);
          secs -= this.hours * 3600;
          this.minutes = ICAL2.helpers.trunc(secs / 60);
          secs -= this.minutes * 60;
          this.seconds = secs;
          return this;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData               An object with members of the duration
         * @param {Number} aData.weeks         Duration in weeks
         * @param {Number} aData.days          Duration in days
         * @param {Number} aData.hours         Duration in hours
         * @param {Number} aData.minutes       Duration in minutes
         * @param {Number} aData.seconds       Duration in seconds
         * @param {Boolean} aData.isNegative   If true, the duration is negative
         */
        fromData: function fromData(aData) {
          var propsToCopy = [
            "weeks",
            "days",
            "hours",
            "minutes",
            "seconds",
            "isNegative"
          ];
          for (var key in propsToCopy) {
            if (!propsToCopy.hasOwnProperty(key)) {
              continue;
            }
            var prop = propsToCopy[key];
            if (aData && prop in aData) {
              this[prop] = aData[prop];
            } else {
              this[prop] = 0;
            }
          }
        },
        /**
         * Resets the duration instance to the default values, i.e. PT0S
         */
        reset: function reset() {
          this.isNegative = false;
          this.weeks = 0;
          this.days = 0;
          this.hours = 0;
          this.minutes = 0;
          this.seconds = 0;
        },
        /**
         * Compares the duration instance with another one.
         *
         * @param {ICAL.Duration} aOther        The instance to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function compare(aOther) {
          var thisSeconds = this.toSeconds();
          var otherSeconds = aOther.toSeconds();
          return (thisSeconds > otherSeconds) - (thisSeconds < otherSeconds);
        },
        /**
         * Normalizes the duration instance. For example, a duration with a value
         * of 61 seconds will be normalized to 1 minute and 1 second.
         */
        normalize: function normalize() {
          this.fromSeconds(this.toSeconds());
        },
        /**
         * The string representation of this duration.
         * @return {String}
         */
        toString: function toString() {
          if (this.toSeconds() == 0) {
            return "PT0S";
          } else {
            var str = "";
            if (this.isNegative)
              str += "-";
            str += "P";
            if (this.weeks)
              str += this.weeks + "W";
            if (this.days)
              str += this.days + "D";
            if (this.hours || this.minutes || this.seconds) {
              str += "T";
              if (this.hours)
                str += this.hours + "H";
              if (this.minutes)
                str += this.minutes + "M";
              if (this.seconds)
                str += this.seconds + "S";
            }
            return str;
          }
        },
        /**
         * The iCalendar string representation of this duration.
         * @return {String}
         */
        toICALString: function() {
          return this.toString();
        }
      };
      ICAL2.Duration.fromSeconds = function icalduration_from_seconds(aSeconds) {
        return new ICAL2.Duration().fromSeconds(aSeconds);
      };
      function parseDurationChunk(letter, number, object) {
        var type;
        switch (letter) {
          case "P":
            if (number && number === "-") {
              object.isNegative = true;
            } else {
              object.isNegative = false;
            }
            break;
          case "D":
            type = "days";
            break;
          case "W":
            type = "weeks";
            break;
          case "H":
            type = "hours";
            break;
          case "M":
            type = "minutes";
            break;
          case "S":
            type = "seconds";
            break;
          default:
            return 0;
        }
        if (type) {
          if (!number && number !== 0) {
            throw new Error(
              'invalid duration value: Missing number before "' + letter + '"'
            );
          }
          var num = parseInt(number, 10);
          if (ICAL2.helpers.isStrictlyNaN(num)) {
            throw new Error(
              'invalid duration value: Invalid number "' + number + '" before "' + letter + '"'
            );
          }
          object[type] = num;
        }
        return 1;
      }
      ICAL2.Duration.isValueString = function(string) {
        return string[0] === "P" || string[1] === "P";
      };
      ICAL2.Duration.fromString = function icalduration_from_string(aStr) {
        var pos = 0;
        var dict = /* @__PURE__ */ Object.create(null);
        var chunks = 0;
        while ((pos = aStr.search(DURATION_LETTERS)) !== -1) {
          var type = aStr[pos];
          var numeric = aStr.substr(0, pos);
          aStr = aStr.substr(pos + 1);
          chunks += parseDurationChunk(type, numeric, dict);
        }
        if (chunks < 2) {
          throw new Error(
            'invalid duration value: Not enough duration components in "' + aStr + '"'
          );
        }
        return new ICAL2.Duration(dict);
      };
      ICAL2.Duration.fromData = function icalduration_from_data(aData) {
        return new ICAL2.Duration(aData);
      };
    })();
    (function() {
      var OPTIONS = [
        "tzid",
        "location",
        "tznames",
        "latitude",
        "longitude"
      ];
      ICAL2.Timezone = function icaltimezone(data) {
        this.wrappedJSObject = this;
        this.fromData(data);
      };
      ICAL2.Timezone.prototype = {
        /**
         * Timezone identifier
         * @type {String}
         */
        tzid: "",
        /**
         * Timezone location
         * @type {String}
         */
        location: "",
        /**
         * Alternative timezone name, for the string representation
         * @type {String}
         */
        tznames: "",
        /**
         * The primary latitude for the timezone.
         * @type {Number}
         */
        latitude: 0,
        /**
         * The primary longitude for the timezone.
         * @type {Number}
         */
        longitude: 0,
        /**
         * The vtimezone component for this timezone.
         * @type {ICAL.Component}
         */
        component: null,
        /**
         * The year this timezone has been expanded to. All timezone transition
         * dates until this year are known and can be used for calculation
         *
         * @private
         * @type {Number}
         */
        expandedUntilYear: 0,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icaltimezone"
         */
        icalclass: "icaltimezone",
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {ICAL.Component|Object} aData options for class
         * @param {String|ICAL.Component} aData.component
         *        If aData is a simple object, then this member can be set to either a
         *        string containing the component data, or an already parsed
         *        ICAL.Component
         * @param {String} aData.tzid      The timezone identifier
         * @param {String} aData.location  The timezone locationw
         * @param {String} aData.tznames   An alternative string representation of the
         *                                  timezone
         * @param {Number} aData.latitude  The latitude of the timezone
         * @param {Number} aData.longitude The longitude of the timezone
         */
        fromData: function fromData(aData) {
          this.expandedUntilYear = 0;
          this.changes = [];
          if (aData instanceof ICAL2.Component) {
            this.component = aData;
          } else {
            if (aData && "component" in aData) {
              if (typeof aData.component == "string") {
                var jCal = ICAL2.parse(aData.component);
                this.component = new ICAL2.Component(jCal);
              } else if (aData.component instanceof ICAL2.Component) {
                this.component = aData.component;
              } else {
                this.component = null;
              }
            }
            for (var key in OPTIONS) {
              if (OPTIONS.hasOwnProperty(key)) {
                var prop = OPTIONS[key];
                if (aData && prop in aData) {
                  this[prop] = aData[prop];
                }
              }
            }
          }
          if (this.component instanceof ICAL2.Component && !this.tzid) {
            this.tzid = this.component.getFirstPropertyValue("tzid");
          }
          return this;
        },
        /**
         * Finds the utcOffset the given time would occur in this timezone.
         *
         * @param {ICAL.Time} tt        The time to check for
         * @return {Number} utc offset in seconds
         */
        utcOffset: function utcOffset(tt) {
          if (this == ICAL2.Timezone.utcTimezone || this == ICAL2.Timezone.localTimezone) {
            return 0;
          }
          this._ensureCoverage(tt.year);
          if (!this.changes.length) {
            return 0;
          }
          var tt_change = {
            year: tt.year,
            month: tt.month,
            day: tt.day,
            hour: tt.hour,
            minute: tt.minute,
            second: tt.second
          };
          var change_num = this._findNearbyChange(tt_change);
          var change_num_to_use = -1;
          var step = 1;
          for (; ; ) {
            var change = ICAL2.helpers.clone(this.changes[change_num], true);
            if (change.utcOffset < change.prevUtcOffset) {
              ICAL2.Timezone.adjust_change(change, 0, 0, 0, change.utcOffset);
            } else {
              ICAL2.Timezone.adjust_change(
                change,
                0,
                0,
                0,
                change.prevUtcOffset
              );
            }
            var cmp = ICAL2.Timezone._compare_change_fn(tt_change, change);
            if (cmp >= 0) {
              change_num_to_use = change_num;
            } else {
              step = -1;
            }
            if (step == -1 && change_num_to_use != -1) {
              break;
            }
            change_num += step;
            if (change_num < 0) {
              return 0;
            }
            if (change_num >= this.changes.length) {
              break;
            }
          }
          var zone_change = this.changes[change_num_to_use];
          var utcOffset_change = zone_change.utcOffset - zone_change.prevUtcOffset;
          if (utcOffset_change < 0 && change_num_to_use > 0) {
            var tmp_change = ICAL2.helpers.clone(zone_change, true);
            ICAL2.Timezone.adjust_change(
              tmp_change,
              0,
              0,
              0,
              tmp_change.prevUtcOffset
            );
            if (ICAL2.Timezone._compare_change_fn(tt_change, tmp_change) < 0) {
              var prev_zone_change = this.changes[change_num_to_use - 1];
              var want_daylight = false;
              if (zone_change.is_daylight != want_daylight && prev_zone_change.is_daylight == want_daylight) {
                zone_change = prev_zone_change;
              }
            }
          }
          return zone_change.utcOffset;
        },
        _findNearbyChange: function icaltimezone_find_nearby_change(change) {
          var idx = ICAL2.helpers.binsearchInsert(
            this.changes,
            change,
            ICAL2.Timezone._compare_change_fn
          );
          if (idx >= this.changes.length) {
            return this.changes.length - 1;
          }
          return idx;
        },
        _ensureCoverage: function(aYear) {
          if (ICAL2.Timezone._minimumExpansionYear == -1) {
            var today = ICAL2.Time.now();
            ICAL2.Timezone._minimumExpansionYear = today.year;
          }
          var changesEndYear = aYear;
          if (changesEndYear < ICAL2.Timezone._minimumExpansionYear) {
            changesEndYear = ICAL2.Timezone._minimumExpansionYear;
          }
          changesEndYear += ICAL2.Timezone.EXTRA_COVERAGE;
          if (changesEndYear > ICAL2.Timezone.MAX_YEAR) {
            changesEndYear = ICAL2.Timezone.MAX_YEAR;
          }
          if (!this.changes.length || this.expandedUntilYear < aYear) {
            var subcomps = this.component.getAllSubcomponents();
            var compLen = subcomps.length;
            var compIdx = 0;
            for (; compIdx < compLen; compIdx++) {
              this._expandComponent(
                subcomps[compIdx],
                changesEndYear,
                this.changes
              );
            }
            this.changes.sort(ICAL2.Timezone._compare_change_fn);
            this.expandedUntilYear = changesEndYear;
          }
        },
        _expandComponent: function(aComponent, aYear, changes) {
          if (!aComponent.hasProperty("dtstart") || !aComponent.hasProperty("tzoffsetto") || !aComponent.hasProperty("tzoffsetfrom")) {
            return null;
          }
          var dtstart = aComponent.getFirstProperty("dtstart").getFirstValue();
          var change;
          function convert_tzoffset(offset) {
            return offset.factor * (offset.hours * 3600 + offset.minutes * 60);
          }
          function init_changes() {
            var changebase = {};
            changebase.is_daylight = aComponent.name == "daylight";
            changebase.utcOffset = convert_tzoffset(
              aComponent.getFirstProperty("tzoffsetto").getFirstValue()
            );
            changebase.prevUtcOffset = convert_tzoffset(
              aComponent.getFirstProperty("tzoffsetfrom").getFirstValue()
            );
            return changebase;
          }
          if (!aComponent.hasProperty("rrule") && !aComponent.hasProperty("rdate")) {
            change = init_changes();
            change.year = dtstart.year;
            change.month = dtstart.month;
            change.day = dtstart.day;
            change.hour = dtstart.hour;
            change.minute = dtstart.minute;
            change.second = dtstart.second;
            ICAL2.Timezone.adjust_change(
              change,
              0,
              0,
              0,
              -change.prevUtcOffset
            );
            changes.push(change);
          } else {
            var props = aComponent.getAllProperties("rdate");
            for (var rdatekey in props) {
              if (!props.hasOwnProperty(rdatekey)) {
                continue;
              }
              var rdate = props[rdatekey];
              var time = rdate.getFirstValue();
              change = init_changes();
              change.year = time.year;
              change.month = time.month;
              change.day = time.day;
              if (time.isDate) {
                change.hour = dtstart.hour;
                change.minute = dtstart.minute;
                change.second = dtstart.second;
                if (dtstart.zone != ICAL2.Timezone.utcTimezone) {
                  ICAL2.Timezone.adjust_change(
                    change,
                    0,
                    0,
                    0,
                    -change.prevUtcOffset
                  );
                }
              } else {
                change.hour = time.hour;
                change.minute = time.minute;
                change.second = time.second;
                if (time.zone != ICAL2.Timezone.utcTimezone) {
                  ICAL2.Timezone.adjust_change(
                    change,
                    0,
                    0,
                    0,
                    -change.prevUtcOffset
                  );
                }
              }
              changes.push(change);
            }
            var rrule = aComponent.getFirstProperty("rrule");
            if (rrule) {
              rrule = rrule.getFirstValue();
              change = init_changes();
              if (rrule.until && rrule.until.zone == ICAL2.Timezone.utcTimezone) {
                rrule.until.adjust(0, 0, 0, change.prevUtcOffset);
                rrule.until.zone = ICAL2.Timezone.localTimezone;
              }
              var iterator = rrule.iterator(dtstart);
              var occ;
              while (occ = iterator.next()) {
                change = init_changes();
                if (occ.year > aYear || !occ) {
                  break;
                }
                change.year = occ.year;
                change.month = occ.month;
                change.day = occ.day;
                change.hour = occ.hour;
                change.minute = occ.minute;
                change.second = occ.second;
                change.isDate = occ.isDate;
                ICAL2.Timezone.adjust_change(
                  change,
                  0,
                  0,
                  0,
                  -change.prevUtcOffset
                );
                changes.push(change);
              }
            }
          }
          return changes;
        },
        /**
         * The string representation of this timezone.
         * @return {String}
         */
        toString: function toString() {
          return this.tznames ? this.tznames : this.tzid;
        }
      };
      ICAL2.Timezone._compare_change_fn = function icaltimezone_compare_change_fn(a3, b3) {
        if (a3.year < b3.year)
          return -1;
        else if (a3.year > b3.year)
          return 1;
        if (a3.month < b3.month)
          return -1;
        else if (a3.month > b3.month)
          return 1;
        if (a3.day < b3.day)
          return -1;
        else if (a3.day > b3.day)
          return 1;
        if (a3.hour < b3.hour)
          return -1;
        else if (a3.hour > b3.hour)
          return 1;
        if (a3.minute < b3.minute)
          return -1;
        else if (a3.minute > b3.minute)
          return 1;
        if (a3.second < b3.second)
          return -1;
        else if (a3.second > b3.second)
          return 1;
        return 0;
      };
      ICAL2.Timezone.convert_time = function icaltimezone_convert_time(tt, from_zone, to_zone) {
        if (tt.isDate || from_zone.tzid == to_zone.tzid || from_zone == ICAL2.Timezone.localTimezone || to_zone == ICAL2.Timezone.localTimezone) {
          tt.zone = to_zone;
          return tt;
        }
        var utcOffset = from_zone.utcOffset(tt);
        tt.adjust(0, 0, 0, -utcOffset);
        utcOffset = to_zone.utcOffset(tt);
        tt.adjust(0, 0, 0, utcOffset);
        return null;
      };
      ICAL2.Timezone.fromData = function icaltimezone_fromData(aData) {
        var tt = new ICAL2.Timezone();
        return tt.fromData(aData);
      };
      ICAL2.Timezone.utcTimezone = ICAL2.Timezone.fromData({
        tzid: "UTC"
      });
      ICAL2.Timezone.localTimezone = ICAL2.Timezone.fromData({
        tzid: "floating"
      });
      ICAL2.Timezone.adjust_change = function icaltimezone_adjust_change(change, days, hours, minutes, seconds) {
        return ICAL2.Time.prototype.adjust.call(
          change,
          days,
          hours,
          minutes,
          seconds,
          change
        );
      };
      ICAL2.Timezone._minimumExpansionYear = -1;
      ICAL2.Timezone.MAX_YEAR = 2035;
      ICAL2.Timezone.EXTRA_COVERAGE = 5;
    })();
    ICAL2.TimezoneService = function() {
      var zones;
      var TimezoneService = {
        get count() {
          return Object.keys(zones).length;
        },
        reset: function() {
          zones = /* @__PURE__ */ Object.create(null);
          var utc = ICAL2.Timezone.utcTimezone;
          zones.Z = utc;
          zones.UTC = utc;
          zones.GMT = utc;
        },
        /**
         * Checks if timezone id has been registered.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {Boolean}        False, when not present
         */
        has: function(tzid) {
          return !!zones[tzid];
        },
        /**
         * Returns a timezone by its tzid if present.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {?ICAL.Timezone} The timezone, or null if not found
         */
        get: function(tzid) {
          return zones[tzid];
        },
        /**
         * Registers a timezone object or component.
         *
         * @param {String=} name
         *        The name of the timezone. Defaults to the component's TZID if not
         *        passed.
         * @param {ICAL.Component|ICAL.Timezone} zone
         *        The initialized zone or vtimezone.
         */
        register: function(name, timezone) {
          if (name instanceof ICAL2.Component) {
            if (name.name === "vtimezone") {
              timezone = new ICAL2.Timezone(name);
              name = timezone.tzid;
            }
          }
          if (timezone instanceof ICAL2.Timezone) {
            zones[name] = timezone;
          } else {
            throw new TypeError("timezone must be ICAL.Timezone or ICAL.Component");
          }
        },
        /**
         * Removes a timezone by its tzid from the list.
         *
         * @param {String} tzid     Timezone identifier (e.g. America/Los_Angeles)
         * @return {?ICAL.Timezone} The removed timezone, or null if not registered
         */
        remove: function(tzid) {
          return delete zones[tzid];
        }
      };
      TimezoneService.reset();
      return TimezoneService;
    }();
    (function() {
      ICAL2.Time = function icaltime(data, zone) {
        this.wrappedJSObject = this;
        var time = this._time = /* @__PURE__ */ Object.create(null);
        time.year = 0;
        time.month = 1;
        time.day = 1;
        time.hour = 0;
        time.minute = 0;
        time.second = 0;
        time.isDate = false;
        this.fromData(data, zone);
      };
      ICAL2.Time._dowCache = {};
      ICAL2.Time._wnCache = {};
      ICAL2.Time.prototype = {
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icaltime"
         */
        icalclass: "icaltime",
        _cachedUnixTime: null,
        /**
         * The type name, to be used in the jCal object. This value may change and
         * is strictly defined by the {@link ICAL.Time#isDate isDate} member.
         * @readonly
         * @type {String}
         * @default "date-time"
         */
        get icaltype() {
          return this.isDate ? "date" : "date-time";
        },
        /**
         * The timezone for this time.
         * @type {ICAL.Timezone}
         */
        zone: null,
        /**
         * Internal uses to indicate that a change has been made and the next read
         * operation must attempt to normalize the value (for example changing the
         * day to 33).
         *
         * @type {Boolean}
         * @private
         */
        _pendingNormalization: false,
        /**
         * Returns a clone of the time object.
         *
         * @return {ICAL.Time}              The cloned object
         */
        clone: function() {
          return new ICAL2.Time(this._time, this.zone);
        },
        /**
         * Reset the time instance to epoch time
         */
        reset: function icaltime_reset() {
          this.fromData(ICAL2.Time.epochTime);
          this.zone = ICAL2.Timezone.utcTimezone;
        },
        /**
         * Reset the time instance to the given date/time values.
         *
         * @param {Number} year             The year to set
         * @param {Number} month            The month to set
         * @param {Number} day              The day to set
         * @param {Number} hour             The hour to set
         * @param {Number} minute           The minute to set
         * @param {Number} second           The second to set
         * @param {ICAL.Timezone} timezone  The timezone to set
         */
        resetTo: function icaltime_resetTo(year, month, day, hour, minute, second, timezone) {
          this.fromData({
            year,
            month,
            day,
            hour,
            minute,
            second,
            zone: timezone
          });
        },
        /**
         * Set up the current instance from the Javascript date value.
         *
         * @param {?Date} aDate     The Javascript Date to read, or null to reset
         * @param {Boolean} useUTC  If true, the UTC values of the date will be used
         */
        fromJSDate: function icaltime_fromJSDate(aDate, useUTC) {
          if (!aDate) {
            this.reset();
          } else {
            if (useUTC) {
              this.zone = ICAL2.Timezone.utcTimezone;
              this.year = aDate.getUTCFullYear();
              this.month = aDate.getUTCMonth() + 1;
              this.day = aDate.getUTCDate();
              this.hour = aDate.getUTCHours();
              this.minute = aDate.getUTCMinutes();
              this.second = aDate.getUTCSeconds();
            } else {
              this.zone = ICAL2.Timezone.localTimezone;
              this.year = aDate.getFullYear();
              this.month = aDate.getMonth() + 1;
              this.day = aDate.getDate();
              this.hour = aDate.getHours();
              this.minute = aDate.getMinutes();
              this.second = aDate.getSeconds();
            }
          }
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} aData            Time initialization
         * @param {Number=} aData.year      The year for this date
         * @param {Number=} aData.month     The month for this date
         * @param {Number=} aData.day       The day for this date
         * @param {Number=} aData.hour      The hour for this date
         * @param {Number=} aData.minute    The minute for this date
         * @param {Number=} aData.second    The second for this date
         * @param {Boolean=} aData.isDate   If true, the instance represents a date
         *                                    (as opposed to a date-time)
         * @param {ICAL.Timezone=} aZone    Timezone this position occurs in
         */
        fromData: function fromData(aData, aZone) {
          if (aData) {
            for (var key in aData) {
              if (Object.prototype.hasOwnProperty.call(aData, key)) {
                if (key === "icaltype")
                  continue;
                this[key] = aData[key];
              }
            }
          }
          if (aZone) {
            this.zone = aZone;
          }
          if (aData && !("isDate" in aData)) {
            this.isDate = !("hour" in aData);
          } else if (aData && "isDate" in aData) {
            this.isDate = aData.isDate;
          }
          if (aData && "timezone" in aData) {
            var zone = ICAL2.TimezoneService.get(
              aData.timezone
            );
            this.zone = zone || ICAL2.Timezone.localTimezone;
          }
          if (aData && "zone" in aData) {
            this.zone = aData.zone;
          }
          if (!this.zone) {
            this.zone = ICAL2.Timezone.localTimezone;
          }
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Calculate the day of week.
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time.weekDay}
         */
        dayOfWeek: function icaltime_dayOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var dowCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + firstDow;
          if (dowCacheKey in ICAL2.Time._dowCache) {
            return ICAL2.Time._dowCache[dowCacheKey];
          }
          var q3 = this.day;
          var m3 = this.month + (this.month < 3 ? 12 : 0);
          var Y = this.year - (this.month < 3 ? 1 : 0);
          var h3 = q3 + Y + ICAL2.helpers.trunc((m3 + 1) * 26 / 10) + ICAL2.helpers.trunc(Y / 4);
          if (true) {
            h3 += ICAL2.helpers.trunc(Y / 100) * 6 + ICAL2.helpers.trunc(Y / 400);
          } else {
            h3 += 5;
          }
          h3 = (h3 + 7 - firstDow) % 7 + 1;
          ICAL2.Time._dowCache[dowCacheKey] = h3;
          return h3;
        },
        /**
         * Calculate the day of year.
         * @return {Number}
         */
        dayOfYear: function dayOfYear() {
          var is_leap = ICAL2.Time.isLeapYear(this.year) ? 1 : 0;
          var diypm = ICAL2.Time.daysInYearPassedMonth;
          return diypm[is_leap][this.month - 1] + this.day;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * week. The resulting ICAL.Time instance is of icaltype date, even if this
         * is a date-time.
         *
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time}      The start of the week (cloned)
         */
        startOfWeek: function startOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var result = this.clone();
          result.day -= (this.dayOfWeek() + 7 - firstDow) % 7;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the week.
         * The resulting ICAL.Time instance is of icaltype date, even if this is a
         * date-time.
         *
         * @param {ICAL.Time.weekDay=} aWeekStart
         *        The week start weekday, defaults to SUNDAY
         * @return {ICAL.Time}      The end of the week (cloned)
         */
        endOfWeek: function endOfWeek(aWeekStart) {
          var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
          var result = this.clone();
          result.day += (7 - this.dayOfWeek() + firstDow - ICAL2.Time.SUNDAY) % 7;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * month. The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The start of the month (cloned)
         */
        startOfMonth: function startOfMonth() {
          var result = this.clone();
          result.day = 1;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the
         * month.  The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The end of the month (cloned)
         */
        endOfMonth: function endOfMonth() {
          var result = this.clone();
          result.day = ICAL2.Time.daysInMonth(result.month, result.year);
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, rewound to the start of the
         * year. The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The start of the year (cloned)
         */
        startOfYear: function startOfYear() {
          var result = this.clone();
          result.day = 1;
          result.month = 1;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * Returns a copy of the current date/time, shifted to the end of the
         * year.  The resulting ICAL.Time instance is of icaltype date, even if
         * this is a date-time.
         *
         * @return {ICAL.Time}      The end of the year (cloned)
         */
        endOfYear: function endOfYear() {
          var result = this.clone();
          result.day = 31;
          result.month = 12;
          result.isDate = true;
          result.hour = 0;
          result.minute = 0;
          result.second = 0;
          return result;
        },
        /**
         * First calculates the start of the week, then returns the day of year for
         * this date. If the day falls into the previous year, the day is zero or negative.
         *
         * @param {ICAL.Time.weekDay=} aFirstDayOfWeek
         *        The week start weekday, defaults to SUNDAY
         * @return {Number}     The calculated day of year
         */
        startDoyWeek: function startDoyWeek(aFirstDayOfWeek) {
          var firstDow = aFirstDayOfWeek || ICAL2.Time.SUNDAY;
          var delta = this.dayOfWeek() - firstDow;
          if (delta < 0)
            delta += 7;
          return this.dayOfYear() - delta;
        },
        /**
         * Get the dominical letter for the current year. Letters range from A - G
         * for common years, and AG to GF for leap years.
         *
         * @param {Number} yr           The year to retrieve the letter for
         * @return {String}             The dominical letter.
         */
        getDominicalLetter: function() {
          return ICAL2.Time.getDominicalLetter(this.year);
        },
        /**
         * Finds the nthWeekDay relative to the current month (not day).  The
         * returned value is a day relative the month that this month belongs to so
         * 1 would indicate the first of the month and 40 would indicate a day in
         * the following month.
         *
         * @param {Number} aDayOfWeek   Day of the week see the day name constants
         * @param {Number} aPos         Nth occurrence of a given week day values
         *        of 1 and 0 both indicate the first weekday of that type. aPos may
         *        be either positive or negative
         *
         * @return {Number} numeric value indicating a day relative
         *                   to the current month of this time object
         */
        nthWeekDay: function icaltime_nthWeekDay(aDayOfWeek, aPos) {
          var daysInMonth = ICAL2.Time.daysInMonth(this.month, this.year);
          var weekday;
          var pos = aPos;
          var start = 0;
          var otherDay = this.clone();
          if (pos >= 0) {
            otherDay.day = 1;
            if (pos != 0) {
              pos--;
            }
            start = otherDay.day;
            var startDow = otherDay.dayOfWeek();
            var offset = aDayOfWeek - startDow;
            if (offset < 0)
              offset += 7;
            start += offset;
            start -= aDayOfWeek;
            weekday = aDayOfWeek;
          } else {
            otherDay.day = daysInMonth;
            var endDow = otherDay.dayOfWeek();
            pos++;
            weekday = endDow - aDayOfWeek;
            if (weekday < 0) {
              weekday += 7;
            }
            weekday = daysInMonth - weekday;
          }
          weekday += pos * 7;
          return start + weekday;
        },
        /**
         * Checks if current time is the nth weekday, relative to the current
         * month.  Will always return false when rule resolves outside of current
         * month.
         *
         * @param {ICAL.Time.weekDay} aDayOfWeek       Day of week to check
         * @param {Number} aPos                        Relative position
         * @return {Boolean}                           True, if it is the nth weekday
         */
        isNthWeekDay: function(aDayOfWeek, aPos) {
          var dow = this.dayOfWeek();
          if (aPos === 0 && dow === aDayOfWeek) {
            return true;
          }
          var day = this.nthWeekDay(aDayOfWeek, aPos);
          if (day === this.day) {
            return true;
          }
          return false;
        },
        /**
         * Calculates the ISO 8601 week number. The first week of a year is the
         * week that contains the first Thursday. The year can have 53 weeks, if
         * January 1st is a Friday.
         *
         * Note there are regions where the first week of the year is the one that
         * starts on January 1st, which may offset the week number. Also, if a
         * different week start is specified, this will also affect the week
         * number.
         *
         * @see ICAL.Time.weekOneStarts
         * @param {ICAL.Time.weekDay} aWeekStart        The weekday the week starts with
         * @return {Number}                             The ISO week number
         */
        weekNumber: function weekNumber(aWeekStart) {
          var wnCacheKey = (this.year << 12) + (this.month << 8) + (this.day << 3) + aWeekStart;
          if (wnCacheKey in ICAL2.Time._wnCache) {
            return ICAL2.Time._wnCache[wnCacheKey];
          }
          var week1;
          var dt = this.clone();
          dt.isDate = true;
          var isoyear = this.year;
          if (dt.month == 12 && dt.day > 25) {
            week1 = ICAL2.Time.weekOneStarts(isoyear + 1, aWeekStart);
            if (dt.compare(week1) < 0) {
              week1 = ICAL2.Time.weekOneStarts(isoyear, aWeekStart);
            } else {
              isoyear++;
            }
          } else {
            week1 = ICAL2.Time.weekOneStarts(isoyear, aWeekStart);
            if (dt.compare(week1) < 0) {
              week1 = ICAL2.Time.weekOneStarts(--isoyear, aWeekStart);
            }
          }
          var daysBetween2 = dt.subtractDate(week1).toSeconds() / 86400;
          var answer = ICAL2.helpers.trunc(daysBetween2 / 7) + 1;
          ICAL2.Time._wnCache[wnCacheKey] = answer;
          return answer;
        },
        /**
         * Adds the duration to the current time. The instance is modified in
         * place.
         *
         * @param {ICAL.Duration} aDuration         The duration to add
         */
        addDuration: function icaltime_add(aDuration) {
          var mult = aDuration.isNegative ? -1 : 1;
          var second = this.second;
          var minute = this.minute;
          var hour = this.hour;
          var day = this.day;
          second += mult * aDuration.seconds;
          minute += mult * aDuration.minutes;
          hour += mult * aDuration.hours;
          day += mult * aDuration.days;
          day += mult * 7 * aDuration.weeks;
          this.second = second;
          this.minute = minute;
          this.hour = hour;
          this.day = day;
          this._cachedUnixTime = null;
        },
        /**
         * Subtract the date details (_excluding_ timezone).  Useful for finding
         * the relative difference between two time objects excluding their
         * timezone differences.
         *
         * @param {ICAL.Time} aDate     The date to substract
         * @return {ICAL.Duration}      The difference as a duration
         */
        subtractDate: function icaltime_subtract(aDate) {
          var unixTime = this.toUnixTime() + this.utcOffset();
          var other = aDate.toUnixTime() + aDate.utcOffset();
          return ICAL2.Duration.fromSeconds(unixTime - other);
        },
        /**
         * Subtract the date details, taking timezones into account.
         *
         * @param {ICAL.Time} aDate  The date to subtract
         * @return {ICAL.Duration}  The difference in duration
         */
        subtractDateTz: function icaltime_subtract_abs(aDate) {
          var unixTime = this.toUnixTime();
          var other = aDate.toUnixTime();
          return ICAL2.Duration.fromSeconds(unixTime - other);
        },
        /**
         * Compares the ICAL.Time instance with another one.
         *
         * @param {ICAL.Duration} aOther        The instance to compare with
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compare: function icaltime_compare(other) {
          var a3 = this.toUnixTime();
          var b3 = other.toUnixTime();
          if (a3 > b3)
            return 1;
          if (b3 > a3)
            return -1;
          return 0;
        },
        /**
         * Compares only the date part of this instance with another one.
         *
         * @param {ICAL.Duration} other         The instance to compare with
         * @param {ICAL.Timezone} tz            The timezone to compare in
         * @return {Number}                     -1, 0 or 1 for less/equal/greater
         */
        compareDateOnlyTz: function icaltime_compareDateOnlyTz(other, tz) {
          function cmp(attr) {
            return ICAL2.Time._cmp_attr(a3, b3, attr);
          }
          var a3 = this.convertToZone(tz);
          var b3 = other.convertToZone(tz);
          var rc = 0;
          if ((rc = cmp("year")) != 0)
            return rc;
          if ((rc = cmp("month")) != 0)
            return rc;
          if ((rc = cmp("day")) != 0)
            return rc;
          return rc;
        },
        /**
         * Convert the instance into another timezone. The returned ICAL.Time
         * instance is always a copy.
         *
         * @param {ICAL.Timezone} zone      The zone to convert to
         * @return {ICAL.Time}              The copy, converted to the zone
         */
        convertToZone: function convertToZone(zone) {
          var copy = this.clone();
          var zone_equals = this.zone.tzid == zone.tzid;
          if (!this.isDate && !zone_equals) {
            ICAL2.Timezone.convert_time(copy, this.zone, zone);
          }
          copy.zone = zone;
          return copy;
        },
        /**
         * Calculates the UTC offset of the current date/time in the timezone it is
         * in.
         *
         * @return {Number}     UTC offset in seconds
         */
        utcOffset: function utc_offset() {
          if (this.zone == ICAL2.Timezone.localTimezone || this.zone == ICAL2.Timezone.utcTimezone) {
            return 0;
          } else {
            return this.zone.utcOffset(this);
          }
        },
        /**
         * Returns an RFC 5545 compliant ical representation of this object.
         *
         * @return {String} ical date/date-time
         */
        toICALString: function() {
          var string = this.toString();
          if (string.length > 10) {
            return ICAL2.design.icalendar.value["date-time"].toICAL(string);
          } else {
            return ICAL2.design.icalendar.value.date.toICAL(string);
          }
        },
        /**
         * The string representation of this date/time, in jCal form
         * (including : and - separators).
         * @return {String}
         */
        toString: function toString() {
          var result = this.year + "-" + ICAL2.helpers.pad2(this.month) + "-" + ICAL2.helpers.pad2(this.day);
          if (!this.isDate) {
            result += "T" + ICAL2.helpers.pad2(this.hour) + ":" + ICAL2.helpers.pad2(this.minute) + ":" + ICAL2.helpers.pad2(this.second);
            if (this.zone === ICAL2.Timezone.utcTimezone) {
              result += "Z";
            }
          }
          return result;
        },
        /**
         * Converts the current instance to a Javascript date
         * @return {Date}
         */
        toJSDate: function toJSDate() {
          if (this.zone == ICAL2.Timezone.localTimezone) {
            if (this.isDate) {
              return new Date(this.year, this.month - 1, this.day);
            } else {
              return new Date(
                this.year,
                this.month - 1,
                this.day,
                this.hour,
                this.minute,
                this.second,
                0
              );
            }
          } else {
            return new Date(this.toUnixTime() * 1e3);
          }
        },
        _normalize: function icaltime_normalize() {
          var isDate2 = this._time.isDate;
          if (this._time.isDate) {
            this._time.hour = 0;
            this._time.minute = 0;
            this._time.second = 0;
          }
          this.adjust(0, 0, 0, 0);
          return this;
        },
        /**
         * Adjust the date/time by the given offset
         *
         * @param {Number} aExtraDays       The extra amount of days
         * @param {Number} aExtraHours      The extra amount of hours
         * @param {Number} aExtraMinutes    The extra amount of minutes
         * @param {Number} aExtraSeconds    The extra amount of seconds
         * @param {Number=} aTime           The time to adjust, defaults to the
         *                                    current instance.
         */
        adjust: function icaltime_adjust(aExtraDays, aExtraHours, aExtraMinutes, aExtraSeconds, aTime) {
          var minutesOverflow, hoursOverflow, daysOverflow = 0, yearsOverflow = 0;
          var second, minute, hour, day;
          var daysInMonth;
          var time = aTime || this._time;
          if (!time.isDate) {
            second = time.second + aExtraSeconds;
            time.second = second % 60;
            minutesOverflow = ICAL2.helpers.trunc(second / 60);
            if (time.second < 0) {
              time.second += 60;
              minutesOverflow--;
            }
            minute = time.minute + aExtraMinutes + minutesOverflow;
            time.minute = minute % 60;
            hoursOverflow = ICAL2.helpers.trunc(minute / 60);
            if (time.minute < 0) {
              time.minute += 60;
              hoursOverflow--;
            }
            hour = time.hour + aExtraHours + hoursOverflow;
            time.hour = hour % 24;
            daysOverflow = ICAL2.helpers.trunc(hour / 24);
            if (time.hour < 0) {
              time.hour += 24;
              daysOverflow--;
            }
          }
          if (time.month > 12) {
            yearsOverflow = ICAL2.helpers.trunc((time.month - 1) / 12);
          } else if (time.month < 1) {
            yearsOverflow = ICAL2.helpers.trunc(time.month / 12) - 1;
          }
          time.year += yearsOverflow;
          time.month -= 12 * yearsOverflow;
          day = time.day + aExtraDays + daysOverflow;
          if (day > 0) {
            for (; ; ) {
              daysInMonth = ICAL2.Time.daysInMonth(time.month, time.year);
              if (day <= daysInMonth) {
                break;
              }
              time.month++;
              if (time.month > 12) {
                time.year++;
                time.month = 1;
              }
              day -= daysInMonth;
            }
          } else {
            while (day <= 0) {
              if (time.month == 1) {
                time.year--;
                time.month = 12;
              } else {
                time.month--;
              }
              day += ICAL2.Time.daysInMonth(time.month, time.year);
            }
          }
          time.day = day;
          this._cachedUnixTime = null;
          return this;
        },
        /**
         * Sets up the current instance from unix time, the number of seconds since
         * January 1st, 1970.
         *
         * @param {Number} seconds      The seconds to set up with
         */
        fromUnixTime: function fromUnixTime(seconds) {
          this.zone = ICAL2.Timezone.utcTimezone;
          var epoch = ICAL2.Time.epochTime.clone();
          epoch.adjust(0, 0, 0, seconds);
          this.year = epoch.year;
          this.month = epoch.month;
          this.day = epoch.day;
          this.hour = epoch.hour;
          this.minute = epoch.minute;
          this.second = Math.floor(epoch.second);
          this._cachedUnixTime = null;
        },
        /**
         * Converts the current instance to seconds since January 1st 1970.
         *
         * @return {Number}         Seconds since 1970
         */
        toUnixTime: function toUnixTime() {
          if (this._cachedUnixTime !== null) {
            return this._cachedUnixTime;
          }
          var offset = this.utcOffset();
          var ms = Date.UTC(
            this.year,
            this.month - 1,
            this.day,
            this.hour,
            this.minute,
            this.second - offset
          );
          this._cachedUnixTime = ms / 1e3;
          return this._cachedUnixTime;
        },
        /**
         * Converts time to into Object which can be serialized then re-created
         * using the constructor.
         *
         * @example
         * // toJSON will automatically be called
         * var json = JSON.stringify(mytime);
         *
         * var deserialized = JSON.parse(json);
         *
         * var time = new ICAL.Time(deserialized);
         *
         * @return {Object}
         */
        toJSON: function() {
          var copy = [
            "year",
            "month",
            "day",
            "hour",
            "minute",
            "second",
            "isDate"
          ];
          var result = /* @__PURE__ */ Object.create(null);
          var i3 = 0;
          var len = copy.length;
          var prop;
          for (; i3 < len; i3++) {
            prop = copy[i3];
            result[prop] = this[prop];
          }
          if (this.zone) {
            result.timezone = this.zone.tzid;
          }
          return result;
        }
      };
      (function setupNormalizeAttributes() {
        function defineAttr(attr) {
          Object.defineProperty(ICAL2.Time.prototype, attr, {
            get: function getTimeAttr() {
              if (this._pendingNormalization) {
                this._normalize();
                this._pendingNormalization = false;
              }
              return this._time[attr];
            },
            set: function setTimeAttr(val) {
              if (attr === "isDate" && val && !this._time.isDate) {
                this.adjust(0, 0, 0, 0);
              }
              this._cachedUnixTime = null;
              this._pendingNormalization = true;
              this._time[attr] = val;
              return val;
            }
          });
        }
        if ("defineProperty" in Object) {
          defineAttr("year");
          defineAttr("month");
          defineAttr("day");
          defineAttr("hour");
          defineAttr("minute");
          defineAttr("second");
          defineAttr("isDate");
        }
      })();
      ICAL2.Time.daysInMonth = function icaltime_daysInMonth(month, year) {
        var _daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var days = 30;
        if (month < 1 || month > 12)
          return days;
        days = _daysInMonth[month];
        if (month == 2) {
          days += ICAL2.Time.isLeapYear(year);
        }
        return days;
      };
      ICAL2.Time.isLeapYear = function isLeapYear2(year) {
        if (year <= 1752) {
          return year % 4 == 0;
        } else {
          return year % 4 == 0 && year % 100 != 0 || year % 400 == 0;
        }
      };
      ICAL2.Time.fromDayOfYear = function icaltime_fromDayOfYear(aDayOfYear, aYear) {
        var year = aYear;
        var doy = aDayOfYear;
        var tt = new ICAL2.Time();
        tt.auto_normalize = false;
        var is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
        if (doy < 1) {
          year--;
          is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
          doy += ICAL2.Time.daysInYearPassedMonth[is_leap][12];
          return ICAL2.Time.fromDayOfYear(doy, year);
        } else if (doy > ICAL2.Time.daysInYearPassedMonth[is_leap][12]) {
          is_leap = ICAL2.Time.isLeapYear(year) ? 1 : 0;
          doy -= ICAL2.Time.daysInYearPassedMonth[is_leap][12];
          year++;
          return ICAL2.Time.fromDayOfYear(doy, year);
        }
        tt.year = year;
        tt.isDate = true;
        for (var month = 11; month >= 0; month--) {
          if (doy > ICAL2.Time.daysInYearPassedMonth[is_leap][month]) {
            tt.month = month + 1;
            tt.day = doy - ICAL2.Time.daysInYearPassedMonth[is_leap][month];
            break;
          }
        }
        tt.auto_normalize = true;
        return tt;
      };
      ICAL2.Time.fromStringv2 = function fromString(str) {
        return new ICAL2.Time({
          year: parseInt(str.substr(0, 4), 10),
          month: parseInt(str.substr(5, 2), 10),
          day: parseInt(str.substr(8, 2), 10),
          isDate: true
        });
      };
      ICAL2.Time.fromDateString = function(aValue) {
        return new ICAL2.Time({
          year: ICAL2.helpers.strictParseInt(aValue.substr(0, 4)),
          month: ICAL2.helpers.strictParseInt(aValue.substr(5, 2)),
          day: ICAL2.helpers.strictParseInt(aValue.substr(8, 2)),
          isDate: true
        });
      };
      ICAL2.Time.fromDateTimeString = function(aValue, prop) {
        if (aValue.length < 19) {
          throw new Error(
            'invalid date-time value: "' + aValue + '"'
          );
        }
        var zone;
        if (aValue[19] && aValue[19] === "Z") {
          zone = "Z";
        } else if (prop) {
          zone = prop.getParameter("tzid");
        }
        var time = new ICAL2.Time({
          year: ICAL2.helpers.strictParseInt(aValue.substr(0, 4)),
          month: ICAL2.helpers.strictParseInt(aValue.substr(5, 2)),
          day: ICAL2.helpers.strictParseInt(aValue.substr(8, 2)),
          hour: ICAL2.helpers.strictParseInt(aValue.substr(11, 2)),
          minute: ICAL2.helpers.strictParseInt(aValue.substr(14, 2)),
          second: ICAL2.helpers.strictParseInt(aValue.substr(17, 2)),
          timezone: zone
        });
        return time;
      };
      ICAL2.Time.fromString = function fromString(aValue, aProperty) {
        if (aValue.length > 10) {
          return ICAL2.Time.fromDateTimeString(aValue, aProperty);
        } else {
          return ICAL2.Time.fromDateString(aValue);
        }
      };
      ICAL2.Time.fromJSDate = function fromJSDate(aDate, useUTC) {
        var tt = new ICAL2.Time();
        return tt.fromJSDate(aDate, useUTC);
      };
      ICAL2.Time.fromData = function fromData(aData, aZone) {
        var t3 = new ICAL2.Time();
        return t3.fromData(aData, aZone);
      };
      ICAL2.Time.now = function icaltime_now() {
        return ICAL2.Time.fromJSDate(new Date(), false);
      };
      ICAL2.Time.weekOneStarts = function weekOneStarts(aYear, aWeekStart) {
        var t3 = ICAL2.Time.fromData({
          year: aYear,
          month: 1,
          day: 1,
          isDate: true
        });
        var dow = t3.dayOfWeek();
        var wkst = aWeekStart || ICAL2.Time.DEFAULT_WEEK_START;
        if (dow > ICAL2.Time.THURSDAY) {
          t3.day += 7;
        }
        if (wkst > ICAL2.Time.THURSDAY) {
          t3.day -= 7;
        }
        t3.day -= dow - wkst;
        return t3;
      };
      ICAL2.Time.getDominicalLetter = function(yr) {
        var LTRS = "GFEDCBA";
        var dom = (yr + (yr / 4 | 0) + (yr / 400 | 0) - (yr / 100 | 0) - 1) % 7;
        var isLeap = ICAL2.Time.isLeapYear(yr);
        if (isLeap) {
          return LTRS[(dom + 6) % 7] + LTRS[dom];
        } else {
          return LTRS[dom];
        }
      };
      ICAL2.Time.epochTime = ICAL2.Time.fromData({
        year: 1970,
        month: 1,
        day: 1,
        hour: 0,
        minute: 0,
        second: 0,
        isDate: false,
        timezone: "Z"
      });
      ICAL2.Time._cmp_attr = function _cmp_attr(a3, b3, attr) {
        if (a3[attr] > b3[attr])
          return 1;
        if (a3[attr] < b3[attr])
          return -1;
        return 0;
      };
      ICAL2.Time.daysInYearPassedMonth = [
        [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365],
        [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366]
      ];
      ICAL2.Time.SUNDAY = 1;
      ICAL2.Time.MONDAY = 2;
      ICAL2.Time.TUESDAY = 3;
      ICAL2.Time.WEDNESDAY = 4;
      ICAL2.Time.THURSDAY = 5;
      ICAL2.Time.FRIDAY = 6;
      ICAL2.Time.SATURDAY = 7;
      ICAL2.Time.DEFAULT_WEEK_START = ICAL2.Time.MONDAY;
    })();
    (function() {
      ICAL2.VCardTime = function(data, zone, icaltype) {
        this.wrappedJSObject = this;
        var time = this._time = /* @__PURE__ */ Object.create(null);
        time.year = null;
        time.month = null;
        time.day = null;
        time.hour = null;
        time.minute = null;
        time.second = null;
        this.icaltype = icaltype || "date-and-or-time";
        this.fromData(data, zone);
      };
      ICAL2.helpers.inherits(
        ICAL2.Time,
        ICAL2.VCardTime,
        /** @lends ICAL.VCardTime */
        {
          /**
           * The class identifier.
           * @constant
           * @type {String}
           * @default "vcardtime"
           */
          icalclass: "vcardtime",
          /**
           * The type name, to be used in the jCal object.
           * @type {String}
           * @default "date-and-or-time"
           */
          icaltype: "date-and-or-time",
          /**
           * The timezone. This can either be floating, UTC, or an instance of
           * ICAL.UtcOffset.
           * @type {ICAL.Timezone|ICAL.UtcOFfset}
           */
          zone: null,
          /**
           * Returns a clone of the vcard date/time object.
           *
           * @return {ICAL.VCardTime}     The cloned object
           */
          clone: function() {
            return new ICAL2.VCardTime(this._time, this.zone, this.icaltype);
          },
          _normalize: function() {
            return this;
          },
          /**
           * @inheritdoc
           */
          utcOffset: function() {
            if (this.zone instanceof ICAL2.UtcOffset) {
              return this.zone.toSeconds();
            } else {
              return ICAL2.Time.prototype.utcOffset.apply(this, arguments);
            }
          },
          /**
           * Returns an RFC 6350 compliant representation of this object.
           *
           * @return {String}         vcard date/time string
           */
          toICALString: function() {
            return ICAL2.design.vcard.value[this.icaltype].toICAL(this.toString());
          },
          /**
           * The string representation of this date/time, in jCard form
           * (including : and - separators).
           * @return {String}
           */
          toString: function toString() {
            var p22 = ICAL2.helpers.pad2;
            var y3 = this.year, m3 = this.month, d2 = this.day;
            var h3 = this.hour, mm = this.minute, s3 = this.second;
            var hasYear = y3 !== null, hasMonth = m3 !== null, hasDay = d2 !== null;
            var hasHour = h3 !== null, hasMinute = mm !== null, hasSecond = s3 !== null;
            var datepart = (hasYear ? p22(y3) + (hasMonth || hasDay ? "-" : "") : hasMonth || hasDay ? "--" : "") + (hasMonth ? p22(m3) : "") + (hasDay ? "-" + p22(d2) : "");
            var timepart = (hasHour ? p22(h3) : "-") + (hasHour && hasMinute ? ":" : "") + (hasMinute ? p22(mm) : "") + (!hasHour && !hasMinute ? "-" : "") + (hasMinute && hasSecond ? ":" : "") + (hasSecond ? p22(s3) : "");
            var zone;
            if (this.zone === ICAL2.Timezone.utcTimezone) {
              zone = "Z";
            } else if (this.zone instanceof ICAL2.UtcOffset) {
              zone = this.zone.toString();
            } else if (this.zone === ICAL2.Timezone.localTimezone) {
              zone = "";
            } else if (this.zone instanceof ICAL2.Timezone) {
              var offset = ICAL2.UtcOffset.fromSeconds(this.zone.utcOffset(this));
              zone = offset.toString();
            } else {
              zone = "";
            }
            switch (this.icaltype) {
              case "time":
                return timepart + zone;
              case "date-and-or-time":
              case "date-time":
                return datepart + (timepart == "--" ? "" : "T" + timepart + zone);
              case "date":
                return datepart;
            }
            return null;
          }
        }
      );
      ICAL2.VCardTime.fromDateAndOrTimeString = function(aValue, aIcalType) {
        function part(v3, s3, e3) {
          return v3 ? ICAL2.helpers.strictParseInt(v3.substr(s3, e3)) : null;
        }
        var parts = aValue.split("T");
        var dt = parts[0], tmz = parts[1];
        var splitzone = tmz ? ICAL2.design.vcard.value.time._splitZone(tmz) : [];
        var zone = splitzone[0], tm = splitzone[1];
        var stoi = ICAL2.helpers.strictParseInt;
        var dtlen = dt ? dt.length : 0;
        var tmlen = tm ? tm.length : 0;
        var hasDashDate = dt && dt[0] == "-" && dt[1] == "-";
        var hasDashTime = tm && tm[0] == "-";
        var o2 = {
          year: hasDashDate ? null : part(dt, 0, 4),
          month: hasDashDate && (dtlen == 4 || dtlen == 7) ? part(dt, 2, 2) : dtlen == 7 ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 5, 2) : null,
          day: dtlen == 5 ? part(dt, 3, 2) : dtlen == 7 && hasDashDate ? part(dt, 5, 2) : dtlen == 10 ? part(dt, 8, 2) : null,
          hour: hasDashTime ? null : part(tm, 0, 2),
          minute: hasDashTime && tmlen == 3 ? part(tm, 1, 2) : tmlen > 4 ? hasDashTime ? part(tm, 1, 2) : part(tm, 3, 2) : null,
          second: tmlen == 4 ? part(tm, 2, 2) : tmlen == 6 ? part(tm, 4, 2) : tmlen == 8 ? part(tm, 6, 2) : null
        };
        if (zone == "Z") {
          zone = ICAL2.Timezone.utcTimezone;
        } else if (zone && zone[3] == ":") {
          zone = ICAL2.UtcOffset.fromString(zone);
        } else {
          zone = null;
        }
        return new ICAL2.VCardTime(o2, zone, aIcalType);
      };
    })();
    (function() {
      var DOW_MAP = {
        SU: ICAL2.Time.SUNDAY,
        MO: ICAL2.Time.MONDAY,
        TU: ICAL2.Time.TUESDAY,
        WE: ICAL2.Time.WEDNESDAY,
        TH: ICAL2.Time.THURSDAY,
        FR: ICAL2.Time.FRIDAY,
        SA: ICAL2.Time.SATURDAY
      };
      var REVERSE_DOW_MAP = {};
      for (var key in DOW_MAP) {
        if (DOW_MAP.hasOwnProperty(key)) {
          REVERSE_DOW_MAP[DOW_MAP[key]] = key;
        }
      }
      var COPY_PARTS = [
        "BYSECOND",
        "BYMINUTE",
        "BYHOUR",
        "BYDAY",
        "BYMONTHDAY",
        "BYYEARDAY",
        "BYWEEKNO",
        "BYMONTH",
        "BYSETPOS"
      ];
      ICAL2.Recur = function icalrecur(data) {
        this.wrappedJSObject = this;
        this.parts = {};
        if (data && typeof data === "object") {
          this.fromData(data);
        }
      };
      ICAL2.Recur.prototype = {
        /**
         * An object holding the BY-parts of the recurrence rule
         * @type {Object}
         */
        parts: null,
        /**
         * The interval value for the recurrence rule.
         * @type {Number}
         */
        interval: 1,
        /**
         * The week start day
         *
         * @type {ICAL.Time.weekDay}
         * @default ICAL.Time.MONDAY
         */
        wkst: ICAL2.Time.MONDAY,
        /**
         * The end of the recurrence
         * @type {?ICAL.Time}
         */
        until: null,
        /**
         * The maximum number of occurrences
         * @type {?Number}
         */
        count: null,
        /**
         * The frequency value.
         * @type {ICAL.Recur.frequencyValues}
         */
        freq: null,
        /**
         * The class identifier.
         * @constant
         * @type {String}
         * @default "icalrecur"
         */
        icalclass: "icalrecur",
        /**
         * The type name, to be used in the jCal object.
         * @constant
         * @type {String}
         * @default "recur"
         */
        icaltype: "recur",
        /**
         * Create a new iterator for this recurrence rule. The passed start date
         * must be the start date of the event, not the start of the range to
         * search in.
         *
         * @example
         * var recur = comp.getFirstPropertyValue('rrule');
         * var dtstart = comp.getFirstPropertyValue('dtstart');
         * var iter = recur.iterator(dtstart);
         * for (var next = iter.next(); next; next = iter.next()) {
         *   if (next.compare(rangeStart) < 0) {
         *     continue;
         *   }
         *   console.log(next.toString());
         * }
         *
         * @param {ICAL.Time} aStart        The item's start date
         * @return {ICAL.RecurIterator}     The recurrence iterator
         */
        iterator: function(aStart) {
          return new ICAL2.RecurIterator({
            rule: this,
            dtstart: aStart
          });
        },
        /**
         * Returns a clone of the recurrence object.
         *
         * @return {ICAL.Recur}      The cloned object
         */
        clone: function clone2() {
          return new ICAL2.Recur(this.toJSON());
        },
        /**
         * Checks if the current rule is finite, i.e. has a count or until part.
         *
         * @return {Boolean}        True, if the rule is finite
         */
        isFinite: function isfinite() {
          return !!(this.count || this.until);
        },
        /**
         * Checks if the current rule has a count part, and not limited by an until
         * part.
         *
         * @return {Boolean}        True, if the rule is by count
         */
        isByCount: function isbycount() {
          return !!(this.count && !this.until);
        },
        /**
         * Adds a component (part) to the recurrence rule. This is not a component
         * in the sense of {@link ICAL.Component}, but a part of the recurrence
         * rule, i.e. BYMONTH.
         *
         * @param {String} aType            The name of the component part
         * @param {Array|String} aValue     The component value
         */
        addComponent: function addPart(aType, aValue) {
          var ucname = aType.toUpperCase();
          if (ucname in this.parts) {
            this.parts[ucname].push(aValue);
          } else {
            this.parts[ucname] = [aValue];
          }
        },
        /**
         * Sets the component value for the given by-part.
         *
         * @param {String} aType        The component part name
         * @param {Array} aValues       The component values
         */
        setComponent: function setComponent(aType, aValues) {
          this.parts[aType.toUpperCase()] = aValues.slice();
        },
        /**
         * Gets (a copy) of the requested component value.
         *
         * @param {String} aType        The component part name
         * @return {Array}              The component part value
         */
        getComponent: function getComponent(aType) {
          var ucname = aType.toUpperCase();
          return ucname in this.parts ? this.parts[ucname].slice() : [];
        },
        /**
         * Retrieves the next occurrence after the given recurrence id. See the
         * guide on {@tutorial terminology} for more details.
         *
         * NOTE: Currently, this method iterates all occurrences from the start
         * date. It should not be called in a loop for performance reasons. If you
         * would like to get more than one occurrence, you can iterate the
         * occurrences manually, see the example on the
         * {@link ICAL.Recur#iterator iterator} method.
         *
         * @param {ICAL.Time} aStartTime        The start of the event series
         * @param {ICAL.Time} aRecurrenceId     The date of the last occurrence
         * @return {ICAL.Time}                  The next occurrence after
         */
        getNextOccurrence: function getNextOccurrence(aStartTime, aRecurrenceId) {
          var iter2 = this.iterator(aStartTime);
          var next, cdt;
          do {
            next = iter2.next();
          } while (next && next.compare(aRecurrenceId) <= 0);
          if (next && aRecurrenceId.zone) {
            next.zone = aRecurrenceId.zone;
          }
          return next;
        },
        /**
         * Sets up the current instance using members from the passed data object.
         *
         * @param {Object} data                               An object with members of the recurrence
         * @param {ICAL.Recur.frequencyValues=} data.freq     The frequency value
         * @param {Number=} data.interval                     The INTERVAL value
         * @param {ICAL.Time.weekDay=} data.wkst              The week start value
         * @param {ICAL.Time=} data.until                     The end of the recurrence set
         * @param {Number=} data.count                        The number of occurrences
         * @param {Array.<Number>=} data.bysecond             The seconds for the BYSECOND part
         * @param {Array.<Number>=} data.byminute             The minutes for the BYMINUTE part
         * @param {Array.<Number>=} data.byhour               The hours for the BYHOUR part
         * @param {Array.<String>=} data.byday                The BYDAY values
         * @param {Array.<Number>=} data.bymonthday           The days for the BYMONTHDAY part
         * @param {Array.<Number>=} data.byyearday            The days for the BYYEARDAY part
         * @param {Array.<Number>=} data.byweekno             The weeks for the BYWEEKNO part
         * @param {Array.<Number>=} data.bymonth              The month for the BYMONTH part
         * @param {Array.<Number>=} data.bysetpos             The positionals for the BYSETPOS part
         */
        fromData: function(data) {
          for (var key2 in data) {
            var uckey = key2.toUpperCase();
            if (uckey in partDesign) {
              if (Array.isArray(data[key2])) {
                this.parts[uckey] = data[key2];
              } else {
                this.parts[uckey] = [data[key2]];
              }
            } else {
              this[key2] = data[key2];
            }
          }
          if (this.interval && typeof this.interval != "number") {
            optionDesign.INTERVAL(this.interval, this);
          }
          if (this.wkst && typeof this.wkst != "number") {
            this.wkst = ICAL2.Recur.icalDayToNumericDay(this.wkst);
          }
          if (this.until && !(this.until instanceof ICAL2.Time)) {
            this.until = ICAL2.Time.fromString(this.until);
          }
        },
        /**
         * The jCal representation of this recurrence type.
         * @return {Object}
         */
        toJSON: function() {
          var res = /* @__PURE__ */ Object.create(null);
          res.freq = this.freq;
          if (this.count) {
            res.count = this.count;
          }
          if (this.interval > 1) {
            res.interval = this.interval;
          }
          for (var k3 in this.parts) {
            if (!this.parts.hasOwnProperty(k3)) {
              continue;
            }
            var kparts = this.parts[k3];
            if (Array.isArray(kparts) && kparts.length == 1) {
              res[k3.toLowerCase()] = kparts[0];
            } else {
              res[k3.toLowerCase()] = ICAL2.helpers.clone(this.parts[k3]);
            }
          }
          if (this.until) {
            res.until = this.until.toString();
          }
          if ("wkst" in this && this.wkst !== ICAL2.Time.DEFAULT_WEEK_START) {
            res.wkst = ICAL2.Recur.numericDayToIcalDay(this.wkst);
          }
          return res;
        },
        /**
         * The string representation of this recurrence rule.
         * @return {String}
         */
        toString: function icalrecur_toString() {
          var str = "FREQ=" + this.freq;
          if (this.count) {
            str += ";COUNT=" + this.count;
          }
          if (this.interval > 1) {
            str += ";INTERVAL=" + this.interval;
          }
          for (var k3 in this.parts) {
            if (this.parts.hasOwnProperty(k3)) {
              str += ";" + k3 + "=" + this.parts[k3];
            }
          }
          if (this.until) {
            str += ";UNTIL=" + this.until.toICALString();
          }
          if ("wkst" in this && this.wkst !== ICAL2.Time.DEFAULT_WEEK_START) {
            str += ";WKST=" + ICAL2.Recur.numericDayToIcalDay(this.wkst);
          }
          return str;
        }
      };
      function parseNumericValue(type, min, max, value) {
        var result = value;
        if (value[0] === "+") {
          result = value.substr(1);
        }
        result = ICAL2.helpers.strictParseInt(result);
        if (min !== void 0 && value < min) {
          throw new Error(
            type + ': invalid value "' + value + '" must be > ' + min
          );
        }
        if (max !== void 0 && value > max) {
          throw new Error(
            type + ': invalid value "' + value + '" must be < ' + min
          );
        }
        return result;
      }
      ICAL2.Recur.icalDayToNumericDay = function toNumericDay(string, aWeekStart) {
        var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
        return (DOW_MAP[string] - firstDow + 7) % 7 + 1;
      };
      ICAL2.Recur.numericDayToIcalDay = function toIcalDay(num, aWeekStart) {
        var firstDow = aWeekStart || ICAL2.Time.SUNDAY;
        var dow = num + firstDow - ICAL2.Time.SUNDAY;
        if (dow > 7) {
          dow -= 7;
        }
        return REVERSE_DOW_MAP[dow];
      };
      var VALID_DAY_NAMES = /^(SU|MO|TU|WE|TH|FR|SA)$/;
      var VALID_BYDAY_PART = /^([+-])?(5[0-3]|[1-4][0-9]|[1-9])?(SU|MO|TU|WE|TH|FR|SA)$/;
      var ALLOWED_FREQ = [
        "SECONDLY",
        "MINUTELY",
        "HOURLY",
        "DAILY",
        "WEEKLY",
        "MONTHLY",
        "YEARLY"
      ];
      var optionDesign = {
        FREQ: function(value, dict, fmtIcal) {
          if (ALLOWED_FREQ.indexOf(value) !== -1) {
            dict.freq = value;
          } else {
            throw new Error(
              'invalid frequency "' + value + '" expected: "' + ALLOWED_FREQ.join(", ") + '"'
            );
          }
        },
        COUNT: function(value, dict, fmtIcal) {
          dict.count = ICAL2.helpers.strictParseInt(value);
        },
        INTERVAL: function(value, dict, fmtIcal) {
          dict.interval = ICAL2.helpers.strictParseInt(value);
          if (dict.interval < 1) {
            dict.interval = 1;
          }
        },
        UNTIL: function(value, dict, fmtIcal) {
          if (value.length > 10) {
            dict.until = ICAL2.design.icalendar.value["date-time"].fromICAL(value);
          } else {
            dict.until = ICAL2.design.icalendar.value.date.fromICAL(value);
          }
          if (!fmtIcal) {
            dict.until = ICAL2.Time.fromString(dict.until);
          }
        },
        WKST: function(value, dict, fmtIcal) {
          if (VALID_DAY_NAMES.test(value)) {
            dict.wkst = ICAL2.Recur.icalDayToNumericDay(value);
          } else {
            throw new Error('invalid WKST value "' + value + '"');
          }
        }
      };
      var partDesign = {
        BYSECOND: parseNumericValue.bind(this, "BYSECOND", 0, 60),
        BYMINUTE: parseNumericValue.bind(this, "BYMINUTE", 0, 59),
        BYHOUR: parseNumericValue.bind(this, "BYHOUR", 0, 23),
        BYDAY: function(value) {
          if (VALID_BYDAY_PART.test(value)) {
            return value;
          } else {
            throw new Error('invalid BYDAY value "' + value + '"');
          }
        },
        BYMONTHDAY: parseNumericValue.bind(this, "BYMONTHDAY", -31, 31),
        BYYEARDAY: parseNumericValue.bind(this, "BYYEARDAY", -366, 366),
        BYWEEKNO: parseNumericValue.bind(this, "BYWEEKNO", -53, 53),
        BYMONTH: parseNumericValue.bind(this, "BYMONTH", 1, 12),
        BYSETPOS: parseNumericValue.bind(this, "BYSETPOS", -366, 366)
      };
      ICAL2.Recur.fromString = function(string) {
        var data = ICAL2.Recur._stringToData(string, false);
        return new ICAL2.Recur(data);
      };
      ICAL2.Recur.fromData = function(aData) {
        return new ICAL2.Recur(aData);
      };
      ICAL2.Recur._stringToData = function(string, fmtIcal) {
        var dict = /* @__PURE__ */ Object.create(null);
        var values = string.split(";");
        var len = values.length;
        for (var i3 = 0; i3 < len; i3++) {
          var parts = values[i3].split("=");
          var ucname = parts[0].toUpperCase();
          var lcname = parts[0].toLowerCase();
          var name = fmtIcal ? lcname : ucname;
          var value = parts[1];
          if (ucname in partDesign) {
            var partArr = value.split(",");
            var partArrIdx = 0;
            var partArrLen = partArr.length;
            for (; partArrIdx < partArrLen; partArrIdx++) {
              partArr[partArrIdx] = partDesign[ucname](partArr[partArrIdx]);
            }
            dict[name] = partArr.length == 1 ? partArr[0] : partArr;
          } else if (ucname in optionDesign) {
            optionDesign[ucname](value, dict, fmtIcal);
          } else {
            dict[lcname] = value;
          }
        }
        return dict;
      };
    })();
    ICAL2.RecurIterator = function() {
      function icalrecur_iterator(options) {
        this.fromData(options);
      }
      icalrecur_iterator.prototype = {
        /**
         * True when iteration is finished.
         * @type {Boolean}
         */
        completed: false,
        /**
         * The rule that is being iterated
         * @type {ICAL.Recur}
         */
        rule: null,
        /**
         * The start date of the event being iterated.
         * @type {ICAL.Time}
         */
        dtstart: null,
        /**
         * The last occurrence that was returned from the
         * {@link ICAL.RecurIterator#next} method.
         * @type {ICAL.Time}
         */
        last: null,
        /**
         * The sequence number from the occurrence
         * @type {Number}
         */
        occurrence_number: 0,
        /**
         * The indices used for the {@link ICAL.RecurIterator#by_data} object.
         * @type {Object}
         * @private
         */
        by_indices: null,
        /**
         * If true, the iterator has already been initialized
         * @type {Boolean}
         * @private
         */
        initialized: false,
        /**
         * The initializd by-data.
         * @type {Object}
         * @private
         */
        by_data: null,
        /**
         * The expanded yeardays
         * @type {Array}
         * @private
         */
        days: null,
        /**
         * The index in the {@link ICAL.RecurIterator#days} array.
         * @type {Number}
         * @private
         */
        days_index: 0,
        /**
         * Initialize the recurrence iterator from the passed data object. This
         * method is usually not called directly, you can initialize the iterator
         * through the constructor.
         *
         * @param {Object} options                The iterator options
         * @param {ICAL.Recur} options.rule       The rule to iterate.
         * @param {ICAL.Time} options.dtstart     The start date of the event.
         * @param {Boolean=} options.initialized  When true, assume that options are
         *        from a previously constructed iterator. Initialization will not be
         *        repeated.
         */
        fromData: function(options) {
          this.rule = ICAL2.helpers.formatClassType(options.rule, ICAL2.Recur);
          if (!this.rule) {
            throw new Error("iterator requires a (ICAL.Recur) rule");
          }
          this.dtstart = ICAL2.helpers.formatClassType(options.dtstart, ICAL2.Time);
          if (!this.dtstart) {
            throw new Error("iterator requires a (ICAL.Time) dtstart");
          }
          if (options.by_data) {
            this.by_data = options.by_data;
          } else {
            this.by_data = ICAL2.helpers.clone(this.rule.parts, true);
          }
          if (options.occurrence_number)
            this.occurrence_number = options.occurrence_number;
          this.days = options.days || [];
          if (options.last) {
            this.last = ICAL2.helpers.formatClassType(options.last, ICAL2.Time);
          }
          this.by_indices = options.by_indices;
          if (!this.by_indices) {
            this.by_indices = {
              "BYSECOND": 0,
              "BYMINUTE": 0,
              "BYHOUR": 0,
              "BYDAY": 0,
              "BYMONTH": 0,
              "BYWEEKNO": 0,
              "BYMONTHDAY": 0
            };
          }
          this.initialized = options.initialized || false;
          if (!this.initialized) {
            this.init();
          }
        },
        /**
         * Intialize the iterator
         * @private
         */
        init: function icalrecur_iterator_init() {
          this.initialized = true;
          this.last = this.dtstart.clone();
          var parts = this.by_data;
          if ("BYDAY" in parts) {
            this.sort_byday_rules(parts.BYDAY);
          }
          if ("BYYEARDAY" in parts) {
            if ("BYMONTH" in parts || "BYWEEKNO" in parts || "BYMONTHDAY" in parts || "BYDAY" in parts) {
              throw new Error("Invalid BYYEARDAY rule");
            }
          }
          if ("BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
            throw new Error("BYWEEKNO does not fit to BYMONTHDAY");
          }
          if (this.rule.freq == "MONTHLY" && ("BYYEARDAY" in parts || "BYWEEKNO" in parts)) {
            throw new Error("For MONTHLY recurrences neither BYYEARDAY nor BYWEEKNO may appear");
          }
          if (this.rule.freq == "WEEKLY" && ("BYYEARDAY" in parts || "BYMONTHDAY" in parts)) {
            throw new Error("For WEEKLY recurrences neither BYMONTHDAY nor BYYEARDAY may appear");
          }
          if (this.rule.freq != "YEARLY" && "BYYEARDAY" in parts) {
            throw new Error("BYYEARDAY may only appear in YEARLY rules");
          }
          this.last.second = this.setup_defaults("BYSECOND", "SECONDLY", this.dtstart.second);
          this.last.minute = this.setup_defaults("BYMINUTE", "MINUTELY", this.dtstart.minute);
          this.last.hour = this.setup_defaults("BYHOUR", "HOURLY", this.dtstart.hour);
          this.last.day = this.setup_defaults("BYMONTHDAY", "DAILY", this.dtstart.day);
          this.last.month = this.setup_defaults("BYMONTH", "MONTHLY", this.dtstart.month);
          if (this.rule.freq == "WEEKLY") {
            if ("BYDAY" in parts) {
              var bydayParts = this.ruleDayOfWeek(parts.BYDAY[0], this.rule.wkst);
              var pos = bydayParts[0];
              var dow = bydayParts[1];
              var wkdy = dow - this.last.dayOfWeek(this.rule.wkst);
              if (this.last.dayOfWeek(this.rule.wkst) < dow && wkdy >= 0 || wkdy < 0) {
                this.last.day += wkdy;
              }
            } else {
              var dayName = ICAL2.Recur.numericDayToIcalDay(this.dtstart.dayOfWeek());
              parts.BYDAY = [dayName];
            }
          }
          if (this.rule.freq == "YEARLY") {
            for (; ; ) {
              this.expand_year_days(this.last.year);
              if (this.days.length > 0) {
                break;
              }
              this.increment_year(this.rule.interval);
            }
            this._nextByYearDay();
          }
          if (this.rule.freq == "MONTHLY" && this.has_by_data("BYDAY")) {
            var tempLast = null;
            var initLast = this.last.clone();
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            for (var i3 in this.by_data.BYDAY) {
              if (!this.by_data.BYDAY.hasOwnProperty(i3)) {
                continue;
              }
              this.last = initLast.clone();
              var bydayParts = this.ruleDayOfWeek(this.by_data.BYDAY[i3]);
              var pos = bydayParts[0];
              var dow = bydayParts[1];
              var dayOfMonth = this.last.nthWeekDay(dow, pos);
              if (pos >= 6 || pos <= -6) {
                throw new Error("Malformed values in BYDAY part");
              }
              if (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                if (tempLast && tempLast.month == initLast.month) {
                  continue;
                }
                while (dayOfMonth > daysInMonth || dayOfMonth <= 0) {
                  this.increment_month();
                  daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
                  dayOfMonth = this.last.nthWeekDay(dow, pos);
                }
              }
              this.last.day = dayOfMonth;
              if (!tempLast || this.last.compare(tempLast) < 0) {
                tempLast = this.last.clone();
              }
            }
            this.last = tempLast.clone();
            if (this.has_by_data("BYMONTHDAY")) {
              this._byDayAndMonthDay(true);
            }
            if (this.last.day > daysInMonth || this.last.day == 0) {
              throw new Error("Malformed values in BYDAY part");
            }
          } else if (this.has_by_data("BYMONTHDAY")) {
            if (this.last.day < 0) {
              var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
              this.last.day = daysInMonth + this.last.day + 1;
            }
          }
        },
        /**
         * Retrieve the next occurrence from the iterator.
         * @return {ICAL.Time}
         */
        next: function icalrecur_iterator_next() {
          var before = this.last ? this.last.clone() : null;
          if (this.rule.count && this.occurrence_number >= this.rule.count || this.rule.until && this.last.compare(this.rule.until) > 0) {
            this.completed = true;
            return null;
          }
          if (this.occurrence_number == 0 && this.last.compare(this.dtstart) >= 0) {
            this.occurrence_number++;
            return this.last;
          }
          var valid;
          do {
            valid = 1;
            switch (this.rule.freq) {
              case "SECONDLY":
                this.next_second();
                break;
              case "MINUTELY":
                this.next_minute();
                break;
              case "HOURLY":
                this.next_hour();
                break;
              case "DAILY":
                this.next_day();
                break;
              case "WEEKLY":
                this.next_week();
                break;
              case "MONTHLY":
                valid = this.next_month();
                break;
              case "YEARLY":
                this.next_year();
                break;
              default:
                return null;
            }
          } while (!this.check_contracting_rules() || this.last.compare(this.dtstart) < 0 || !valid);
          if (this.last.compare(before) == 0) {
            throw new Error("Same occurrence found twice, protecting you from death by recursion");
          }
          if (this.rule.until && this.last.compare(this.rule.until) > 0) {
            this.completed = true;
            return null;
          } else {
            this.occurrence_number++;
            return this.last;
          }
        },
        next_second: function next_second() {
          return this.next_generic("BYSECOND", "SECONDLY", "second", "minute");
        },
        increment_second: function increment_second(inc) {
          return this.increment_generic(inc, "second", 60, "minute");
        },
        next_minute: function next_minute() {
          return this.next_generic(
            "BYMINUTE",
            "MINUTELY",
            "minute",
            "hour",
            "next_second"
          );
        },
        increment_minute: function increment_minute(inc) {
          return this.increment_generic(inc, "minute", 60, "hour");
        },
        next_hour: function next_hour() {
          return this.next_generic(
            "BYHOUR",
            "HOURLY",
            "hour",
            "monthday",
            "next_minute"
          );
        },
        increment_hour: function increment_hour(inc) {
          this.increment_generic(inc, "hour", 24, "monthday");
        },
        next_day: function next_day() {
          var has_by_day = "BYDAY" in this.by_data;
          var this_freq = this.rule.freq == "DAILY";
          if (this.next_hour() == 0) {
            return 0;
          }
          if (this_freq) {
            this.increment_monthday(this.rule.interval);
          } else {
            this.increment_monthday(1);
          }
          return 0;
        },
        next_week: function next_week() {
          var end_of_data = 0;
          if (this.next_weekday_by_week() == 0) {
            return end_of_data;
          }
          if (this.has_by_data("BYWEEKNO")) {
            var idx = ++this.by_indices.BYWEEKNO;
            if (this.by_indices.BYWEEKNO == this.by_data.BYWEEKNO.length) {
              this.by_indices.BYWEEKNO = 0;
              end_of_data = 1;
            }
            this.last.month = 1;
            this.last.day = 1;
            var week_no = this.by_data.BYWEEKNO[this.by_indices.BYWEEKNO];
            this.last.day += 7 * week_no;
            if (end_of_data) {
              this.increment_year(1);
            }
          } else {
            this.increment_monthday(7 * this.rule.interval);
          }
          return end_of_data;
        },
        /**
         * Normalize each by day rule for a given year/month.
         * Takes into account ordering and negative rules
         *
         * @private
         * @param {Number} year         Current year.
         * @param {Number} month        Current month.
         * @param {Array}  rules        Array of rules.
         *
         * @return {Array} sorted and normalized rules.
         *                 Negative rules will be expanded to their
         *                 correct positive values for easier processing.
         */
        normalizeByMonthDayRules: function(year, month, rules) {
          var daysInMonth = ICAL2.Time.daysInMonth(month, year);
          var newRules = [];
          var ruleIdx = 0;
          var len = rules.length;
          var rule;
          for (; ruleIdx < len; ruleIdx++) {
            rule = rules[ruleIdx];
            if (Math.abs(rule) > daysInMonth) {
              continue;
            }
            if (rule < 0) {
              rule = daysInMonth + (rule + 1);
            } else if (rule === 0) {
              continue;
            }
            if (newRules.indexOf(rule) === -1) {
              newRules.push(rule);
            }
          }
          return newRules.sort(function(a3, b3) {
            return a3 - b3;
          });
        },
        /**
         * NOTES:
         * We are given a list of dates in the month (BYMONTHDAY) (23, etc..)
         * Also we are given a list of days (BYDAY) (MO, 2SU, etc..) when
         * both conditions match a given date (this.last.day) iteration stops.
         *
         * @private
         * @param {Boolean=} isInit     When given true will not increment the
         *                                current day (this.last).
         */
        _byDayAndMonthDay: function(isInit) {
          var byMonthDay;
          var byDay = this.by_data.BYDAY;
          var date;
          var dateIdx = 0;
          var dateLen;
          var dayLen = byDay.length;
          var dataIsValid = 0;
          var daysInMonth;
          var self2 = this;
          var lastDay = this.last.day;
          function initMonth() {
            daysInMonth = ICAL2.Time.daysInMonth(
              self2.last.month,
              self2.last.year
            );
            byMonthDay = self2.normalizeByMonthDayRules(
              self2.last.year,
              self2.last.month,
              self2.by_data.BYMONTHDAY
            );
            dateLen = byMonthDay.length;
            while (byMonthDay[dateIdx] <= lastDay && !(isInit && byMonthDay[dateIdx] == lastDay) && dateIdx < dateLen - 1) {
              dateIdx++;
            }
          }
          function nextMonth() {
            lastDay = 0;
            self2.increment_month();
            dateIdx = 0;
            initMonth();
          }
          initMonth();
          if (isInit) {
            lastDay -= 1;
          }
          var monthsCounter = 48;
          while (!dataIsValid && monthsCounter) {
            monthsCounter--;
            date = lastDay + 1;
            if (date > daysInMonth) {
              nextMonth();
              continue;
            }
            var next = byMonthDay[dateIdx++];
            if (next >= date) {
              lastDay = next;
            } else {
              nextMonth();
              continue;
            }
            for (var dayIdx = 0; dayIdx < dayLen; dayIdx++) {
              var parts = this.ruleDayOfWeek(byDay[dayIdx]);
              var pos = parts[0];
              var dow = parts[1];
              this.last.day = lastDay;
              if (this.last.isNthWeekDay(dow, pos)) {
                dataIsValid = 1;
                break;
              }
            }
            if (!dataIsValid && dateIdx === dateLen) {
              nextMonth();
              continue;
            }
          }
          if (monthsCounter <= 0) {
            throw new Error("Malformed values in BYDAY combined with BYMONTHDAY parts");
          }
          return dataIsValid;
        },
        next_month: function next_month() {
          var this_freq = this.rule.freq == "MONTHLY";
          var data_valid = 1;
          if (this.next_hour() == 0) {
            return data_valid;
          }
          if (this.has_by_data("BYDAY") && this.has_by_data("BYMONTHDAY")) {
            data_valid = this._byDayAndMonthDay();
          } else if (this.has_by_data("BYDAY")) {
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            var setpos = 0;
            var setpos_total = 0;
            if (this.has_by_data("BYSETPOS")) {
              var last_day = this.last.day;
              for (var day = 1; day <= daysInMonth; day++) {
                this.last.day = day;
                if (this.is_day_in_byday(this.last)) {
                  setpos_total++;
                  if (day <= last_day) {
                    setpos++;
                  }
                }
              }
              this.last.day = last_day;
            }
            data_valid = 0;
            for (var day = this.last.day + 1; day <= daysInMonth; day++) {
              this.last.day = day;
              if (this.is_day_in_byday(this.last)) {
                if (!this.has_by_data("BYSETPOS") || this.check_set_position(++setpos) || this.check_set_position(setpos - setpos_total - 1)) {
                  data_valid = 1;
                  break;
                }
              }
            }
            if (day > daysInMonth) {
              this.last.day = 1;
              this.increment_month();
              if (this.is_day_in_byday(this.last)) {
                if (!this.has_by_data("BYSETPOS") || this.check_set_position(1)) {
                  data_valid = 1;
                }
              } else {
                data_valid = 0;
              }
            }
          } else if (this.has_by_data("BYMONTHDAY")) {
            this.by_indices.BYMONTHDAY++;
            if (this.by_indices.BYMONTHDAY >= this.by_data.BYMONTHDAY.length) {
              this.by_indices.BYMONTHDAY = 0;
              this.increment_month();
            }
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            var day = this.by_data.BYMONTHDAY[this.by_indices.BYMONTHDAY];
            if (day < 0) {
              day = daysInMonth + day + 1;
            }
            if (day > daysInMonth) {
              this.last.day = 1;
              data_valid = this.is_day_in_byday(this.last);
            } else {
              this.last.day = day;
            }
          } else {
            this.increment_month();
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            if (this.by_data.BYMONTHDAY[0] > daysInMonth) {
              data_valid = 0;
            } else {
              this.last.day = this.by_data.BYMONTHDAY[0];
            }
          }
          return data_valid;
        },
        next_weekday_by_week: function next_weekday_by_week() {
          var end_of_data = 0;
          if (this.next_hour() == 0) {
            return end_of_data;
          }
          if (!this.has_by_data("BYDAY")) {
            return 1;
          }
          for (; ; ) {
            var tt = new ICAL2.Time();
            this.by_indices.BYDAY++;
            if (this.by_indices.BYDAY == Object.keys(this.by_data.BYDAY).length) {
              this.by_indices.BYDAY = 0;
              end_of_data = 1;
            }
            var coded_day = this.by_data.BYDAY[this.by_indices.BYDAY];
            var parts = this.ruleDayOfWeek(coded_day);
            var dow = parts[1];
            dow -= this.rule.wkst;
            if (dow < 0) {
              dow += 7;
            }
            tt.year = this.last.year;
            tt.month = this.last.month;
            tt.day = this.last.day;
            var startOfWeek = tt.startDoyWeek(this.rule.wkst);
            if (dow + startOfWeek < 1) {
              if (!end_of_data) {
                continue;
              }
            }
            var next = ICAL2.Time.fromDayOfYear(
              startOfWeek + dow,
              this.last.year
            );
            this.last.year = next.year;
            this.last.month = next.month;
            this.last.day = next.day;
            return end_of_data;
          }
        },
        next_year: function next_year() {
          if (this.next_hour() == 0) {
            return 0;
          }
          if (++this.days_index == this.days.length) {
            this.days_index = 0;
            do {
              this.increment_year(this.rule.interval);
              this.expand_year_days(this.last.year);
            } while (this.days.length == 0);
          }
          this._nextByYearDay();
          return 1;
        },
        _nextByYearDay: function _nextByYearDay() {
          var doy = this.days[this.days_index];
          var year = this.last.year;
          if (doy < 1) {
            doy += 1;
            year += 1;
          }
          var next = ICAL2.Time.fromDayOfYear(doy, year);
          this.last.day = next.day;
          this.last.month = next.month;
        },
        /**
         * @param dow (eg: '1TU', '-1MO')
         * @param {ICAL.Time.weekDay=} aWeekStart The week start weekday
         * @return [pos, numericDow] (eg: [1, 3]) numericDow is relative to aWeekStart
         */
        ruleDayOfWeek: function ruleDayOfWeek(dow, aWeekStart) {
          var matches = dow.match(/([+-]?[0-9])?(MO|TU|WE|TH|FR|SA|SU)/);
          if (matches) {
            var pos = parseInt(matches[1] || 0, 10);
            dow = ICAL2.Recur.icalDayToNumericDay(matches[2], aWeekStart);
            return [pos, dow];
          } else {
            return [0, 0];
          }
        },
        next_generic: function next_generic(aRuleType, aInterval, aDateAttr, aFollowingAttr, aPreviousIncr) {
          var has_by_rule = aRuleType in this.by_data;
          var this_freq = this.rule.freq == aInterval;
          var end_of_data = 0;
          if (aPreviousIncr && this[aPreviousIncr]() == 0) {
            return end_of_data;
          }
          if (has_by_rule) {
            this.by_indices[aRuleType]++;
            var idx = this.by_indices[aRuleType];
            var dta = this.by_data[aRuleType];
            if (this.by_indices[aRuleType] == dta.length) {
              this.by_indices[aRuleType] = 0;
              end_of_data = 1;
            }
            this.last[aDateAttr] = dta[this.by_indices[aRuleType]];
          } else if (this_freq) {
            this["increment_" + aDateAttr](this.rule.interval);
          }
          if (has_by_rule && end_of_data && this_freq) {
            this["increment_" + aFollowingAttr](1);
          }
          return end_of_data;
        },
        increment_monthday: function increment_monthday(inc) {
          for (var i3 = 0; i3 < inc; i3++) {
            var daysInMonth = ICAL2.Time.daysInMonth(this.last.month, this.last.year);
            this.last.day++;
            if (this.last.day > daysInMonth) {
              this.last.day -= daysInMonth;
              this.increment_month();
            }
          }
        },
        increment_month: function increment_month() {
          this.last.day = 1;
          if (this.has_by_data("BYMONTH")) {
            this.by_indices.BYMONTH++;
            if (this.by_indices.BYMONTH == this.by_data.BYMONTH.length) {
              this.by_indices.BYMONTH = 0;
              this.increment_year(1);
            }
            this.last.month = this.by_data.BYMONTH[this.by_indices.BYMONTH];
          } else {
            if (this.rule.freq == "MONTHLY") {
              this.last.month += this.rule.interval;
            } else {
              this.last.month++;
            }
            this.last.month--;
            var years = ICAL2.helpers.trunc(this.last.month / 12);
            this.last.month %= 12;
            this.last.month++;
            if (years != 0) {
              this.increment_year(years);
            }
          }
        },
        increment_year: function increment_year(inc) {
          this.last.year += inc;
        },
        increment_generic: function increment_generic(inc, aDateAttr, aFactor, aNextIncrement) {
          this.last[aDateAttr] += inc;
          var nextunit = ICAL2.helpers.trunc(this.last[aDateAttr] / aFactor);
          this.last[aDateAttr] %= aFactor;
          if (nextunit != 0) {
            this["increment_" + aNextIncrement](nextunit);
          }
        },
        has_by_data: function has_by_data(aRuleType) {
          return aRuleType in this.rule.parts;
        },
        expand_year_days: function expand_year_days(aYear) {
          var t3 = new ICAL2.Time();
          this.days = [];
          var parts = {};
          var rules = ["BYDAY", "BYWEEKNO", "BYMONTHDAY", "BYMONTH", "BYYEARDAY"];
          for (var p3 in rules) {
            if (rules.hasOwnProperty(p3)) {
              var part = rules[p3];
              if (part in this.rule.parts) {
                parts[part] = this.rule.parts[part];
              }
            }
          }
          if ("BYMONTH" in parts && "BYWEEKNO" in parts) {
            var valid = 1;
            var validWeeks = {};
            t3.year = aYear;
            t3.isDate = true;
            for (var monthIdx = 0; monthIdx < this.by_data.BYMONTH.length; monthIdx++) {
              var month = this.by_data.BYMONTH[monthIdx];
              t3.month = month;
              t3.day = 1;
              var first_week = t3.weekNumber(this.rule.wkst);
              t3.day = ICAL2.Time.daysInMonth(month, aYear);
              var last_week = t3.weekNumber(this.rule.wkst);
              for (monthIdx = first_week; monthIdx < last_week; monthIdx++) {
                validWeeks[monthIdx] = 1;
              }
            }
            for (var weekIdx = 0; weekIdx < this.by_data.BYWEEKNO.length && valid; weekIdx++) {
              var weekno = this.by_data.BYWEEKNO[weekIdx];
              if (weekno < 52) {
                valid &= validWeeks[weekIdx];
              } else {
                valid = 0;
              }
            }
            if (valid) {
              delete parts.BYMONTH;
            } else {
              delete parts.BYWEEKNO;
            }
          }
          var partCount = Object.keys(parts).length;
          if (partCount == 0) {
            var t1 = this.dtstart.clone();
            t1.year = this.last.year;
            this.days.push(t1.dayOfYear());
          } else if (partCount == 1 && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var t22 = this.dtstart.clone();
              t22.year = aYear;
              t22.month = this.by_data.BYMONTH[monthkey];
              t22.isDate = true;
              this.days.push(t22.dayOfYear());
            }
          } else if (partCount == 1 && "BYMONTHDAY" in parts) {
            for (var monthdaykey in this.by_data.BYMONTHDAY) {
              if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                continue;
              }
              var t32 = this.dtstart.clone();
              var day_ = this.by_data.BYMONTHDAY[monthdaykey];
              if (day_ < 0) {
                var daysInMonth = ICAL2.Time.daysInMonth(t32.month, aYear);
                day_ = day_ + daysInMonth + 1;
              }
              t32.day = day_;
              t32.year = aYear;
              t32.isDate = true;
              this.days.push(t32.dayOfYear());
            }
          } else if (partCount == 2 && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var month_ = this.by_data.BYMONTH[monthkey];
              var daysInMonth = ICAL2.Time.daysInMonth(month_, aYear);
              for (var monthdaykey in this.by_data.BYMONTHDAY) {
                if (!this.by_data.BYMONTHDAY.hasOwnProperty(monthdaykey)) {
                  continue;
                }
                var day_ = this.by_data.BYMONTHDAY[monthdaykey];
                if (day_ < 0) {
                  day_ = day_ + daysInMonth + 1;
                }
                t3.day = day_;
                t3.month = month_;
                t3.year = aYear;
                t3.isDate = true;
                this.days.push(t3.dayOfYear());
              }
            }
          } else if (partCount == 1 && "BYWEEKNO" in parts) {
          } else if (partCount == 2 && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
          } else if (partCount == 1 && "BYDAY" in parts) {
            this.days = this.days.concat(this.expand_by_day(aYear));
          } else if (partCount == 2 && "BYDAY" in parts && "BYMONTH" in parts) {
            for (var monthkey in this.by_data.BYMONTH) {
              if (!this.by_data.BYMONTH.hasOwnProperty(monthkey)) {
                continue;
              }
              var month = this.by_data.BYMONTH[monthkey];
              var daysInMonth = ICAL2.Time.daysInMonth(month, aYear);
              t3.year = aYear;
              t3.month = this.by_data.BYMONTH[monthkey];
              t3.day = 1;
              t3.isDate = true;
              var first_dow = t3.dayOfWeek();
              var doy_offset = t3.dayOfYear() - 1;
              t3.day = daysInMonth;
              var last_dow = t3.dayOfWeek();
              if (this.has_by_data("BYSETPOS")) {
                var set_pos_counter = 0;
                var by_month_day = [];
                for (var day = 1; day <= daysInMonth; day++) {
                  t3.day = day;
                  if (this.is_day_in_byday(t3)) {
                    by_month_day.push(day);
                  }
                }
                for (var spIndex = 0; spIndex < by_month_day.length; spIndex++) {
                  if (this.check_set_position(spIndex + 1) || this.check_set_position(spIndex - by_month_day.length)) {
                    this.days.push(doy_offset + by_month_day[spIndex]);
                  }
                }
              } else {
                for (var daycodedkey in this.by_data.BYDAY) {
                  if (!this.by_data.BYDAY.hasOwnProperty(daycodedkey)) {
                    continue;
                  }
                  var coded_day = this.by_data.BYDAY[daycodedkey];
                  var bydayParts = this.ruleDayOfWeek(coded_day);
                  var pos = bydayParts[0];
                  var dow = bydayParts[1];
                  var month_day;
                  var first_matching_day = (dow + 7 - first_dow) % 7 + 1;
                  var last_matching_day = daysInMonth - (last_dow + 7 - dow) % 7;
                  if (pos == 0) {
                    for (var day = first_matching_day; day <= daysInMonth; day += 7) {
                      this.days.push(doy_offset + day);
                    }
                  } else if (pos > 0) {
                    month_day = first_matching_day + (pos - 1) * 7;
                    if (month_day <= daysInMonth) {
                      this.days.push(doy_offset + month_day);
                    }
                  } else {
                    month_day = last_matching_day + (pos + 1) * 7;
                    if (month_day > 0) {
                      this.days.push(doy_offset + month_day);
                    }
                  }
                }
              }
            }
            this.days.sort(function(a3, b3) {
              return a3 - b3;
            });
          } else if (partCount == 2 && "BYDAY" in parts && "BYMONTHDAY" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              if (this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                this.days.push(day);
              }
            }
          } else if (partCount == 3 && "BYDAY" in parts && "BYMONTHDAY" in parts && "BYMONTH" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              if (this.by_data.BYMONTH.indexOf(tt.month) >= 0 && this.by_data.BYMONTHDAY.indexOf(tt.day) >= 0) {
                this.days.push(day);
              }
            }
          } else if (partCount == 2 && "BYDAY" in parts && "BYWEEKNO" in parts) {
            var expandedDays = this.expand_by_day(aYear);
            for (var daykey in expandedDays) {
              if (!expandedDays.hasOwnProperty(daykey)) {
                continue;
              }
              var day = expandedDays[daykey];
              var tt = ICAL2.Time.fromDayOfYear(day, aYear);
              var weekno = tt.weekNumber(this.rule.wkst);
              if (this.by_data.BYWEEKNO.indexOf(weekno)) {
                this.days.push(day);
              }
            }
          } else if (partCount == 3 && "BYDAY" in parts && "BYWEEKNO" in parts && "BYMONTHDAY" in parts) {
          } else if (partCount == 1 && "BYYEARDAY" in parts) {
            this.days = this.days.concat(this.by_data.BYYEARDAY);
          } else {
            this.days = [];
          }
          return 0;
        },
        expand_by_day: function expand_by_day(aYear) {
          var days_list = [];
          var tmp = this.last.clone();
          tmp.year = aYear;
          tmp.month = 1;
          tmp.day = 1;
          tmp.isDate = true;
          var start_dow = tmp.dayOfWeek();
          tmp.month = 12;
          tmp.day = 31;
          tmp.isDate = true;
          var end_dow = tmp.dayOfWeek();
          var end_year_day = tmp.dayOfYear();
          for (var daykey in this.by_data.BYDAY) {
            if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
              continue;
            }
            var day = this.by_data.BYDAY[daykey];
            var parts = this.ruleDayOfWeek(day);
            var pos = parts[0];
            var dow = parts[1];
            if (pos == 0) {
              var tmp_start_doy = (dow + 7 - start_dow) % 7 + 1;
              for (var doy = tmp_start_doy; doy <= end_year_day; doy += 7) {
                days_list.push(doy);
              }
            } else if (pos > 0) {
              var first;
              if (dow >= start_dow) {
                first = dow - start_dow + 1;
              } else {
                first = dow - start_dow + 8;
              }
              days_list.push(first + (pos - 1) * 7);
            } else {
              var last;
              pos = -pos;
              if (dow <= end_dow) {
                last = end_year_day - end_dow + dow;
              } else {
                last = end_year_day - end_dow + dow - 7;
              }
              days_list.push(last - (pos - 1) * 7);
            }
          }
          return days_list;
        },
        is_day_in_byday: function is_day_in_byday(tt) {
          for (var daykey in this.by_data.BYDAY) {
            if (!this.by_data.BYDAY.hasOwnProperty(daykey)) {
              continue;
            }
            var day = this.by_data.BYDAY[daykey];
            var parts = this.ruleDayOfWeek(day);
            var pos = parts[0];
            var dow = parts[1];
            var this_dow = tt.dayOfWeek();
            if (pos == 0 && dow == this_dow || tt.nthWeekDay(dow, pos) == tt.day) {
              return 1;
            }
          }
          return 0;
        },
        /**
         * Checks if given value is in BYSETPOS.
         *
         * @private
         * @param {Numeric} aPos position to check for.
         * @return {Boolean} false unless BYSETPOS rules exist
         *                   and the given value is present in rules.
         */
        check_set_position: function check_set_position(aPos) {
          if (this.has_by_data("BYSETPOS")) {
            var idx = this.by_data.BYSETPOS.indexOf(aPos);
            return idx !== -1;
          }
          return false;
        },
        sort_byday_rules: function icalrecur_sort_byday_rules(aRules) {
          for (var i3 = 0; i3 < aRules.length; i3++) {
            for (var j4 = 0; j4 < i3; j4++) {
              var one = this.ruleDayOfWeek(aRules[j4], this.rule.wkst)[1];
              var two = this.ruleDayOfWeek(aRules[i3], this.rule.wkst)[1];
              if (one > two) {
                var tmp = aRules[i3];
                aRules[i3] = aRules[j4];
                aRules[j4] = tmp;
              }
            }
          }
        },
        check_contract_restriction: function check_contract_restriction(aRuleType, v3) {
          var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
          var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
          var pass = false;
          if (aRuleType in this.by_data && ruleMapValue == icalrecur_iterator.CONTRACT) {
            var ruleType = this.by_data[aRuleType];
            for (var bydatakey in ruleType) {
              if (ruleType.hasOwnProperty(bydatakey)) {
                if (ruleType[bydatakey] == v3) {
                  pass = true;
                  break;
                }
              }
            }
          } else {
            pass = true;
          }
          return pass;
        },
        check_contracting_rules: function check_contracting_rules() {
          var dow = this.last.dayOfWeek();
          var weekNo = this.last.weekNumber(this.rule.wkst);
          var doy = this.last.dayOfYear();
          return this.check_contract_restriction("BYSECOND", this.last.second) && this.check_contract_restriction("BYMINUTE", this.last.minute) && this.check_contract_restriction("BYHOUR", this.last.hour) && this.check_contract_restriction("BYDAY", ICAL2.Recur.numericDayToIcalDay(dow)) && this.check_contract_restriction("BYWEEKNO", weekNo) && this.check_contract_restriction("BYMONTHDAY", this.last.day) && this.check_contract_restriction("BYMONTH", this.last.month) && this.check_contract_restriction("BYYEARDAY", doy);
        },
        setup_defaults: function setup_defaults(aRuleType, req, deftime) {
          var indexMapValue = icalrecur_iterator._indexMap[aRuleType];
          var ruleMapValue = icalrecur_iterator._expandMap[this.rule.freq][indexMapValue];
          if (ruleMapValue != icalrecur_iterator.CONTRACT) {
            if (!(aRuleType in this.by_data)) {
              this.by_data[aRuleType] = [deftime];
            }
            if (this.rule.freq != req) {
              return this.by_data[aRuleType][0];
            }
          }
          return deftime;
        },
        /**
         * Convert iterator into a serialize-able object.  Will preserve current
         * iteration sequence to ensure the seamless continuation of the recurrence
         * rule.
         * @return {Object}
         */
        toJSON: function() {
          var result = /* @__PURE__ */ Object.create(null);
          result.initialized = this.initialized;
          result.rule = this.rule.toJSON();
          result.dtstart = this.dtstart.toJSON();
          result.by_data = this.by_data;
          result.days = this.days;
          result.last = this.last.toJSON();
          result.by_indices = this.by_indices;
          result.occurrence_number = this.occurrence_number;
          return result;
        }
      };
      icalrecur_iterator._indexMap = {
        "BYSECOND": 0,
        "BYMINUTE": 1,
        "BYHOUR": 2,
        "BYDAY": 3,
        "BYMONTHDAY": 4,
        "BYYEARDAY": 5,
        "BYWEEKNO": 6,
        "BYMONTH": 7,
        "BYSETPOS": 8
      };
      icalrecur_iterator._expandMap = {
        "SECONDLY": [1, 1, 1, 1, 1, 1, 1, 1],
        "MINUTELY": [2, 1, 1, 1, 1, 1, 1, 1],
        "HOURLY": [2, 2, 1, 1, 1, 1, 1, 1],
        "DAILY": [2, 2, 2, 1, 1, 1, 1, 1],
        "WEEKLY": [2, 2, 2, 2, 3, 3, 1, 1],
        "MONTHLY": [2, 2, 2, 2, 2, 3, 3, 1],
        "YEARLY": [2, 2, 2, 2, 2, 2, 2, 2]
      };
      icalrecur_iterator.UNKNOWN = 0;
      icalrecur_iterator.CONTRACT = 1;
      icalrecur_iterator.EXPAND = 2;
      icalrecur_iterator.ILLEGAL = 3;
      return icalrecur_iterator;
    }();
    ICAL2.RecurExpansion = function() {
      function formatTime(item) {
        return ICAL2.helpers.formatClassType(item, ICAL2.Time);
      }
      function compareTime(a3, b3) {
        return a3.compare(b3);
      }
      function isRecurringComponent(comp) {
        return comp.hasProperty("rdate") || comp.hasProperty("rrule") || comp.hasProperty("recurrence-id");
      }
      function RecurExpansion(options) {
        this.ruleDates = [];
        this.exDates = [];
        this.fromData(options);
      }
      RecurExpansion.prototype = {
        /**
         * True when iteration is fully completed.
         * @type {Boolean}
         */
        complete: false,
        /**
         * Array of rrule iterators.
         *
         * @type {ICAL.RecurIterator[]}
         * @private
         */
        ruleIterators: null,
        /**
         * Array of rdate instances.
         *
         * @type {ICAL.Time[]}
         * @private
         */
        ruleDates: null,
        /**
         * Array of exdate instances.
         *
         * @type {ICAL.Time[]}
         * @private
         */
        exDates: null,
        /**
         * Current position in ruleDates array.
         * @type {Number}
         * @private
         */
        ruleDateInc: 0,
        /**
         * Current position in exDates array
         * @type {Number}
         * @private
         */
        exDateInc: 0,
        /**
         * Current negative date.
         *
         * @type {ICAL.Time}
         * @private
         */
        exDate: null,
        /**
         * Current additional date.
         *
         * @type {ICAL.Time}
         * @private
         */
        ruleDate: null,
        /**
         * Start date of recurring rules.
         *
         * @type {ICAL.Time}
         */
        dtstart: null,
        /**
         * Last expanded time
         *
         * @type {ICAL.Time}
         */
        last: null,
        /**
         * Initialize the recurrence expansion from the data object. The options
         * object may also contain additional members, see the
         * {@link ICAL.RecurExpansion constructor} for more details.
         *
         * @param {Object} options
         *        Recurrence expansion options
         * @param {ICAL.Time} options.dtstart
         *        Start time of the event
         * @param {ICAL.Component=} options.component
         *        Component for expansion, required if not resuming.
         */
        fromData: function(options) {
          var start = ICAL2.helpers.formatClassType(options.dtstart, ICAL2.Time);
          if (!start) {
            throw new Error(".dtstart (ICAL.Time) must be given");
          } else {
            this.dtstart = start;
          }
          if (options.component) {
            this._init(options.component);
          } else {
            this.last = formatTime(options.last) || start.clone();
            if (!options.ruleIterators) {
              throw new Error(".ruleIterators or .component must be given");
            }
            this.ruleIterators = options.ruleIterators.map(function(item) {
              return ICAL2.helpers.formatClassType(item, ICAL2.RecurIterator);
            });
            this.ruleDateInc = options.ruleDateInc;
            this.exDateInc = options.exDateInc;
            if (options.ruleDates) {
              this.ruleDates = options.ruleDates.map(formatTime);
              this.ruleDate = this.ruleDates[this.ruleDateInc];
            }
            if (options.exDates) {
              this.exDates = options.exDates.map(formatTime);
              this.exDate = this.exDates[this.exDateInc];
            }
            if (typeof options.complete !== "undefined") {
              this.complete = options.complete;
            }
          }
        },
        /**
         * Retrieve the next occurrence in the series.
         * @return {ICAL.Time}
         */
        next: function() {
          var iter2;
          var ruleOfDay;
          var next;
          var compare;
          var maxTries = 500;
          var currentTry = 0;
          while (true) {
            if (currentTry++ > maxTries) {
              throw new Error(
                "max tries have occured, rule may be impossible to forfill."
              );
            }
            next = this.ruleDate;
            iter2 = this._nextRecurrenceIter(this.last);
            if (!next && !iter2) {
              this.complete = true;
              break;
            }
            if (!next || iter2 && next.compare(iter2.last) > 0) {
              next = iter2.last.clone();
              iter2.next();
            }
            if (this.ruleDate === next) {
              this._nextRuleDay();
            }
            this.last = next;
            if (this.exDate) {
              compare = this.exDate.compare(this.last);
              if (compare < 0) {
                this._nextExDay();
              }
              if (compare === 0) {
                this._nextExDay();
                continue;
              }
            }
            return this.last;
          }
        },
        /**
         * Converts object into a serialize-able format. This format can be passed
         * back into the expansion to resume iteration.
         * @return {Object}
         */
        toJSON: function() {
          function toJSON(item) {
            return item.toJSON();
          }
          var result = /* @__PURE__ */ Object.create(null);
          result.ruleIterators = this.ruleIterators.map(toJSON);
          if (this.ruleDates) {
            result.ruleDates = this.ruleDates.map(toJSON);
          }
          if (this.exDates) {
            result.exDates = this.exDates.map(toJSON);
          }
          result.ruleDateInc = this.ruleDateInc;
          result.exDateInc = this.exDateInc;
          result.last = this.last.toJSON();
          result.dtstart = this.dtstart.toJSON();
          result.complete = this.complete;
          return result;
        },
        /**
         * Extract all dates from the properties in the given component. The
         * properties will be filtered by the property name.
         *
         * @private
         * @param {ICAL.Component} component        The component to search in
         * @param {String} propertyName             The property name to search for
         * @return {ICAL.Time[]}                    The extracted dates.
         */
        _extractDates: function(component, propertyName) {
          function handleProp(prop2) {
            idx = ICAL2.helpers.binsearchInsert(
              result,
              prop2,
              compareTime
            );
            result.splice(idx, 0, prop2);
          }
          var result = [];
          var props = component.getAllProperties(propertyName);
          var len = props.length;
          var i3 = 0;
          var prop;
          var idx;
          for (; i3 < len; i3++) {
            props[i3].getValues().forEach(handleProp);
          }
          return result;
        },
        /**
         * Initialize the recurrence expansion.
         *
         * @private
         * @param {ICAL.Component} component    The component to initialize from.
         */
        _init: function(component) {
          this.ruleIterators = [];
          this.last = this.dtstart.clone();
          if (!isRecurringComponent(component)) {
            this.ruleDate = this.last.clone();
            this.complete = true;
            return;
          }
          if (component.hasProperty("rdate")) {
            this.ruleDates = this._extractDates(component, "rdate");
            if (this.ruleDates[0] && this.ruleDates[0].compare(this.dtstart) < 0) {
              this.ruleDateInc = 0;
              this.last = this.ruleDates[0].clone();
            } else {
              this.ruleDateInc = ICAL2.helpers.binsearchInsert(
                this.ruleDates,
                this.last,
                compareTime
              );
            }
            this.ruleDate = this.ruleDates[this.ruleDateInc];
          }
          if (component.hasProperty("rrule")) {
            var rules = component.getAllProperties("rrule");
            var i3 = 0;
            var len = rules.length;
            var rule;
            var iter2;
            for (; i3 < len; i3++) {
              rule = rules[i3].getFirstValue();
              iter2 = rule.iterator(this.dtstart);
              this.ruleIterators.push(iter2);
              iter2.next();
            }
          }
          if (component.hasProperty("exdate")) {
            this.exDates = this._extractDates(component, "exdate");
            this.exDateInc = ICAL2.helpers.binsearchInsert(
              this.exDates,
              this.last,
              compareTime
            );
            this.exDate = this.exDates[this.exDateInc];
          }
        },
        /**
         * Advance to the next exdate
         * @private
         */
        _nextExDay: function() {
          this.exDate = this.exDates[++this.exDateInc];
        },
        /**
         * Advance to the next rule date
         * @private
         */
        _nextRuleDay: function() {
          this.ruleDate = this.ruleDates[++this.ruleDateInc];
        },
        /**
         * Find and return the recurrence rule with the most recent event and
         * return it.
         *
         * @private
         * @return {?ICAL.RecurIterator}    Found iterator.
         */
        _nextRecurrenceIter: function() {
          var iters = this.ruleIterators;
          if (iters.length === 0) {
            return null;
          }
          var len = iters.length;
          var iter2;
          var iterTime;
          var iterIdx = 0;
          var chosenIter;
          for (; iterIdx < len; iterIdx++) {
            iter2 = iters[iterIdx];
            iterTime = iter2.last;
            if (iter2.completed) {
              len--;
              if (iterIdx !== 0) {
                iterIdx--;
              }
              iters.splice(iterIdx, 1);
              continue;
            }
            if (!chosenIter || chosenIter.last.compare(iterTime) > 0) {
              chosenIter = iter2;
            }
          }
          return chosenIter;
        }
      };
      return RecurExpansion;
    }();
    ICAL2.Event = function() {
      function Event2(component, options) {
        if (!(component instanceof ICAL2.Component)) {
          options = component;
          component = null;
        }
        if (component) {
          this.component = component;
        } else {
          this.component = new ICAL2.Component("vevent");
        }
        this._rangeExceptionCache = /* @__PURE__ */ Object.create(null);
        this.exceptions = /* @__PURE__ */ Object.create(null);
        this.rangeExceptions = [];
        if (options && options.strictExceptions) {
          this.strictExceptions = options.strictExceptions;
        }
        if (options && options.exceptions) {
          options.exceptions.forEach(this.relateException, this);
        } else if (this.component.parent && !this.isRecurrenceException()) {
          this.component.parent.getAllSubcomponents("vevent").forEach(function(event) {
            if (event.hasProperty("recurrence-id")) {
              this.relateException(event);
            }
          }, this);
        }
      }
      Event2.prototype = {
        THISANDFUTURE: "THISANDFUTURE",
        /**
         * List of related event exceptions.
         *
         * @type {ICAL.Event[]}
         */
        exceptions: null,
        /**
         * When true, will verify exceptions are related by their UUID.
         *
         * @type {Boolean}
         */
        strictExceptions: false,
        /**
         * Relates a given event exception to this object.  If the given component
         * does not share the UID of this event it cannot be related and will throw
         * an exception.
         *
         * If this component is an exception it cannot have other exceptions
         * related to it.
         *
         * @param {ICAL.Component|ICAL.Event} obj       Component or event
         */
        relateException: function(obj) {
          if (this.isRecurrenceException()) {
            throw new Error("cannot relate exception to exceptions");
          }
          if (obj instanceof ICAL2.Component) {
            obj = new ICAL2.Event(obj);
          }
          if (this.strictExceptions && obj.uid !== this.uid) {
            throw new Error("attempted to relate unrelated exception");
          }
          var id = obj.recurrenceId.toString();
          this.exceptions[id] = obj;
          if (obj.modifiesFuture()) {
            var item = [
              obj.recurrenceId.toUnixTime(),
              id
            ];
            var idx = ICAL2.helpers.binsearchInsert(
              this.rangeExceptions,
              item,
              compareRangeException
            );
            this.rangeExceptions.splice(idx, 0, item);
          }
        },
        /**
         * Checks if this record is an exception and has the RANGE=THISANDFUTURE
         * value.
         *
         * @return {Boolean}        True, when exception is within range
         */
        modifiesFuture: function() {
          if (!this.component.hasProperty("recurrence-id")) {
            return false;
          }
          var range2 = this.component.getFirstProperty("recurrence-id").getParameter("range");
          return range2 === this.THISANDFUTURE;
        },
        /**
         * Finds the range exception nearest to the given date.
         *
         * @param {ICAL.Time} time usually an occurrence time of an event
         * @return {?ICAL.Event} the related event/exception or null
         */
        findRangeException: function(time) {
          if (!this.rangeExceptions.length) {
            return null;
          }
          var utc = time.toUnixTime();
          var idx = ICAL2.helpers.binsearchInsert(
            this.rangeExceptions,
            [utc],
            compareRangeException
          );
          idx -= 1;
          if (idx < 0) {
            return null;
          }
          var rangeItem = this.rangeExceptions[idx];
          if (utc < rangeItem[0]) {
            return null;
          }
          return rangeItem[1];
        },
        /**
         * This object is returned by {@link ICAL.Event#getOccurrenceDetails getOccurrenceDetails}
         *
         * @typedef {Object} occurrenceDetails
         * @memberof ICAL.Event
         * @property {ICAL.Time} recurrenceId       The passed in recurrence id
         * @property {ICAL.Event} item              The occurrence
         * @property {ICAL.Time} startDate          The start of the occurrence
         * @property {ICAL.Time} endDate            The end of the occurrence
         */
        /**
         * Returns the occurrence details based on its start time.  If the
         * occurrence has an exception will return the details for that exception.
         *
         * NOTE: this method is intend to be used in conjunction
         *       with the {@link ICAL.Event#iterator iterator} method.
         *
         * @param {ICAL.Time} occurrence time occurrence
         * @return {ICAL.Event.occurrenceDetails} Information about the occurrence
         */
        getOccurrenceDetails: function(occurrence) {
          var id = occurrence.toString();
          var utcId = occurrence.convertToZone(ICAL2.Timezone.utcTimezone).toString();
          var item;
          var result = {
            //XXX: Clone?
            recurrenceId: occurrence
          };
          if (id in this.exceptions) {
            item = result.item = this.exceptions[id];
            result.startDate = item.startDate;
            result.endDate = item.endDate;
            result.item = item;
          } else if (utcId in this.exceptions) {
            item = this.exceptions[utcId];
            result.startDate = item.startDate;
            result.endDate = item.endDate;
            result.item = item;
          } else {
            var rangeExceptionId = this.findRangeException(
              occurrence
            );
            var end;
            if (rangeExceptionId) {
              var exception = this.exceptions[rangeExceptionId];
              result.item = exception;
              var startDiff = this._rangeExceptionCache[rangeExceptionId];
              if (!startDiff) {
                var original = exception.recurrenceId.clone();
                var newStart = exception.startDate.clone();
                original.zone = newStart.zone;
                startDiff = newStart.subtractDate(original);
                this._rangeExceptionCache[rangeExceptionId] = startDiff;
              }
              var start = occurrence.clone();
              start.zone = exception.startDate.zone;
              start.addDuration(startDiff);
              end = start.clone();
              end.addDuration(exception.duration);
              result.startDate = start;
              result.endDate = end;
            } else {
              end = occurrence.clone();
              end.addDuration(this.duration);
              result.endDate = end;
              result.startDate = occurrence;
              result.item = this;
            }
          }
          return result;
        },
        /**
         * Builds a recur expansion instance for a specific point in time (defaults
         * to startDate).
         *
         * @param {ICAL.Time} startTime     Starting point for expansion
         * @return {ICAL.RecurExpansion}    Expansion object
         */
        iterator: function(startTime) {
          return new ICAL2.RecurExpansion({
            component: this.component,
            dtstart: startTime || this.startDate
          });
        },
        /**
         * Checks if the event is recurring
         *
         * @return {Boolean}        True, if event is recurring
         */
        isRecurring: function() {
          var comp = this.component;
          return comp.hasProperty("rrule") || comp.hasProperty("rdate");
        },
        /**
         * Checks if the event describes a recurrence exception. See
         * {@tutorial terminology} for details.
         *
         * @return {Boolean}    True, if the event describes a recurrence exception
         */
        isRecurrenceException: function() {
          return this.component.hasProperty("recurrence-id");
        },
        /**
         * Returns the types of recurrences this event may have.
         *
         * Returned as an object with the following possible keys:
         *
         *    - YEARLY
         *    - MONTHLY
         *    - WEEKLY
         *    - DAILY
         *    - MINUTELY
         *    - SECONDLY
         *
         * @return {Object.<ICAL.Recur.frequencyValues, Boolean>}
         *          Object of recurrence flags
         */
        getRecurrenceTypes: function() {
          var rules = this.component.getAllProperties("rrule");
          var i3 = 0;
          var len = rules.length;
          var result = /* @__PURE__ */ Object.create(null);
          for (; i3 < len; i3++) {
            var value = rules[i3].getFirstValue();
            result[value.freq] = true;
          }
          return result;
        },
        /**
         * The uid of this event
         * @type {String}
         */
        get uid() {
          return this._firstProp("uid");
        },
        set uid(value) {
          this._setProp("uid", value);
        },
        /**
         * The start date
         * @type {ICAL.Time}
         */
        get startDate() {
          return this._firstProp("dtstart");
        },
        set startDate(value) {
          this._setTime("dtstart", value);
        },
        /**
         * The end date. This can be the result directly from the property, or the
         * end date calculated from start date and duration. Setting the property
         * will remove any duration properties.
         * @type {ICAL.Time}
         */
        get endDate() {
          var endDate = this._firstProp("dtend");
          if (!endDate) {
            var duration = this._firstProp("duration");
            endDate = this.startDate.clone();
            if (duration) {
              endDate.addDuration(duration);
            } else if (endDate.isDate) {
              endDate.day += 1;
            }
          }
          return endDate;
        },
        set endDate(value) {
          if (this.component.hasProperty("duration")) {
            this.component.removeProperty("duration");
          }
          this._setTime("dtend", value);
        },
        /**
         * The duration. This can be the result directly from the property, or the
         * duration calculated from start date and end date. Setting the property
         * will remove any `dtend` properties.
         * @type {ICAL.Duration}
         */
        get duration() {
          var duration = this._firstProp("duration");
          if (!duration) {
            return this.endDate.subtractDateTz(this.startDate);
          }
          return duration;
        },
        set duration(value) {
          if (this.component.hasProperty("dtend")) {
            this.component.removeProperty("dtend");
          }
          this._setProp("duration", value);
        },
        /**
         * The location of the event.
         * @type {String}
         */
        get location() {
          return this._firstProp("location");
        },
        set location(value) {
          return this._setProp("location", value);
        },
        /**
         * The attendees in the event
         * @type {ICAL.Property[]}
         * @readonly
         */
        get attendees() {
          return this.component.getAllProperties("attendee");
        },
        /**
         * The event summary
         * @type {String}
         */
        get summary() {
          return this._firstProp("summary");
        },
        set summary(value) {
          this._setProp("summary", value);
        },
        /**
         * The event description.
         * @type {String}
         */
        get description() {
          return this._firstProp("description");
        },
        set description(value) {
          this._setProp("description", value);
        },
        /**
         * The event color from [rfc7986](https://datatracker.ietf.org/doc/html/rfc7986)
         * @type {String}
         */
        get color() {
          return this._firstProp("color");
        },
        set color(value) {
          this._setProp("color", value);
        },
        /**
         * The organizer value as an uri. In most cases this is a mailto: uri, but
         * it can also be something else, like urn:uuid:...
         * @type {String}
         */
        get organizer() {
          return this._firstProp("organizer");
        },
        set organizer(value) {
          this._setProp("organizer", value);
        },
        /**
         * The sequence value for this event. Used for scheduling
         * see {@tutorial terminology}.
         * @type {Number}
         */
        get sequence() {
          return this._firstProp("sequence");
        },
        set sequence(value) {
          this._setProp("sequence", value);
        },
        /**
         * The recurrence id for this event. See {@tutorial terminology} for details.
         * @type {ICAL.Time}
         */
        get recurrenceId() {
          return this._firstProp("recurrence-id");
        },
        set recurrenceId(value) {
          this._setTime("recurrence-id", value);
        },
        /**
         * Set/update a time property's value.
         * This will also update the TZID of the property.
         *
         * TODO: this method handles the case where we are switching
         * from a known timezone to an implied timezone (one without TZID).
         * This does _not_ handle the case of moving between a known
         *  (by TimezoneService) timezone to an unknown timezone...
         *
         * We will not add/remove/update the VTIMEZONE subcomponents
         *  leading to invalid ICAL data...
         * @private
         * @param {String} propName     The property name
         * @param {ICAL.Time} time      The time to set
         */
        _setTime: function(propName, time) {
          var prop = this.component.getFirstProperty(propName);
          if (!prop) {
            prop = new ICAL2.Property(propName);
            this.component.addProperty(prop);
          }
          if (time.zone === ICAL2.Timezone.localTimezone || time.zone === ICAL2.Timezone.utcTimezone) {
            prop.removeParameter("tzid");
          } else {
            prop.setParameter("tzid", time.zone.tzid);
          }
          prop.setValue(time);
        },
        _setProp: function(name, value) {
          this.component.updatePropertyWithValue(name, value);
        },
        _firstProp: function(name) {
          return this.component.getFirstPropertyValue(name);
        },
        /**
         * The string representation of this event.
         * @return {String}
         */
        toString: function() {
          return this.component.toString();
        }
      };
      function compareRangeException(a3, b3) {
        if (a3[0] > b3[0])
          return 1;
        if (b3[0] > a3[0])
          return -1;
        return 0;
      }
      return Event2;
    }();
    ICAL2.ComponentParser = function() {
      function ComponentParser(options) {
        if (typeof options === "undefined") {
          options = {};
        }
        var key;
        for (key in options) {
          if (options.hasOwnProperty(key)) {
            this[key] = options[key];
          }
        }
      }
      ComponentParser.prototype = {
        /**
         * When true, parse events
         *
         * @type {Boolean}
         */
        parseEvent: true,
        /**
         * When true, parse timezones
         *
         * @type {Boolean}
         */
        parseTimezone: true,
        /* SAX like events here for reference */
        /**
         * Fired when parsing is complete
         * @callback
         */
        oncomplete: (
          /* istanbul ignore next */
          function() {
          }
        ),
        /**
         * Fired if an error occurs during parsing.
         *
         * @callback
         * @param {Error} err details of error
         */
        onerror: (
          /* istanbul ignore next */
          function(err) {
          }
        ),
        /**
         * Fired when a top level component (VTIMEZONE) is found
         *
         * @callback
         * @param {ICAL.Timezone} component     Timezone object
         */
        ontimezone: (
          /* istanbul ignore next */
          function(component) {
          }
        ),
        /**
         * Fired when a top level component (VEVENT) is found.
         *
         * @callback
         * @param {ICAL.Event} component    Top level component
         */
        onevent: (
          /* istanbul ignore next */
          function(component) {
          }
        ),
        /**
         * Process a string or parse ical object.  This function itself will return
         * nothing but will start the parsing process.
         *
         * Events must be registered prior to calling this method.
         *
         * @param {ICAL.Component|String|Object} ical      The component to process,
         *        either in its final form, as a jCal Object, or string representation
         */
        process: function(ical) {
          if (typeof ical === "string") {
            ical = ICAL2.parse(ical);
          }
          if (!(ical instanceof ICAL2.Component)) {
            ical = new ICAL2.Component(ical);
          }
          var components = ical.getAllSubcomponents();
          var i3 = 0;
          var len = components.length;
          var component;
          for (; i3 < len; i3++) {
            component = components[i3];
            switch (component.name) {
              case "vtimezone":
                if (this.parseTimezone) {
                  var tzid = component.getFirstPropertyValue("tzid");
                  if (tzid) {
                    this.ontimezone(new ICAL2.Timezone({
                      tzid,
                      component
                    }));
                  }
                }
                break;
              case "vevent":
                if (this.parseEvent) {
                  this.onevent(new ICAL2.Event(component));
                }
                break;
              default:
                continue;
            }
          }
          this.oncomplete();
        }
      };
      return ComponentParser;
    }();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/views/CalendarView.ts
var import_obsidian = require("obsidian");

// src/types.ts
var Src = class {
  constructor(path) {
    this._path = path;
  }
  addExcludes(excludes) {
    return true;
  }
  get path() {
    return this._path;
  }
  get excludes() {
    return structuredClone(this._excludes);
  }
};

// src/constants.ts
var MSG_PLG_NAME = "MyCalendar";
var EVENT_SRC = "databases";
var PLACE_FOR_CREATING_NOTE = "databases";
var daysOfWeek = ["1", "2", "3", "4", "5", "6", "0"];
var display = "background";
var COLOUR_REST = "#305B60";
var COLOUR_SLEEP = "#cc0000";
var DEFAULT_SETTINGS = {
  statusCorrector: {
    isOn: true,
    startOnStartUp: true
  },
  calendar: {
    slotDuration: "00:30:00",
    colours: {
      frequency: "#8A1717",
      done: "#008E04",
      tick: "#457E7E",
      default: "#5e3fa8"
    },
    restTime: [
      {
        daysOfWeek,
        display,
        startTime: "0:00:00",
        endTime: "8:00:00",
        color: COLOUR_SLEEP
      },
      {
        daysOfWeek,
        display,
        startTime: "24:00:00",
        endTime: "24:00:00",
        color: COLOUR_SLEEP
      },
      {
        daysOfWeek,
        display,
        startTime: "0:00:00",
        endTime: "8:30:00",
        color: COLOUR_REST
      },
      {
        daysOfWeek,
        display,
        startTime: "23:00:00",
        endTime: "24:00:00",
        color: COLOUR_REST
      }
    ]
  },
  source: {
    noteSources: [new Src(EVENT_SRC)],
    // NOTE default path where note will be created
    defaultCreatePath: PLACE_FOR_CREATING_NOTE
  }
};
var VIEW_TYPE = "my-obsidian-calendar-plugin";
var TEXT_DONE = "\u{1F7E2}done";
var FORMAT_DAY = "d";
var FORMAT_HOUR = "h";
var FORMAT_MINUTE = "m";
var BACKGROUND_COLOUR = {
  hue: {
    shift: 0,
    min: 0,
    max: 360
  },
  saturation: {
    shift: 0,
    min: 70,
    max: 90
  },
  lightness: {
    shift: 0,
    min: 30,
    max: 50
  }
};
var MillisecsInSecond = 1e3;
var SecsInMinute = 60;
var MinutesInHour = 60;
var HoursInDay = 24;
var MillisecsInMinute = MillisecsInSecond * SecsInMinute;
var MillisecsInHour = MillisecsInMinute * MinutesInHour;
var MillisecsInDay = MillisecsInHour * HoursInDay;

// src/util.ts
var import_obsidian_dataview = __toESM(require_lib());
var dv = (0, import_obsidian_dataview.getAPI)();
function pathToFileWithoutFileName(path) {
  const path_separator = path.lastIndexOf("/");
  if (path_separator !== -1)
    return path.slice(0, path_separator);
  return "";
}
function IDateToCalendarEvent(args) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const structure = {
    start: new Date(args.ff_date),
    allDay: false
  };
  if (args.ff_duration) {
    structure.start.setHours(((_b = (_a = args.ff_timeStart) == null ? void 0 : _a.values) == null ? void 0 : _b.hours) || 0);
    structure.start.setMinutes(((_d = (_c = args.ff_timeStart) == null ? void 0 : _c.values) == null ? void 0 : _d.minutes) || 0);
    let tmpTime = new Date(structure.start);
    if (((_f = (_e = args.ff_duration) == null ? void 0 : _e.values) == null ? void 0 : _f.minutes) || ((_h = (_g = args.ff_duration) == null ? void 0 : _g.values) == null ? void 0 : _h.hours) || ((_j = (_i = args.ff_duration) == null ? void 0 : _i.values) == null ? void 0 : _j.days)) {
      const duration = args.ff_duration.values;
      tmpTime.setMinutes(
        tmpTime.getMinutes() + (duration.minutes || 0)
      );
      tmpTime.setHours(
        tmpTime.getHours() + (duration.hours || 0)
      );
      tmpTime.setDate(
        tmpTime.getDate() + (duration.days || 0)
      );
    } else {
      structure.allDay = true;
    }
    if (!((_k = args.ff_timeStart) == null ? void 0 : _k.values))
      structure.allDay = true;
    structure.end = tmpTime;
  } else if (args.ff_duration) {
    structure.allDay = true;
  } else
    structure.allDay = true;
  return structure;
}
function CalendarEventToIDate(event) {
  const { start, end, allDay } = event;
  start.setMinutes(
    start.getMinutes() - start.getTimezoneOffset()
  );
  const result = {
    ff_duration: "",
    ff_timeStart: "",
    ff_date: new Date(start)
  };
  start.setMinutes(
    start.getMinutes() + start.getTimezoneOffset()
  );
  let srcMillisec = end ? end - start : MillisecsInHour;
  if (allDay) {
    result["ff_timeStart"] = "";
    if (srcMillisec <= MillisecsInDay)
      srcMillisec = 0;
  } else
    result["ff_timeStart"] = start.getHours() + "h" + start.getMinutes() + "m";
  result["ff_duration"] = millisecToString(srcMillisec);
  return result;
}
function getTicksFromText(text) {
  var _a, _b, _c, _d, _e;
  const result = [];
  const regExpTicks = /\[t::.+\]/gm;
  const matches = text.match(regExpTicks);
  if (matches)
    for (let match of matches) {
      const args = match.slice(1, -1).split("::")[1].split(",");
      if (!args)
        continue;
      const name = (_a = args[0]) == null ? void 0 : _a.trim();
      const ff_date = dv.date((_b = args[1]) == null ? void 0 : _b.trim());
      const ff_timeStart = dv.duration((_c = args[2]) == null ? void 0 : _c.trim());
      const tempDuration = (_d = args[3]) == null ? void 0 : _d.trim();
      const ff_duration = tempDuration == "x" ? "x" : dv.duration((_e = args[3]) == null ? void 0 : _e.trim());
      if (name == "")
        continue;
      result.push(
        { name, ff_date, ff_timeStart, ff_duration }
      );
    }
  return result;
}
function millisecToString(millisec) {
  const days = Math.floor(
    millisec / MillisecsInDay
  );
  millisec -= days * MillisecsInDay;
  const hours = Math.floor(
    millisec / MillisecsInHour
  );
  millisec -= hours * MillisecsInHour;
  const minutes = Math.floor(
    millisec / MillisecsInMinute
  );
  millisec -= minutes * MillisecsInMinute;
  let resString = "";
  if (days)
    resString += days.toString() + FORMAT_DAY;
  if (hours)
    resString += hours.toString() + FORMAT_HOUR;
  if (minutes)
    resString += minutes.toString() + FORMAT_MINUTE;
  return resString;
}
function isEqualObj(object1, object2) {
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    const val2 = object2[key];
    const areObjects = isObject(val1) && isObject(val2);
    if (areObjects && !isEqualObj(val1, val2) || !areObjects && val1 !== val2) {
      return false;
    }
  }
  return true;
}
function isObject(object) {
  return object != null && typeof object === "object";
}
function templateIDTick(path, tickName) {
  return path + tickName;
}
function templateNameTick(fileName, tickName) {
  return "(" + fileName + ")" + tickName;
}
function hashString(str) {
  let hash = 0;
  for (let i3 = 0; i3 < str.length; i3++) {
    hash = (hash << 5) - hash + str.charCodeAt(i3);
    hash |= 0;
  }
  return hash;
}
function toRange(src, min, max) {
  max -= min;
  src %= max + 1;
  return src + min;
}
function getColourFromPath(path) {
  const str = pathToFileWithoutFileName(path);
  const str1 = hashString([...str].filter((_3, index8) => (index8 + 1) % 3 !== 0).join(""));
  const str2 = hashString([...str].filter((_3, index8) => (index8 + 2) % 3 !== 0).join(""));
  const str3 = hashString([...str].filter((_3, index8) => (index8 + 3) % 3 !== 0).join(""));
  const hue = toRange(
    str1 + BACKGROUND_COLOUR.hue.shift,
    BACKGROUND_COLOUR.hue.min,
    BACKGROUND_COLOUR.hue.max
  );
  const saturation = toRange(
    str2 + BACKGROUND_COLOUR.saturation.shift,
    BACKGROUND_COLOUR.saturation.min,
    BACKGROUND_COLOUR.saturation.max
  );
  const lightness = toRange(
    str3 + BACKGROUND_COLOUR.lightness.shift,
    BACKGROUND_COLOUR.lightness.min,
    BACKGROUND_COLOUR.lightness.max
  );
  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}
function safeParseInt(str) {
  const num = Number(str);
  return Number.isInteger(num) ? num : NaN;
}
function timeAdd(start, duration) {
  const dur = duration.as("minutes");
  const result = new Date(start);
  result.setMinutes(result.getMinutes() + dur);
  return result;
}
function pageToEvents(page) {
  const result = [];
  const colours = this.calendarSettings.colours;
  const structureTemplate = {
    id: "",
    title: "",
    borderColor: colours.default,
    color: getColourFromPath(page.file.path),
    editable: true
  };
  if (page.ff_date) {
    const structure = {
      ...structureTemplate,
      id: page.file.path,
      title: page.file.name,
      ...IDateToCalendarEvent(page)
    };
    if (page.ff_frequency)
      structure.borderColor = colours.frequency;
    if (page.ff_status == TEXT_DONE)
      structure.borderColor = colours.done;
    result.push(structure);
  }
  for (let tick of page.ticks) {
    const structure = {
      ...structureTemplate,
      id: templateIDTick(page.file.path, tick.name),
      title: templateNameTick(page.file.name, tick.name),
      borderColor: colours.tick,
      extendedProps: {
        tickName: tick.name,
        notePath: page.file.path
      },
      ...IDateToCalendarEvent(tick)
    };
    result.push(structure);
  }
  return result;
}

// node_modules/@fullcalendar/core/node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var i;
var t;
var r;
var o;
var f;
var e;
var c = {};
var s = [];
var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
function h(n2, l3) {
  for (var u3 in l3)
    n2[u3] = l3[u3];
  return n2;
}
function v(n2) {
  var l3 = n2.parentNode;
  l3 && l3.removeChild(n2);
}
function y(l3, u3, i3) {
  var t3, r3, o2, f3 = {};
  for (o2 in u3)
    "key" == o2 ? t3 = u3[o2] : "ref" == o2 ? r3 = u3[o2] : f3[o2] = u3[o2];
  if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : i3), "function" == typeof l3 && null != l3.defaultProps)
    for (o2 in l3.defaultProps)
      void 0 === f3[o2] && (f3[o2] = l3.defaultProps[o2]);
  return p(l3, f3, t3, r3, null);
}
function p(n2, i3, t3, r3, o2) {
  var f3 = { type: n2, props: i3, key: t3, ref: r3, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == o2 ? ++u : o2 };
  return null == o2 && null != l.vnode && l.vnode(f3), f3;
}
function d() {
  return { current: null };
}
function _(n2) {
  return n2.children;
}
function k(n2, l3, u3, i3, t3) {
  var r3;
  for (r3 in u3)
    "children" === r3 || "key" === r3 || r3 in l3 || g(n2, r3, null, u3[r3], i3);
  for (r3 in l3)
    t3 && "function" != typeof l3[r3] || "children" === r3 || "key" === r3 || "value" === r3 || "checked" === r3 || u3[r3] === l3[r3] || g(n2, r3, l3[r3], u3[r3], i3);
}
function b(n2, l3, u3) {
  "-" === l3[0] ? n2.setProperty(l3, null == u3 ? "" : u3) : n2[l3] = null == u3 ? "" : "number" != typeof u3 || a.test(l3) ? u3 : u3 + "px";
}
function g(n2, l3, u3, i3, t3) {
  var r3;
  n:
    if ("style" === l3)
      if ("string" == typeof u3)
        n2.style.cssText = u3;
      else {
        if ("string" == typeof i3 && (n2.style.cssText = i3 = ""), i3)
          for (l3 in i3)
            u3 && l3 in u3 || b(n2.style, l3, "");
        if (u3)
          for (l3 in u3)
            i3 && u3[l3] === i3[l3] || b(n2.style, l3, u3[l3]);
      }
    else if ("o" === l3[0] && "n" === l3[1])
      r3 = l3 !== (l3 = l3.replace(/Capture$/, "")), l3 = l3.toLowerCase() in n2 ? l3.toLowerCase().slice(2) : l3.slice(2), n2.l || (n2.l = {}), n2.l[l3 + r3] = u3, u3 ? i3 || n2.addEventListener(l3, r3 ? w : m, r3) : n2.removeEventListener(l3, r3 ? w : m, r3);
    else if ("dangerouslySetInnerHTML" !== l3) {
      if (t3)
        l3 = l3.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" !== l3 && "height" !== l3 && "href" !== l3 && "list" !== l3 && "form" !== l3 && "tabIndex" !== l3 && "download" !== l3 && l3 in n2)
        try {
          n2[l3] = null == u3 ? "" : u3;
          break n;
        } catch (n3) {
        }
      "function" == typeof u3 || (null == u3 || false === u3 && -1 == l3.indexOf("-") ? n2.removeAttribute(l3) : n2.setAttribute(l3, u3));
    }
}
function m(n2) {
  t = true;
  try {
    return this.l[n2.type + false](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function w(n2) {
  t = true;
  try {
    return this.l[n2.type + true](l.event ? l.event(n2) : n2);
  } finally {
    t = false;
  }
}
function x(n2, l3) {
  this.props = n2, this.context = l3;
}
function A(n2, l3) {
  if (null == l3)
    return n2.__ ? A(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
  for (var u3; l3 < n2.__k.length; l3++)
    if (null != (u3 = n2.__k[l3]) && null != u3.__e)
      return u3.__e;
  return "function" == typeof n2.type ? A(n2) : null;
}
function P(n2) {
  var l3, u3;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l3 = 0; l3 < n2.__k.length; l3++)
      if (null != (u3 = n2.__k[l3]) && null != u3.__e) {
        n2.__e = n2.__c.base = u3.__e;
        break;
      }
    return P(n2);
  }
}
function C(n2) {
  t ? setTimeout(n2) : f(n2);
}
function T(n2) {
  (!n2.__d && (n2.__d = true) && r.push(n2) && !$.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || C)($);
}
function $() {
  var n2, l3, u3, i3, t3, o2, f3, e3;
  for (r.sort(function(n3, l4) {
    return n3.__v.__b - l4.__v.__b;
  }); n2 = r.shift(); )
    n2.__d && (l3 = r.length, i3 = void 0, t3 = void 0, f3 = (o2 = (u3 = n2).__v).__e, (e3 = u3.__P) && (i3 = [], (t3 = h({}, o2)).__v = o2.__v + 1, M(e3, o2, t3, u3.__n, void 0 !== e3.ownerSVGElement, null != o2.__h ? [f3] : null, i3, null == f3 ? A(o2) : f3, o2.__h), N(i3, o2), o2.__e != f3 && P(o2)), r.length > l3 && r.sort(function(n3, l4) {
      return n3.__v.__b - l4.__v.__b;
    }));
  $.__r = 0;
}
function H(n2, l3, u3, i3, t3, r3, o2, f3, e3, a3) {
  var h3, v3, y3, d2, k3, b3, g4, m3 = i3 && i3.__k || s, w4 = m3.length;
  for (u3.__k = [], h3 = 0; h3 < l3.length; h3++)
    if (null != (d2 = u3.__k[h3] = null == (d2 = l3[h3]) || "boolean" == typeof d2 ? null : "string" == typeof d2 || "number" == typeof d2 || "bigint" == typeof d2 ? p(null, d2, null, null, d2) : Array.isArray(d2) ? p(_, { children: d2 }, null, null, null) : d2.__b > 0 ? p(d2.type, d2.props, d2.key, d2.ref ? d2.ref : null, d2.__v) : d2)) {
      if (d2.__ = u3, d2.__b = u3.__b + 1, null === (y3 = m3[h3]) || y3 && d2.key == y3.key && d2.type === y3.type)
        m3[h3] = void 0;
      else
        for (v3 = 0; v3 < w4; v3++) {
          if ((y3 = m3[v3]) && d2.key == y3.key && d2.type === y3.type) {
            m3[v3] = void 0;
            break;
          }
          y3 = null;
        }
      M(n2, d2, y3 = y3 || c, t3, r3, o2, f3, e3, a3), k3 = d2.__e, (v3 = d2.ref) && y3.ref != v3 && (g4 || (g4 = []), y3.ref && g4.push(y3.ref, null, d2), g4.push(v3, d2.__c || k3, d2)), null != k3 ? (null == b3 && (b3 = k3), "function" == typeof d2.type && d2.__k === y3.__k ? d2.__d = e3 = I(d2, e3, n2) : e3 = z(n2, d2, y3, m3, k3, e3), "function" == typeof u3.type && (u3.__d = e3)) : e3 && y3.__e == e3 && e3.parentNode != n2 && (e3 = A(y3));
    }
  for (u3.__e = b3, h3 = w4; h3--; )
    null != m3[h3] && ("function" == typeof u3.type && null != m3[h3].__e && m3[h3].__e == u3.__d && (u3.__d = L(i3).nextSibling), q(m3[h3], m3[h3]));
  if (g4)
    for (h3 = 0; h3 < g4.length; h3++)
      S(g4[h3], g4[++h3], g4[++h3]);
}
function I(n2, l3, u3) {
  for (var i3, t3 = n2.__k, r3 = 0; t3 && r3 < t3.length; r3++)
    (i3 = t3[r3]) && (i3.__ = n2, l3 = "function" == typeof i3.type ? I(i3, l3, u3) : z(u3, i3, i3, t3, i3.__e, l3));
  return l3;
}
function j(n2, l3) {
  return l3 = l3 || [], null == n2 || "boolean" == typeof n2 || (Array.isArray(n2) ? n2.some(function(n3) {
    j(n3, l3);
  }) : l3.push(n2)), l3;
}
function z(n2, l3, u3, i3, t3, r3) {
  var o2, f3, e3;
  if (void 0 !== l3.__d)
    o2 = l3.__d, l3.__d = void 0;
  else if (null == u3 || t3 != r3 || null == t3.parentNode)
    n:
      if (null == r3 || r3.parentNode !== n2)
        n2.appendChild(t3), o2 = null;
      else {
        for (f3 = r3, e3 = 0; (f3 = f3.nextSibling) && e3 < i3.length; e3 += 1)
          if (f3 == t3)
            break n;
        n2.insertBefore(t3, r3), o2 = r3;
      }
  return void 0 !== o2 ? o2 : t3.nextSibling;
}
function L(n2) {
  var l3, u3, i3;
  if (null == n2.type || "string" == typeof n2.type)
    return n2.__e;
  if (n2.__k) {
    for (l3 = n2.__k.length - 1; l3 >= 0; l3--)
      if ((u3 = n2.__k[l3]) && (i3 = L(u3)))
        return i3;
  }
  return null;
}
function M(n2, u3, i3, t3, r3, o2, f3, e3, c3) {
  var s3, a3, v3, y3, p3, d2, k3, b3, g4, m3, w4, A3, P3, C3, T4, $3 = u3.type;
  if (void 0 !== u3.constructor)
    return null;
  null != i3.__h && (c3 = i3.__h, e3 = u3.__e = i3.__e, u3.__h = null, o2 = [e3]), (s3 = l.__b) && s3(u3);
  try {
    n:
      if ("function" == typeof $3) {
        if (b3 = u3.props, g4 = (s3 = $3.contextType) && t3[s3.__c], m3 = s3 ? g4 ? g4.props.value : s3.__ : t3, i3.__c ? k3 = (a3 = u3.__c = i3.__c).__ = a3.__E : ("prototype" in $3 && $3.prototype.render ? u3.__c = a3 = new $3(b3, m3) : (u3.__c = a3 = new x(b3, m3), a3.constructor = $3, a3.render = B), g4 && g4.sub(a3), a3.props = b3, a3.state || (a3.state = {}), a3.context = m3, a3.__n = t3, v3 = a3.__d = true, a3.__h = [], a3._sb = []), null == a3.__s && (a3.__s = a3.state), null != $3.getDerivedStateFromProps && (a3.__s == a3.state && (a3.__s = h({}, a3.__s)), h(a3.__s, $3.getDerivedStateFromProps(b3, a3.__s))), y3 = a3.props, p3 = a3.state, a3.__v = u3, v3)
          null == $3.getDerivedStateFromProps && null != a3.componentWillMount && a3.componentWillMount(), null != a3.componentDidMount && a3.__h.push(a3.componentDidMount);
        else {
          if (null == $3.getDerivedStateFromProps && b3 !== y3 && null != a3.componentWillReceiveProps && a3.componentWillReceiveProps(b3, m3), !a3.__e && null != a3.shouldComponentUpdate && false === a3.shouldComponentUpdate(b3, a3.__s, m3) || u3.__v === i3.__v) {
            for (u3.__v !== i3.__v && (a3.props = b3, a3.state = a3.__s, a3.__d = false), u3.__e = i3.__e, u3.__k = i3.__k, u3.__k.forEach(function(n3) {
              n3 && (n3.__ = u3);
            }), w4 = 0; w4 < a3._sb.length; w4++)
              a3.__h.push(a3._sb[w4]);
            a3._sb = [], a3.__h.length && f3.push(a3);
            break n;
          }
          null != a3.componentWillUpdate && a3.componentWillUpdate(b3, a3.__s, m3), null != a3.componentDidUpdate && a3.__h.push(function() {
            a3.componentDidUpdate(y3, p3, d2);
          });
        }
        if (a3.context = m3, a3.props = b3, a3.__P = n2, A3 = l.__r, P3 = 0, "prototype" in $3 && $3.prototype.render) {
          for (a3.state = a3.__s, a3.__d = false, A3 && A3(u3), s3 = a3.render(a3.props, a3.state, a3.context), C3 = 0; C3 < a3._sb.length; C3++)
            a3.__h.push(a3._sb[C3]);
          a3._sb = [];
        } else
          do {
            a3.__d = false, A3 && A3(u3), s3 = a3.render(a3.props, a3.state, a3.context), a3.state = a3.__s;
          } while (a3.__d && ++P3 < 25);
        a3.state = a3.__s, null != a3.getChildContext && (t3 = h(h({}, t3), a3.getChildContext())), v3 || null == a3.getSnapshotBeforeUpdate || (d2 = a3.getSnapshotBeforeUpdate(y3, p3)), T4 = null != s3 && s3.type === _ && null == s3.key ? s3.props.children : s3, H(n2, Array.isArray(T4) ? T4 : [T4], u3, i3, t3, r3, o2, f3, e3, c3), a3.base = u3.__e, u3.__h = null, a3.__h.length && f3.push(a3), k3 && (a3.__E = a3.__ = null), a3.__e = false;
      } else
        null == o2 && u3.__v === i3.__v ? (u3.__k = i3.__k, u3.__e = i3.__e) : u3.__e = O(i3.__e, u3, i3, t3, r3, o2, f3, c3);
    (s3 = l.diffed) && s3(u3);
  } catch (n3) {
    u3.__v = null, (c3 || null != o2) && (u3.__e = e3, u3.__h = !!c3, o2[o2.indexOf(e3)] = null), l.__e(n3, u3, i3);
  }
}
function N(n2, u3) {
  l.__c && l.__c(u3, n2), n2.some(function(u4) {
    try {
      n2 = u4.__h, u4.__h = [], n2.some(function(n3) {
        n3.call(u4);
      });
    } catch (n3) {
      l.__e(n3, u4.__v);
    }
  });
}
function O(l3, u3, i3, t3, r3, o2, f3, e3) {
  var s3, a3, h3, y3 = i3.props, p3 = u3.props, d2 = u3.type, _3 = 0;
  if ("svg" === d2 && (r3 = true), null != o2) {
    for (; _3 < o2.length; _3++)
      if ((s3 = o2[_3]) && "setAttribute" in s3 == !!d2 && (d2 ? s3.localName === d2 : 3 === s3.nodeType)) {
        l3 = s3, o2[_3] = null;
        break;
      }
  }
  if (null == l3) {
    if (null === d2)
      return document.createTextNode(p3);
    l3 = r3 ? document.createElementNS("http://www.w3.org/2000/svg", d2) : document.createElement(d2, p3.is && p3), o2 = null, e3 = false;
  }
  if (null === d2)
    y3 === p3 || e3 && l3.data === p3 || (l3.data = p3);
  else {
    if (o2 = o2 && n.call(l3.childNodes), a3 = (y3 = i3.props || c).dangerouslySetInnerHTML, h3 = p3.dangerouslySetInnerHTML, !e3) {
      if (null != o2)
        for (y3 = {}, _3 = 0; _3 < l3.attributes.length; _3++)
          y3[l3.attributes[_3].name] = l3.attributes[_3].value;
      (h3 || a3) && (h3 && (a3 && h3.__html == a3.__html || h3.__html === l3.innerHTML) || (l3.innerHTML = h3 && h3.__html || ""));
    }
    if (k(l3, p3, y3, r3, e3), h3)
      u3.__k = [];
    else if (_3 = u3.props.children, H(l3, Array.isArray(_3) ? _3 : [_3], u3, i3, t3, r3 && "foreignObject" !== d2, o2, f3, o2 ? o2[0] : i3.__k && A(i3, 0), e3), null != o2)
      for (_3 = o2.length; _3--; )
        null != o2[_3] && v(o2[_3]);
    e3 || ("value" in p3 && void 0 !== (_3 = p3.value) && (_3 !== l3.value || "progress" === d2 && !_3 || "option" === d2 && _3 !== y3.value) && g(l3, "value", _3, y3.value, false), "checked" in p3 && void 0 !== (_3 = p3.checked) && _3 !== l3.checked && g(l3, "checked", _3, y3.checked, false));
  }
  return l3;
}
function S(n2, u3, i3) {
  try {
    "function" == typeof n2 ? n2(u3) : n2.current = u3;
  } catch (n3) {
    l.__e(n3, i3);
  }
}
function q(n2, u3, i3) {
  var t3, r3;
  if (l.unmount && l.unmount(n2), (t3 = n2.ref) && (t3.current && t3.current !== n2.__e || S(t3, null, u3)), null != (t3 = n2.__c)) {
    if (t3.componentWillUnmount)
      try {
        t3.componentWillUnmount();
      } catch (n3) {
        l.__e(n3, u3);
      }
    t3.base = t3.__P = null, n2.__c = void 0;
  }
  if (t3 = n2.__k)
    for (r3 = 0; r3 < t3.length; r3++)
      t3[r3] && q(t3[r3], u3, i3 || "function" != typeof n2.type);
  i3 || null == n2.__e || v(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
}
function B(n2, l3, u3) {
  return this.constructor(n2, u3);
}
function D(u3, i3, t3) {
  var r3, o2, f3;
  l.__ && l.__(u3, i3), o2 = (r3 = "function" == typeof t3) ? null : t3 && t3.__k || i3.__k, f3 = [], M(i3, u3 = (!r3 && t3 || i3).__k = y(_, null, [u3]), o2 || c, c, void 0 !== i3.ownerSVGElement, !r3 && t3 ? [t3] : o2 ? null : i3.firstChild ? n.call(i3.childNodes) : null, f3, !r3 && t3 ? t3 : o2 ? o2.__e : i3.firstChild, r3), N(f3, u3);
}
function G(n2, l3) {
  var u3 = { __c: l3 = "__cC" + e++, __: n2, Consumer: function(n3, l4) {
    return n3.children(l4);
  }, Provider: function(n3) {
    var u4, i3;
    return this.getChildContext || (u4 = [], (i3 = {})[l3] = this, this.getChildContext = function() {
      return i3;
    }, this.shouldComponentUpdate = function(n4) {
      this.props.value !== n4.value && u4.some(function(n5) {
        n5.__e = true, T(n5);
      });
    }, this.sub = function(n4) {
      u4.push(n4);
      var l4 = n4.componentWillUnmount;
      n4.componentWillUnmount = function() {
        u4.splice(u4.indexOf(n4), 1), l4 && l4.call(n4);
      };
    }), n3.children;
  } };
  return u3.Provider.__ = u3.Consumer.contextType = u3;
}
n = s.slice, l = { __e: function(n2, l3, u3, i3) {
  for (var t3, r3, o2; l3 = l3.__; )
    if ((t3 = l3.__c) && !t3.__)
      try {
        if ((r3 = t3.constructor) && null != r3.getDerivedStateFromError && (t3.setState(r3.getDerivedStateFromError(n2)), o2 = t3.__d), null != t3.componentDidCatch && (t3.componentDidCatch(n2, i3 || {}), o2 = t3.__d), o2)
          return t3.__E = t3;
      } catch (l4) {
        n2 = l4;
      }
  throw n2;
} }, u = 0, i = function(n2) {
  return null != n2 && void 0 === n2.constructor;
}, t = false, x.prototype.setState = function(n2, l3) {
  var u3;
  u3 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n2 && (n2 = n2(h({}, u3), this.props)), n2 && h(u3, n2), null != n2 && this.__v && (l3 && this._sb.push(l3), T(this));
}, x.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), T(this));
}, x.prototype.render = _, r = [], f = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, $.__r = 0, e = 0;

// node_modules/@fullcalendar/core/node_modules/preact/hooks/dist/hooks.module.js
var t2;
var r2;
var u2;
var i2;
var f2 = [];
var c2 = [];
var e2 = l.__b;
var a2 = l.__r;
var v2 = l.diffed;
var l2 = l.__c;
var m2 = l.unmount;
function b2() {
  for (var t3; t3 = f2.shift(); )
    if (t3.__P && t3.__H)
      try {
        t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
      } catch (r3) {
        t3.__H.__h = [], l.__e(r3, t3.__v);
      }
}
l.__b = function(n2) {
  r2 = null, e2 && e2(n2);
}, l.__r = function(n2) {
  a2 && a2(n2), t2 = 0;
  var i3 = (r2 = n2.__c).__H;
  i3 && (u2 === r2 ? (i3.__h = [], r2.__h = [], i3.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.__V = c2, n3.__N = n3.i = void 0;
  })) : (i3.__h.forEach(k2), i3.__h.forEach(w2), i3.__h = [])), u2 = r2;
}, l.diffed = function(t3) {
  v2 && v2(t3);
  var o2 = t3.__c;
  o2 && o2.__H && (o2.__H.__h.length && (1 !== f2.push(o2) && i2 === l.requestAnimationFrame || ((i2 = l.requestAnimationFrame) || j2)(b2)), o2.__H.__.forEach(function(n2) {
    n2.i && (n2.__H = n2.i), n2.__V !== c2 && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c2;
  })), u2 = r2 = null;
}, l.__c = function(t3, r3) {
  r3.some(function(t4) {
    try {
      t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n2) {
        return !n2.__ || w2(n2);
      });
    } catch (u3) {
      r3.some(function(n2) {
        n2.__h && (n2.__h = []);
      }), r3 = [], l.__e(u3, t4.__v);
    }
  }), l2 && l2(t3, r3);
}, l.unmount = function(t3) {
  m2 && m2(t3);
  var r3, u3 = t3.__c;
  u3 && u3.__H && (u3.__H.__.forEach(function(n2) {
    try {
      k2(n2);
    } catch (n3) {
      r3 = n3;
    }
  }), u3.__H = void 0, r3 && l.__e(r3, u3.__v));
};
var g2 = "function" == typeof requestAnimationFrame;
function j2(n2) {
  var t3, r3 = function() {
    clearTimeout(u3), g2 && cancelAnimationFrame(t3), setTimeout(n2);
  }, u3 = setTimeout(r3, 100);
  g2 && (t3 = requestAnimationFrame(r3));
}
function k2(n2) {
  var t3 = r2, u3 = n2.__c;
  "function" == typeof u3 && (n2.__c = void 0, u3()), r2 = t3;
}
function w2(n2) {
  var t3 = r2;
  n2.__c = n2.__(), r2 = t3;
}

// node_modules/@fullcalendar/core/node_modules/preact/compat/dist/compat.module.js
function g3(n2, t3) {
  for (var e3 in t3)
    n2[e3] = t3[e3];
  return n2;
}
function C2(n2, t3) {
  for (var e3 in n2)
    if ("__source" !== e3 && !(e3 in t3))
      return true;
  for (var r3 in t3)
    if ("__source" !== r3 && n2[r3] !== t3[r3])
      return true;
  return false;
}
function w3(n2) {
  this.props = n2;
}
(w3.prototype = new x()).isPureReactComponent = true, w3.prototype.shouldComponentUpdate = function(n2, t3) {
  return C2(this.props, n2) || C2(this.state, t3);
};
var x3 = l.__b;
l.__b = function(n2) {
  n2.type && n2.type.__f && n2.ref && (n2.props.ref = n2.ref, n2.ref = null), x3 && x3(n2);
};
var N2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
var T3 = l.__e;
l.__e = function(n2, t3, e3, r3) {
  if (n2.then) {
    for (var u3, o2 = t3; o2 = o2.__; )
      if ((u3 = o2.__c) && u3.__c)
        return null == t3.__e && (t3.__e = e3.__e, t3.__k = e3.__k), u3.__c(n2, t3);
  }
  T3(n2, t3, e3, r3);
};
var I2 = l.unmount;
function L2(n2, t3, e3) {
  return n2 && (n2.__c && n2.__c.__H && (n2.__c.__H.__.forEach(function(n3) {
    "function" == typeof n3.__c && n3.__c();
  }), n2.__c.__H = null), null != (n2 = g3({}, n2)).__c && (n2.__c.__P === e3 && (n2.__c.__P = t3), n2.__c = null), n2.__k = n2.__k && n2.__k.map(function(n3) {
    return L2(n3, t3, e3);
  })), n2;
}
function U(n2, t3, e3) {
  return n2 && (n2.__v = null, n2.__k = n2.__k && n2.__k.map(function(n3) {
    return U(n3, t3, e3);
  }), n2.__c && n2.__c.__P === t3 && (n2.__e && e3.insertBefore(n2.__e, n2.__d), n2.__c.__e = true, n2.__c.__P = e3)), n2;
}
function D2() {
  this.__u = 0, this.t = null, this.__b = null;
}
function F3(n2) {
  var t3 = n2.__.__c;
  return t3 && t3.__a && t3.__a(n2);
}
function V2() {
  this.u = null, this.o = null;
}
l.unmount = function(n2) {
  var t3 = n2.__c;
  t3 && t3.__R && t3.__R(), t3 && true === n2.__h && (n2.type = null), I2 && I2(n2);
}, (D2.prototype = new x()).__c = function(n2, t3) {
  var e3 = t3.__c, r3 = this;
  null == r3.t && (r3.t = []), r3.t.push(e3);
  var u3 = F3(r3.__v), o2 = false, i3 = function() {
    o2 || (o2 = true, e3.__R = null, u3 ? u3(l3) : l3());
  };
  e3.__R = i3;
  var l3 = function() {
    if (!--r3.__u) {
      if (r3.state.__a) {
        var n3 = r3.state.__a;
        r3.__v.__k[0] = U(n3, n3.__c.__P, n3.__c.__O);
      }
      var t4;
      for (r3.setState({ __a: r3.__b = null }); t4 = r3.t.pop(); )
        t4.forceUpdate();
    }
  }, c3 = true === t3.__h;
  r3.__u++ || c3 || r3.setState({ __a: r3.__b = r3.__v.__k[0] }), n2.then(i3, i3);
}, D2.prototype.componentWillUnmount = function() {
  this.t = [];
}, D2.prototype.render = function(n2, e3) {
  if (this.__b) {
    if (this.__v.__k) {
      var r3 = document.createElement("div"), o2 = this.__v.__k[0].__c;
      this.__v.__k[0] = L2(this.__b, r3, o2.__O = o2.__P);
    }
    this.__b = null;
  }
  var i3 = e3.__a && y(_, null, n2.fallback);
  return i3 && (i3.__h = null), [y(_, null, e3.__a ? null : n2.children), i3];
};
var W = function(n2, t3, e3) {
  if (++e3[1] === e3[0] && n2.o.delete(t3), n2.props.revealOrder && ("t" !== n2.props.revealOrder[0] || !n2.o.size))
    for (e3 = n2.u; e3; ) {
      for (; e3.length > 3; )
        e3.pop()();
      if (e3[1] < e3[0])
        break;
      n2.u = e3 = e3[2];
    }
};
function P2(n2) {
  return this.getChildContext = function() {
    return n2.context;
  }, n2.children;
}
function $2(n2) {
  var e3 = this, r3 = n2.i;
  e3.componentWillUnmount = function() {
    D(null, e3.l), e3.l = null, e3.i = null;
  }, e3.i && e3.i !== r3 && e3.componentWillUnmount(), n2.__v ? (e3.l || (e3.i = r3, e3.l = { nodeType: 1, parentNode: r3, childNodes: [], appendChild: function(n3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, insertBefore: function(n3, t3) {
    this.childNodes.push(n3), e3.i.appendChild(n3);
  }, removeChild: function(n3) {
    this.childNodes.splice(this.childNodes.indexOf(n3) >>> 1, 1), e3.i.removeChild(n3);
  } }), D(y(P2, { context: e3.context }, n2.__v), e3.l)) : e3.l && e3.componentWillUnmount();
}
function j3(n2, e3) {
  var r3 = y($2, { __v: n2, i: e3 });
  return r3.containerInfo = e3, r3;
}
(V2.prototype = new x()).__a = function(n2) {
  var t3 = this, e3 = F3(t3.__v), r3 = t3.o.get(n2);
  return r3[0]++, function(u3) {
    var o2 = function() {
      t3.props.revealOrder ? (r3.push(u3), W(t3, n2, r3)) : u3();
    };
    e3 ? e3(o2) : o2();
  };
}, V2.prototype.render = function(n2) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t3 = j(n2.children);
  n2.revealOrder && "b" === n2.revealOrder[0] && t3.reverse();
  for (var e3 = t3.length; e3--; )
    this.o.set(t3[e3], this.u = [1, 0, this.u]);
  return n2.children;
}, V2.prototype.componentDidUpdate = V2.prototype.componentDidMount = function() {
  var n2 = this;
  this.o.forEach(function(t3, e3) {
    W(n2, e3, t3);
  });
};
var z2 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
var B2 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var H2 = "undefined" != typeof document;
var Z = function(n2) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/i : /fil|che|ra/i).test(n2);
};
x.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t3) {
  Object.defineProperty(x.prototype, t3, { configurable: true, get: function() {
    return this["UNSAFE_" + t3];
  }, set: function(n2) {
    Object.defineProperty(this, t3, { configurable: true, writable: true, value: n2 });
  } });
});
var G2 = l.event;
function J() {
}
function K() {
  return this.cancelBubble;
}
function Q() {
  return this.defaultPrevented;
}
l.event = function(n2) {
  return G2 && (n2 = G2(n2)), n2.persist = J, n2.isPropagationStopped = K, n2.isDefaultPrevented = Q, n2.nativeEvent = n2;
};
var X;
var nn = { configurable: true, get: function() {
  return this.class;
} };
var tn = l.vnode;
l.vnode = function(n2) {
  var t3 = n2.type, e3 = n2.props, u3 = e3;
  if ("string" == typeof t3) {
    var o2 = -1 === t3.indexOf("-");
    for (var i3 in u3 = {}, e3) {
      var l3 = e3[i3];
      H2 && "children" === i3 && "noscript" === t3 || "value" === i3 && "defaultValue" in e3 && null == l3 || ("defaultValue" === i3 && "value" in e3 && null == e3.value ? i3 = "value" : "download" === i3 && true === l3 ? l3 = "" : /ondoubleclick/i.test(i3) ? i3 = "ondblclick" : /^onchange(textarea|input)/i.test(i3 + t3) && !Z(e3.type) ? i3 = "oninput" : /^onfocus$/i.test(i3) ? i3 = "onfocusin" : /^onblur$/i.test(i3) ? i3 = "onfocusout" : /^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i3) ? i3 = i3.toLowerCase() : o2 && B2.test(i3) ? i3 = i3.replace(/[A-Z0-9]/g, "-$&").toLowerCase() : null === l3 && (l3 = void 0), /^oninput$/i.test(i3) && (i3 = i3.toLowerCase(), u3[i3] && (i3 = "oninputCapture")), u3[i3] = l3);
    }
    "select" == t3 && u3.multiple && Array.isArray(u3.value) && (u3.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = -1 != u3.value.indexOf(n3.props.value);
    })), "select" == t3 && null != u3.defaultValue && (u3.value = j(e3.children).forEach(function(n3) {
      n3.props.selected = u3.multiple ? -1 != u3.defaultValue.indexOf(n3.props.value) : u3.defaultValue == n3.props.value;
    })), n2.props = u3, e3.class != e3.className && (nn.enumerable = "className" in e3, null != e3.className && (u3.class = e3.className), Object.defineProperty(u3, "className", nn));
  }
  n2.$$typeof = z2, tn && tn(n2);
};
var en = l.__r;
l.__r = function(n2) {
  en && en(n2), X = n2.__c;
};

// node_modules/@fullcalendar/core/internal-common.js
var styleTexts = [];
var styleEls = /* @__PURE__ */ new Map();
function injectStyles(styleText) {
  styleTexts.push(styleText);
  styleEls.forEach((styleEl) => {
    appendStylesTo(styleEl, styleText);
  });
}
function ensureElHasStyles(el) {
  if (el.isConnected && // sometimes true if SSR system simulates DOM
  el.getRootNode) {
    registerStylesRoot(el.getRootNode());
  }
}
function registerStylesRoot(rootNode) {
  let styleEl = styleEls.get(rootNode);
  if (!styleEl || !styleEl.isConnected) {
    styleEl = rootNode.querySelector("style[data-fullcalendar]");
    if (!styleEl) {
      styleEl = document.createElement("style");
      styleEl.setAttribute("data-fullcalendar", "");
      const nonce = getNonceValue();
      if (nonce) {
        styleEl.nonce = nonce;
      }
      const parentEl = rootNode === document ? document.head : rootNode;
      const insertBefore = rootNode === document ? parentEl.querySelector("script,link[rel=stylesheet],link[as=style],style") : parentEl.firstChild;
      parentEl.insertBefore(styleEl, insertBefore);
    }
    styleEls.set(rootNode, styleEl);
    hydrateStylesRoot(styleEl);
  }
}
function hydrateStylesRoot(styleEl) {
  for (const styleText of styleTexts) {
    appendStylesTo(styleEl, styleText);
  }
}
function appendStylesTo(styleEl, styleText) {
  const { sheet } = styleEl;
  const ruleCnt = sheet.cssRules.length;
  styleText.split("}").forEach((styleStr, i3) => {
    styleStr = styleStr.trim();
    if (styleStr) {
      sheet.insertRule(styleStr + "}", ruleCnt + i3);
    }
  });
}
var queriedNonceValue;
function getNonceValue() {
  if (queriedNonceValue === void 0) {
    queriedNonceValue = queryNonceValue();
  }
  return queriedNonceValue;
}
function queryNonceValue() {
  const metaWithNonce = document.querySelector('meta[name="csp-nonce"]');
  if (metaWithNonce && metaWithNonce.hasAttribute("content")) {
    return metaWithNonce.getAttribute("content");
  }
  const elWithNonce = document.querySelector("script[nonce]");
  if (elWithNonce) {
    return elWithNonce.nonce || "";
  }
  return "";
}
if (typeof document !== "undefined") {
  registerStylesRoot(document);
}
var css_248z = ':root{--fc-small-font-size:.85em;--fc-page-bg-color:#fff;--fc-neutral-bg-color:hsla(0,0%,82%,.3);--fc-neutral-text-color:grey;--fc-border-color:#ddd;--fc-button-text-color:#fff;--fc-button-bg-color:#2c3e50;--fc-button-border-color:#2c3e50;--fc-button-hover-bg-color:#1e2b37;--fc-button-hover-border-color:#1a252f;--fc-button-active-bg-color:#1a252f;--fc-button-active-border-color:#151e27;--fc-event-bg-color:#3788d8;--fc-event-border-color:#3788d8;--fc-event-text-color:#fff;--fc-event-selected-overlay-color:rgba(0,0,0,.25);--fc-more-link-bg-color:#d0d0d0;--fc-more-link-text-color:inherit;--fc-event-resizer-thickness:8px;--fc-event-resizer-dot-total-width:8px;--fc-event-resizer-dot-border-width:1px;--fc-non-business-color:hsla(0,0%,84%,.3);--fc-bg-event-color:#8fdf82;--fc-bg-event-opacity:0.3;--fc-highlight-color:rgba(188,232,241,.3);--fc-today-bg-color:rgba(255,220,40,.15);--fc-now-indicator-color:red}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc{display:flex;flex-direction:column;font-size:1em}.fc,.fc *,.fc :after,.fc :before{box-sizing:border-box}.fc table{border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{padding:0;vertical-align:top}.fc a[data-navlink]{cursor:pointer}.fc a[data-navlink]:hover{text-decoration:underline}.fc-direction-ltr{direction:ltr;text-align:left}.fc-direction-rtl{direction:rtl;text-align:right}.fc-theme-standard td,.fc-theme-standard th{border:1px solid var(--fc-border-color)}.fc-liquid-hack td,.fc-liquid-hack th{position:relative}@font-face{font-family:fcicons;font-style:normal;font-weight:400;src:url("data:application/x-font-ttf;charset=utf-8;base64,AAEAAAALAIAAAwAwT1MvMg8SBfAAAAC8AAAAYGNtYXAXVtKNAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZgYydxIAAAF4AAAFNGhlYWQUJ7cIAAAGrAAAADZoaGVhB20DzAAABuQAAAAkaG10eCIABhQAAAcIAAAALGxvY2ED4AU6AAAHNAAAABhtYXhwAA8AjAAAB0wAAAAgbmFtZXsr690AAAdsAAABhnBvc3QAAwAAAAAI9AAAACAAAwPAAZAABQAAApkCzAAAAI8CmQLMAAAB6wAzAQkAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADpBgPA/8AAQAPAAEAAAAABAAAAAAAAAAAAAAAgAAAAAAADAAAAAwAAABwAAQADAAAAHAADAAEAAAAcAAQAOAAAAAoACAACAAIAAQAg6Qb//f//AAAAAAAg6QD//f//AAH/4xcEAAMAAQAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAWIAjQKeAskAEwAAJSc3NjQnJiIHAQYUFwEWMjc2NCcCnuLiDQ0MJAz/AA0NAQAMJAwNDcni4gwjDQwM/wANIwz/AA0NDCMNAAAAAQFiAI0CngLJABMAACUBNjQnASYiBwYUHwEHBhQXFjI3AZ4BAA0N/wAMJAwNDeLiDQ0MJAyNAQAMIw0BAAwMDSMM4uINIwwNDQAAAAIA4gC3Ax4CngATACcAACUnNzY0JyYiDwEGFB8BFjI3NjQnISc3NjQnJiIPAQYUHwEWMjc2NCcB87e3DQ0MIw3VDQ3VDSMMDQ0BK7e3DQ0MJAzVDQ3VDCQMDQ3zuLcMJAwNDdUNIwzWDAwNIwy4twwkDA0N1Q0jDNYMDA0jDAAAAgDiALcDHgKeABMAJwAAJTc2NC8BJiIHBhQfAQcGFBcWMjchNzY0LwEmIgcGFB8BBwYUFxYyNwJJ1Q0N1Q0jDA0Nt7cNDQwjDf7V1Q0N1QwkDA0Nt7cNDQwkDLfWDCMN1Q0NDCQMt7gMIw0MDNYMIw3VDQ0MJAy3uAwjDQwMAAADAFUAAAOrA1UAMwBoAHcAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMhMjY1NCYjISIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAAVYRGRkR/qoRGRkRA1UFBAUOCQkVDAsZDf2rDRkLDBUJCA4FBQUFBQUOCQgVDAsZDQJVDRkLDBUJCQ4FBAVVAgECBQMCBwQECAX9qwQJAwQHAwMFAQICAgIBBQMDBwQDCQQCVQUIBAQHAgMFAgEC/oAZEhEZGRESGQAAAAADAFUAAAOrA1UAMwBoAIkAABMiBgcOAQcOAQcOARURFBYXHgEXHgEXHgEzITI2Nz4BNz4BNz4BNRE0JicuAScuAScuASMFITIWFx4BFx4BFx4BFREUBgcOAQcOAQcOASMhIiYnLgEnLgEnLgE1ETQ2Nz4BNz4BNz4BMxMzFRQWMzI2PQEzMjY1NCYrATU0JiMiBh0BIyIGFRQWM9UNGAwLFQkJDgUFBQUFBQ4JCRULDBgNAlYNGAwLFQkJDgUFBQUFBQ4JCRULDBgN/aoCVgQIBAQHAwMFAQIBAQIBBQMDBwQECAT9qgQIBAQHAwMFAQIBAQIBBQMDBwQECASAgBkSEhmAERkZEYAZEhIZgBEZGREDVQUEBQ4JCRUMCxkN/asNGQsMFQkIDgUFBQUFBQ4JCBUMCxkNAlUNGQsMFQkJDgUEBVUCAQIFAwIHBAQIBf2rBAkDBAcDAwUBAgICAgEFAwMHBAMJBAJVBQgEBAcCAwUCAQL+gIASGRkSgBkSERmAEhkZEoAZERIZAAABAOIAjQMeAskAIAAAExcHBhQXFjI/ARcWMjc2NC8BNzY0JyYiDwEnJiIHBhQX4uLiDQ0MJAzi4gwkDA0N4uINDQwkDOLiDCQMDQ0CjeLiDSMMDQ3h4Q0NDCMN4uIMIw0MDOLiDAwNIwwAAAABAAAAAQAAa5n0y18PPPUACwQAAAAAANivOVsAAAAA2K85WwAAAAADqwNVAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAOrAAEAAAAAAAAAAAAAAAAAAAALBAAAAAAAAAAAAAAAAgAAAAQAAWIEAAFiBAAA4gQAAOIEAABVBAAAVQQAAOIAAAAAAAoAFAAeAEQAagCqAOoBngJkApoAAQAAAAsAigADAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAcAAAABAAAAAAACAAcAYAABAAAAAAADAAcANgABAAAAAAAEAAcAdQABAAAAAAAFAAsAFQABAAAAAAAGAAcASwABAAAAAAAKABoAigADAAEECQABAA4ABwADAAEECQACAA4AZwADAAEECQADAA4APQADAAEECQAEAA4AfAADAAEECQAFABYAIAADAAEECQAGAA4AUgADAAEECQAKADQApGZjaWNvbnMAZgBjAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMGZjaWNvbnMAZgBjAGkAYwBvAG4Ac2ZjaWNvbnMAZgBjAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcmZjaWNvbnMAZgBjAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=") format("truetype")}.fc-icon{speak:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;display:inline-block;font-family:fcicons!important;font-style:normal;font-variant:normal;font-weight:400;height:1em;line-height:1;text-align:center;text-transform:none;-moz-user-select:none;user-select:none;width:1em}.fc-icon-chevron-left:before{content:"\\e900"}.fc-icon-chevron-right:before{content:"\\e901"}.fc-icon-chevrons-left:before{content:"\\e902"}.fc-icon-chevrons-right:before{content:"\\e903"}.fc-icon-minus-square:before{content:"\\e904"}.fc-icon-plus-square:before{content:"\\e905"}.fc-icon-x:before{content:"\\e906"}.fc .fc-button{border-radius:0;font-family:inherit;font-size:inherit;line-height:inherit;margin:0;overflow:visible;text-transform:none}.fc .fc-button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}.fc .fc-button{-webkit-appearance:button}.fc .fc-button:not(:disabled){cursor:pointer}.fc .fc-button{background-color:transparent;border:1px solid transparent;border-radius:.25em;display:inline-block;font-size:1em;font-weight:400;line-height:1.5;padding:.4em .65em;text-align:center;-moz-user-select:none;user-select:none;vertical-align:middle}.fc .fc-button:hover{text-decoration:none}.fc .fc-button:focus{box-shadow:0 0 0 .2rem rgba(44,62,80,.25);outline:0}.fc .fc-button:disabled{opacity:.65}.fc .fc-button-primary{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:hover{background-color:var(--fc-button-hover-bg-color);border-color:var(--fc-button-hover-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:disabled{background-color:var(--fc-button-bg-color);border-color:var(--fc-button-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button-primary:not(:disabled).fc-button-active,.fc .fc-button-primary:not(:disabled):active{background-color:var(--fc-button-active-bg-color);border-color:var(--fc-button-active-border-color);color:var(--fc-button-text-color)}.fc .fc-button-primary:not(:disabled).fc-button-active:focus,.fc .fc-button-primary:not(:disabled):active:focus{box-shadow:0 0 0 .2rem rgba(76,91,106,.5)}.fc .fc-button .fc-icon{font-size:1.5em;vertical-align:middle}.fc .fc-button-group{display:inline-flex;position:relative;vertical-align:middle}.fc .fc-button-group>.fc-button{flex:1 1 auto;position:relative}.fc .fc-button-group>.fc-button.fc-button-active,.fc .fc-button-group>.fc-button:active,.fc .fc-button-group>.fc-button:focus,.fc .fc-button-group>.fc-button:hover{z-index:1}.fc-direction-ltr .fc-button-group>.fc-button:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0;margin-left:-1px}.fc-direction-ltr .fc-button-group>.fc-button:not(:last-child){border-bottom-right-radius:0;border-top-right-radius:0}.fc-direction-rtl .fc-button-group>.fc-button:not(:first-child){border-bottom-right-radius:0;border-top-right-radius:0;margin-right:-1px}.fc-direction-rtl .fc-button-group>.fc-button:not(:last-child){border-bottom-left-radius:0;border-top-left-radius:0}.fc .fc-toolbar{align-items:center;display:flex;justify-content:space-between}.fc .fc-toolbar.fc-header-toolbar{margin-bottom:1.5em}.fc .fc-toolbar.fc-footer-toolbar{margin-top:1.5em}.fc .fc-toolbar-title{font-size:1.75em;margin:0}.fc-direction-ltr .fc-toolbar>*>:not(:first-child){margin-left:.75em}.fc-direction-rtl .fc-toolbar>*>:not(:first-child){margin-right:.75em}.fc-direction-rtl .fc-toolbar-ltr{flex-direction:row-reverse}.fc .fc-scroller{-webkit-overflow-scrolling:touch;position:relative}.fc .fc-scroller-liquid{height:100%}.fc .fc-scroller-liquid-absolute{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-scroller-harness{direction:ltr;overflow:hidden;position:relative}.fc .fc-scroller-harness-liquid{height:100%}.fc-direction-rtl .fc-scroller-harness>.fc-scroller{direction:rtl}.fc-theme-standard .fc-scrollgrid{border:1px solid var(--fc-border-color)}.fc .fc-scrollgrid,.fc .fc-scrollgrid table{table-layout:fixed;width:100%}.fc .fc-scrollgrid table{border-left-style:hidden;border-right-style:hidden;border-top-style:hidden}.fc .fc-scrollgrid{border-bottom-width:0;border-collapse:separate;border-right-width:0}.fc .fc-scrollgrid-liquid{height:100%}.fc .fc-scrollgrid-section,.fc .fc-scrollgrid-section table,.fc .fc-scrollgrid-section>td{height:1px}.fc .fc-scrollgrid-section-liquid>td{height:100%}.fc .fc-scrollgrid-section>*{border-left-width:0;border-top-width:0}.fc .fc-scrollgrid-section-footer>*,.fc .fc-scrollgrid-section-header>*{border-bottom-width:0}.fc .fc-scrollgrid-section-body table,.fc .fc-scrollgrid-section-footer table{border-bottom-style:hidden}.fc .fc-scrollgrid-section-sticky>*{background:var(--fc-page-bg-color);position:sticky;z-index:3}.fc .fc-scrollgrid-section-header.fc-scrollgrid-section-sticky>*{top:0}.fc .fc-scrollgrid-section-footer.fc-scrollgrid-section-sticky>*{bottom:0}.fc .fc-scrollgrid-sticky-shim{height:1px;margin-bottom:-1px}.fc-sticky{position:sticky}.fc .fc-view-harness{flex-grow:1;position:relative}.fc .fc-view-harness-active>.fc-view{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-col-header-cell-cushion{display:inline-block;padding:2px 4px}.fc .fc-bg-event,.fc .fc-highlight,.fc .fc-non-business{bottom:0;left:0;position:absolute;right:0;top:0}.fc .fc-non-business{background:var(--fc-non-business-color)}.fc .fc-bg-event{background:var(--fc-bg-event-color);opacity:var(--fc-bg-event-opacity)}.fc .fc-bg-event .fc-event-title{font-size:var(--fc-small-font-size);font-style:italic;margin:.5em}.fc .fc-highlight{background:var(--fc-highlight-color)}.fc .fc-cell-shaded,.fc .fc-day-disabled{background:var(--fc-neutral-bg-color)}a.fc-event,a.fc-event:hover{text-decoration:none}.fc-event.fc-event-draggable,.fc-event[href]{cursor:pointer}.fc-event .fc-event-main{position:relative;z-index:2}.fc-event-dragging:not(.fc-event-selected){opacity:.75}.fc-event-dragging.fc-event-selected{box-shadow:0 2px 7px rgba(0,0,0,.3)}.fc-event .fc-event-resizer{display:none;position:absolute;z-index:4}.fc-event-selected .fc-event-resizer,.fc-event:hover .fc-event-resizer{display:block}.fc-event-selected .fc-event-resizer{background:var(--fc-page-bg-color);border-color:inherit;border-radius:calc(var(--fc-event-resizer-dot-total-width)/2);border-style:solid;border-width:var(--fc-event-resizer-dot-border-width);height:var(--fc-event-resizer-dot-total-width);width:var(--fc-event-resizer-dot-total-width)}.fc-event-selected .fc-event-resizer:before{bottom:-20px;content:"";left:-20px;position:absolute;right:-20px;top:-20px}.fc-event-selected,.fc-event:focus{box-shadow:0 2px 5px rgba(0,0,0,.2)}.fc-event-selected:before,.fc-event:focus:before{bottom:0;content:"";left:0;position:absolute;right:0;top:0;z-index:3}.fc-event-selected:after,.fc-event:focus:after{background:var(--fc-event-selected-overlay-color);bottom:-1px;content:"";left:-1px;position:absolute;right:-1px;top:-1px;z-index:1}.fc-h-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-h-event .fc-event-main{color:var(--fc-event-text-color)}.fc-h-event .fc-event-main-frame{display:flex}.fc-h-event .fc-event-time{max-width:100%;overflow:hidden}.fc-h-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-width:0}.fc-h-event .fc-event-title{display:inline-block;left:0;max-width:100%;overflow:hidden;right:0;vertical-align:top}.fc-h-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-start),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-end){border-bottom-left-radius:0;border-left-width:0;border-top-left-radius:0}.fc-direction-ltr .fc-daygrid-block-event:not(.fc-event-end),.fc-direction-rtl .fc-daygrid-block-event:not(.fc-event-start){border-bottom-right-radius:0;border-right-width:0;border-top-right-radius:0}.fc-h-event:not(.fc-event-selected) .fc-event-resizer{bottom:0;top:0;width:var(--fc-event-resizer-thickness)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end{cursor:w-resize;left:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-direction-ltr .fc-h-event:not(.fc-event-selected) .fc-event-resizer-end,.fc-direction-rtl .fc-h-event:not(.fc-event-selected) .fc-event-resizer-start{cursor:e-resize;right:calc(var(--fc-event-resizer-thickness)*-.5)}.fc-h-event.fc-event-selected .fc-event-resizer{margin-top:calc(var(--fc-event-resizer-dot-total-width)*-.5);top:50%}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-start,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-end{left:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc-direction-ltr .fc-h-event.fc-event-selected .fc-event-resizer-end,.fc-direction-rtl .fc-h-event.fc-event-selected .fc-event-resizer-start{right:calc(var(--fc-event-resizer-dot-total-width)*-.5)}.fc .fc-popover{box-shadow:0 2px 6px rgba(0,0,0,.15);position:absolute;z-index:9999}.fc .fc-popover-header{align-items:center;display:flex;flex-direction:row;justify-content:space-between;padding:3px 4px}.fc .fc-popover-title{margin:0 2px}.fc .fc-popover-close{cursor:pointer;font-size:1.1em;opacity:.65}.fc-theme-standard .fc-popover{background:var(--fc-page-bg-color);border:1px solid var(--fc-border-color)}.fc-theme-standard .fc-popover-header{background:var(--fc-neutral-bg-color)}';
injectStyles(css_248z);
var DelayedRunner = class {
  constructor(drainedOption) {
    this.drainedOption = drainedOption;
    this.isRunning = false;
    this.isDirty = false;
    this.pauseDepths = {};
    this.timeoutId = 0;
  }
  request(delay) {
    this.isDirty = true;
    if (!this.isPaused()) {
      this.clearTimeout();
      if (delay == null) {
        this.tryDrain();
      } else {
        this.timeoutId = setTimeout(
          // NOT OPTIMAL! TODO: look at debounce
          this.tryDrain.bind(this),
          delay
        );
      }
    }
  }
  pause(scope = "") {
    let { pauseDepths } = this;
    pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;
    this.clearTimeout();
  }
  resume(scope = "", force) {
    let { pauseDepths } = this;
    if (scope in pauseDepths) {
      if (force) {
        delete pauseDepths[scope];
      } else {
        pauseDepths[scope] -= 1;
        let depth = pauseDepths[scope];
        if (depth <= 0) {
          delete pauseDepths[scope];
        }
      }
      this.tryDrain();
    }
  }
  isPaused() {
    return Object.keys(this.pauseDepths).length;
  }
  tryDrain() {
    if (!this.isRunning && !this.isPaused()) {
      this.isRunning = true;
      while (this.isDirty) {
        this.isDirty = false;
        this.drained();
      }
      this.isRunning = false;
    }
  }
  clear() {
    this.clearTimeout();
    this.isDirty = false;
    this.pauseDepths = {};
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
      this.timeoutId = 0;
    }
  }
  drained() {
    if (this.drainedOption) {
      this.drainedOption();
    }
  }
};
function removeElement(el) {
  if (el.parentNode) {
    el.parentNode.removeChild(el);
  }
}
function elementClosest(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  if (!document.documentElement.contains(el)) {
    return null;
  }
  do {
    if (elementMatches(el, selector)) {
      return el;
    }
    el = el.parentElement || el.parentNode;
  } while (el !== null && el.nodeType === 1);
  return null;
}
function elementMatches(el, selector) {
  let method = el.matches || el.matchesSelector || el.msMatchesSelector;
  return method.call(el, selector);
}
function findElements(container, selector) {
  let containers = container instanceof HTMLElement ? [container] : container;
  let allMatches = [];
  for (let i3 = 0; i3 < containers.length; i3 += 1) {
    let matches = containers[i3].querySelectorAll(selector);
    for (let j4 = 0; j4 < matches.length; j4 += 1) {
      allMatches.push(matches[j4]);
    }
  }
  return allMatches;
}
var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;
function applyStyle(el, props) {
  for (let propName in props) {
    applyStyleProp(el, propName, props[propName]);
  }
}
function applyStyleProp(el, name, val) {
  if (val == null) {
    el.style[name] = "";
  } else if (typeof val === "number" && PIXEL_PROP_RE.test(name)) {
    el.style[name] = `${val}px`;
  } else {
    el.style[name] = val;
  }
}
function getEventTargetViaRoot(ev) {
  var _a, _b;
  return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;
}
var guid$1 = 0;
function getUniqueDomId() {
  guid$1 += 1;
  return "fc-dom-" + guid$1;
}
function preventDefault(ev) {
  ev.preventDefault();
}
function buildDelegationHandler(selector, handler) {
  return (ev) => {
    let matchedChild = elementClosest(ev.target, selector);
    if (matchedChild) {
      handler.call(matchedChild, ev, matchedChild);
    }
  };
}
function listenBySelector(container, eventType, selector, handler) {
  let attachedHandler = buildDelegationHandler(selector, handler);
  container.addEventListener(eventType, attachedHandler);
  return () => {
    container.removeEventListener(eventType, attachedHandler);
  };
}
function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {
  let currentMatchedChild;
  return listenBySelector(container, "mouseover", selector, (mouseOverEv, matchedChild) => {
    if (matchedChild !== currentMatchedChild) {
      currentMatchedChild = matchedChild;
      onMouseEnter(mouseOverEv, matchedChild);
      let realOnMouseLeave = (mouseLeaveEv) => {
        currentMatchedChild = null;
        onMouseLeave(mouseLeaveEv, matchedChild);
        matchedChild.removeEventListener("mouseleave", realOnMouseLeave);
      };
      matchedChild.addEventListener("mouseleave", realOnMouseLeave);
    }
  });
}
var transitionEventNames = [
  "webkitTransitionEnd",
  "otransitionend",
  "oTransitionEnd",
  "msTransitionEnd",
  "transitionend"
];
function whenTransitionDone(el, callback) {
  let realCallback = (ev) => {
    callback(ev);
    transitionEventNames.forEach((eventName) => {
      el.removeEventListener(eventName, realCallback);
    });
  };
  transitionEventNames.forEach((eventName) => {
    el.addEventListener(eventName, realCallback);
  });
}
function createAriaClickAttrs(handler) {
  return Object.assign({ onClick: handler }, createAriaKeyboardAttrs(handler));
}
function createAriaKeyboardAttrs(handler) {
  return {
    tabIndex: 0,
    onKeyDown(ev) {
      if (ev.key === "Enter" || ev.key === " ") {
        handler(ev);
        ev.preventDefault();
      }
    }
  };
}
var guidNumber = 0;
function guid() {
  guidNumber += 1;
  return String(guidNumber);
}
function disableCursor() {
  document.body.classList.add("fc-not-allowed");
}
function enableCursor() {
  document.body.classList.remove("fc-not-allowed");
}
function preventSelection(el) {
  el.style.userSelect = "none";
  el.style.webkitUserSelect = "none";
  el.addEventListener("selectstart", preventDefault);
}
function allowSelection(el) {
  el.style.userSelect = "";
  el.style.webkitUserSelect = "";
  el.removeEventListener("selectstart", preventDefault);
}
function preventContextMenu(el) {
  el.addEventListener("contextmenu", preventDefault);
}
function allowContextMenu(el) {
  el.removeEventListener("contextmenu", preventDefault);
}
function parseFieldSpecs(input) {
  let specs = [];
  let tokens = [];
  let i3;
  let token;
  if (typeof input === "string") {
    tokens = input.split(/\s*,\s*/);
  } else if (typeof input === "function") {
    tokens = [input];
  } else if (Array.isArray(input)) {
    tokens = input;
  }
  for (i3 = 0; i3 < tokens.length; i3 += 1) {
    token = tokens[i3];
    if (typeof token === "string") {
      specs.push(token.charAt(0) === "-" ? { field: token.substring(1), order: -1 } : { field: token, order: 1 });
    } else if (typeof token === "function") {
      specs.push({ func: token });
    }
  }
  return specs;
}
function compareByFieldSpecs(obj0, obj1, fieldSpecs) {
  let i3;
  let cmp;
  for (i3 = 0; i3 < fieldSpecs.length; i3 += 1) {
    cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i3]);
    if (cmp) {
      return cmp;
    }
  }
  return 0;
}
function compareByFieldSpec(obj0, obj1, fieldSpec) {
  if (fieldSpec.func) {
    return fieldSpec.func(obj0, obj1);
  }
  return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);
}
function flexibleCompare(a3, b3) {
  if (!a3 && !b3) {
    return 0;
  }
  if (b3 == null) {
    return -1;
  }
  if (a3 == null) {
    return 1;
  }
  if (typeof a3 === "string" || typeof b3 === "string") {
    return String(a3).localeCompare(String(b3));
  }
  return a3 - b3;
}
function padStart(val, len) {
  let s3 = String(val);
  return "000".substr(0, len - s3.length) + s3;
}
function formatWithOrdinals(formatter, args, fallbackText) {
  if (typeof formatter === "function") {
    return formatter(...args);
  }
  if (typeof formatter === "string") {
    return args.reduce((str, arg, index8) => str.replace("$" + index8, arg || ""), formatter);
  }
  return fallbackText;
}
function compareNumbers(a3, b3) {
  return a3 - b3;
}
function isInt(n2) {
  return n2 % 1 === 0;
}
function computeSmallestCellWidth(cellEl) {
  let allWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-frame");
  let contentWidthEl = cellEl.querySelector(".fc-scrollgrid-shrink-cushion");
  if (!allWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-frame className");
  }
  if (!contentWidthEl) {
    throw new Error("needs fc-scrollgrid-shrink-cushion className");
  }
  return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border
  contentWidthEl.getBoundingClientRect().width;
}
var INTERNAL_UNITS = ["years", "months", "days", "milliseconds"];
var PARSE_RE = /^(-?)(?:(\d+)\.)?(\d+):(\d\d)(?::(\d\d)(?:\.(\d\d\d))?)?/;
function createDuration(input, unit) {
  if (typeof input === "string") {
    return parseString(input);
  }
  if (typeof input === "object" && input) {
    return parseObject(input);
  }
  if (typeof input === "number") {
    return parseObject({ [unit || "milliseconds"]: input });
  }
  return null;
}
function parseString(s3) {
  let m3 = PARSE_RE.exec(s3);
  if (m3) {
    let sign = m3[1] ? -1 : 1;
    return {
      years: 0,
      months: 0,
      days: sign * (m3[2] ? parseInt(m3[2], 10) : 0),
      milliseconds: sign * ((m3[3] ? parseInt(m3[3], 10) : 0) * 60 * 60 * 1e3 + // hours
      (m3[4] ? parseInt(m3[4], 10) : 0) * 60 * 1e3 + // minutes
      (m3[5] ? parseInt(m3[5], 10) : 0) * 1e3 + // seconds
      (m3[6] ? parseInt(m3[6], 10) : 0))
    };
  }
  return null;
}
function parseObject(obj) {
  let duration = {
    years: obj.years || obj.year || 0,
    months: obj.months || obj.month || 0,
    days: obj.days || obj.day || 0,
    milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1e3 + // hours
    (obj.minutes || obj.minute || 0) * 60 * 1e3 + // minutes
    (obj.seconds || obj.second || 0) * 1e3 + // seconds
    (obj.milliseconds || obj.millisecond || obj.ms || 0)
    // ms
  };
  let weeks = obj.weeks || obj.week;
  if (weeks) {
    duration.days += weeks * 7;
    duration.specifiedWeeks = true;
  }
  return duration;
}
function durationsEqual(d0, d1) {
  return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;
}
function addDurations(d0, d1) {
  return {
    years: d0.years + d1.years,
    months: d0.months + d1.months,
    days: d0.days + d1.days,
    milliseconds: d0.milliseconds + d1.milliseconds
  };
}
function subtractDurations(d1, d0) {
  return {
    years: d1.years - d0.years,
    months: d1.months - d0.months,
    days: d1.days - d0.days,
    milliseconds: d1.milliseconds - d0.milliseconds
  };
}
function multiplyDuration(d2, n2) {
  return {
    years: d2.years * n2,
    months: d2.months * n2,
    days: d2.days * n2,
    milliseconds: d2.milliseconds * n2
  };
}
function asRoughYears(dur) {
  return asRoughDays(dur) / 365;
}
function asRoughMonths(dur) {
  return asRoughDays(dur) / 30;
}
function asRoughDays(dur) {
  return asRoughMs(dur) / 864e5;
}
function asRoughMs(dur) {
  return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;
}
function wholeDivideDurations(numerator, denominator) {
  let res = null;
  for (let i3 = 0; i3 < INTERNAL_UNITS.length; i3 += 1) {
    let unit = INTERNAL_UNITS[i3];
    if (denominator[unit]) {
      let localRes = numerator[unit] / denominator[unit];
      if (!isInt(localRes) || res !== null && res !== localRes) {
        return null;
      }
      res = localRes;
    } else if (numerator[unit]) {
      return null;
    }
  }
  return res;
}
function greatestDurationDenominator(dur) {
  let ms = dur.milliseconds;
  if (ms) {
    if (ms % 1e3 !== 0) {
      return { unit: "millisecond", value: ms };
    }
    if (ms % (1e3 * 60) !== 0) {
      return { unit: "second", value: ms / 1e3 };
    }
    if (ms % (1e3 * 60 * 60) !== 0) {
      return { unit: "minute", value: ms / (1e3 * 60) };
    }
    if (ms) {
      return { unit: "hour", value: ms / (1e3 * 60 * 60) };
    }
  }
  if (dur.days) {
    if (dur.specifiedWeeks && dur.days % 7 === 0) {
      return { unit: "week", value: dur.days / 7 };
    }
    return { unit: "day", value: dur.days };
  }
  if (dur.months) {
    return { unit: "month", value: dur.months };
  }
  if (dur.years) {
    return { unit: "year", value: dur.years };
  }
  return { unit: "millisecond", value: 0 };
}
function isArraysEqual(a0, a1, equalityFunc) {
  if (a0 === a1) {
    return true;
  }
  let len = a0.length;
  let i3;
  if (len !== a1.length) {
    return false;
  }
  for (i3 = 0; i3 < len; i3 += 1) {
    if (!(equalityFunc ? equalityFunc(a0[i3], a1[i3]) : a0[i3] === a1[i3])) {
      return false;
    }
  }
  return true;
}
var DAY_IDS = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
function addWeeks(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2 * 7;
  return arrayToUtcDate(a3);
}
function addDays(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[2] += n2;
  return arrayToUtcDate(a3);
}
function addMs(m3, n2) {
  let a3 = dateToUtcArray(m3);
  a3[6] += n2;
  return arrayToUtcDate(a3);
}
function diffWeeks(m0, m1) {
  return diffDays(m0, m1) / 7;
}
function diffDays(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60 * 24);
}
function diffHours(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60 * 60);
}
function diffMinutes(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / (1e3 * 60);
}
function diffSeconds(m0, m1) {
  return (m1.valueOf() - m0.valueOf()) / 1e3;
}
function diffDayAndTime(m0, m1) {
  let m0day = startOfDay(m0);
  let m1day = startOfDay(m1);
  return {
    years: 0,
    months: 0,
    days: Math.round(diffDays(m0day, m1day)),
    milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())
  };
}
function diffWholeWeeks(m0, m1) {
  let d2 = diffWholeDays(m0, m1);
  if (d2 !== null && d2 % 7 === 0) {
    return d2 / 7;
  }
  return null;
}
function diffWholeDays(m0, m1) {
  if (timeAsMs(m0) === timeAsMs(m1)) {
    return Math.round(diffDays(m0, m1));
  }
  return null;
}
function startOfDay(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate()
  ]);
}
function startOfHour(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours()
  ]);
}
function startOfMinute(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes()
  ]);
}
function startOfSecond(m3) {
  return arrayToUtcDate([
    m3.getUTCFullYear(),
    m3.getUTCMonth(),
    m3.getUTCDate(),
    m3.getUTCHours(),
    m3.getUTCMinutes(),
    m3.getUTCSeconds()
  ]);
}
function weekOfYear(marker, dow, doy) {
  let y3 = marker.getUTCFullYear();
  let w4 = weekOfGivenYear(marker, y3, dow, doy);
  if (w4 < 1) {
    return weekOfGivenYear(marker, y3 - 1, dow, doy);
  }
  let nextW = weekOfGivenYear(marker, y3 + 1, dow, doy);
  if (nextW >= 1) {
    return Math.min(w4, nextW);
  }
  return w4;
}
function weekOfGivenYear(marker, year, dow, doy) {
  let firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);
  let dayStart = startOfDay(marker);
  let days = Math.round(diffDays(firstWeekStart, dayStart));
  return Math.floor(days / 7) + 1;
}
function firstWeekOffset(year, dow, doy) {
  let fwd = 7 + dow - doy;
  let fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dateToLocalArray(date) {
  return [
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds()
  ];
}
function arrayToLocalDate(a3) {
  return new Date(
    a3[0],
    a3[1] || 0,
    a3[2] == null ? 1 : a3[2],
    // day of month
    a3[3] || 0,
    a3[4] || 0,
    a3[5] || 0
  );
}
function dateToUtcArray(date) {
  return [
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds(),
    date.getUTCMilliseconds()
  ];
}
function arrayToUtcDate(a3) {
  if (a3.length === 1) {
    a3 = a3.concat([0]);
  }
  return new Date(Date.UTC(...a3));
}
function isValidDate(m3) {
  return !isNaN(m3.valueOf());
}
function timeAsMs(m3) {
  return m3.getUTCHours() * 1e3 * 60 * 60 + m3.getUTCMinutes() * 1e3 * 60 + m3.getUTCSeconds() * 1e3 + m3.getUTCMilliseconds();
}
function buildIsoString(marker, timeZoneOffset, stripZeroTime = false) {
  let s3 = marker.toISOString();
  s3 = s3.replace(".000", "");
  if (stripZeroTime) {
    s3 = s3.replace("T00:00:00Z", "");
  }
  if (s3.length > 10) {
    if (timeZoneOffset == null) {
      s3 = s3.replace("Z", "");
    } else if (timeZoneOffset !== 0) {
      s3 = s3.replace("Z", formatTimeZoneOffset(timeZoneOffset, true));
    }
  }
  return s3;
}
function formatDayString(marker) {
  return marker.toISOString().replace(/T.*$/, "");
}
function formatIsoMonthStr(marker) {
  return marker.toISOString().match(/^\d{4}-\d{2}/)[0];
}
function formatIsoTimeString(marker) {
  return padStart(marker.getUTCHours(), 2) + ":" + padStart(marker.getUTCMinutes(), 2) + ":" + padStart(marker.getUTCSeconds(), 2);
}
function formatTimeZoneOffset(minutes, doIso = false) {
  let sign = minutes < 0 ? "-" : "+";
  let abs = Math.abs(minutes);
  let hours = Math.floor(abs / 60);
  let mins = Math.round(abs % 60);
  if (doIso) {
    return `${sign + padStart(hours, 2)}:${padStart(mins, 2)}`;
  }
  return `GMT${sign}${hours}${mins ? `:${padStart(mins, 2)}` : ""}`;
}
function memoize(workerFunc, resEquality, teardownFunc) {
  let currentArgs;
  let currentRes;
  return function(...newArgs) {
    if (!currentArgs) {
      currentRes = workerFunc.apply(this, newArgs);
    } else if (!isArraysEqual(currentArgs, newArgs)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.apply(this, newArgs);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArgs = newArgs;
    return currentRes;
  };
}
function memoizeObjArg(workerFunc, resEquality, teardownFunc) {
  let currentArg;
  let currentRes;
  return (newArg) => {
    if (!currentArg) {
      currentRes = workerFunc.call(this, newArg);
    } else if (!isPropsEqual(currentArg, newArg)) {
      if (teardownFunc) {
        teardownFunc(currentRes);
      }
      let res = workerFunc.call(this, newArg);
      if (!resEquality || !resEquality(res, currentRes)) {
        currentRes = res;
      }
    }
    currentArg = newArg;
    return currentRes;
  };
}
var EXTENDED_SETTINGS_AND_SEVERITIES = {
  week: 3,
  separator: 0,
  omitZeroMinute: 0,
  meridiem: 0,
  omitCommas: 0
};
var STANDARD_DATE_PROP_SEVERITIES = {
  timeZoneName: 7,
  era: 6,
  year: 5,
  month: 4,
  day: 2,
  weekday: 2,
  hour: 1,
  minute: 1,
  second: 1
};
var MERIDIEM_RE = /\s*([ap])\.?m\.?/i;
var COMMA_RE = /,/g;
var MULTI_SPACE_RE = /\s+/g;
var LTR_RE = /\u200e/g;
var UTC_RE = /UTC|GMT/;
var NativeFormatter = class {
  constructor(formatSettings) {
    let standardDateProps = {};
    let extendedSettings = {};
    let severity = 0;
    for (let name in formatSettings) {
      if (name in EXTENDED_SETTINGS_AND_SEVERITIES) {
        extendedSettings[name] = formatSettings[name];
        severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name], severity);
      } else {
        standardDateProps[name] = formatSettings[name];
        if (name in STANDARD_DATE_PROP_SEVERITIES) {
          severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name], severity);
        }
      }
    }
    this.standardDateProps = standardDateProps;
    this.extendedSettings = extendedSettings;
    this.severity = severity;
    this.buildFormattingFunc = memoize(buildFormattingFunc);
  }
  format(date, context) {
    return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    let { standardDateProps, extendedSettings } = this;
    let diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);
    if (!diffSeverity) {
      return this.format(start, context);
    }
    let biggestUnitForPartial = diffSeverity;
    if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time
    (standardDateProps.year === "numeric" || standardDateProps.year === "2-digit") && (standardDateProps.month === "numeric" || standardDateProps.month === "2-digit") && (standardDateProps.day === "numeric" || standardDateProps.day === "2-digit")) {
      biggestUnitForPartial = 1;
    }
    let full0 = this.format(start, context);
    let full1 = this.format(end, context);
    if (full0 === full1) {
      return full0;
    }
    let partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);
    let partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);
    let partial0 = partialFormattingFunc(start);
    let partial1 = partialFormattingFunc(end);
    let insertion = findCommonInsertion(full0, partial0, full1, partial1);
    let separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || "";
    if (insertion) {
      return insertion.before + partial0 + separator + partial1 + insertion.after;
    }
    return full0 + separator + full1;
  }
  getLargestUnit() {
    switch (this.severity) {
      case 7:
      case 6:
      case 5:
        return "year";
      case 4:
        return "month";
      case 3:
        return "week";
      case 2:
        return "day";
      default:
        return "time";
    }
  }
};
function buildFormattingFunc(standardDateProps, extendedSettings, context) {
  let standardDatePropCnt = Object.keys(standardDateProps).length;
  if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === "short") {
    return (date) => formatTimeZoneOffset(date.timeZoneOffset);
  }
  if (standardDatePropCnt === 0 && extendedSettings.week) {
    return (date) => formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);
  }
  return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);
}
function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {
  standardDateProps = Object.assign({}, standardDateProps);
  extendedSettings = Object.assign({}, extendedSettings);
  sanitizeSettings(standardDateProps, extendedSettings);
  standardDateProps.timeZone = "UTC";
  let normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);
  let zeroFormat;
  if (extendedSettings.omitZeroMinute) {
    let zeroProps = Object.assign({}, standardDateProps);
    delete zeroProps.minute;
    zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);
  }
  return (date) => {
    let { marker } = date;
    let format;
    if (zeroFormat && !marker.getUTCMinutes()) {
      format = zeroFormat;
    } else {
      format = normalFormat;
    }
    let s3 = format.format(marker);
    return postProcess(s3, date, standardDateProps, extendedSettings, context);
  };
}
function sanitizeSettings(standardDateProps, extendedSettings) {
  if (standardDateProps.timeZoneName) {
    if (!standardDateProps.hour) {
      standardDateProps.hour = "2-digit";
    }
    if (!standardDateProps.minute) {
      standardDateProps.minute = "2-digit";
    }
  }
  if (standardDateProps.timeZoneName === "long") {
    standardDateProps.timeZoneName = "short";
  }
  if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {
    delete extendedSettings.omitZeroMinute;
  }
}
function postProcess(s3, date, standardDateProps, extendedSettings, context) {
  s3 = s3.replace(LTR_RE, "");
  if (standardDateProps.timeZoneName === "short") {
    s3 = injectTzoStr(s3, context.timeZone === "UTC" || date.timeZoneOffset == null ? "UTC" : (
      // important to normalize for IE, which does "GMT"
      formatTimeZoneOffset(date.timeZoneOffset)
    ));
  }
  if (extendedSettings.omitCommas) {
    s3 = s3.replace(COMMA_RE, "").trim();
  }
  if (extendedSettings.omitZeroMinute) {
    s3 = s3.replace(":00", "");
  }
  if (extendedSettings.meridiem === false) {
    s3 = s3.replace(MERIDIEM_RE, "").trim();
  } else if (extendedSettings.meridiem === "narrow") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => m1.toLocaleLowerCase());
  } else if (extendedSettings.meridiem === "short") {
    s3 = s3.replace(MERIDIEM_RE, (m0, m1) => `${m1.toLocaleLowerCase()}m`);
  } else if (extendedSettings.meridiem === "lowercase") {
    s3 = s3.replace(MERIDIEM_RE, (m0) => m0.toLocaleLowerCase());
  }
  s3 = s3.replace(MULTI_SPACE_RE, " ");
  s3 = s3.trim();
  return s3;
}
function injectTzoStr(s3, tzoStr) {
  let replaced = false;
  s3 = s3.replace(UTC_RE, () => {
    replaced = true;
    return tzoStr;
  });
  if (!replaced) {
    s3 += ` ${tzoStr}`;
  }
  return s3;
}
function formatWeekNumber(num, weekText, weekTextLong, locale, display2) {
  let parts = [];
  if (display2 === "long") {
    parts.push(weekTextLong);
  } else if (display2 === "short" || display2 === "narrow") {
    parts.push(weekText);
  }
  if (display2 === "long" || display2 === "short") {
    parts.push(" ");
  }
  parts.push(locale.simpleNumberFormat.format(num));
  if (locale.options.direction === "rtl") {
    parts.reverse();
  }
  return parts.join("");
}
function computeMarkerDiffSeverity(d0, d1, ca) {
  if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {
    return 5;
  }
  if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {
    return 4;
  }
  if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {
    return 2;
  }
  if (timeAsMs(d0) !== timeAsMs(d1)) {
    return 1;
  }
  return 0;
}
function computePartialFormattingOptions(options, biggestUnit) {
  let partialOptions = {};
  for (let name in options) {
    if (!(name in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)
    STANDARD_DATE_PROP_SEVERITIES[name] <= biggestUnit) {
      partialOptions[name] = options[name];
    }
  }
  return partialOptions;
}
function findCommonInsertion(full0, partial0, full1, partial1) {
  let i0 = 0;
  while (i0 < full0.length) {
    let found0 = full0.indexOf(partial0, i0);
    if (found0 === -1) {
      break;
    }
    let before0 = full0.substr(0, found0);
    i0 = found0 + partial0.length;
    let after0 = full0.substr(i0);
    let i1 = 0;
    while (i1 < full1.length) {
      let found1 = full1.indexOf(partial1, i1);
      if (found1 === -1) {
        break;
      }
      let before1 = full1.substr(0, found1);
      i1 = found1 + partial1.length;
      let after1 = full1.substr(i1);
      if (before0 === before1 && after0 === after1) {
        return {
          before: before0,
          after: after0
        };
      }
    }
  }
  return null;
}
function expandZonedMarker(dateInfo, calendarSystem) {
  let a3 = calendarSystem.markerToArray(dateInfo.marker);
  return {
    marker: dateInfo.marker,
    timeZoneOffset: dateInfo.timeZoneOffset,
    array: a3,
    year: a3[0],
    month: a3[1],
    day: a3[2],
    hour: a3[3],
    minute: a3[4],
    second: a3[5],
    millisecond: a3[6]
  };
}
function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {
  let startInfo = expandZonedMarker(start, context.calendarSystem);
  let endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;
  return {
    date: startInfo,
    start: startInfo,
    end: endInfo,
    timeZone: context.timeZone,
    localeCodes: context.locale.codes,
    defaultSeparator: betterDefaultSeparator || context.defaultSeparator
  };
}
var CmdFormatter = class {
  constructor(cmdStr) {
    this.cmdStr = cmdStr;
  }
  format(date, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
  }
};
var FuncFormatter = class {
  constructor(func) {
    this.func = func;
  }
  format(date, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));
  }
  formatRange(start, end, context, betterDefaultSeparator) {
    return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));
  }
};
function createFormatter(input) {
  if (typeof input === "object" && input) {
    return new NativeFormatter(input);
  }
  if (typeof input === "string") {
    return new CmdFormatter(input);
  }
  if (typeof input === "function") {
    return new FuncFormatter(input);
  }
  return null;
}
var BASE_OPTION_REFINERS = {
  navLinkDayClick: identity,
  navLinkWeekClick: identity,
  duration: createDuration,
  bootstrapFontAwesome: identity,
  buttonIcons: identity,
  customButtons: identity,
  defaultAllDayEventDuration: createDuration,
  defaultTimedEventDuration: createDuration,
  nextDayThreshold: createDuration,
  scrollTime: createDuration,
  scrollTimeReset: Boolean,
  slotMinTime: createDuration,
  slotMaxTime: createDuration,
  dayPopoverFormat: createFormatter,
  slotDuration: createDuration,
  snapDuration: createDuration,
  headerToolbar: identity,
  footerToolbar: identity,
  defaultRangeSeparator: String,
  titleRangeSeparator: String,
  forceEventDuration: Boolean,
  dayHeaders: Boolean,
  dayHeaderFormat: createFormatter,
  dayHeaderClassNames: identity,
  dayHeaderContent: identity,
  dayHeaderDidMount: identity,
  dayHeaderWillUnmount: identity,
  dayCellClassNames: identity,
  dayCellContent: identity,
  dayCellDidMount: identity,
  dayCellWillUnmount: identity,
  initialView: String,
  aspectRatio: Number,
  weekends: Boolean,
  weekNumberCalculation: identity,
  weekNumbers: Boolean,
  weekNumberClassNames: identity,
  weekNumberContent: identity,
  weekNumberDidMount: identity,
  weekNumberWillUnmount: identity,
  editable: Boolean,
  viewClassNames: identity,
  viewDidMount: identity,
  viewWillUnmount: identity,
  nowIndicator: Boolean,
  nowIndicatorClassNames: identity,
  nowIndicatorContent: identity,
  nowIndicatorDidMount: identity,
  nowIndicatorWillUnmount: identity,
  showNonCurrentDates: Boolean,
  lazyFetching: Boolean,
  startParam: String,
  endParam: String,
  timeZoneParam: String,
  timeZone: String,
  locales: identity,
  locale: identity,
  themeSystem: String,
  dragRevertDuration: Number,
  dragScroll: Boolean,
  allDayMaintainDuration: Boolean,
  unselectAuto: Boolean,
  dropAccept: identity,
  eventOrder: parseFieldSpecs,
  eventOrderStrict: Boolean,
  handleWindowResize: Boolean,
  windowResizeDelay: Number,
  longPressDelay: Number,
  eventDragMinDistance: Number,
  expandRows: Boolean,
  height: identity,
  contentHeight: identity,
  direction: String,
  weekNumberFormat: createFormatter,
  eventResizableFromStart: Boolean,
  displayEventTime: Boolean,
  displayEventEnd: Boolean,
  weekText: String,
  weekTextLong: String,
  progressiveEventRendering: Boolean,
  businessHours: identity,
  initialDate: identity,
  now: identity,
  eventDataTransform: identity,
  stickyHeaderDates: identity,
  stickyFooterScrollbar: identity,
  viewHeight: identity,
  defaultAllDay: Boolean,
  eventSourceFailure: identity,
  eventSourceSuccess: identity,
  eventDisplay: String,
  eventStartEditable: Boolean,
  eventDurationEditable: Boolean,
  eventOverlap: identity,
  eventConstraint: identity,
  eventAllow: identity,
  eventBackgroundColor: String,
  eventBorderColor: String,
  eventTextColor: String,
  eventColor: String,
  eventClassNames: identity,
  eventContent: identity,
  eventDidMount: identity,
  eventWillUnmount: identity,
  selectConstraint: identity,
  selectOverlap: identity,
  selectAllow: identity,
  droppable: Boolean,
  unselectCancel: String,
  slotLabelFormat: identity,
  slotLaneClassNames: identity,
  slotLaneContent: identity,
  slotLaneDidMount: identity,
  slotLaneWillUnmount: identity,
  slotLabelClassNames: identity,
  slotLabelContent: identity,
  slotLabelDidMount: identity,
  slotLabelWillUnmount: identity,
  dayMaxEvents: identity,
  dayMaxEventRows: identity,
  dayMinWidth: Number,
  slotLabelInterval: createDuration,
  allDayText: String,
  allDayClassNames: identity,
  allDayContent: identity,
  allDayDidMount: identity,
  allDayWillUnmount: identity,
  slotMinWidth: Number,
  navLinks: Boolean,
  eventTimeFormat: createFormatter,
  rerenderDelay: Number,
  moreLinkText: identity,
  moreLinkHint: identity,
  selectMinDistance: Number,
  selectable: Boolean,
  selectLongPressDelay: Number,
  eventLongPressDelay: Number,
  selectMirror: Boolean,
  eventMaxStack: Number,
  eventMinHeight: Number,
  eventMinWidth: Number,
  eventShortHeight: Number,
  slotEventOverlap: Boolean,
  plugins: identity,
  firstDay: Number,
  dayCount: Number,
  dateAlignment: String,
  dateIncrement: createDuration,
  hiddenDays: identity,
  fixedWeekCount: Boolean,
  validRange: identity,
  visibleRange: identity,
  titleFormat: identity,
  eventInteractive: Boolean,
  // only used by list-view, but languages define the value, so we need it in base options
  noEventsText: String,
  viewHint: identity,
  navLinkHint: identity,
  closeHint: String,
  timeHint: String,
  eventHint: String,
  moreLinkClick: identity,
  moreLinkClassNames: identity,
  moreLinkContent: identity,
  moreLinkDidMount: identity,
  moreLinkWillUnmount: identity,
  monthStartFormat: createFormatter,
  // for connectors
  // (can't be part of plugin system b/c must be provided at runtime)
  handleCustomRendering: identity,
  customRenderingMetaMap: identity,
  customRenderingReplaces: Boolean
};
var BASE_OPTION_DEFAULTS = {
  eventDisplay: "auto",
  defaultRangeSeparator: " - ",
  titleRangeSeparator: " \u2013 ",
  defaultTimedEventDuration: "01:00:00",
  defaultAllDayEventDuration: { day: 1 },
  forceEventDuration: false,
  nextDayThreshold: "00:00:00",
  dayHeaders: true,
  initialView: "",
  aspectRatio: 1.35,
  headerToolbar: {
    start: "title",
    center: "",
    end: "today prev,next"
  },
  weekends: true,
  weekNumbers: false,
  weekNumberCalculation: "local",
  editable: false,
  nowIndicator: false,
  scrollTime: "06:00:00",
  scrollTimeReset: true,
  slotMinTime: "00:00:00",
  slotMaxTime: "24:00:00",
  showNonCurrentDates: true,
  lazyFetching: true,
  startParam: "start",
  endParam: "end",
  timeZoneParam: "timeZone",
  timeZone: "local",
  locales: [],
  locale: "",
  themeSystem: "standard",
  dragRevertDuration: 500,
  dragScroll: true,
  allDayMaintainDuration: false,
  unselectAuto: true,
  dropAccept: "*",
  eventOrder: "start,-duration,allDay,title",
  dayPopoverFormat: { month: "long", day: "numeric", year: "numeric" },
  handleWindowResize: true,
  windowResizeDelay: 100,
  longPressDelay: 1e3,
  eventDragMinDistance: 5,
  expandRows: false,
  navLinks: false,
  selectable: false,
  eventMinHeight: 15,
  eventMinWidth: 30,
  eventShortHeight: 30,
  monthStartFormat: { month: "long", day: "numeric" }
};
var CALENDAR_LISTENER_REFINERS = {
  datesSet: identity,
  eventsSet: identity,
  eventAdd: identity,
  eventChange: identity,
  eventRemove: identity,
  windowResize: identity,
  eventClick: identity,
  eventMouseEnter: identity,
  eventMouseLeave: identity,
  select: identity,
  unselect: identity,
  loading: identity,
  // internal
  _unmount: identity,
  _beforeprint: identity,
  _afterprint: identity,
  _noEventDrop: identity,
  _noEventResize: identity,
  _resize: identity,
  _scrollRequest: identity
};
var CALENDAR_OPTION_REFINERS = {
  buttonText: identity,
  buttonHints: identity,
  views: identity,
  plugins: identity,
  initialEvents: identity,
  events: identity,
  eventSources: identity
};
var COMPLEX_OPTION_COMPARATORS = {
  headerToolbar: isMaybeObjectsEqual,
  footerToolbar: isMaybeObjectsEqual,
  buttonText: isMaybeObjectsEqual,
  buttonHints: isMaybeObjectsEqual,
  buttonIcons: isMaybeObjectsEqual,
  dateIncrement: isMaybeObjectsEqual,
  plugins: isMaybeArraysEqual,
  events: isMaybeArraysEqual,
  eventSources: isMaybeArraysEqual,
  ["resources"]: isMaybeArraysEqual
};
function isMaybeObjectsEqual(a3, b3) {
  if (typeof a3 === "object" && typeof b3 === "object" && a3 && b3) {
    return isPropsEqual(a3, b3);
  }
  return a3 === b3;
}
function isMaybeArraysEqual(a3, b3) {
  if (Array.isArray(a3) && Array.isArray(b3)) {
    return isArraysEqual(a3, b3);
  }
  return a3 === b3;
}
var VIEW_OPTION_REFINERS = {
  type: String,
  component: identity,
  buttonText: String,
  buttonTextKey: String,
  dateProfileGeneratorClass: identity,
  usesMinMaxTime: Boolean,
  classNames: identity,
  content: identity,
  didMount: identity,
  willUnmount: identity
};
function mergeRawOptions(optionSets) {
  return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);
}
function refineProps(input, refiners) {
  let refined = {};
  let extra = {};
  for (let propName in refiners) {
    if (propName in input) {
      refined[propName] = refiners[propName](input[propName]);
    }
  }
  for (let propName in input) {
    if (!(propName in refiners)) {
      extra[propName] = input[propName];
    }
  }
  return { refined, extra };
}
function identity(raw) {
  return raw;
}
var { hasOwnProperty } = Object.prototype;
function mergeProps(propObjs, complexPropsMap) {
  let dest = {};
  if (complexPropsMap) {
    for (let name in complexPropsMap) {
      if (complexPropsMap[name] === isMaybeObjectsEqual) {
        let complexObjs = [];
        for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
          let val = propObjs[i3][name];
          if (typeof val === "object" && val) {
            complexObjs.unshift(val);
          } else if (val !== void 0) {
            dest[name] = val;
            break;
          }
        }
        if (complexObjs.length) {
          dest[name] = mergeProps(complexObjs);
        }
      }
    }
  }
  for (let i3 = propObjs.length - 1; i3 >= 0; i3 -= 1) {
    let props = propObjs[i3];
    for (let name in props) {
      if (!(name in dest)) {
        dest[name] = props[name];
      }
    }
  }
  return dest;
}
function filterHash(hash, func) {
  let filtered = {};
  for (let key in hash) {
    if (func(hash[key], key)) {
      filtered[key] = hash[key];
    }
  }
  return filtered;
}
function mapHash(hash, func) {
  let newHash = {};
  for (let key in hash) {
    newHash[key] = func(hash[key], key);
  }
  return newHash;
}
function arrayToHash(a3) {
  let hash = {};
  for (let item of a3) {
    hash[item] = true;
  }
  return hash;
}
function hashValuesToArray(obj) {
  let a3 = [];
  for (let key in obj) {
    a3.push(obj[key]);
  }
  return a3;
}
function isPropsEqual(obj0, obj1) {
  if (obj0 === obj1) {
    return true;
  }
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        return false;
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        return false;
      }
    }
  }
  return true;
}
var HANDLER_RE = /^on[A-Z]/;
function isNonHandlerPropsEqual(obj0, obj1) {
  const keys = getUnequalProps(obj0, obj1);
  for (let key of keys) {
    if (!HANDLER_RE.test(key)) {
      return false;
    }
  }
  return true;
}
function getUnequalProps(obj0, obj1) {
  let keys = [];
  for (let key in obj0) {
    if (hasOwnProperty.call(obj0, key)) {
      if (!(key in obj1)) {
        keys.push(key);
      }
    }
  }
  for (let key in obj1) {
    if (hasOwnProperty.call(obj1, key)) {
      if (obj0[key] !== obj1[key]) {
        keys.push(key);
      }
    }
  }
  return keys;
}
function compareObjs(oldProps, newProps, equalityFuncs = {}) {
  if (oldProps === newProps) {
    return true;
  }
  for (let key in newProps) {
    if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key]))
      ;
    else {
      return false;
    }
  }
  for (let key in oldProps) {
    if (!(key in newProps)) {
      return false;
    }
  }
  return true;
}
function isObjValsEqual(val0, val1, comparator) {
  if (val0 === val1 || comparator === true) {
    return true;
  }
  if (comparator) {
    return comparator(val0, val1);
  }
  return false;
}
function collectFromHash(hash, startIndex = 0, endIndex, step = 1) {
  let res = [];
  if (endIndex == null) {
    endIndex = Object.keys(hash).length;
  }
  for (let i3 = startIndex; i3 < endIndex; i3 += step) {
    let val = hash[i3];
    if (val !== void 0) {
      res.push(val);
    }
  }
  return res;
}
var calendarSystemClassMap = {};
function registerCalendarSystem(name, theClass) {
  calendarSystemClassMap[name] = theClass;
}
function createCalendarSystem(name) {
  return new calendarSystemClassMap[name]();
}
var GregorianCalendarSystem = class {
  getMarkerYear(d2) {
    return d2.getUTCFullYear();
  }
  getMarkerMonth(d2) {
    return d2.getUTCMonth();
  }
  getMarkerDay(d2) {
    return d2.getUTCDate();
  }
  arrayToMarker(arr) {
    return arrayToUtcDate(arr);
  }
  markerToArray(marker) {
    return dateToUtcArray(marker);
  }
};
registerCalendarSystem("gregory", GregorianCalendarSystem);
var ISO_RE = /^\s*(\d{4})(-?(\d{2})(-?(\d{2})([T ](\d{2}):?(\d{2})(:?(\d{2})(\.(\d+))?)?(Z|(([-+])(\d{2})(:?(\d{2}))?))?)?)?)?$/;
function parse(str) {
  let m3 = ISO_RE.exec(str);
  if (m3) {
    let marker = new Date(Date.UTC(Number(m3[1]), m3[3] ? Number(m3[3]) - 1 : 0, Number(m3[5] || 1), Number(m3[7] || 0), Number(m3[8] || 0), Number(m3[10] || 0), m3[12] ? Number(`0.${m3[12]}`) * 1e3 : 0));
    if (isValidDate(marker)) {
      let timeZoneOffset = null;
      if (m3[13]) {
        timeZoneOffset = (m3[15] === "-" ? -1 : 1) * (Number(m3[16] || 0) * 60 + Number(m3[18] || 0));
      }
      return {
        marker,
        isTimeUnspecified: !m3[6],
        timeZoneOffset
      };
    }
  }
  return null;
}
var DateEnv = class {
  constructor(settings) {
    let timeZone = this.timeZone = settings.timeZone;
    let isNamedTimeZone = timeZone !== "local" && timeZone !== "UTC";
    if (settings.namedTimeZoneImpl && isNamedTimeZone) {
      this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);
    }
    this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);
    this.calendarSystem = createCalendarSystem(settings.calendarSystem);
    this.locale = settings.locale;
    this.weekDow = settings.locale.week.dow;
    this.weekDoy = settings.locale.week.doy;
    if (settings.weekNumberCalculation === "ISO") {
      this.weekDow = 1;
      this.weekDoy = 4;
    }
    if (typeof settings.firstDay === "number") {
      this.weekDow = settings.firstDay;
    }
    if (typeof settings.weekNumberCalculation === "function") {
      this.weekNumberFunc = settings.weekNumberCalculation;
    }
    this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;
    this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;
    this.cmdFormatter = settings.cmdFormatter;
    this.defaultSeparator = settings.defaultSeparator;
  }
  // Creating / Parsing
  createMarker(input) {
    let meta = this.createMarkerMeta(input);
    if (meta === null) {
      return null;
    }
    return meta.marker;
  }
  createNowMarker() {
    if (this.canComputeOffset) {
      return this.timestampToMarker(new Date().valueOf());
    }
    return arrayToUtcDate(dateToLocalArray(new Date()));
  }
  createMarkerMeta(input) {
    if (typeof input === "string") {
      return this.parse(input);
    }
    let marker = null;
    if (typeof input === "number") {
      marker = this.timestampToMarker(input);
    } else if (input instanceof Date) {
      input = input.valueOf();
      if (!isNaN(input)) {
        marker = this.timestampToMarker(input);
      }
    } else if (Array.isArray(input)) {
      marker = arrayToUtcDate(input);
    }
    if (marker === null || !isValidDate(marker)) {
      return null;
    }
    return { marker, isTimeUnspecified: false, forcedTzo: null };
  }
  parse(s3) {
    let parts = parse(s3);
    if (parts === null) {
      return null;
    }
    let { marker } = parts;
    let forcedTzo = null;
    if (parts.timeZoneOffset !== null) {
      if (this.canComputeOffset) {
        marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1e3);
      } else {
        forcedTzo = parts.timeZoneOffset;
      }
    }
    return { marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo };
  }
  // Accessors
  getYear(marker) {
    return this.calendarSystem.getMarkerYear(marker);
  }
  getMonth(marker) {
    return this.calendarSystem.getMarkerMonth(marker);
  }
  getDay(marker) {
    return this.calendarSystem.getMarkerDay(marker);
  }
  // Adding / Subtracting
  add(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += dur.years;
    a3[1] += dur.months;
    a3[2] += dur.days;
    a3[6] += dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  subtract(marker, dur) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] -= dur.years;
    a3[1] -= dur.months;
    a3[2] -= dur.days;
    a3[6] -= dur.milliseconds;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addYears(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[0] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  addMonths(marker, n2) {
    let a3 = this.calendarSystem.markerToArray(marker);
    a3[1] += n2;
    return this.calendarSystem.arrayToMarker(a3);
  }
  // Diffing Whole Units
  diffWholeYears(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {
      return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);
    }
    return null;
  }
  diffWholeMonths(m0, m1) {
    let { calendarSystem } = this;
    if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {
      return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;
    }
    return null;
  }
  // Range / Duration
  greatestWholeUnit(m0, m1) {
    let n2 = this.diffWholeYears(m0, m1);
    if (n2 !== null) {
      return { unit: "year", value: n2 };
    }
    n2 = this.diffWholeMonths(m0, m1);
    if (n2 !== null) {
      return { unit: "month", value: n2 };
    }
    n2 = diffWholeWeeks(m0, m1);
    if (n2 !== null) {
      return { unit: "week", value: n2 };
    }
    n2 = diffWholeDays(m0, m1);
    if (n2 !== null) {
      return { unit: "day", value: n2 };
    }
    n2 = diffHours(m0, m1);
    if (isInt(n2)) {
      return { unit: "hour", value: n2 };
    }
    n2 = diffMinutes(m0, m1);
    if (isInt(n2)) {
      return { unit: "minute", value: n2 };
    }
    n2 = diffSeconds(m0, m1);
    if (isInt(n2)) {
      return { unit: "second", value: n2 };
    }
    return { unit: "millisecond", value: m1.valueOf() - m0.valueOf() };
  }
  countDurationsBetween(m0, m1, d2) {
    let diff;
    if (d2.years) {
      diff = this.diffWholeYears(m0, m1);
      if (diff !== null) {
        return diff / asRoughYears(d2);
      }
    }
    if (d2.months) {
      diff = this.diffWholeMonths(m0, m1);
      if (diff !== null) {
        return diff / asRoughMonths(d2);
      }
    }
    if (d2.days) {
      diff = diffWholeDays(m0, m1);
      if (diff !== null) {
        return diff / asRoughDays(d2);
      }
    }
    return (m1.valueOf() - m0.valueOf()) / asRoughMs(d2);
  }
  // Start-Of
  // these DON'T return zoned-dates. only UTC start-of dates
  startOf(m3, unit) {
    if (unit === "year") {
      return this.startOfYear(m3);
    }
    if (unit === "month") {
      return this.startOfMonth(m3);
    }
    if (unit === "week") {
      return this.startOfWeek(m3);
    }
    if (unit === "day") {
      return startOfDay(m3);
    }
    if (unit === "hour") {
      return startOfHour(m3);
    }
    if (unit === "minute") {
      return startOfMinute(m3);
    }
    if (unit === "second") {
      return startOfSecond(m3);
    }
    return null;
  }
  startOfYear(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3)
    ]);
  }
  startOfMonth(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3)
    ]);
  }
  startOfWeek(m3) {
    return this.calendarSystem.arrayToMarker([
      this.calendarSystem.getMarkerYear(m3),
      this.calendarSystem.getMarkerMonth(m3),
      m3.getUTCDate() - (m3.getUTCDay() - this.weekDow + 7) % 7
    ]);
  }
  // Week Number
  computeWeekNumber(marker) {
    if (this.weekNumberFunc) {
      return this.weekNumberFunc(this.toDate(marker));
    }
    return weekOfYear(marker, this.weekDow, this.weekDoy);
  }
  // TODO: choke on timeZoneName: long
  format(marker, formatter, dateOptions = {}) {
    return formatter.format({
      marker,
      timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)
    }, this);
  }
  formatRange(start, end, formatter, dateOptions = {}) {
    if (dateOptions.isEndExclusive) {
      end = addMs(end, -1);
    }
    return formatter.formatRange({
      marker: start,
      timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)
    }, {
      marker: end,
      timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)
    }, this, dateOptions.defaultSeparator);
  }
  /*
  DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,
  might as well use buildIsoString or some other util directly
  */
  formatIso(marker, extraOptions = {}) {
    let timeZoneOffset = null;
    if (!extraOptions.omitTimeZoneOffset) {
      if (extraOptions.forcedTzo != null) {
        timeZoneOffset = extraOptions.forcedTzo;
      } else {
        timeZoneOffset = this.offsetForMarker(marker);
      }
    }
    return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);
  }
  // TimeZone
  timestampToMarker(ms) {
    if (this.timeZone === "local") {
      return arrayToUtcDate(dateToLocalArray(new Date(ms)));
    }
    if (this.timeZone === "UTC" || !this.namedTimeZoneImpl) {
      return new Date(ms);
    }
    return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));
  }
  offsetForMarker(m3) {
    if (this.timeZone === "local") {
      return -arrayToLocalDate(dateToUtcArray(m3)).getTimezoneOffset();
    }
    if (this.timeZone === "UTC") {
      return 0;
    }
    if (this.namedTimeZoneImpl) {
      return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3));
    }
    return null;
  }
  // Conversion
  toDate(m3, forcedTzo) {
    if (this.timeZone === "local") {
      return arrayToLocalDate(dateToUtcArray(m3));
    }
    if (this.timeZone === "UTC") {
      return new Date(m3.valueOf());
    }
    if (!this.namedTimeZoneImpl) {
      return new Date(m3.valueOf() - (forcedTzo || 0));
    }
    return new Date(m3.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m3)) * 1e3 * 60);
  }
};
var Theme = class {
  constructor(calendarOptions) {
    if (this.iconOverrideOption) {
      this.setIconOverride(calendarOptions[this.iconOverrideOption]);
    }
  }
  setIconOverride(iconOverrideHash) {
    let iconClassesCopy;
    let buttonName;
    if (typeof iconOverrideHash === "object" && iconOverrideHash) {
      iconClassesCopy = Object.assign({}, this.iconClasses);
      for (buttonName in iconOverrideHash) {
        iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
      }
      this.iconClasses = iconClassesCopy;
    } else if (iconOverrideHash === false) {
      this.iconClasses = {};
    }
  }
  applyIconOverridePrefix(className) {
    let prefix = this.iconOverridePrefix;
    if (prefix && className.indexOf(prefix) !== 0) {
      className = prefix + className;
    }
    return className;
  }
  getClass(key) {
    return this.classes[key] || "";
  }
  getIconClass(buttonName, isRtl) {
    let className;
    if (isRtl && this.rtlIconClasses) {
      className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];
    } else {
      className = this.iconClasses[buttonName];
    }
    if (className) {
      return `${this.baseIconClass} ${className}`;
    }
    return "";
  }
  getCustomButtonIconClass(customButtonProps) {
    let className;
    if (this.iconOverrideCustomButtonOption) {
      className = customButtonProps[this.iconOverrideCustomButtonOption];
      if (className) {
        return `${this.baseIconClass} ${this.applyIconOverridePrefix(className)}`;
      }
    }
    return "";
  }
};
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = "";
Theme.prototype.iconOverridePrefix = "";
function flushSync(runBeforeFlush) {
  runBeforeFlush();
  let oldDebounceRendering = l.debounceRendering;
  let callbackQ = [];
  function execCallbackSync(callback) {
    callbackQ.push(callback);
  }
  l.debounceRendering = execCallbackSync;
  D(y(FakeComponent, {}), document.createElement("div"));
  while (callbackQ.length) {
    callbackQ.shift()();
  }
  l.debounceRendering = oldDebounceRendering;
}
var FakeComponent = class extends x {
  render() {
    return y("div", {});
  }
  componentDidMount() {
    this.setState({});
  }
};
function createContext(defaultValue) {
  let ContextType = G(defaultValue);
  let origProvider = ContextType.Provider;
  ContextType.Provider = function() {
    let isNew = !this.getChildContext;
    let children = origProvider.apply(this, arguments);
    if (isNew) {
      let subs = [];
      this.shouldComponentUpdate = (_props) => {
        if (this.props.value !== _props.value) {
          subs.forEach((c3) => {
            c3.context = _props.value;
            c3.forceUpdate();
          });
        }
      };
      this.sub = (c3) => {
        subs.push(c3);
        let old = c3.componentWillUnmount;
        c3.componentWillUnmount = () => {
          subs.splice(subs.indexOf(c3), 1);
          old && old.call(c3);
        };
      };
    }
    return children;
  };
  return ContextType;
}
var ScrollResponder = class {
  constructor(execFunc, emitter, scrollTime, scrollTimeReset) {
    this.execFunc = execFunc;
    this.emitter = emitter;
    this.scrollTime = scrollTime;
    this.scrollTimeReset = scrollTimeReset;
    this.handleScrollRequest = (request) => {
      this.queuedRequest = Object.assign({}, this.queuedRequest || {}, request);
      this.drain();
    };
    emitter.on("_scrollRequest", this.handleScrollRequest);
    this.fireInitialScroll();
  }
  detach() {
    this.emitter.off("_scrollRequest", this.handleScrollRequest);
  }
  update(isDatesNew) {
    if (isDatesNew && this.scrollTimeReset) {
      this.fireInitialScroll();
    } else {
      this.drain();
    }
  }
  fireInitialScroll() {
    this.handleScrollRequest({
      time: this.scrollTime
    });
  }
  drain() {
    if (this.queuedRequest && this.execFunc(this.queuedRequest)) {
      this.queuedRequest = null;
    }
  }
};
var ViewContextType = createContext({});
function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {
  return {
    dateEnv,
    options: viewOptions,
    pluginHooks,
    emitter,
    dispatch,
    getCurrentData,
    calendarApi,
    viewSpec,
    viewApi,
    dateProfileGenerator,
    theme,
    isRtl: viewOptions.direction === "rtl",
    addResizeHandler(handler) {
      emitter.on("_resize", handler);
    },
    removeResizeHandler(handler) {
      emitter.off("_resize", handler);
    },
    createScrollResponder(execFunc) {
      return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);
    },
    registerInteractiveComponent,
    unregisterInteractiveComponent
  };
}
var PureComponent = class extends x {
  shouldComponentUpdate(nextProps, nextState) {
    if (this.debug) {
      console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));
    }
    return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);
  }
  // HACK for freakin' React StrictMode
  safeSetState(newState) {
    if (!compareObjs(this.state, Object.assign(Object.assign({}, this.state), newState), this.stateEquality)) {
      this.setState(newState);
    }
  }
};
PureComponent.addPropsEquality = addPropsEquality;
PureComponent.addStateEquality = addStateEquality;
PureComponent.contextType = ViewContextType;
PureComponent.prototype.propEquality = {};
PureComponent.prototype.stateEquality = {};
var BaseComponent = class extends PureComponent {
};
BaseComponent.contextType = ViewContextType;
function addPropsEquality(propEquality) {
  let hash = Object.create(this.prototype.propEquality);
  Object.assign(hash, propEquality);
  this.prototype.propEquality = hash;
}
function addStateEquality(stateEquality) {
  let hash = Object.create(this.prototype.stateEquality);
  Object.assign(hash, stateEquality);
  this.prototype.stateEquality = hash;
}
function setRef(ref, current) {
  if (typeof ref === "function") {
    ref(current);
  } else if (ref) {
    ref.current = current;
  }
}
var ContentInjector = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.id = guid();
    this.queuedDomNodes = [];
    this.currentDomNodes = [];
    this.handleEl = (el) => {
      const { options } = this.context;
      const { generatorName } = this.props;
      if (!options.customRenderingReplaces || !hasCustomRenderingHandler(generatorName, options)) {
        this.updateElRef(el);
      }
    };
    this.updateElRef = (el) => {
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { customGenerator, defaultGenerator, renderProps } = props;
    const attrs = buildElAttrs(props, [], this.handleEl);
    let useDefault = false;
    let innerContent;
    let queuedDomNodes = [];
    let currentGeneratorMeta;
    if (customGenerator != null) {
      const customGeneratorRes = typeof customGenerator === "function" ? customGenerator(renderProps, y) : customGenerator;
      if (customGeneratorRes === true) {
        useDefault = true;
      } else {
        const isObject2 = customGeneratorRes && typeof customGeneratorRes === "object";
        if (isObject2 && "html" in customGeneratorRes) {
          attrs.dangerouslySetInnerHTML = { __html: customGeneratorRes.html };
        } else if (isObject2 && "domNodes" in customGeneratorRes) {
          queuedDomNodes = Array.prototype.slice.call(customGeneratorRes.domNodes);
        } else if (isObject2 ? i(customGeneratorRes) : typeof customGeneratorRes !== "function") {
          innerContent = customGeneratorRes;
        } else {
          currentGeneratorMeta = customGeneratorRes;
        }
      }
    } else {
      useDefault = !hasCustomRenderingHandler(props.generatorName, options);
    }
    if (useDefault && defaultGenerator) {
      innerContent = defaultGenerator(renderProps);
    }
    this.queuedDomNodes = queuedDomNodes;
    this.currentGeneratorMeta = currentGeneratorMeta;
    return y(props.elTag, attrs, innerContent);
  }
  componentDidMount() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentDidUpdate() {
    this.applyQueueudDomNodes();
    this.triggerCustomRendering(true);
  }
  componentWillUnmount() {
    this.triggerCustomRendering(false);
  }
  triggerCustomRendering(isActive) {
    var _a;
    const { props, context } = this;
    const { handleCustomRendering, customRenderingMetaMap } = context.options;
    if (handleCustomRendering) {
      const generatorMeta = (_a = this.currentGeneratorMeta) !== null && _a !== void 0 ? _a : customRenderingMetaMap === null || customRenderingMetaMap === void 0 ? void 0 : customRenderingMetaMap[props.generatorName];
      if (generatorMeta) {
        handleCustomRendering(Object.assign(Object.assign({
          id: this.id,
          isActive,
          containerEl: this.base,
          reportNewContainerEl: this.updateElRef,
          // front-end framework tells us about new container els
          generatorMeta
        }, props), { elClasses: (props.elClasses || []).filter(isTruthy) }));
      }
    }
  }
  applyQueueudDomNodes() {
    const { queuedDomNodes, currentDomNodes } = this;
    const el = this.base;
    if (!isArraysEqual(queuedDomNodes, currentDomNodes)) {
      currentDomNodes.forEach(removeElement);
      for (let newNode of queuedDomNodes) {
        el.appendChild(newNode);
      }
      this.currentDomNodes = queuedDomNodes;
    }
  }
};
ContentInjector.addPropsEquality({
  elClasses: isArraysEqual,
  elStyle: isPropsEqual,
  elAttrs: isNonHandlerPropsEqual,
  renderProps: isPropsEqual
});
function hasCustomRenderingHandler(generatorName, options) {
  var _a;
  return Boolean(options.handleCustomRendering && generatorName && ((_a = options.customRenderingMetaMap) === null || _a === void 0 ? void 0 : _a[generatorName]));
}
function buildElAttrs(props, extraClassNames, elRef) {
  const attrs = Object.assign(Object.assign({}, props.elAttrs), { ref: elRef });
  if (props.elClasses || extraClassNames) {
    attrs.className = (props.elClasses || []).concat(extraClassNames || []).concat(attrs.className || []).filter(Boolean).join(" ");
  }
  if (props.elStyle) {
    attrs.style = props.elStyle;
  }
  return attrs;
}
function isTruthy(val) {
  return Boolean(val);
}
var RenderId = createContext(0);
var ContentContainer = class extends x {
  constructor() {
    super(...arguments);
    this.InnerContent = InnerContentInjector.bind(void 0, this);
    this.handleEl = (el) => {
      this.el = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
        if (el && this.didMountMisfire) {
          this.componentDidMount();
        }
      }
    };
  }
  render() {
    const { props } = this;
    const generatedClassNames = generateClassNames(props.classNameGenerator, props.renderProps);
    if (props.children) {
      const elAttrs = buildElAttrs(props, generatedClassNames, this.handleEl);
      const children = props.children(this.InnerContent, props.renderProps, elAttrs);
      if (props.elTag) {
        return y(props.elTag, elAttrs, children);
      } else {
        return children;
      }
    } else {
      return y(ContentInjector, Object.assign(Object.assign({}, props), { elRef: this.handleEl, elTag: props.elTag || "div", elClasses: (props.elClasses || []).concat(generatedClassNames), renderId: this.context }));
    }
  }
  componentDidMount() {
    var _a, _b;
    if (this.el) {
      (_b = (_a = this.props).didMount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
    } else {
      this.didMountMisfire = true;
    }
  }
  componentWillUnmount() {
    var _a, _b;
    (_b = (_a = this.props).willUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, Object.assign(Object.assign({}, this.props.renderProps), { el: this.el }));
  }
};
ContentContainer.contextType = RenderId;
function InnerContentInjector(containerComponent, props) {
  const parentProps = containerComponent.props;
  return y(ContentInjector, Object.assign({ renderProps: parentProps.renderProps, generatorName: parentProps.generatorName, customGenerator: parentProps.customGenerator, defaultGenerator: parentProps.defaultGenerator, renderId: containerComponent.context }, props));
}
function generateClassNames(classNameGenerator, renderProps) {
  const classNames = typeof classNameGenerator === "function" ? classNameGenerator(renderProps) : classNameGenerator || [];
  return typeof classNames === "string" ? [classNames] : classNames;
}
var ViewContainer = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = { view: context.viewApi };
    return y(ContentContainer, Object.assign({}, props, { elTag: props.elTag || "div", elClasses: [
      ...buildViewClassNames(props.viewSpec),
      ...props.elClasses || []
    ], renderProps, classNameGenerator: options.viewClassNames, generatorName: void 0, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount }), () => props.children);
  }
};
function buildViewClassNames(viewSpec) {
  return [
    `fc-${viewSpec.type}-view`,
    "fc-view"
  ];
}
function parseRange(input, dateEnv) {
  let start = null;
  let end = null;
  if (input.start) {
    start = dateEnv.createMarker(input.start);
  }
  if (input.end) {
    end = dateEnv.createMarker(input.end);
  }
  if (!start && !end) {
    return null;
  }
  if (start && end && end < start) {
    return null;
  }
  return { start, end };
}
function invertRanges(ranges, constraintRange) {
  let invertedRanges = [];
  let { start } = constraintRange;
  let i3;
  let dateRange;
  ranges.sort(compareRanges);
  for (i3 = 0; i3 < ranges.length; i3 += 1) {
    dateRange = ranges[i3];
    if (dateRange.start > start) {
      invertedRanges.push({ start, end: dateRange.start });
    }
    if (dateRange.end > start) {
      start = dateRange.end;
    }
  }
  if (start < constraintRange.end) {
    invertedRanges.push({ start, end: constraintRange.end });
  }
  return invertedRanges;
}
function compareRanges(range0, range1) {
  return range0.start.valueOf() - range1.start.valueOf();
}
function intersectRanges(range0, range1) {
  let { start, end } = range0;
  let newRange = null;
  if (range1.start !== null) {
    if (start === null) {
      start = range1.start;
    } else {
      start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));
    }
  }
  if (range1.end != null) {
    if (end === null) {
      end = range1.end;
    } else {
      end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));
    }
  }
  if (start === null || end === null || start < end) {
    newRange = { start, end };
  }
  return newRange;
}
function rangesEqual(range0, range1) {
  return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());
}
function rangesIntersect(range0, range1) {
  return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);
}
function rangeContainsRange(outerRange, innerRange) {
  return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);
}
function rangeContainsMarker(range2, date) {
  return (range2.start === null || date >= range2.start) && (range2.end === null || date < range2.end);
}
function constrainMarkerToRange(date, range2) {
  if (range2.start != null && date < range2.start) {
    return range2.start;
  }
  if (range2.end != null && date >= range2.end) {
    return new Date(range2.end.valueOf() - 1);
  }
  return date;
}
function computeAlignedDayRange(timedRange) {
  let dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;
  let start = startOfDay(timedRange.start);
  let end = addDays(start, dayCnt);
  return { start, end };
}
function computeVisibleDayRange(timedRange, nextDayThreshold = createDuration(0)) {
  let startDay = null;
  let endDay = null;
  if (timedRange.end) {
    endDay = startOfDay(timedRange.end);
    let endTimeMS = timedRange.end.valueOf() - endDay.valueOf();
    if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {
      endDay = addDays(endDay, 1);
    }
  }
  if (timedRange.start) {
    startDay = startOfDay(timedRange.start);
    if (endDay && endDay <= startDay) {
      endDay = addDays(startDay, 1);
    }
  }
  return { start: startDay, end: endDay };
}
function isMultiDayRange(range2) {
  let visibleRange = computeVisibleDayRange(range2);
  return diffDays(visibleRange.start, visibleRange.end) > 1;
}
function diffDates(date0, date1, dateEnv, largeUnit) {
  if (largeUnit === "year") {
    return createDuration(dateEnv.diffWholeYears(date0, date1), "year");
  }
  if (largeUnit === "month") {
    return createDuration(dateEnv.diffWholeMonths(date0, date1), "month");
  }
  return diffDayAndTime(date0, date1);
}
function reduceCurrentDate(currentDate, action) {
  switch (action.type) {
    case "CHANGE_DATE":
      return action.dateMarker;
    default:
      return currentDate;
  }
}
function getInitialDate(options, dateEnv) {
  let initialDateInput = options.initialDate;
  if (initialDateInput != null) {
    return dateEnv.createMarker(initialDateInput);
  }
  return getNow(options.now, dateEnv);
}
function getNow(nowInput, dateEnv) {
  if (typeof nowInput === "function") {
    nowInput = nowInput();
  }
  if (nowInput == null) {
    return dateEnv.createNowMarker();
  }
  return dateEnv.createMarker(nowInput);
}
var DateProfileGenerator = class {
  constructor(props) {
    this.props = props;
    this.nowDate = getNow(props.nowInput, props.dateEnv);
    this.initHiddenDays();
  }
  /* Date Range Computation
  ------------------------------------------------------------------------------------------------------------------*/
  // Builds a structure with info about what the dates/ranges will be for the "prev" view.
  buildPrev(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let prevDate = dateEnv.subtract(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(prevDate, -1, forceToValid);
  }
  // Builds a structure with info about what the dates/ranges will be for the "next" view.
  buildNext(currentDateProfile, currentDate, forceToValid) {
    let { dateEnv } = this.props;
    let nextDate = dateEnv.add(
      dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit),
      // important for start-of-month
      currentDateProfile.dateIncrement
    );
    return this.build(nextDate, 1, forceToValid);
  }
  // Builds a structure holding dates/ranges for rendering around the given date.
  // Optional direction param indicates whether the date is being incremented/decremented
  // from its previous value. decremented = -1, incremented = 1 (default).
  build(currentDate, direction, forceToValid = true) {
    let { props } = this;
    let validRange;
    let currentInfo;
    let isRangeAllDay;
    let renderRange;
    let activeRange;
    let isValid;
    validRange = this.buildValidRange();
    validRange = this.trimHiddenDays(validRange);
    if (forceToValid) {
      currentDate = constrainMarkerToRange(currentDate, validRange);
    }
    currentInfo = this.buildCurrentRangeInfo(currentDate, direction);
    isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
    renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);
    renderRange = this.trimHiddenDays(renderRange);
    activeRange = renderRange;
    if (!props.showNonCurrentDates) {
      activeRange = intersectRanges(activeRange, currentInfo.range);
    }
    activeRange = this.adjustActiveRange(activeRange);
    activeRange = intersectRanges(activeRange, validRange);
    isValid = rangesIntersect(currentInfo.range, validRange);
    if (!rangeContainsMarker(renderRange, currentDate)) {
      currentDate = renderRange.start;
    }
    return {
      currentDate,
      // constraint for where prev/next operations can go and where events can be dragged/resized to.
      // an object with optional start and end properties.
      validRange,
      // range the view is formally responsible for.
      // for example, a month view might have 1st-31st, excluding padded dates
      currentRange: currentInfo.range,
      // name of largest unit being displayed, like "month" or "week"
      currentRangeUnit: currentInfo.unit,
      isRangeAllDay,
      // dates that display events and accept drag-n-drop
      // will be `null` if no dates accept events
      activeRange,
      // date range with a rendered skeleton
      // includes not-active days that need some sort of DOM
      renderRange,
      // Duration object that denotes the first visible time of any given day
      slotMinTime: props.slotMinTime,
      // Duration object that denotes the exclusive visible end time of any given day
      slotMaxTime: props.slotMaxTime,
      isValid,
      // how far the current date will move for a prev/next operation
      dateIncrement: this.buildDateIncrement(currentInfo.duration)
      // pass a fallback (might be null) ^
    };
  }
  // Builds an object with optional start/end properties.
  // Indicates the minimum/maximum dates to display.
  // not responsible for trimming hidden days.
  buildValidRange() {
    let input = this.props.validRangeInput;
    let simpleInput = typeof input === "function" ? input.call(this.props.calendarApi, this.nowDate) : input;
    return this.refineRange(simpleInput) || { start: null, end: null };
  }
  // Builds a structure with info about the "current" range, the range that is
  // highlighted as being the current month for example.
  // See build() for a description of `direction`.
  // Guaranteed to have `range` and `unit` properties. `duration` is optional.
  buildCurrentRangeInfo(date, direction) {
    let { props } = this;
    let duration = null;
    let unit = null;
    let range2 = null;
    let dayCount;
    if (props.duration) {
      duration = props.duration;
      unit = props.durationUnit;
      range2 = this.buildRangeFromDuration(date, direction, duration, unit);
    } else if (dayCount = this.props.dayCount) {
      unit = "day";
      range2 = this.buildRangeFromDayCount(date, direction, dayCount);
    } else if (range2 = this.buildCustomVisibleRange(date)) {
      unit = props.dateEnv.greatestWholeUnit(range2.start, range2.end).unit;
    } else {
      duration = this.getFallbackDuration();
      unit = greatestDurationDenominator(duration).unit;
      range2 = this.buildRangeFromDuration(date, direction, duration, unit);
    }
    return { duration, unit, range: range2 };
  }
  getFallbackDuration() {
    return createDuration({ day: 1 });
  }
  // Returns a new activeRange to have time values (un-ambiguate)
  // slotMinTime or slotMaxTime causes the range to expand.
  adjustActiveRange(range2) {
    let { dateEnv, usesMinMaxTime, slotMinTime, slotMaxTime } = this.props;
    let { start, end } = range2;
    if (usesMinMaxTime) {
      if (asRoughDays(slotMinTime) < 0) {
        start = startOfDay(start);
        start = dateEnv.add(start, slotMinTime);
      }
      if (asRoughDays(slotMaxTime) > 1) {
        end = startOfDay(end);
        end = addDays(end, -1);
        end = dateEnv.add(end, slotMaxTime);
      }
    }
    return { start, end };
  }
  // Builds the "current" range when it is specified as an explicit duration.
  // `unit` is the already-computed greatestDurationDenominator unit of duration.
  buildRangeFromDuration(date, direction, duration, unit) {
    let { dateEnv, dateAlignment } = this.props;
    let start;
    let end;
    let res;
    if (!dateAlignment) {
      let { dateIncrement } = this.props;
      if (dateIncrement) {
        if (asRoughMs(dateIncrement) < asRoughMs(duration)) {
          dateAlignment = greatestDurationDenominator(dateIncrement).unit;
        } else {
          dateAlignment = unit;
        }
      } else {
        dateAlignment = unit;
      }
    }
    if (asRoughDays(duration) <= 1) {
      if (this.isHiddenDay(start)) {
        start = this.skipHiddenDays(start, direction);
        start = startOfDay(start);
      }
    }
    function computeRes() {
      start = dateEnv.startOf(date, dateAlignment);
      end = dateEnv.add(start, duration);
      res = { start, end };
    }
    computeRes();
    if (!this.trimHiddenDays(res)) {
      date = this.skipHiddenDays(date, direction);
      computeRes();
    }
    return res;
  }
  // Builds the "current" range when a dayCount is specified.
  buildRangeFromDayCount(date, direction, dayCount) {
    let { dateEnv, dateAlignment } = this.props;
    let runningCount = 0;
    let start = date;
    let end;
    if (dateAlignment) {
      start = dateEnv.startOf(start, dateAlignment);
    }
    start = startOfDay(start);
    start = this.skipHiddenDays(start, direction);
    end = start;
    do {
      end = addDays(end, 1);
      if (!this.isHiddenDay(end)) {
        runningCount += 1;
      }
    } while (runningCount < dayCount);
    return { start, end };
  }
  // Builds a normalized range object for the "visible" range,
  // which is a way to define the currentRange and activeRange at the same time.
  buildCustomVisibleRange(date) {
    let { props } = this;
    let input = props.visibleRangeInput;
    let simpleInput = typeof input === "function" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;
    let range2 = this.refineRange(simpleInput);
    if (range2 && (range2.start == null || range2.end == null)) {
      return null;
    }
    return range2;
  }
  // Computes the range that will represent the element/cells for *rendering*,
  // but which may have voided days/times.
  // not responsible for trimming hidden days.
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    return currentRange;
  }
  // Compute the duration value that should be added/substracted to the current date
  // when a prev/next operation happens.
  buildDateIncrement(fallback) {
    let { dateIncrement } = this.props;
    let customAlignment;
    if (dateIncrement) {
      return dateIncrement;
    }
    if (customAlignment = this.props.dateAlignment) {
      return createDuration(1, customAlignment);
    }
    if (fallback) {
      return fallback;
    }
    return createDuration({ days: 1 });
  }
  refineRange(rangeInput) {
    if (rangeInput) {
      let range2 = parseRange(rangeInput, this.props.dateEnv);
      if (range2) {
        range2 = computeVisibleDayRange(range2);
      }
      return range2;
    }
    return null;
  }
  /* Hidden Days
  ------------------------------------------------------------------------------------------------------------------*/
  // Initializes internal variables related to calculating hidden days-of-week
  initHiddenDays() {
    let hiddenDays = this.props.hiddenDays || [];
    let isHiddenDayHash = [];
    let dayCnt = 0;
    let i3;
    if (this.props.weekends === false) {
      hiddenDays.push(0, 6);
    }
    for (i3 = 0; i3 < 7; i3 += 1) {
      if (!(isHiddenDayHash[i3] = hiddenDays.indexOf(i3) !== -1)) {
        dayCnt += 1;
      }
    }
    if (!dayCnt) {
      throw new Error("invalid hiddenDays");
    }
    this.isHiddenDayHash = isHiddenDayHash;
  }
  // Remove days from the beginning and end of the range that are computed as hidden.
  // If the whole range is trimmed off, returns null
  trimHiddenDays(range2) {
    let { start, end } = range2;
    if (start) {
      start = this.skipHiddenDays(start);
    }
    if (end) {
      end = this.skipHiddenDays(end, -1, true);
    }
    if (start == null || end == null || start < end) {
      return { start, end };
    }
    return null;
  }
  // Is the current day hidden?
  // `day` is a day-of-week index (0-6), or a Date (used for UTC)
  isHiddenDay(day) {
    if (day instanceof Date) {
      day = day.getUTCDay();
    }
    return this.isHiddenDayHash[day];
  }
  // Incrementing the current day until it is no longer a hidden day, returning a copy.
  // DOES NOT CONSIDER validRange!
  // If the initial value of `date` is not a hidden day, don't do anything.
  // Pass `isExclusive` as `true` if you are dealing with an end date.
  // `inc` defaults to `1` (increment one day forward each time)
  skipHiddenDays(date, inc = 1, isExclusive = false) {
    while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {
      date = addDays(date, inc);
    }
    return date;
  }
};
function createEventInstance(defId, range2, forcedStartTzo, forcedEndTzo) {
  return {
    instanceId: guid(),
    defId,
    range: range2,
    forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,
    forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo
  };
}
function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {
  for (let i3 = 0; i3 < recurringTypes.length; i3 += 1) {
    let parsed = recurringTypes[i3].parse(refined, dateEnv);
    if (parsed) {
      let { allDay } = refined;
      if (allDay == null) {
        allDay = defaultAllDay;
        if (allDay == null) {
          allDay = parsed.allDayGuess;
          if (allDay == null) {
            allDay = false;
          }
        }
      }
      return {
        allDay,
        duration: parsed.duration,
        typeData: parsed.typeData,
        typeId: i3
      };
    }
  }
  return null;
}
function expandRecurring(eventStore, framingRange, context) {
  let { dateEnv, pluginHooks, options } = context;
  let { defs, instances } = eventStore;
  instances = filterHash(instances, (instance) => !defs[instance.defId].recurringDef);
  for (let defId in defs) {
    let def = defs[defId];
    if (def.recurringDef) {
      let { duration } = def.recurringDef;
      if (!duration) {
        duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;
      }
      let starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);
      for (let start of starts) {
        let instance = createEventInstance(defId, {
          start,
          end: dateEnv.add(start, duration)
        });
        instances[instance.instanceId] = instance;
      }
    }
  }
  return { defs, instances };
}
function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {
  let typeDef = recurringTypes[eventDef.recurringDef.typeId];
  let markers = typeDef.expand(eventDef.recurringDef.typeData, {
    start: dateEnv.subtract(framingRange.start, duration),
    end: framingRange.end
  }, dateEnv);
  if (eventDef.allDay) {
    markers = markers.map(startOfDay);
  }
  return markers;
}
var EVENT_NON_DATE_REFINERS = {
  id: String,
  groupId: String,
  title: String,
  url: String,
  interactive: Boolean
};
var EVENT_DATE_REFINERS = {
  start: identity,
  end: identity,
  date: identity,
  allDay: Boolean
};
var EVENT_REFINERS = Object.assign(Object.assign(Object.assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity });
function parseEvent(raw, eventSource, context, allowOpenRange, refiners = buildEventRefiners(context), defIdMap, instanceIdMap) {
  let { refined, extra } = refineEventDef(raw, context, refiners);
  let defaultAllDay = computeIsDefaultAllDay(eventSource, context);
  let recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);
  if (recurringRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", recurringRes.allDay, Boolean(recurringRes.duration), context, defIdMap);
    def.recurringDef = {
      typeId: recurringRes.typeId,
      typeData: recurringRes.typeData,
      duration: recurringRes.duration
    };
    return { def, instance: null };
  }
  let singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);
  if (singleRes) {
    let def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : "", singleRes.allDay, singleRes.hasEnd, context, defIdMap);
    let instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);
    if (instanceIdMap && def.publicId && instanceIdMap[def.publicId]) {
      instance.instanceId = instanceIdMap[def.publicId];
    }
    return { def, instance };
  }
  return null;
}
function refineEventDef(raw, context, refiners = buildEventRefiners(context)) {
  return refineProps(raw, refiners);
}
function buildEventRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);
}
function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context, defIdMap) {
  let def = {
    title: refined.title || "",
    groupId: refined.groupId || "",
    publicId: refined.id || "",
    url: refined.url || "",
    recurringDef: null,
    defId: (defIdMap && refined.id ? defIdMap[refined.id] : "") || guid(),
    sourceId,
    allDay,
    hasEnd,
    interactive: refined.interactive,
    ui: createEventUi(refined, context),
    extendedProps: Object.assign(Object.assign({}, refined.extendedProps || {}), extra)
  };
  for (let memberAdder of context.pluginHooks.eventDefMemberAdders) {
    Object.assign(def, memberAdder(refined));
  }
  Object.freeze(def.ui.classNames);
  Object.freeze(def.extendedProps);
  return def;
}
function parseSingle(refined, defaultAllDay, context, allowOpenRange) {
  let { allDay } = refined;
  let startMeta;
  let startMarker = null;
  let hasEnd = false;
  let endMeta;
  let endMarker = null;
  let startInput = refined.start != null ? refined.start : refined.date;
  startMeta = context.dateEnv.createMarkerMeta(startInput);
  if (startMeta) {
    startMarker = startMeta.marker;
  } else if (!allowOpenRange) {
    return null;
  }
  if (refined.end != null) {
    endMeta = context.dateEnv.createMarkerMeta(refined.end);
  }
  if (allDay == null) {
    if (defaultAllDay != null) {
      allDay = defaultAllDay;
    } else {
      allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);
    }
  }
  if (allDay && startMarker) {
    startMarker = startOfDay(startMarker);
  }
  if (endMeta) {
    endMarker = endMeta.marker;
    if (allDay) {
      endMarker = startOfDay(endMarker);
    }
    if (startMarker && endMarker <= startMarker) {
      endMarker = null;
    }
  }
  if (endMarker) {
    hasEnd = true;
  } else if (!allowOpenRange) {
    hasEnd = context.options.forceEventDuration || false;
    endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);
  }
  return {
    allDay,
    hasEnd,
    range: { start: startMarker, end: endMarker },
    forcedStartTzo: startMeta ? startMeta.forcedTzo : null,
    forcedEndTzo: endMeta ? endMeta.forcedTzo : null
  };
}
function computeIsDefaultAllDay(eventSource, context) {
  let res = null;
  if (eventSource) {
    res = eventSource.defaultAllDay;
  }
  if (res == null) {
    res = context.options.defaultAllDay;
  }
  return res;
}
function parseEvents(rawEvents, eventSource, context, allowOpenRange, defIdMap, instanceIdMap) {
  let eventStore = createEmptyEventStore();
  let eventRefiners = buildEventRefiners(context);
  for (let rawEvent of rawEvents) {
    let tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners, defIdMap, instanceIdMap);
    if (tuple) {
      eventTupleToStore(tuple, eventStore);
    }
  }
  return eventStore;
}
function eventTupleToStore(tuple, eventStore = createEmptyEventStore()) {
  eventStore.defs[tuple.def.defId] = tuple.def;
  if (tuple.instance) {
    eventStore.instances[tuple.instance.instanceId] = tuple.instance;
  }
  return eventStore;
}
function getRelevantEvents(eventStore, instanceId) {
  let instance = eventStore.instances[instanceId];
  if (instance) {
    let def = eventStore.defs[instance.defId];
    let newStore = filterEventStoreDefs(eventStore, (lookDef) => isEventDefsGrouped(def, lookDef));
    newStore.defs[def.defId] = def;
    newStore.instances[instance.instanceId] = instance;
    return newStore;
  }
  return createEmptyEventStore();
}
function isEventDefsGrouped(def0, def1) {
  return Boolean(def0.groupId && def0.groupId === def1.groupId);
}
function createEmptyEventStore() {
  return { defs: {}, instances: {} };
}
function mergeEventStores(store0, store1) {
  return {
    defs: Object.assign(Object.assign({}, store0.defs), store1.defs),
    instances: Object.assign(Object.assign({}, store0.instances), store1.instances)
  };
}
function filterEventStoreDefs(eventStore, filterFunc) {
  let defs = filterHash(eventStore.defs, filterFunc);
  let instances = filterHash(eventStore.instances, (instance) => defs[instance.defId]);
  return { defs, instances };
}
function excludeSubEventStore(master, sub) {
  let { defs, instances } = master;
  let filteredDefs = {};
  let filteredInstances = {};
  for (let defId in defs) {
    if (!sub.defs[defId]) {
      filteredDefs[defId] = defs[defId];
    }
  }
  for (let instanceId in instances) {
    if (!sub.instances[instanceId] && // not explicitly excluded
    filteredDefs[instances[instanceId].defId]) {
      filteredInstances[instanceId] = instances[instanceId];
    }
  }
  return {
    defs: filteredDefs,
    instances: filteredInstances
  };
}
function normalizeConstraint(input, context) {
  if (Array.isArray(input)) {
    return parseEvents(input, null, context, true);
  }
  if (typeof input === "object" && input) {
    return parseEvents([input], null, context, true);
  }
  if (input != null) {
    return String(input);
  }
  return null;
}
function parseClassNames(raw) {
  if (Array.isArray(raw)) {
    return raw;
  }
  if (typeof raw === "string") {
    return raw.split(/\s+/);
  }
  return [];
}
var EVENT_UI_REFINERS = {
  display: String,
  editable: Boolean,
  startEditable: Boolean,
  durationEditable: Boolean,
  constraint: identity,
  overlap: identity,
  allow: identity,
  className: parseClassNames,
  classNames: parseClassNames,
  color: String,
  backgroundColor: String,
  borderColor: String,
  textColor: String
};
var EMPTY_EVENT_UI = {
  display: null,
  startEditable: null,
  durationEditable: null,
  constraints: [],
  overlap: null,
  allows: [],
  backgroundColor: "",
  borderColor: "",
  textColor: "",
  classNames: []
};
function createEventUi(refined, context) {
  let constraint = normalizeConstraint(refined.constraint, context);
  return {
    display: refined.display || null,
    startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,
    durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,
    constraints: constraint != null ? [constraint] : [],
    overlap: refined.overlap != null ? refined.overlap : null,
    allows: refined.allow != null ? [refined.allow] : [],
    backgroundColor: refined.backgroundColor || refined.color || "",
    borderColor: refined.borderColor || refined.color || "",
    textColor: refined.textColor || "",
    classNames: (refined.className || []).concat(refined.classNames || [])
    // join singular and plural
  };
}
function combineEventUis(uis) {
  return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);
}
function combineTwoEventUis(item0, item1) {
  return {
    display: item1.display != null ? item1.display : item0.display,
    startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,
    durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,
    constraints: item0.constraints.concat(item1.constraints),
    overlap: typeof item1.overlap === "boolean" ? item1.overlap : item0.overlap,
    allows: item0.allows.concat(item1.allows),
    backgroundColor: item1.backgroundColor || item0.backgroundColor,
    borderColor: item1.borderColor || item0.borderColor,
    textColor: item1.textColor || item0.textColor,
    classNames: item0.classNames.concat(item1.classNames)
  };
}
var EVENT_SOURCE_REFINERS = {
  id: String,
  defaultAllDay: Boolean,
  url: String,
  format: String,
  events: identity,
  eventDataTransform: identity,
  // for any network-related sources
  success: identity,
  failure: identity
};
function parseEventSource(raw, context, refiners = buildEventSourceRefiners(context)) {
  let rawObj;
  if (typeof raw === "string") {
    rawObj = { url: raw };
  } else if (typeof raw === "function" || Array.isArray(raw)) {
    rawObj = { events: raw };
  } else if (typeof raw === "object" && raw) {
    rawObj = raw;
  }
  if (rawObj) {
    let { refined, extra } = refineProps(rawObj, refiners);
    let metaRes = buildEventSourceMeta(refined, context);
    if (metaRes) {
      return {
        _raw: raw,
        isFetching: false,
        latestFetchId: "",
        fetchRange: null,
        defaultAllDay: refined.defaultAllDay,
        eventDataTransform: refined.eventDataTransform,
        success: refined.success,
        failure: refined.failure,
        publicId: refined.id || "",
        sourceId: guid(),
        sourceDefId: metaRes.sourceDefId,
        meta: metaRes.meta,
        ui: createEventUi(refined, context),
        extendedProps: extra
      };
    }
  }
  return null;
}
function buildEventSourceRefiners(context) {
  return Object.assign(Object.assign(Object.assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);
}
function buildEventSourceMeta(raw, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  for (let i3 = defs.length - 1; i3 >= 0; i3 -= 1) {
    let def = defs[i3];
    let meta = def.parseMeta(raw);
    if (meta) {
      return { sourceDefId: i3, meta };
    }
  }
  return null;
}
function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {
  switch (action.type) {
    case "RECEIVE_EVENTS":
      return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);
    case "RESET_RAW_EVENTS":
      return resetRawEvents(eventStore, eventSources[action.sourceId], action.rawEvents, dateProfile.activeRange, context);
    case "ADD_EVENTS":
      return addEvent(
        eventStore,
        action.eventStore,
        // new ones
        dateProfile ? dateProfile.activeRange : null,
        context
      );
    case "RESET_EVENTS":
      return action.eventStore;
    case "MERGE_EVENTS":
      return mergeEventStores(eventStore, action.eventStore);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return expandRecurring(eventStore, dateProfile.activeRange, context);
      }
      return eventStore;
    case "REMOVE_EVENTS":
      return excludeSubEventStore(eventStore, action.eventStore);
    case "REMOVE_EVENT_SOURCE":
      return excludeEventsBySourceId(eventStore, action.sourceId);
    case "REMOVE_ALL_EVENT_SOURCES":
      return filterEventStoreDefs(eventStore, (eventDef) => !eventDef.sourceId);
    case "REMOVE_ALL_EVENTS":
      return createEmptyEventStore();
    default:
      return eventStore;
  }
}
function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    let subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);
    if (fetchRange) {
      subset = expandRecurring(subset, fetchRange, context);
    }
    return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);
  }
  return eventStore;
}
function resetRawEvents(existingEventStore, eventSource, rawEvents, activeRange, context) {
  const { defIdMap, instanceIdMap } = buildPublicIdMaps(existingEventStore);
  let newEventStore = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context, false, defIdMap, instanceIdMap);
  return expandRecurring(newEventStore, activeRange, context);
}
function transformRawEvents(rawEvents, eventSource, context) {
  let calEachTransform = context.options.eventDataTransform;
  let sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;
  if (sourceEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);
  }
  if (calEachTransform) {
    rawEvents = transformEachRawEvent(rawEvents, calEachTransform);
  }
  return rawEvents;
}
function transformEachRawEvent(rawEvents, func) {
  let refinedEvents;
  if (!func) {
    refinedEvents = rawEvents;
  } else {
    refinedEvents = [];
    for (let rawEvent of rawEvents) {
      let refinedEvent = func(rawEvent);
      if (refinedEvent) {
        refinedEvents.push(refinedEvent);
      } else if (refinedEvent == null) {
        refinedEvents.push(rawEvent);
      }
    }
  }
  return refinedEvents;
}
function addEvent(eventStore, subset, expandRange, context) {
  if (expandRange) {
    subset = expandRecurring(subset, expandRange, context);
  }
  return mergeEventStores(eventStore, subset);
}
function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {
  let { defs } = eventStore;
  let instances = mapHash(eventStore.instances, (instance) => {
    let def = defs[instance.defId];
    if (def.allDay) {
      return instance;
    }
    return Object.assign(Object.assign({}, instance), { range: {
      start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),
      end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))
    }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });
  });
  return { defs, instances };
}
function excludeEventsBySourceId(eventStore, sourceId) {
  return filterEventStoreDefs(eventStore, (eventDef) => eventDef.sourceId !== sourceId);
}
function excludeInstances(eventStore, removals) {
  return {
    defs: eventStore.defs,
    instances: filterHash(eventStore.instances, (instance) => !removals[instance.instanceId])
  };
}
function buildPublicIdMaps(eventStore) {
  const { defs, instances } = eventStore;
  const defIdMap = {};
  const instanceIdMap = {};
  for (let defId in defs) {
    const def = defs[defId];
    const { publicId } = def;
    if (publicId) {
      defIdMap[publicId] = defId;
    }
  }
  for (let instanceId in instances) {
    const instance = instances[instanceId];
    const def = defs[instance.defId];
    const { publicId } = def;
    if (publicId) {
      instanceIdMap[publicId] = instanceId;
    }
  }
  return { defIdMap, instanceIdMap };
}
var Emitter = class {
  constructor() {
    this.handlers = {};
    this.thisContext = null;
  }
  setThisContext(thisContext) {
    this.thisContext = thisContext;
  }
  setOptions(options) {
    this.options = options;
  }
  on(type, handler) {
    addToHash(this.handlers, type, handler);
  }
  off(type, handler) {
    removeFromHash(this.handlers, type, handler);
  }
  trigger(type, ...args) {
    let attachedHandlers = this.handlers[type] || [];
    let optionHandler = this.options && this.options[type];
    let handlers = [].concat(optionHandler || [], attachedHandlers);
    for (let handler of handlers) {
      handler.apply(this.thisContext, args);
    }
  }
  hasHandlers(type) {
    return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);
  }
};
function addToHash(hash, type, handler) {
  (hash[type] || (hash[type] = [])).push(handler);
}
function removeFromHash(hash, type, handler) {
  if (handler) {
    if (hash[type]) {
      hash[type] = hash[type].filter((func) => func !== handler);
    }
  } else {
    delete hash[type];
  }
}
var DEF_DEFAULTS = {
  startTime: "09:00",
  endTime: "17:00",
  daysOfWeek: [1, 2, 3, 4, 5],
  display: "inverse-background",
  classNames: "fc-non-business",
  groupId: "_businessHours"
  // so multiple defs get grouped
};
function parseBusinessHours(input, context) {
  return parseEvents(refineInputs(input), null, context);
}
function refineInputs(input) {
  let rawDefs;
  if (input === true) {
    rawDefs = [{}];
  } else if (Array.isArray(input)) {
    rawDefs = input.filter((rawDef) => rawDef.daysOfWeek);
  } else if (typeof input === "object" && input) {
    rawDefs = [input];
  } else {
    rawDefs = [];
  }
  rawDefs = rawDefs.map((rawDef) => Object.assign(Object.assign({}, DEF_DEFAULTS), rawDef));
  return rawDefs;
}
function triggerDateSelect(selection, pev, context) {
  context.emitter.trigger("select", Object.assign(Object.assign({}, buildDateSpanApiWithContext(selection, context)), { jsEvent: pev ? pev.origEvent : null, view: context.viewApi || context.calendarApi.view }));
}
function triggerDateUnselect(pev, context) {
  context.emitter.trigger("unselect", {
    jsEvent: pev ? pev.origEvent : null,
    view: context.viewApi || context.calendarApi.view
  });
}
function buildDateSpanApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.dateSpanTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDateSpanApi(dateSpan, context.dateEnv));
  return props;
}
function getDefaultEventEnd(allDay, marker, context) {
  let { dateEnv, options } = context;
  let end = marker;
  if (allDay) {
    end = startOfDay(end);
    end = dateEnv.add(end, options.defaultAllDayEventDuration);
  } else {
    end = dateEnv.add(end, options.defaultTimedEventDuration);
  }
  return end;
}
function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {
  let eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);
  let dest = createEmptyEventStore();
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = dest.defs[instance.defId];
    dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);
  }
  return dest;
}
function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {
  let standardProps = mutation.standardProps || {};
  if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {
    standardProps.hasEnd = true;
  }
  let copy = Object.assign(Object.assign(Object.assign({}, eventDef), standardProps), { ui: Object.assign(Object.assign({}, eventDef.ui), standardProps.ui) });
  if (mutation.extendedProps) {
    copy.extendedProps = Object.assign(Object.assign({}, copy.extendedProps), mutation.extendedProps);
  }
  for (let applier of context.pluginHooks.eventDefMutationAppliers) {
    applier(copy, mutation, context);
  }
  if (!copy.hasEnd && context.options.forceEventDuration) {
    copy.hasEnd = true;
  }
  return copy;
}
function applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {
  let { dateEnv } = context;
  let forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;
  let clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;
  let copy = Object.assign({}, eventInstance);
  if (forceAllDay) {
    copy.range = computeAlignedDayRange(copy.range);
  }
  if (mutation.datesDelta && eventConfig.startEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.datesDelta),
      end: dateEnv.add(copy.range.end, mutation.datesDelta)
    };
  }
  if (mutation.startDelta && eventConfig.durationEditable) {
    copy.range = {
      start: dateEnv.add(copy.range.start, mutation.startDelta),
      end: copy.range.end
    };
  }
  if (mutation.endDelta && eventConfig.durationEditable) {
    copy.range = {
      start: copy.range.start,
      end: dateEnv.add(copy.range.end, mutation.endDelta)
    };
  }
  if (clearEnd) {
    copy.range = {
      start: copy.range.start,
      end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)
    };
  }
  if (eventDef.allDay) {
    copy.range = {
      start: startOfDay(copy.range.start),
      end: startOfDay(copy.range.end)
    };
  }
  if (copy.range.end < copy.range.start) {
    copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);
  }
  return copy;
}
var EventSourceImpl = class {
  constructor(context, internalEventSource) {
    this.context = context;
    this.internalEventSource = internalEventSource;
  }
  remove() {
    this.context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: this.internalEventSource.sourceId
    });
  }
  refetch() {
    this.context.dispatch({
      type: "FETCH_EVENT_SOURCES",
      sourceIds: [this.internalEventSource.sourceId],
      isRefetch: true
    });
  }
  get id() {
    return this.internalEventSource.publicId;
  }
  get url() {
    return this.internalEventSource.meta.url;
  }
  get format() {
    return this.internalEventSource.meta.format;
  }
};
var EventImpl = class {
  // instance will be null if expressing a recurring event that has no current instances,
  // OR if trying to validate an incoming external event that has no dates assigned
  constructor(context, def, instance) {
    this._context = context;
    this._def = def;
    this._instance = instance || null;
  }
  /*
  TODO: make event struct more responsible for this
  */
  setProp(name, val) {
    if (name in EVENT_DATE_REFINERS) {
      console.warn("Could not set date-related prop 'name'. Use one of the date-related methods instead.");
    } else if (name === "id") {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { publicId: val }
        // hardcoded internal name
      });
    } else if (name in EVENT_NON_DATE_REFINERS) {
      val = EVENT_NON_DATE_REFINERS[name](val);
      this.mutate({
        standardProps: { [name]: val }
      });
    } else if (name in EVENT_UI_REFINERS) {
      let ui = EVENT_UI_REFINERS[name](val);
      if (name === "color") {
        ui = { backgroundColor: val, borderColor: val };
      } else if (name === "editable") {
        ui = { startEditable: val, durationEditable: val };
      } else {
        ui = { [name]: val };
      }
      this.mutate({
        standardProps: { ui }
      });
    } else {
      console.warn(`Could not set prop '${name}'. Use setExtendedProp instead.`);
    }
  }
  setExtendedProp(name, val) {
    this.mutate({
      extendedProps: { [name]: val }
    });
  }
  setStart(startInput, options = {}) {
    let { dateEnv } = this._context;
    let start = dateEnv.createMarker(startInput);
    if (start && this._instance) {
      let instanceRange = this._instance.range;
      let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
      if (options.maintainDuration) {
        this.mutate({ datesDelta: startDelta });
      } else {
        this.mutate({ startDelta });
      }
    }
  }
  setEnd(endInput, options = {}) {
    let { dateEnv } = this._context;
    let end;
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      if (end) {
        let endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);
        this.mutate({ endDelta });
      } else {
        this.mutate({ standardProps: { hasEnd: false } });
      }
    }
  }
  setDates(startInput, endInput, options = {}) {
    let { dateEnv } = this._context;
    let standardProps = { allDay: options.allDay };
    let start = dateEnv.createMarker(startInput);
    let end;
    if (!start) {
      return;
    }
    if (endInput != null) {
      end = dateEnv.createMarker(endInput);
      if (!end) {
        return;
      }
    }
    if (this._instance) {
      let instanceRange = this._instance.range;
      if (options.allDay === true) {
        instanceRange = computeAlignedDayRange(instanceRange);
      }
      let startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);
      if (end) {
        let endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);
        if (durationsEqual(startDelta, endDelta)) {
          this.mutate({ datesDelta: startDelta, standardProps });
        } else {
          this.mutate({ startDelta, endDelta, standardProps });
        }
      } else {
        standardProps.hasEnd = false;
        this.mutate({ datesDelta: startDelta, standardProps });
      }
    }
  }
  moveStart(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ startDelta: delta });
    }
  }
  moveEnd(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ endDelta: delta });
    }
  }
  moveDates(deltaInput) {
    let delta = createDuration(deltaInput);
    if (delta) {
      this.mutate({ datesDelta: delta });
    }
  }
  setAllDay(allDay, options = {}) {
    let standardProps = { allDay };
    let { maintainDuration } = options;
    if (maintainDuration == null) {
      maintainDuration = this._context.options.allDayMaintainDuration;
    }
    if (this._def.allDay !== allDay) {
      standardProps.hasEnd = maintainDuration;
    }
    this.mutate({ standardProps });
  }
  formatRange(formatInput) {
    let { dateEnv } = this._context;
    let instance = this._instance;
    let formatter = createFormatter(formatInput);
    if (this._def.hasEnd) {
      return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {
        forcedStartTzo: instance.forcedStartTzo,
        forcedEndTzo: instance.forcedEndTzo
      });
    }
    return dateEnv.format(instance.range.start, formatter, {
      forcedTzo: instance.forcedStartTzo
    });
  }
  mutate(mutation) {
    let instance = this._instance;
    if (instance) {
      let def = this._def;
      let context = this._context;
      let { eventStore } = context.getCurrentData();
      let relevantEvents = getRelevantEvents(eventStore, instance.instanceId);
      let eventConfigBase = {
        "": {
          display: "",
          startEditable: true,
          durationEditable: true,
          constraints: [],
          overlap: null,
          allows: [],
          backgroundColor: "",
          borderColor: "",
          textColor: "",
          classNames: []
        }
      };
      relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context);
      let oldEvent = new EventImpl(context, def, instance);
      this._def = relevantEvents.defs[def.defId];
      this._instance = relevantEvents.instances[instance.instanceId];
      context.dispatch({
        type: "MERGE_EVENTS",
        eventStore: relevantEvents
      });
      context.emitter.trigger("eventChange", {
        oldEvent,
        event: this,
        relatedEvents: buildEventApis(relevantEvents, context, instance),
        revert() {
          context.dispatch({
            type: "RESET_EVENTS",
            eventStore
            // the ORIGINAL store
          });
        }
      });
    }
  }
  remove() {
    let context = this._context;
    let asStore = eventApiToStore(this);
    context.dispatch({
      type: "REMOVE_EVENTS",
      eventStore: asStore
    });
    context.emitter.trigger("eventRemove", {
      event: this,
      relatedEvents: [],
      revert() {
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: asStore
        });
      }
    });
  }
  get source() {
    let { sourceId } = this._def;
    if (sourceId) {
      return new EventSourceImpl(this._context, this._context.getCurrentData().eventSources[sourceId]);
    }
    return null;
  }
  get start() {
    return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;
  }
  get end() {
    return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;
  }
  get startStr() {
    let instance = this._instance;
    if (instance) {
      return this._context.dateEnv.formatIso(instance.range.start, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedStartTzo
      });
    }
    return "";
  }
  get endStr() {
    let instance = this._instance;
    if (instance && this._def.hasEnd) {
      return this._context.dateEnv.formatIso(instance.range.end, {
        omitTime: this._def.allDay,
        forcedTzo: instance.forcedEndTzo
      });
    }
    return "";
  }
  // computable props that all access the def
  // TODO: find a TypeScript-compatible way to do this at scale
  get id() {
    return this._def.publicId;
  }
  get groupId() {
    return this._def.groupId;
  }
  get allDay() {
    return this._def.allDay;
  }
  get title() {
    return this._def.title;
  }
  get url() {
    return this._def.url;
  }
  get display() {
    return this._def.ui.display || "auto";
  }
  // bad. just normalize the type earlier
  get startEditable() {
    return this._def.ui.startEditable;
  }
  get durationEditable() {
    return this._def.ui.durationEditable;
  }
  get constraint() {
    return this._def.ui.constraints[0] || null;
  }
  get overlap() {
    return this._def.ui.overlap;
  }
  get allow() {
    return this._def.ui.allows[0] || null;
  }
  get backgroundColor() {
    return this._def.ui.backgroundColor;
  }
  get borderColor() {
    return this._def.ui.borderColor;
  }
  get textColor() {
    return this._def.ui.textColor;
  }
  // NOTE: user can't modify these because Object.freeze was called in event-def parsing
  get classNames() {
    return this._def.ui.classNames;
  }
  get extendedProps() {
    return this._def.extendedProps;
  }
  toPlainObject(settings = {}) {
    let def = this._def;
    let { ui } = def;
    let { startStr, endStr } = this;
    let res = {
      allDay: def.allDay
    };
    if (def.title) {
      res.title = def.title;
    }
    if (startStr) {
      res.start = startStr;
    }
    if (endStr) {
      res.end = endStr;
    }
    if (def.publicId) {
      res.id = def.publicId;
    }
    if (def.groupId) {
      res.groupId = def.groupId;
    }
    if (def.url) {
      res.url = def.url;
    }
    if (ui.display && ui.display !== "auto") {
      res.display = ui.display;
    }
    if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {
      res.color = ui.backgroundColor;
    } else {
      if (ui.backgroundColor) {
        res.backgroundColor = ui.backgroundColor;
      }
      if (ui.borderColor) {
        res.borderColor = ui.borderColor;
      }
    }
    if (ui.textColor) {
      res.textColor = ui.textColor;
    }
    if (ui.classNames.length) {
      res.classNames = ui.classNames;
    }
    if (Object.keys(def.extendedProps).length) {
      if (settings.collapseExtendedProps) {
        Object.assign(res, def.extendedProps);
      } else {
        res.extendedProps = def.extendedProps;
      }
    }
    return res;
  }
  toJSON() {
    return this.toPlainObject();
  }
};
function eventApiToStore(eventApi) {
  let def = eventApi._def;
  let instance = eventApi._instance;
  return {
    defs: { [def.defId]: def },
    instances: instance ? { [instance.instanceId]: instance } : {}
  };
}
function buildEventApis(eventStore, context, excludeInstance) {
  let { defs, instances } = eventStore;
  let eventApis = [];
  let excludeInstanceId = excludeInstance ? excludeInstance.instanceId : "";
  for (let id in instances) {
    let instance = instances[id];
    let def = defs[instance.defId];
    if (instance.instanceId !== excludeInstanceId) {
      eventApis.push(new EventImpl(context, def, instance));
    }
  }
  return eventApis;
}
function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {
  let inverseBgByGroupId = {};
  let inverseBgByDefId = {};
  let defByGroupId = {};
  let bgRanges = [];
  let fgRanges = [];
  let eventUis = compileEventUis(eventStore.defs, eventUiBases);
  for (let defId in eventStore.defs) {
    let def = eventStore.defs[defId];
    let ui = eventUis[def.defId];
    if (ui.display === "inverse-background") {
      if (def.groupId) {
        inverseBgByGroupId[def.groupId] = [];
        if (!defByGroupId[def.groupId]) {
          defByGroupId[def.groupId] = def;
        }
      } else {
        inverseBgByDefId[defId] = [];
      }
    }
  }
  for (let instanceId in eventStore.instances) {
    let instance = eventStore.instances[instanceId];
    let def = eventStore.defs[instance.defId];
    let ui = eventUis[def.defId];
    let origRange = instance.range;
    let normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;
    let slicedRange = intersectRanges(normalRange, framingRange);
    if (slicedRange) {
      if (ui.display === "inverse-background") {
        if (def.groupId) {
          inverseBgByGroupId[def.groupId].push(slicedRange);
        } else {
          inverseBgByDefId[instance.defId].push(slicedRange);
        }
      } else if (ui.display !== "none") {
        (ui.display === "background" ? bgRanges : fgRanges).push({
          def,
          ui,
          instance,
          range: slicedRange,
          isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),
          isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()
        });
      }
    }
  }
  for (let groupId in inverseBgByGroupId) {
    let ranges = inverseBgByGroupId[groupId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      let def = defByGroupId[groupId];
      let ui = eventUis[def.defId];
      bgRanges.push({
        def,
        ui,
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  for (let defId in inverseBgByDefId) {
    let ranges = inverseBgByDefId[defId];
    let invertedRanges = invertRanges(ranges, framingRange);
    for (let invertedRange of invertedRanges) {
      bgRanges.push({
        def: eventStore.defs[defId],
        ui: eventUis[defId],
        instance: null,
        range: invertedRange,
        isStart: false,
        isEnd: false
      });
    }
  }
  return { bg: bgRanges, fg: fgRanges };
}
function hasBgRendering(def) {
  return def.ui.display === "background" || def.ui.display === "inverse-background";
}
function setElSeg(el, seg) {
  el.fcSeg = seg;
}
function getElSeg(el) {
  return el.fcSeg || el.parentNode.fcSeg || // for the harness
  null;
}
function compileEventUis(eventDefs, eventUiBases) {
  return mapHash(eventDefs, (eventDef) => compileEventUi(eventDef, eventUiBases));
}
function compileEventUi(eventDef, eventUiBases) {
  let uis = [];
  if (eventUiBases[""]) {
    uis.push(eventUiBases[""]);
  }
  if (eventUiBases[eventDef.defId]) {
    uis.push(eventUiBases[eventDef.defId]);
  }
  uis.push(eventDef.ui);
  return combineEventUis(uis);
}
function sortEventSegs(segs, eventOrderSpecs) {
  let objs = segs.map(buildSegCompareObj);
  objs.sort((obj0, obj1) => compareByFieldSpecs(obj0, obj1, eventOrderSpecs));
  return objs.map((c3) => c3._seg);
}
function buildSegCompareObj(seg) {
  let { eventRange } = seg;
  let eventDef = eventRange.def;
  let range2 = eventRange.instance ? eventRange.instance.range : eventRange.range;
  let start = range2.start ? range2.start.valueOf() : 0;
  let end = range2.end ? range2.end.valueOf() : 0;
  return Object.assign(Object.assign(Object.assign({}, eventDef.extendedProps), eventDef), {
    id: eventDef.publicId,
    start,
    end,
    duration: end - start,
    allDay: Number(eventDef.allDay),
    _seg: seg
  });
}
function computeSegDraggable(seg, context) {
  let { pluginHooks } = context;
  let transformers = pluginHooks.isDraggableTransformers;
  let { def, ui } = seg.eventRange;
  let val = ui.startEditable;
  for (let transformer of transformers) {
    val = transformer(val, def, ui, context);
  }
  return val;
}
function computeSegStartResizable(seg, context) {
  return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;
}
function computeSegEndResizable(seg, context) {
  return seg.isEnd && seg.eventRange.ui.durationEditable;
}
function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {
  let { dateEnv, options } = context;
  let { displayEventTime, displayEventEnd } = options;
  let eventDef = seg.eventRange.def;
  let eventInstance = seg.eventRange.instance;
  if (displayEventTime == null) {
    displayEventTime = defaultDisplayEventTime !== false;
  }
  if (displayEventEnd == null) {
    displayEventEnd = defaultDisplayEventEnd !== false;
  }
  let wholeEventStart = eventInstance.range.start;
  let wholeEventEnd = eventInstance.range.end;
  let segStart = startOverride || seg.start || seg.eventRange.range.start;
  let segEnd = endOverride || seg.end || seg.eventRange.range.end;
  let isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();
  let isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();
  if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {
    segStart = isStartDay ? wholeEventStart : segStart;
    segEnd = isEndDay ? wholeEventEnd : segEnd;
    if (displayEventEnd && eventDef.hasEnd) {
      return dateEnv.formatRange(segStart, segEnd, timeFormat, {
        forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,
        forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo
      });
    }
    return dateEnv.format(segStart, timeFormat, {
      forcedTzo: startOverride ? null : eventInstance.forcedStartTzo
      // nooooo, same
    });
  }
  return "";
}
function getSegMeta(seg, todayRange, nowDate) {
  let segRange = seg.eventRange.range;
  return {
    isPast: segRange.end <= (nowDate || todayRange.start),
    isFuture: segRange.start >= (nowDate || todayRange.end),
    isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)
  };
}
function getEventClassNames(props) {
  let classNames = ["fc-event"];
  if (props.isMirror) {
    classNames.push("fc-event-mirror");
  }
  if (props.isDraggable) {
    classNames.push("fc-event-draggable");
  }
  if (props.isStartResizable || props.isEndResizable) {
    classNames.push("fc-event-resizable");
  }
  if (props.isDragging) {
    classNames.push("fc-event-dragging");
  }
  if (props.isResizing) {
    classNames.push("fc-event-resizing");
  }
  if (props.isSelected) {
    classNames.push("fc-event-selected");
  }
  if (props.isStart) {
    classNames.push("fc-event-start");
  }
  if (props.isEnd) {
    classNames.push("fc-event-end");
  }
  if (props.isPast) {
    classNames.push("fc-event-past");
  }
  if (props.isToday) {
    classNames.push("fc-event-today");
  }
  if (props.isFuture) {
    classNames.push("fc-event-future");
  }
  return classNames;
}
function buildEventRangeKey(eventRange) {
  return eventRange.instance ? eventRange.instance.instanceId : `${eventRange.def.defId}:${eventRange.range.start.toISOString()}`;
}
function getSegAnchorAttrs(seg, context) {
  let { def, instance } = seg.eventRange;
  let { url } = def;
  if (url) {
    return { href: url };
  }
  let { emitter, options } = context;
  let { eventInteractive } = options;
  if (eventInteractive == null) {
    eventInteractive = def.interactive;
    if (eventInteractive == null) {
      eventInteractive = Boolean(emitter.hasHandlers("eventClick"));
    }
  }
  if (eventInteractive) {
    return createAriaKeyboardAttrs((ev) => {
      emitter.trigger("eventClick", {
        el: ev.target,
        event: new EventImpl(context, def, instance),
        jsEvent: ev,
        view: context.viewApi
      });
    });
  }
  return {};
}
var STANDARD_PROPS = {
  start: identity,
  end: identity,
  allDay: Boolean
};
function parseDateSpan(raw, dateEnv, defaultDuration) {
  let span = parseOpenDateSpan(raw, dateEnv);
  let { range: range2 } = span;
  if (!range2.start) {
    return null;
  }
  if (!range2.end) {
    if (defaultDuration == null) {
      return null;
    }
    range2.end = dateEnv.add(range2.start, defaultDuration);
  }
  return span;
}
function parseOpenDateSpan(raw, dateEnv) {
  let { refined: standardProps, extra } = refineProps(raw, STANDARD_PROPS);
  let startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;
  let endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;
  let { allDay } = standardProps;
  if (allDay == null) {
    allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);
  }
  return Object.assign({ range: {
    start: startMeta ? startMeta.marker : null,
    end: endMeta ? endMeta.marker : null
  }, allDay }, extra);
}
function isDateSpansEqual(span0, span1) {
  return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);
}
function isSpanPropsEqual(span0, span1) {
  for (let propName in span1) {
    if (propName !== "range" && propName !== "allDay") {
      if (span0[propName] !== span1[propName]) {
        return false;
      }
    }
  }
  for (let propName in span0) {
    if (!(propName in span1)) {
      return false;
    }
  }
  return true;
}
function buildDateSpanApi(span, dateEnv) {
  return Object.assign(Object.assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });
}
function buildRangeApiWithTimeZone(range2, dateEnv, omitTime) {
  return Object.assign(Object.assign({}, buildRangeApi(range2, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });
}
function buildRangeApi(range2, dateEnv, omitTime) {
  return {
    start: dateEnv.toDate(range2.start),
    end: dateEnv.toDate(range2.end),
    startStr: dateEnv.formatIso(range2.start, { omitTime }),
    endStr: dateEnv.formatIso(range2.end, { omitTime })
  };
}
function fabricateEventRange(dateSpan, eventUiBases, context) {
  let res = refineEventDef({ editable: false }, context);
  let def = parseEventDef(
    res.refined,
    res.extra,
    "",
    // sourceId
    dateSpan.allDay,
    true,
    // hasEnd
    context
  );
  return {
    def,
    ui: compileEventUi(def, eventUiBases),
    instance: createEventInstance(def.defId, dateSpan.range),
    range: dateSpan.range,
    isStart: true,
    isEnd: true
  };
}
function unpromisify(func, normalizedSuccessCallback, normalizedFailureCallback) {
  let isResolved = false;
  let wrappedSuccess = function(res2) {
    if (!isResolved) {
      isResolved = true;
      normalizedSuccessCallback(res2);
    }
  };
  let wrappedFailure = function(error) {
    if (!isResolved) {
      isResolved = true;
      normalizedFailureCallback(error);
    }
  };
  let res = func(wrappedSuccess, wrappedFailure);
  if (res && typeof res.then === "function") {
    res.then(wrappedSuccess, wrappedFailure);
  }
}
var JsonRequestError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
function requestJson(method, url, params) {
  method = method.toUpperCase();
  const fetchOptions = {
    method
  };
  if (method === "GET") {
    url += (url.indexOf("?") === -1 ? "?" : "&") + new URLSearchParams(params);
  } else {
    fetchOptions.body = new URLSearchParams(params);
    fetchOptions.headers = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
  }
  return fetch(url, fetchOptions).then((fetchRes) => {
    if (fetchRes.ok) {
      return fetchRes.json().then((parsedResponse) => {
        return [parsedResponse, fetchRes];
      }, () => {
        throw new JsonRequestError("Failure parsing JSON", fetchRes);
      });
    } else {
      throw new JsonRequestError("Request failed", fetchRes);
    }
  });
}
var canVGrowWithinCell;
function getCanVGrowWithinCell() {
  if (canVGrowWithinCell == null) {
    canVGrowWithinCell = computeCanVGrowWithinCell();
  }
  return canVGrowWithinCell;
}
function computeCanVGrowWithinCell() {
  if (typeof document === "undefined") {
    return true;
  }
  let el = document.createElement("div");
  el.style.position = "absolute";
  el.style.top = "0px";
  el.style.left = "0px";
  el.innerHTML = "<table><tr><td><div></div></td></tr></table>";
  el.querySelector("table").style.height = "100px";
  el.querySelector("div").style.height = "100%";
  document.body.appendChild(el);
  let div = el.querySelector("div");
  let possible = div.offsetHeight > 0;
  document.body.removeChild(el);
  return possible;
}
var CalendarRoot = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      forPrint: false
    };
    this.handleBeforePrint = () => {
      flushSync(() => {
        this.setState({ forPrint: true });
      });
    };
    this.handleAfterPrint = () => {
      flushSync(() => {
        this.setState({ forPrint: false });
      });
    };
  }
  render() {
    let { props } = this;
    let { options } = props;
    let { forPrint } = this.state;
    let isHeightAuto = forPrint || options.height === "auto" || options.contentHeight === "auto";
    let height = !isHeightAuto && options.height != null ? options.height : "";
    let classNames = [
      "fc",
      forPrint ? "fc-media-print" : "fc-media-screen",
      `fc-direction-${options.direction}`,
      props.theme.getClass("root")
    ];
    if (!getCanVGrowWithinCell()) {
      classNames.push("fc-liquid-hack");
    }
    return props.children(classNames, height, isHeightAuto, forPrint);
  }
  componentDidMount() {
    let { emitter } = this.props;
    emitter.on("_beforeprint", this.handleBeforePrint);
    emitter.on("_afterprint", this.handleAfterPrint);
  }
  componentWillUnmount() {
    let { emitter } = this.props;
    emitter.off("_beforeprint", this.handleBeforePrint);
    emitter.off("_afterprint", this.handleAfterPrint);
  }
};
var Interaction = class {
  constructor(settings) {
    this.component = settings.component;
    this.isHitComboAllowed = settings.isHitComboAllowed || null;
  }
  destroy() {
  }
};
function parseInteractionSettings(component, input) {
  return {
    component,
    el: input.el,
    useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,
    isHitComboAllowed: input.isHitComboAllowed || null
  };
}
function interactionSettingsToStore(settings) {
  return {
    [settings.component.uid]: settings
  };
}
var interactionSettingsStore = {};
var CalendarImpl = class {
  getCurrentData() {
    return this.currentDataManager.getCurrentData();
  }
  dispatch(action) {
    this.currentDataManager.dispatch(action);
  }
  get view() {
    return this.getCurrentData().viewApi;
  }
  batchRendering(callback) {
    callback();
  }
  updateSize() {
    this.trigger("_resize", true);
  }
  // Options
  // -----------------------------------------------------------------------------------------------------------------
  setOption(name, val) {
    this.dispatch({
      type: "SET_OPTION",
      optionName: name,
      rawOptionValue: val
    });
  }
  getOption(name) {
    return this.currentDataManager.currentCalendarOptionsInput[name];
  }
  getAvailableLocaleCodes() {
    return Object.keys(this.getCurrentData().availableRawLocales);
  }
  // Trigger
  // -----------------------------------------------------------------------------------------------------------------
  on(handlerName, handler) {
    let { currentDataManager } = this;
    if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {
      currentDataManager.emitter.on(handlerName, handler);
    } else {
      console.warn(`Unknown listener name '${handlerName}'`);
    }
  }
  off(handlerName, handler) {
    this.currentDataManager.emitter.off(handlerName, handler);
  }
  // not meant for public use
  trigger(handlerName, ...args) {
    this.currentDataManager.emitter.trigger(handlerName, ...args);
  }
  // View
  // -----------------------------------------------------------------------------------------------------------------
  changeView(viewType, dateOrRange) {
    this.batchRendering(() => {
      this.unselect();
      if (dateOrRange) {
        if (dateOrRange.start && dateOrRange.end) {
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType
          });
          this.dispatch({
            type: "SET_OPTION",
            optionName: "visibleRange",
            rawOptionValue: dateOrRange
          });
        } else {
          let { dateEnv } = this.getCurrentData();
          this.dispatch({
            type: "CHANGE_VIEW_TYPE",
            viewType,
            dateMarker: dateEnv.createMarker(dateOrRange)
          });
        }
      } else {
        this.dispatch({
          type: "CHANGE_VIEW_TYPE",
          viewType
        });
      }
    });
  }
  // Forces navigation to a view for the given date.
  // `viewType` can be a specific view name or a generic one like "week" or "day".
  // needs to change
  zoomTo(dateMarker, viewType) {
    let state = this.getCurrentData();
    let spec;
    viewType = viewType || "day";
    spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);
    this.unselect();
    if (spec) {
      this.dispatch({
        type: "CHANGE_VIEW_TYPE",
        viewType: spec.type,
        dateMarker
      });
    } else {
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker
      });
    }
  }
  // Given a duration singular unit, like "week" or "day", finds a matching view spec.
  // Preference is given to views that have corresponding buttons.
  getUnitViewSpec(unit) {
    let { viewSpecs, toolbarConfig } = this.getCurrentData();
    let viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);
    let i3;
    let spec;
    for (let viewType in viewSpecs) {
      viewTypes.push(viewType);
    }
    for (i3 = 0; i3 < viewTypes.length; i3 += 1) {
      spec = viewSpecs[viewTypes[i3]];
      if (spec) {
        if (spec.singleUnit === unit) {
          return spec;
        }
      }
    }
    return null;
  }
  // Current Date
  // -----------------------------------------------------------------------------------------------------------------
  prev() {
    this.unselect();
    this.dispatch({ type: "PREV" });
  }
  next() {
    this.unselect();
    this.dispatch({ type: "NEXT" });
  }
  prevYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, -1)
    });
  }
  nextYear() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.addYears(state.currentDate, 1)
    });
  }
  today() {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: getNow(state.calendarOptions.now, state.dateEnv)
    });
  }
  gotoDate(zonedDateInput) {
    let state = this.getCurrentData();
    this.unselect();
    this.dispatch({
      type: "CHANGE_DATE",
      dateMarker: state.dateEnv.createMarker(zonedDateInput)
    });
  }
  incrementDate(deltaInput) {
    let state = this.getCurrentData();
    let delta = createDuration(deltaInput);
    if (delta) {
      this.unselect();
      this.dispatch({
        type: "CHANGE_DATE",
        dateMarker: state.dateEnv.add(state.currentDate, delta)
      });
    }
  }
  getDate() {
    let state = this.getCurrentData();
    return state.dateEnv.toDate(state.currentDate);
  }
  // Date Formatting Utils
  // -----------------------------------------------------------------------------------------------------------------
  formatDate(d2, formatter) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.format(dateEnv.createMarker(d2), createFormatter(formatter));
  }
  // `settings` is for formatter AND isEndExclusive
  formatRange(d0, d1, settings) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);
  }
  formatIso(d2, omitTime) {
    let { dateEnv } = this.getCurrentData();
    return dateEnv.formatIso(dateEnv.createMarker(d2), { omitTime });
  }
  // Date Selection / Event Selection / DayClick
  // -----------------------------------------------------------------------------------------------------------------
  select(dateOrObj, endDate) {
    let selectionInput;
    if (endDate == null) {
      if (dateOrObj.start != null) {
        selectionInput = dateOrObj;
      } else {
        selectionInput = {
          start: dateOrObj,
          end: null
        };
      }
    } else {
      selectionInput = {
        start: dateOrObj,
        end: endDate
      };
    }
    let state = this.getCurrentData();
    let selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({ days: 1 }));
    if (selection) {
      this.dispatch({ type: "SELECT_DATES", selection });
      triggerDateSelect(selection, null, state);
    }
  }
  unselect(pev) {
    let state = this.getCurrentData();
    if (state.dateSelection) {
      this.dispatch({ type: "UNSELECT_DATES" });
      triggerDateUnselect(pev, state);
    }
  }
  // Public Events API
  // -----------------------------------------------------------------------------------------------------------------
  addEvent(eventInput, sourceInput) {
    if (eventInput instanceof EventImpl) {
      let def = eventInput._def;
      let instance = eventInput._instance;
      let currentData = this.getCurrentData();
      if (!currentData.eventStore.defs[def.defId]) {
        this.dispatch({
          type: "ADD_EVENTS",
          eventStore: eventTupleToStore({ def, instance })
          // TODO: better util for two args?
        });
        this.triggerEventAdd(eventInput);
      }
      return eventInput;
    }
    let state = this.getCurrentData();
    let eventSource;
    if (sourceInput instanceof EventSourceImpl) {
      eventSource = sourceInput.internalEventSource;
    } else if (typeof sourceInput === "boolean") {
      if (sourceInput) {
        [eventSource] = hashValuesToArray(state.eventSources);
      }
    } else if (sourceInput != null) {
      let sourceApi = this.getEventSourceById(sourceInput);
      if (!sourceApi) {
        console.warn(`Could not find an event source with ID "${sourceInput}"`);
        return null;
      }
      eventSource = sourceApi.internalEventSource;
    }
    let tuple = parseEvent(eventInput, eventSource, state, false);
    if (tuple) {
      let newEventApi = new EventImpl(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);
      this.dispatch({
        type: "ADD_EVENTS",
        eventStore: eventTupleToStore(tuple)
      });
      this.triggerEventAdd(newEventApi);
      return newEventApi;
    }
    return null;
  }
  triggerEventAdd(eventApi) {
    let { emitter } = this.getCurrentData();
    emitter.trigger("eventAdd", {
      event: eventApi,
      relatedEvents: [],
      revert: () => {
        this.dispatch({
          type: "REMOVE_EVENTS",
          eventStore: eventApiToStore(eventApi)
        });
      }
    });
  }
  // TODO: optimize
  getEventById(id) {
    let state = this.getCurrentData();
    let { defs, instances } = state.eventStore;
    id = String(id);
    for (let defId in defs) {
      let def = defs[defId];
      if (def.publicId === id) {
        if (def.recurringDef) {
          return new EventImpl(state, def, null);
        }
        for (let instanceId in instances) {
          let instance = instances[instanceId];
          if (instance.defId === def.defId) {
            return new EventImpl(state, def, instance);
          }
        }
      }
    }
    return null;
  }
  getEvents() {
    let currentData = this.getCurrentData();
    return buildEventApis(currentData.eventStore, currentData);
  }
  removeAllEvents() {
    this.dispatch({ type: "REMOVE_ALL_EVENTS" });
  }
  // Public Event Sources API
  // -----------------------------------------------------------------------------------------------------------------
  getEventSources() {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    let sourceApis = [];
    for (let internalId in sourceHash) {
      sourceApis.push(new EventSourceImpl(state, sourceHash[internalId]));
    }
    return sourceApis;
  }
  getEventSourceById(id) {
    let state = this.getCurrentData();
    let sourceHash = state.eventSources;
    id = String(id);
    for (let sourceId in sourceHash) {
      if (sourceHash[sourceId].publicId === id) {
        return new EventSourceImpl(state, sourceHash[sourceId]);
      }
    }
    return null;
  }
  addEventSource(sourceInput) {
    let state = this.getCurrentData();
    if (sourceInput instanceof EventSourceImpl) {
      if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {
        this.dispatch({
          type: "ADD_EVENT_SOURCES",
          sources: [sourceInput.internalEventSource]
        });
      }
      return sourceInput;
    }
    let eventSource = parseEventSource(sourceInput, state);
    if (eventSource) {
      this.dispatch({ type: "ADD_EVENT_SOURCES", sources: [eventSource] });
      return new EventSourceImpl(state, eventSource);
    }
    return null;
  }
  removeAllEventSources() {
    this.dispatch({ type: "REMOVE_ALL_EVENT_SOURCES" });
  }
  refetchEvents() {
    this.dispatch({ type: "FETCH_EVENT_SOURCES", isRefetch: true });
  }
  // Scroll
  // -----------------------------------------------------------------------------------------------------------------
  scrollToTime(timeInput) {
    let time = createDuration(timeInput);
    if (time) {
      this.trigger("_scrollRequest", { time });
    }
  }
};
function pointInsideRect(point, rect) {
  return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;
}
function intersectRects(rect1, rect2) {
  let res = {
    left: Math.max(rect1.left, rect2.left),
    right: Math.min(rect1.right, rect2.right),
    top: Math.max(rect1.top, rect2.top),
    bottom: Math.min(rect1.bottom, rect2.bottom)
  };
  if (res.left < res.right && res.top < res.bottom) {
    return res;
  }
  return false;
}
function constrainPoint(point, rect) {
  return {
    left: Math.min(Math.max(point.left, rect.left), rect.right),
    top: Math.min(Math.max(point.top, rect.top), rect.bottom)
  };
}
function getRectCenter(rect) {
  return {
    left: (rect.left + rect.right) / 2,
    top: (rect.top + rect.bottom) / 2
  };
}
function diffPoints(point1, point2) {
  return {
    left: point1.left - point2.left,
    top: point1.top - point2.top
  };
}
var EMPTY_EVENT_STORE = createEmptyEventStore();
var Splitter = class {
  constructor() {
    this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);
    this.splitDateSelection = memoize(this._splitDateSpan);
    this.splitEventStore = memoize(this._splitEventStore);
    this.splitIndividualUi = memoize(this._splitIndividualUi);
    this.splitEventDrag = memoize(this._splitInteraction);
    this.splitEventResize = memoize(this._splitInteraction);
    this.eventUiBuilders = {};
  }
  splitProps(props) {
    let keyInfos = this.getKeyInfo(props);
    let defKeys = this.getKeysForEventDefs(props.eventStore);
    let dateSelections = this.splitDateSelection(props.dateSelection);
    let individualUi = this.splitIndividualUi(props.eventUiBases, defKeys);
    let eventStores = this.splitEventStore(props.eventStore, defKeys);
    let eventDrags = this.splitEventDrag(props.eventDrag);
    let eventResizes = this.splitEventResize(props.eventResize);
    let splitProps = {};
    this.eventUiBuilders = mapHash(keyInfos, (info, key) => this.eventUiBuilders[key] || memoize(buildEventUiForKey));
    for (let key in keyInfos) {
      let keyInfo = keyInfos[key];
      let eventStore = eventStores[key] || EMPTY_EVENT_STORE;
      let buildEventUi = this.eventUiBuilders[key];
      splitProps[key] = {
        businessHours: keyInfo.businessHours || props.businessHours,
        dateSelection: dateSelections[key] || null,
        eventStore,
        eventUiBases: buildEventUi(props.eventUiBases[""], keyInfo.ui, individualUi[key]),
        eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : "",
        eventDrag: eventDrags[key] || null,
        eventResize: eventResizes[key] || null
      };
    }
    return splitProps;
  }
  _splitDateSpan(dateSpan) {
    let dateSpans = {};
    if (dateSpan) {
      let keys = this.getKeysForDateSpan(dateSpan);
      for (let key of keys) {
        dateSpans[key] = dateSpan;
      }
    }
    return dateSpans;
  }
  _getKeysForEventDefs(eventStore) {
    return mapHash(eventStore.defs, (eventDef) => this.getKeysForEventDef(eventDef));
  }
  _splitEventStore(eventStore, defKeys) {
    let { defs, instances } = eventStore;
    let splitStores = {};
    for (let defId in defs) {
      for (let key of defKeys[defId]) {
        if (!splitStores[key]) {
          splitStores[key] = createEmptyEventStore();
        }
        splitStores[key].defs[defId] = defs[defId];
      }
    }
    for (let instanceId in instances) {
      let instance = instances[instanceId];
      for (let key of defKeys[instance.defId]) {
        if (splitStores[key]) {
          splitStores[key].instances[instanceId] = instance;
        }
      }
    }
    return splitStores;
  }
  _splitIndividualUi(eventUiBases, defKeys) {
    let splitHashes = {};
    for (let defId in eventUiBases) {
      if (defId) {
        for (let key of defKeys[defId]) {
          if (!splitHashes[key]) {
            splitHashes[key] = {};
          }
          splitHashes[key][defId] = eventUiBases[defId];
        }
      }
    }
    return splitHashes;
  }
  _splitInteraction(interaction) {
    let splitStates = {};
    if (interaction) {
      let affectedStores = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));
      let mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);
      let mutatedStores = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);
      let populate = (key) => {
        if (!splitStates[key]) {
          splitStates[key] = {
            affectedEvents: affectedStores[key] || EMPTY_EVENT_STORE,
            mutatedEvents: mutatedStores[key] || EMPTY_EVENT_STORE,
            isEvent: interaction.isEvent
          };
        }
      };
      for (let key in affectedStores) {
        populate(key);
      }
      for (let key in mutatedStores) {
        populate(key);
      }
    }
    return splitStates;
  }
};
function buildEventUiForKey(allUi, eventUiForKey, individualUi) {
  let baseParts = [];
  if (allUi) {
    baseParts.push(allUi);
  }
  if (eventUiForKey) {
    baseParts.push(eventUiForKey);
  }
  let stuff = {
    "": combineEventUis(baseParts)
  };
  if (individualUi) {
    Object.assign(stuff, individualUi);
  }
  return stuff;
}
function getDateMeta(date, todayRange, nowDate, dateProfile) {
  return {
    dow: date.getUTCDay(),
    isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),
    isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),
    isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),
    isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),
    isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)
  };
}
function getDayClassNames(meta, theme) {
  let classNames = [
    "fc-day",
    `fc-day-${DAY_IDS[meta.dow]}`
  ];
  if (meta.isDisabled) {
    classNames.push("fc-day-disabled");
  } else {
    if (meta.isToday) {
      classNames.push("fc-day-today");
      classNames.push(theme.getClass("today"));
    }
    if (meta.isPast) {
      classNames.push("fc-day-past");
    }
    if (meta.isFuture) {
      classNames.push("fc-day-future");
    }
    if (meta.isOther) {
      classNames.push("fc-day-other");
    }
  }
  return classNames;
}
var DAY_FORMAT = createFormatter({ year: "numeric", month: "long", day: "numeric" });
var WEEK_FORMAT = createFormatter({ week: "long" });
function buildNavLinkAttrs(context, dateMarker, viewType = "day", isTabbable = true) {
  const { dateEnv, options, calendarApi } = context;
  let dateStr = dateEnv.format(dateMarker, viewType === "week" ? WEEK_FORMAT : DAY_FORMAT);
  if (options.navLinks) {
    let zonedDate = dateEnv.toDate(dateMarker);
    const handleInteraction = (ev) => {
      let customAction = viewType === "day" ? options.navLinkDayClick : viewType === "week" ? options.navLinkWeekClick : null;
      if (typeof customAction === "function") {
        customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);
      } else {
        if (typeof customAction === "string") {
          viewType = customAction;
        }
        calendarApi.zoomTo(dateMarker, viewType);
      }
    };
    return Object.assign({ title: formatWithOrdinals(options.navLinkHint, [dateStr, zonedDate], dateStr), "data-navlink": "" }, isTabbable ? createAriaClickAttrs(handleInteraction) : { onClick: handleInteraction });
  }
  return { "aria-label": dateStr };
}
var _isRtlScrollbarOnLeft = null;
function getIsRtlScrollbarOnLeft() {
  if (_isRtlScrollbarOnLeft === null) {
    _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();
  }
  return _isRtlScrollbarOnLeft;
}
function computeIsRtlScrollbarOnLeft() {
  let outerEl = document.createElement("div");
  applyStyle(outerEl, {
    position: "absolute",
    top: -1e3,
    left: 0,
    border: 0,
    padding: 0,
    overflow: "scroll",
    direction: "rtl"
  });
  outerEl.innerHTML = "<div></div>";
  document.body.appendChild(outerEl);
  let innerEl = outerEl.firstChild;
  let res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;
  removeElement(outerEl);
  return res;
}
var _scrollbarWidths;
function getScrollbarWidths() {
  if (!_scrollbarWidths) {
    _scrollbarWidths = computeScrollbarWidths();
  }
  return _scrollbarWidths;
}
function computeScrollbarWidths() {
  let el = document.createElement("div");
  el.style.overflow = "scroll";
  el.style.position = "absolute";
  el.style.top = "-9999px";
  el.style.left = "-9999px";
  document.body.appendChild(el);
  let res = computeScrollbarWidthsForEl(el);
  document.body.removeChild(el);
  return res;
}
function computeScrollbarWidthsForEl(el) {
  return {
    x: el.offsetHeight - el.clientHeight,
    y: el.offsetWidth - el.clientWidth
  };
}
function computeEdges(el, getPadding = false) {
  let computedStyle = window.getComputedStyle(el);
  let borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;
  let borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;
  let borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;
  let borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
  let badScrollbarWidths = computeScrollbarWidthsForEl(el);
  let scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;
  let scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;
  let res = {
    borderLeft,
    borderRight,
    borderTop,
    borderBottom,
    scrollbarBottom,
    scrollbarLeft: 0,
    scrollbarRight: 0
  };
  if (getIsRtlScrollbarOnLeft() && computedStyle.direction === "rtl") {
    res.scrollbarLeft = scrollbarLeftRight;
  } else {
    res.scrollbarRight = scrollbarLeftRight;
  }
  if (getPadding) {
    res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;
    res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;
    res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;
    res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;
  }
  return res;
}
function computeInnerRect(el, goWithinPadding = false, doFromWindowViewport) {
  let outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);
  let edges = computeEdges(el, goWithinPadding);
  let res = {
    left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,
    right: outerRect.right - edges.borderRight - edges.scrollbarRight,
    top: outerRect.top + edges.borderTop,
    bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom
  };
  if (goWithinPadding) {
    res.left += edges.paddingLeft;
    res.right -= edges.paddingRight;
    res.top += edges.paddingTop;
    res.bottom -= edges.paddingBottom;
  }
  return res;
}
function computeRect(el) {
  let rect = el.getBoundingClientRect();
  return {
    left: rect.left + window.scrollX,
    top: rect.top + window.scrollY,
    right: rect.right + window.scrollX,
    bottom: rect.bottom + window.scrollY
  };
}
function computeClippedClientRect(el) {
  let clippingParents = getClippingParents(el);
  let rect = el.getBoundingClientRect();
  for (let clippingParent of clippingParents) {
    let intersection = intersectRects(rect, clippingParent.getBoundingClientRect());
    if (intersection) {
      rect = intersection;
    } else {
      return null;
    }
  }
  return rect;
}
function getClippingParents(el) {
  let parents = [];
  while (el instanceof HTMLElement) {
    let computedStyle = window.getComputedStyle(el);
    if (computedStyle.position === "fixed") {
      break;
    }
    if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {
      parents.push(el);
    }
    el = el.parentNode;
  }
  return parents;
}
var PositionCache = class {
  constructor(originEl, els, isHorizontal, isVertical) {
    this.els = els;
    let originClientRect = this.originClientRect = originEl.getBoundingClientRect();
    if (isHorizontal) {
      this.buildElHorizontals(originClientRect.left);
    }
    if (isVertical) {
      this.buildElVerticals(originClientRect.top);
    }
  }
  // Populates the left/right internal coordinate arrays
  buildElHorizontals(originClientLeft) {
    let lefts = [];
    let rights = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      lefts.push(rect.left - originClientLeft);
      rights.push(rect.right - originClientLeft);
    }
    this.lefts = lefts;
    this.rights = rights;
  }
  // Populates the top/bottom internal coordinate arrays
  buildElVerticals(originClientTop) {
    let tops = [];
    let bottoms = [];
    for (let el of this.els) {
      let rect = el.getBoundingClientRect();
      tops.push(rect.top - originClientTop);
      bottoms.push(rect.bottom - originClientTop);
    }
    this.tops = tops;
    this.bottoms = bottoms;
  }
  // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
  // If no intersection is made, returns undefined.
  leftToIndex(leftPosition) {
    let { lefts, rights } = this;
    let len = lefts.length;
    let i3;
    for (i3 = 0; i3 < len; i3 += 1) {
      if (leftPosition >= lefts[i3] && leftPosition < rights[i3]) {
        return i3;
      }
    }
    return void 0;
  }
  // Given a top offset (from document top), returns the index of the el that it vertically intersects.
  // If no intersection is made, returns undefined.
  topToIndex(topPosition) {
    let { tops, bottoms } = this;
    let len = tops.length;
    let i3;
    for (i3 = 0; i3 < len; i3 += 1) {
      if (topPosition >= tops[i3] && topPosition < bottoms[i3]) {
        return i3;
      }
    }
    return void 0;
  }
  // Gets the width of the element at the given index
  getWidth(leftIndex) {
    return this.rights[leftIndex] - this.lefts[leftIndex];
  }
  // Gets the height of the element at the given index
  getHeight(topIndex) {
    return this.bottoms[topIndex] - this.tops[topIndex];
  }
  similarTo(otherCache) {
    return similarNumArrays(this.tops || [], otherCache.tops || []) && similarNumArrays(this.bottoms || [], otherCache.bottoms || []) && similarNumArrays(this.lefts || [], otherCache.lefts || []) && similarNumArrays(this.rights || [], otherCache.rights || []);
  }
};
function similarNumArrays(a3, b3) {
  const len = a3.length;
  if (len !== b3.length) {
    return false;
  }
  for (let i3 = 0; i3 < len; i3++) {
    if (Math.round(a3[i3]) !== Math.round(b3[i3])) {
      return false;
    }
  }
  return true;
}
var ScrollController = class {
  getMaxScrollTop() {
    return this.getScrollHeight() - this.getClientHeight();
  }
  getMaxScrollLeft() {
    return this.getScrollWidth() - this.getClientWidth();
  }
  canScrollVertically() {
    return this.getMaxScrollTop() > 0;
  }
  canScrollHorizontally() {
    return this.getMaxScrollLeft() > 0;
  }
  canScrollUp() {
    return this.getScrollTop() > 0;
  }
  canScrollDown() {
    return this.getScrollTop() < this.getMaxScrollTop();
  }
  canScrollLeft() {
    return this.getScrollLeft() > 0;
  }
  canScrollRight() {
    return this.getScrollLeft() < this.getMaxScrollLeft();
  }
};
var ElementScrollController = class extends ScrollController {
  constructor(el) {
    super();
    this.el = el;
  }
  getScrollTop() {
    return this.el.scrollTop;
  }
  getScrollLeft() {
    return this.el.scrollLeft;
  }
  setScrollTop(top) {
    this.el.scrollTop = top;
  }
  setScrollLeft(left) {
    this.el.scrollLeft = left;
  }
  getScrollWidth() {
    return this.el.scrollWidth;
  }
  getScrollHeight() {
    return this.el.scrollHeight;
  }
  getClientHeight() {
    return this.el.clientHeight;
  }
  getClientWidth() {
    return this.el.clientWidth;
  }
};
var WindowScrollController = class extends ScrollController {
  getScrollTop() {
    return window.scrollY;
  }
  getScrollLeft() {
    return window.scrollX;
  }
  setScrollTop(n2) {
    window.scroll(window.scrollX, n2);
  }
  setScrollLeft(n2) {
    window.scroll(n2, window.scrollY);
  }
  getScrollWidth() {
    return document.documentElement.scrollWidth;
  }
  getScrollHeight() {
    return document.documentElement.scrollHeight;
  }
  getClientHeight() {
    return document.documentElement.clientHeight;
  }
  getClientWidth() {
    return document.documentElement.clientWidth;
  }
};
var DateComponent = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.uid = guid();
  }
  // Hit System
  // -----------------------------------------------------------------------------------------------------------------
  prepareHits() {
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    return null;
  }
  // Pointer Interaction Utils
  // -----------------------------------------------------------------------------------------------------------------
  isValidSegDownEl(el) {
    return !this.props.eventDrag && // HACK
    !this.props.eventResize && // HACK
    !elementClosest(el, ".fc-event-mirror");
  }
  isValidDateDownEl(el) {
    return !elementClosest(el, ".fc-event:not(.fc-bg-event)") && !elementClosest(el, ".fc-more-link") && // a "more.." link
    !elementClosest(el, "a[data-navlink]") && // a clickable nav link
    !elementClosest(el, ".fc-popover");
  }
};
var SegHierarchy = class {
  constructor(getEntryThickness = (entry) => {
    return entry.thickness || 1;
  }) {
    this.getEntryThickness = getEntryThickness;
    this.strictOrder = false;
    this.allowReslicing = false;
    this.maxCoord = -1;
    this.maxStackCnt = -1;
    this.levelCoords = [];
    this.entriesByLevel = [];
    this.stackCnts = {};
  }
  addSegs(inputs) {
    let hiddenEntries = [];
    for (let input of inputs) {
      this.insertEntry(input, hiddenEntries);
    }
    return hiddenEntries;
  }
  insertEntry(entry, hiddenEntries) {
    let insertion = this.findInsertion(entry);
    if (this.isInsertionValid(insertion, entry)) {
      this.insertEntryAt(entry, insertion);
    } else {
      this.handleInvalidInsertion(insertion, entry, hiddenEntries);
    }
  }
  isInsertionValid(insertion, entry) {
    return (this.maxCoord === -1 || insertion.levelCoord + this.getEntryThickness(entry) <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    if (this.allowReslicing && insertion.touchingEntry) {
      const hiddenEntry = Object.assign(Object.assign({}, entry), { span: intersectSpans(entry.span, insertion.touchingEntry.span) });
      hiddenEntries.push(hiddenEntry);
      this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);
    } else {
      hiddenEntries.push(entry);
    }
  }
  /*
  Does NOT add what hit the `barrier` into hiddenEntries. Should already be done.
  */
  splitEntry(entry, barrier, hiddenEntries) {
    let entrySpan = entry.span;
    let barrierSpan = barrier.span;
    if (entrySpan.start < barrierSpan.start) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: entrySpan.start, end: barrierSpan.start }
      }, hiddenEntries);
    }
    if (entrySpan.end > barrierSpan.end) {
      this.insertEntry({
        index: entry.index,
        thickness: entry.thickness,
        span: { start: barrierSpan.end, end: entrySpan.end }
      }, hiddenEntries);
    }
  }
  insertEntryAt(entry, insertion) {
    let { entriesByLevel, levelCoords } = this;
    if (insertion.lateral === -1) {
      insertAt(levelCoords, insertion.level, insertion.levelCoord);
      insertAt(entriesByLevel, insertion.level, [entry]);
    } else {
      insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);
    }
    this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;
  }
  /*
  does not care about limits
  */
  findInsertion(newEntry) {
    let { levelCoords, entriesByLevel, strictOrder, stackCnts } = this;
    let levelCnt = levelCoords.length;
    let candidateCoord = 0;
    let touchingLevel = -1;
    let touchingLateral = -1;
    let touchingEntry = null;
    let stackCnt = 0;
    for (let trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1) {
      const trackingCoord = levelCoords[trackingLevel];
      if (!strictOrder && trackingCoord >= candidateCoord + this.getEntryThickness(newEntry)) {
        break;
      }
      let trackingEntries = entriesByLevel[trackingLevel];
      let trackingEntry;
      let searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd);
      let lateralIndex = searchRes[0] + searchRes[1];
      while (
        // loop through entries that horizontally intersect
        (trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list
        trackingEntry.span.start < newEntry.span.end
      ) {
        let trackingEntryBottom = trackingCoord + this.getEntryThickness(trackingEntry);
        if (trackingEntryBottom > candidateCoord) {
          candidateCoord = trackingEntryBottom;
          touchingEntry = trackingEntry;
          touchingLevel = trackingLevel;
          touchingLateral = lateralIndex;
        }
        if (trackingEntryBottom === candidateCoord) {
          stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);
        }
        lateralIndex += 1;
      }
    }
    let destLevel = 0;
    if (touchingEntry) {
      destLevel = touchingLevel + 1;
      while (destLevel < levelCnt && levelCoords[destLevel] < candidateCoord) {
        destLevel += 1;
      }
    }
    let destLateral = -1;
    if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {
      destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];
    }
    return {
      touchingLevel,
      touchingLateral,
      touchingEntry,
      stackCnt,
      levelCoord: candidateCoord,
      level: destLevel,
      lateral: destLateral
    };
  }
  // sorted by levelCoord (lowest to highest)
  toRects() {
    let { entriesByLevel, levelCoords } = this;
    let levelCnt = entriesByLevel.length;
    let rects = [];
    for (let level = 0; level < levelCnt; level += 1) {
      let entries = entriesByLevel[level];
      let levelCoord = levelCoords[level];
      for (let entry of entries) {
        rects.push(Object.assign(Object.assign({}, entry), { thickness: this.getEntryThickness(entry), levelCoord }));
      }
    }
    return rects;
  }
};
function getEntrySpanEnd(entry) {
  return entry.span.end;
}
function buildEntryKey(entry) {
  return entry.index + ":" + entry.span.start;
}
function groupIntersectingEntries(entries) {
  let merges = [];
  for (let entry of entries) {
    let filteredMerges = [];
    let hungryMerge = {
      span: entry.span,
      entries: [entry]
    };
    for (let merge of merges) {
      if (intersectSpans(merge.span, hungryMerge.span)) {
        hungryMerge = {
          entries: merge.entries.concat(hungryMerge.entries),
          span: joinSpans(merge.span, hungryMerge.span)
        };
      } else {
        filteredMerges.push(merge);
      }
    }
    filteredMerges.push(hungryMerge);
    merges = filteredMerges;
  }
  return merges;
}
function joinSpans(span0, span1) {
  return {
    start: Math.min(span0.start, span1.start),
    end: Math.max(span0.end, span1.end)
  };
}
function intersectSpans(span0, span1) {
  let start = Math.max(span0.start, span1.start);
  let end = Math.min(span0.end, span1.end);
  if (start < end) {
    return { start, end };
  }
  return null;
}
function insertAt(arr, index8, item) {
  arr.splice(index8, 0, item);
}
function binarySearch(a3, searchVal, getItemVal) {
  let startIndex = 0;
  let endIndex = a3.length;
  if (!endIndex || searchVal < getItemVal(a3[startIndex])) {
    return [0, 0];
  }
  if (searchVal > getItemVal(a3[endIndex - 1])) {
    return [endIndex, 0];
  }
  while (startIndex < endIndex) {
    let middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);
    let middleVal = getItemVal(a3[middleIndex]);
    if (searchVal < middleVal) {
      endIndex = middleIndex;
    } else if (searchVal > middleVal) {
      startIndex = middleIndex + 1;
    } else {
      return [middleIndex, 1];
    }
  }
  return [startIndex, 0];
}
var ElementDragging = class {
  constructor(el, selector) {
    this.emitter = new Emitter();
  }
  destroy() {
  }
  setMirrorIsVisible(bool) {
  }
  setMirrorNeedsRevert(bool) {
  }
  setAutoScrollEnabled(bool) {
  }
};
var config = {};
function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {
  if (!datesRepDistinctDays || dayCnt > 10) {
    return createFormatter({ weekday: "short" });
  }
  if (dayCnt > 1) {
    return createFormatter({ weekday: "short", month: "numeric", day: "numeric", omitCommas: true });
  }
  return createFormatter({ weekday: "long" });
}
var CLASS_NAME = "fc-col-header-cell";
function renderInner$1(renderProps) {
  return renderProps.text;
}
var TableDateCell = class extends BaseComponent {
  render() {
    let { dateEnv, options, theme, viewApi } = this.context;
    let { props } = this;
    let { date, dateProfile } = props;
    let dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);
    let classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};
    let renderProps = Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: viewApi }, props.extraRenderProps), { text }), dayMeta);
    return y(ContentContainer, { elTag: "th", elClasses: classNames, elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan, "data-date": !dayMeta.isDisabled ? formatDayString(date) : void 0 }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContainer) => y("div", { className: "fc-scrollgrid-sync-inner" }, !dayMeta.isDisabled && y(InnerContainer, { elTag: "a", elAttrs: navLinkAttrs, elClasses: [
      "fc-col-header-cell-cushion",
      props.isSticky && "fc-sticky"
    ] })));
  }
};
var WEEKDAY_FORMAT = createFormatter({ weekday: "long" });
var TableDowCell = class extends BaseComponent {
  render() {
    let { props } = this;
    let { dateEnv, theme, viewApi, options } = this.context;
    let date = addDays(new Date(2592e5), props.dow);
    let dateMeta = {
      dow: props.dow,
      isDisabled: false,
      isFuture: false,
      isPast: false,
      isToday: false,
      isOther: false
    };
    let text = dateEnv.format(date, props.dayHeaderFormat);
    let renderProps = Object.assign(Object.assign(Object.assign(Object.assign({
      // TODO: make this public?
      date
    }, dateMeta), { view: viewApi }), props.extraRenderProps), { text });
    return y(ContentContainer, { elTag: "th", elClasses: [
      CLASS_NAME,
      ...getDayClassNames(dateMeta, theme),
      ...props.extraClassNames || []
    ], elAttrs: Object.assign({ role: "columnheader", colSpan: props.colSpan }, props.extraDataAttrs), renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInner$1, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-scrollgrid-sync-inner" },
      y(InnerContent, { elTag: "a", elClasses: [
        "fc-col-header-cell-cushion",
        props.isSticky && "fc-sticky"
      ], elAttrs: {
        "aria-label": dateEnv.format(date, WEEKDAY_FORMAT)
      } })
    ));
  }
};
var NowTimer = class extends x {
  constructor(props, context) {
    super(props, context);
    this.initialNowDate = getNow(context.options.now, context.dateEnv);
    this.initialNowQueriedMs = new Date().valueOf();
    this.state = this.computeTiming().currentState;
  }
  render() {
    let { props, state } = this;
    return props.children(state.nowDate, state.todayRange);
  }
  componentDidMount() {
    this.setTimeout();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.unit !== this.props.unit) {
      this.clearTimeout();
      this.setTimeout();
    }
  }
  componentWillUnmount() {
    this.clearTimeout();
  }
  computeTiming() {
    let { props, context } = this;
    let unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);
    let currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);
    let nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));
    let waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();
    waitMs = Math.min(1e3 * 60 * 60 * 24, waitMs);
    return {
      currentState: { nowDate: currentUnitStart, todayRange: buildDayRange(currentUnitStart) },
      nextState: { nowDate: nextUnitStart, todayRange: buildDayRange(nextUnitStart) },
      waitMs
    };
  }
  setTimeout() {
    let { nextState, waitMs } = this.computeTiming();
    this.timeoutId = setTimeout(() => {
      this.setState(nextState, () => {
        this.setTimeout();
      });
    }, waitMs);
  }
  clearTimeout() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
  }
};
NowTimer.contextType = ViewContextType;
function buildDayRange(date) {
  let start = startOfDay(date);
  let end = addDays(start, 1);
  return { start, end };
}
var DayHeader = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);
  }
  render() {
    let { context } = this;
    let { dates, dateProfile, datesRepDistinctDays, renderIntro } = this.props;
    let dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(
      "tr",
      { role: "row" },
      renderIntro && renderIntro("day"),
      dates.map((date) => datesRepDistinctDays ? y(TableDateCell, { key: date.toISOString(), date, dateProfile, todayRange, colCnt: dates.length, dayHeaderFormat }) : y(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat }))
    ));
  }
};
function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {
  return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);
}
var DaySeriesModel = class {
  constructor(range2, dateProfileGenerator) {
    let date = range2.start;
    let { end } = range2;
    let indices = [];
    let dates = [];
    let dayIndex = -1;
    while (date < end) {
      if (dateProfileGenerator.isHiddenDay(date)) {
        indices.push(dayIndex + 0.5);
      } else {
        dayIndex += 1;
        indices.push(dayIndex);
        dates.push(date);
      }
      date = addDays(date, 1);
    }
    this.dates = dates;
    this.indices = indices;
    this.cnt = dates.length;
  }
  sliceRange(range2) {
    let firstIndex = this.getDateDayIndex(range2.start);
    let lastIndex = this.getDateDayIndex(addDays(range2.end, -1));
    let clippedFirstIndex = Math.max(0, firstIndex);
    let clippedLastIndex = Math.min(this.cnt - 1, lastIndex);
    clippedFirstIndex = Math.ceil(clippedFirstIndex);
    clippedLastIndex = Math.floor(clippedLastIndex);
    if (clippedFirstIndex <= clippedLastIndex) {
      return {
        firstIndex: clippedFirstIndex,
        lastIndex: clippedLastIndex,
        isStart: firstIndex === clippedFirstIndex,
        isEnd: lastIndex === clippedLastIndex
      };
    }
    return null;
  }
  // Given a date, returns its chronolocial cell-index from the first cell of the grid.
  // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
  // If before the first offset, returns a negative number.
  // If after the last offset, returns an offset past the last cell offset.
  // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
  getDateDayIndex(date) {
    let { indices } = this;
    let dayOffset = Math.floor(diffDays(this.dates[0], date));
    if (dayOffset < 0) {
      return indices[0] - 1;
    }
    if (dayOffset >= indices.length) {
      return indices[indices.length - 1] + 1;
    }
    return indices[dayOffset];
  }
};
var DayTableModel = class {
  constructor(daySeries, breakOnWeeks) {
    let { dates } = daySeries;
    let daysPerRow;
    let firstDay;
    let rowCnt;
    if (breakOnWeeks) {
      firstDay = dates[0].getUTCDay();
      for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {
        if (dates[daysPerRow].getUTCDay() === firstDay) {
          break;
        }
      }
      rowCnt = Math.ceil(dates.length / daysPerRow);
    } else {
      rowCnt = 1;
      daysPerRow = dates.length;
    }
    this.rowCnt = rowCnt;
    this.colCnt = daysPerRow;
    this.daySeries = daySeries;
    this.cells = this.buildCells();
    this.headerDates = this.buildHeaderDates();
  }
  buildCells() {
    let rows = [];
    for (let row = 0; row < this.rowCnt; row += 1) {
      let cells = [];
      for (let col = 0; col < this.colCnt; col += 1) {
        cells.push(this.buildCell(row, col));
      }
      rows.push(cells);
    }
    return rows;
  }
  buildCell(row, col) {
    let date = this.daySeries.dates[row * this.colCnt + col];
    return {
      key: date.toISOString(),
      date
    };
  }
  buildHeaderDates() {
    let dates = [];
    for (let col = 0; col < this.colCnt; col += 1) {
      dates.push(this.cells[0][col].date);
    }
    return dates;
  }
  sliceRange(range2) {
    let { colCnt } = this;
    let seriesSeg = this.daySeries.sliceRange(range2);
    let segs = [];
    if (seriesSeg) {
      let { firstIndex, lastIndex } = seriesSeg;
      let index8 = firstIndex;
      while (index8 <= lastIndex) {
        let row = Math.floor(index8 / colCnt);
        let nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);
        segs.push({
          row,
          firstCol: index8 % colCnt,
          lastCol: (nextIndex - 1) % colCnt,
          isStart: seriesSeg.isStart && index8 === firstIndex,
          isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex
        });
        index8 = nextIndex;
      }
    }
    return segs;
  }
};
var Slicer = class {
  constructor() {
    this.sliceBusinessHours = memoize(this._sliceBusinessHours);
    this.sliceDateSelection = memoize(this._sliceDateSpan);
    this.sliceEventStore = memoize(this._sliceEventStore);
    this.sliceEventDrag = memoize(this._sliceInteraction);
    this.sliceEventResize = memoize(this._sliceInteraction);
    this.forceDayIfListItem = false;
  }
  sliceProps(props, dateProfile, nextDayThreshold, context, ...extraArgs) {
    let { eventUiBases } = props;
    let eventSegs = this.sliceEventStore(props.eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs);
    return {
      dateSelectionSegs: this.sliceDateSelection(props.dateSelection, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs),
      businessHourSegs: this.sliceBusinessHours(props.businessHours, dateProfile, nextDayThreshold, context, ...extraArgs),
      fgEventSegs: eventSegs.fg,
      bgEventSegs: eventSegs.bg,
      eventDrag: this.sliceEventDrag(props.eventDrag, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventResize: this.sliceEventResize(props.eventResize, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs),
      eventSelection: props.eventSelection
    };
  }
  sliceNowDate(date, dateProfile, nextDayThreshold, context, ...extraArgs) {
    return this._sliceDateSpan(
      { range: { start: date, end: addMs(date, 1) }, allDay: false },
      // add 1 ms, protect against null range
      dateProfile,
      nextDayThreshold,
      {},
      context,
      ...extraArgs
    );
  }
  _sliceBusinessHours(businessHours, dateProfile, nextDayThreshold, context, ...extraArgs) {
    if (!businessHours) {
      return [];
    }
    return this._sliceEventStore(expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context), {}, dateProfile, nextDayThreshold, ...extraArgs).bg;
  }
  _sliceEventStore(eventStore, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (eventStore) {
      let rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
      return {
        bg: this.sliceEventRanges(rangeRes.bg, extraArgs),
        fg: this.sliceEventRanges(rangeRes.fg, extraArgs)
      };
    }
    return { bg: [], fg: [] };
  }
  _sliceInteraction(interaction, eventUiBases, dateProfile, nextDayThreshold, ...extraArgs) {
    if (!interaction) {
      return null;
    }
    let rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);
    return {
      segs: this.sliceEventRanges(rangeRes.fg, extraArgs),
      affectedInstances: interaction.affectedEvents.instances,
      isEvent: interaction.isEvent
    };
  }
  _sliceDateSpan(dateSpan, dateProfile, nextDayThreshold, eventUiBases, context, ...extraArgs) {
    if (!dateSpan) {
      return [];
    }
    let activeRange = computeActiveRange(dateProfile, Boolean(nextDayThreshold));
    let activeDateSpanRange = intersectRanges(dateSpan.range, activeRange);
    if (activeDateSpanRange) {
      dateSpan = Object.assign(Object.assign({}, dateSpan), { range: activeDateSpanRange });
      let eventRange = fabricateEventRange(dateSpan, eventUiBases, context);
      let segs = this.sliceRange(dateSpan.range, ...extraArgs);
      for (let seg of segs) {
        seg.eventRange = eventRange;
      }
      return segs;
    }
    return [];
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRanges(eventRanges, extraArgs) {
    let segs = [];
    for (let eventRange of eventRanges) {
      segs.push(...this.sliceEventRange(eventRange, extraArgs));
    }
    return segs;
  }
  /*
  "complete" seg means it has component and eventRange
  */
  sliceEventRange(eventRange, extraArgs) {
    let dateRange = eventRange.range;
    if (this.forceDayIfListItem && eventRange.ui.display === "list-item") {
      dateRange = {
        start: dateRange.start,
        end: addDays(dateRange.start, 1)
      };
    }
    let segs = this.sliceRange(dateRange, ...extraArgs);
    for (let seg of segs) {
      seg.eventRange = eventRange;
      seg.isStart = eventRange.isStart && seg.isStart;
      seg.isEnd = eventRange.isEnd && seg.isEnd;
    }
    return segs;
  }
};
function computeActiveRange(dateProfile, isComponentAllDay) {
  let range2 = dateProfile.activeRange;
  if (isComponentAllDay) {
    return range2;
  }
  return {
    start: addMs(range2.start, dateProfile.slotMinTime.milliseconds),
    end: addMs(range2.end, dateProfile.slotMaxTime.milliseconds - 864e5)
    // 864e5 = ms in a day
  };
}
function isInteractionValid(interaction, dateProfile, context) {
  let { instances } = interaction.mutatedEvents;
  for (let instanceId in instances) {
    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {
      return false;
    }
  }
  return isNewPropsValid({ eventDrag: interaction }, context);
}
function isDateSelectionValid(dateSelection, dateProfile, context) {
  if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {
    return false;
  }
  return isNewPropsValid({ dateSelection }, context);
}
function isNewPropsValid(newProps, context) {
  let calendarState = context.getCurrentData();
  let props = Object.assign({ businessHours: calendarState.businessHours, dateSelection: "", eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: "", eventDrag: null, eventResize: null }, newProps);
  return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);
}
function isPropsValid(state, context, dateSpanMeta = {}, filterConfig) {
  if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {
    return false;
  }
  return true;
}
function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let currentState = context.getCurrentData();
  let interaction = state.eventDrag;
  let subjectEventStore = interaction.mutatedEvents;
  let subjectDefs = subjectEventStore.defs;
  let subjectInstances = subjectEventStore.instances;
  let subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : { "": currentState.selectionConfig });
  if (filterConfig) {
    subjectConfigs = mapHash(subjectConfigs, filterConfig);
  }
  let otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);
  let otherDefs = otherEventStore.defs;
  let otherInstances = otherEventStore.instances;
  let otherConfigs = compileEventUis(otherDefs, state.eventUiBases);
  for (let subjectInstanceId in subjectInstances) {
    let subjectInstance = subjectInstances[subjectInstanceId];
    let subjectRange = subjectInstance.range;
    let subjectConfig = subjectConfigs[subjectInstance.defId];
    let subjectDef = subjectDefs[subjectInstance.defId];
    if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {
      return false;
    }
    let { eventOverlap } = context.options;
    let eventOverlapFunc = typeof eventOverlap === "function" ? eventOverlap : null;
    for (let otherInstanceId in otherInstances) {
      let otherInstance = otherInstances[otherInstanceId];
      if (rangesIntersect(subjectRange, otherInstance.range)) {
        let otherOverlap = otherConfigs[otherInstance.defId].overlap;
        if (otherOverlap === false && interaction.isEvent) {
          return false;
        }
        if (subjectConfig.overlap === false) {
          return false;
        }
        if (eventOverlapFunc && !eventOverlapFunc(
          new EventImpl(context, otherDefs[otherInstance.defId], otherInstance),
          // still event
          new EventImpl(context, subjectDef, subjectInstance)
        )) {
          return false;
        }
      }
    }
    let calendarEventStore = currentState.eventStore;
    for (let subjectAllow of subjectConfig.allows) {
      let subjectDateSpan = Object.assign(Object.assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });
      let origDef = calendarEventStore.defs[subjectDef.defId];
      let origInstance = calendarEventStore.instances[subjectInstanceId];
      let eventApi;
      if (origDef) {
        eventApi = new EventImpl(context, origDef, origInstance);
      } else {
        eventApi = new EventImpl(context, subjectDef);
      }
      if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {
        return false;
      }
    }
  }
  return true;
}
function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {
  let relevantEventStore = state.eventStore;
  let relevantDefs = relevantEventStore.defs;
  let relevantInstances = relevantEventStore.instances;
  let selection = state.dateSelection;
  let selectionRange = selection.range;
  let { selectionConfig } = context.getCurrentData();
  if (filterConfig) {
    selectionConfig = filterConfig(selectionConfig);
  }
  if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {
    return false;
  }
  let { selectOverlap } = context.options;
  let selectOverlapFunc = typeof selectOverlap === "function" ? selectOverlap : null;
  for (let relevantInstanceId in relevantInstances) {
    let relevantInstance = relevantInstances[relevantInstanceId];
    if (rangesIntersect(selectionRange, relevantInstance.range)) {
      if (selectionConfig.overlap === false) {
        return false;
      }
      if (selectOverlapFunc && !selectOverlapFunc(new EventImpl(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {
        return false;
      }
    }
  }
  for (let selectionAllow of selectionConfig.allows) {
    let fullDateSpan = Object.assign(Object.assign({}, dateSpanMeta), selection);
    if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {
      return false;
    }
  }
  return true;
}
function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  for (let constraint of constraints) {
    if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {
      return false;
    }
  }
  return true;
}
function constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {
  if (constraint === "businessHours") {
    return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));
  }
  if (typeof constraint === "string") {
    return eventStoreToRanges(filterEventStoreDefs(otherEventStore, (eventDef) => eventDef.groupId === constraint));
  }
  if (typeof constraint === "object" && constraint) {
    return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));
  }
  return [];
}
function eventStoreToRanges(eventStore) {
  let { instances } = eventStore;
  let ranges = [];
  for (let instanceId in instances) {
    ranges.push(instances[instanceId].range);
  }
  return ranges;
}
function anyRangesContainRange(outerRanges, innerRange) {
  for (let outerRange of outerRanges) {
    if (rangeContainsRange(outerRange, innerRange)) {
      return true;
    }
  }
  return false;
}
var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;
var Scroller = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { props } = this;
    let { liquid, liquidIsAbsolute } = props;
    let isAbsolute = liquid && liquidIsAbsolute;
    let className = ["fc-scroller"];
    if (liquid) {
      if (liquidIsAbsolute) {
        className.push("fc-scroller-liquid-absolute");
      } else {
        className.push("fc-scroller-liquid");
      }
    }
    return y("div", { ref: this.handleEl, className: className.join(" "), style: {
      overflowX: props.overflowX,
      overflowY: props.overflowY,
      left: isAbsolute && -(props.overcomeLeft || 0) || "",
      right: isAbsolute && -(props.overcomeRight || 0) || "",
      bottom: isAbsolute && -(props.overcomeBottom || 0) || "",
      marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || "",
      marginRight: !isAbsolute && -(props.overcomeRight || 0) || "",
      marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || "",
      maxHeight: props.maxHeight || ""
    } }, props.children);
  }
  needsXScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return false;
    }
    let { el } = this;
    let realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();
    let { children } = el;
    for (let i3 = 0; i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().width > realClientWidth) {
        return true;
      }
    }
    return false;
  }
  needsYScrolling() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return false;
    }
    let { el } = this;
    let realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();
    let { children } = el;
    for (let i3 = 0; i3 < children.length; i3 += 1) {
      let childEl = children[i3];
      if (childEl.getBoundingClientRect().height > realClientHeight) {
        return true;
      }
    }
    return false;
  }
  getXScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {
      return 0;
    }
    return this.el.offsetHeight - this.el.clientHeight;
  }
  getYScrollbarWidth() {
    if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {
      return 0;
    }
    return this.el.offsetWidth - this.el.clientWidth;
  }
};
var RefMap = class {
  constructor(masterCallback) {
    this.masterCallback = masterCallback;
    this.currentMap = {};
    this.depths = {};
    this.callbackMap = {};
    this.handleValue = (val, key) => {
      let { depths, currentMap } = this;
      let removed = false;
      let added = false;
      if (val !== null) {
        removed = key in currentMap;
        currentMap[key] = val;
        depths[key] = (depths[key] || 0) + 1;
        added = true;
      } else {
        depths[key] -= 1;
        if (!depths[key]) {
          delete currentMap[key];
          delete this.callbackMap[key];
          removed = true;
        }
      }
      if (this.masterCallback) {
        if (removed) {
          this.masterCallback(null, String(key));
        }
        if (added) {
          this.masterCallback(val, String(key));
        }
      }
    };
  }
  createRef(key) {
    let refCallback = this.callbackMap[key];
    if (!refCallback) {
      refCallback = this.callbackMap[key] = (val) => {
        this.handleValue(val, String(key));
      };
    }
    return refCallback;
  }
  // TODO: check callers that don't care about order. should use getAll instead
  // NOTE: this method has become less valuable now that we are encouraged to map order by some other index
  // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and "collect"
  collect(startIndex, endIndex, step) {
    return collectFromHash(this.currentMap, startIndex, endIndex, step);
  }
  getAll() {
    return hashValuesToArray(this.currentMap);
  }
};
function computeShrinkWidth(chunkEls) {
  let shrinkCells = findElements(chunkEls, ".fc-scrollgrid-shrink");
  let largestWidth = 0;
  for (let shrinkCell of shrinkCells) {
    largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));
  }
  return Math.ceil(largestWidth);
}
function getSectionHasLiquidHeight(props, sectionConfig) {
  return props.liquid && sectionConfig.liquid;
}
function getAllowYScrolling(props, sectionConfig) {
  return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars
  getSectionHasLiquidHeight(props, sectionConfig);
}
function renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {
  let { expandRows } = arg;
  let content = typeof chunkConfig.content === "function" ? chunkConfig.content(arg) : y("table", {
    role: "presentation",
    className: [
      chunkConfig.tableClassName,
      sectionConfig.syncRowHeights ? "fc-scrollgrid-sync-table" : ""
    ].join(" "),
    style: {
      minWidth: arg.tableMinWidth,
      width: arg.clientWidth,
      height: expandRows ? arg.clientHeight : ""
      // css `height` on a <table> serves as a min-height
    }
  }, arg.tableColGroupNode, y(isHeader ? "thead" : "tbody", {
    role: "presentation"
  }, typeof chunkConfig.rowContent === "function" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));
  return content;
}
function isColPropsEqual(cols0, cols1) {
  return isArraysEqual(cols0, cols1, isPropsEqual);
}
function renderMicroColGroup(cols, shrinkWidth) {
  let colNodes = [];
  for (let colProps of cols) {
    let span = colProps.span || 1;
    for (let i3 = 0; i3 < span; i3 += 1) {
      colNodes.push(y("col", { style: {
        width: colProps.width === "shrink" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || "",
        minWidth: colProps.minWidth || ""
      } }));
    }
  }
  return y("colgroup", {}, ...colNodes);
}
function sanitizeShrinkWidth(shrinkWidth) {
  return shrinkWidth == null ? 4 : shrinkWidth;
}
function hasShrinkWidth(cols) {
  for (let col of cols) {
    if (col.width === "shrink") {
      return true;
    }
  }
  return false;
}
function getScrollGridClassNames(liquid, context) {
  let classNames = [
    "fc-scrollgrid",
    context.theme.getClass("table")
  ];
  if (liquid) {
    classNames.push("fc-scrollgrid-liquid");
  }
  return classNames;
}
function getSectionClassNames(sectionConfig, wholeTableVGrow) {
  let classNames = [
    "fc-scrollgrid-section",
    `fc-scrollgrid-section-${sectionConfig.type}`,
    sectionConfig.className
    // used?
  ];
  if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {
    classNames.push("fc-scrollgrid-section-liquid");
  }
  if (sectionConfig.isSticky) {
    classNames.push("fc-scrollgrid-section-sticky");
  }
  return classNames;
}
function renderScrollShim(arg) {
  return y("div", { className: "fc-scrollgrid-sticky-shim", style: {
    width: arg.clientWidth,
    minWidth: arg.tableMinWidth
  } });
}
function getStickyHeaderDates(options) {
  let { stickyHeaderDates } = options;
  if (stickyHeaderDates == null || stickyHeaderDates === "auto") {
    stickyHeaderDates = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyHeaderDates;
}
function getStickyFooterScrollbar(options) {
  let { stickyFooterScrollbar } = options;
  if (stickyFooterScrollbar == null || stickyFooterScrollbar === "auto") {
    stickyFooterScrollbar = options.height === "auto" || options.viewHeight === "auto";
  }
  return stickyFooterScrollbar;
}
var SimpleScrollGrid = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.processCols = memoize((a3) => a3, isColPropsEqual);
    this.renderMicroColGroup = memoize(renderMicroColGroup);
    this.scrollerRefs = new RefMap();
    this.scrollerElRefs = new RefMap(this._handleScrollerEl.bind(this));
    this.state = {
      shrinkWidth: null,
      forceYScrollbars: false,
      scrollerClientWidths: {},
      scrollerClientHeights: {}
    };
    this.handleSizing = () => {
      this.safeSetState(Object.assign({ shrinkWidth: this.computeShrinkWidth() }, this.computeScrollerDims()));
    };
  }
  render() {
    let { props, state, context } = this;
    let sectionConfigs = props.sections || [];
    let cols = this.processCols(props.cols);
    let microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);
    let classNames = getScrollGridClassNames(props.liquid, context);
    if (props.collapsibleWidth) {
      classNames.push("fc-scrollgrid-collapsible");
    }
    let configCnt = sectionConfigs.length;
    let configI = 0;
    let currentConfig;
    let headSectionNodes = [];
    let bodySectionNodes = [];
    let footSectionNodes = [];
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "header") {
      headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "body") {
      bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));
      configI += 1;
    }
    while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === "footer") {
      footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));
      configI += 1;
    }
    let isBuggy = !getCanVGrowWithinCell();
    const roleAttrs = { role: "rowgroup" };
    return y("table", {
      role: "grid",
      className: classNames.join(" "),
      style: { height: props.height }
    }, Boolean(!isBuggy && headSectionNodes.length) && y("thead", roleAttrs, ...headSectionNodes), Boolean(!isBuggy && bodySectionNodes.length) && y("tbody", roleAttrs, ...bodySectionNodes), Boolean(!isBuggy && footSectionNodes.length) && y("tfoot", roleAttrs, ...footSectionNodes), isBuggy && y("tbody", roleAttrs, ...headSectionNodes, ...bodySectionNodes, ...footSectionNodes));
  }
  renderSection(sectionConfig, microColGroupNode, isHeader) {
    if ("outerContent" in sectionConfig) {
      return y(_, { key: sectionConfig.key }, sectionConfig.outerContent);
    }
    return y("tr", { key: sectionConfig.key, role: "presentation", className: getSectionClassNames(sectionConfig, this.props.liquid).join(" ") }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));
  }
  renderChunkTd(sectionConfig, microColGroupNode, chunkConfig, isHeader) {
    if ("outerContent" in chunkConfig) {
      return chunkConfig.outerContent;
    }
    let { props } = this;
    let { forceYScrollbars, scrollerClientWidths, scrollerClientHeights } = this.state;
    let needsYScrolling = getAllowYScrolling(props, sectionConfig);
    let isLiquid = getSectionHasLiquidHeight(props, sectionConfig);
    let overflowY = !props.liquid ? "visible" : forceYScrollbars ? "scroll" : !needsYScrolling ? "hidden" : "auto";
    let sectionKey = sectionConfig.key;
    let content = renderChunkContent(sectionConfig, chunkConfig, {
      tableColGroupNode: microColGroupNode,
      tableMinWidth: "",
      clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== void 0 ? scrollerClientWidths[sectionKey] : null,
      clientHeight: scrollerClientHeights[sectionKey] !== void 0 ? scrollerClientHeights[sectionKey] : null,
      expandRows: sectionConfig.expandRows,
      syncRowHeights: false,
      rowSyncHeights: [],
      reportRowHeightChange: () => {
      }
    }, isHeader);
    return y(isHeader ? "th" : "td", {
      ref: chunkConfig.elRef,
      role: "presentation"
    }, y(
      "div",
      { className: `fc-scroller-harness${isLiquid ? " fc-scroller-harness-liquid" : ""}` },
      y(Scroller, { ref: this.scrollerRefs.createRef(sectionKey), elRef: this.scrollerElRefs.createRef(sectionKey), overflowY, overflowX: !props.liquid ? "visible" : "hidden", maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute: true }, content)
    ));
  }
  _handleScrollerEl(scrollerEl, key) {
    let section = getSectionByKey(this.props.sections, key);
    if (section) {
      setRef(section.chunk.scrollerElRef, scrollerEl);
    }
  }
  componentDidMount() {
    this.handleSizing();
    this.context.addResizeHandler(this.handleSizing);
  }
  componentDidUpdate() {
    this.handleSizing();
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleSizing);
  }
  computeShrinkWidth() {
    return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;
  }
  computeScrollerDims() {
    let scrollbarWidth = getScrollbarWidths();
    let { scrollerRefs, scrollerElRefs } = this;
    let forceYScrollbars = false;
    let scrollerClientWidths = {};
    let scrollerClientHeights = {};
    for (let sectionKey in scrollerRefs.currentMap) {
      let scroller = scrollerRefs.currentMap[sectionKey];
      if (scroller && scroller.needsYScrolling()) {
        forceYScrollbars = true;
        break;
      }
    }
    for (let section of this.props.sections) {
      let sectionKey = section.key;
      let scrollerEl = scrollerElRefs.currentMap[sectionKey];
      if (scrollerEl) {
        let harnessEl = scrollerEl.parentNode;
        scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y : 0));
        scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);
      }
    }
    return { forceYScrollbars, scrollerClientWidths, scrollerClientHeights };
  }
};
SimpleScrollGrid.addStateEquality({
  scrollerClientWidths: isPropsEqual,
  scrollerClientHeights: isPropsEqual
});
function getSectionByKey(sections, key) {
  for (let section of sections) {
    if (section.key === key) {
      return section;
    }
  }
  return null;
}
var EventContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.handleEl = (el) => {
      this.el = el;
      if (el) {
        setElSeg(el, this.props.seg);
      }
    };
  }
  render() {
    const { props, context } = this;
    const { options } = context;
    const { seg } = props;
    const { eventRange } = seg;
    const { ui } = eventRange;
    const renderProps = {
      event: new EventImpl(context, eventRange.def, eventRange.instance),
      view: context.viewApi,
      timeText: props.timeText,
      textColor: ui.textColor,
      backgroundColor: ui.backgroundColor,
      borderColor: ui.borderColor,
      isDraggable: !props.disableDragging && computeSegDraggable(seg, context),
      isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),
      isEndResizable: !props.disableResizing && computeSegEndResizable(seg),
      isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),
      isStart: Boolean(seg.isStart),
      isEnd: Boolean(seg.isEnd),
      isPast: Boolean(props.isPast),
      isFuture: Boolean(props.isFuture),
      isToday: Boolean(props.isToday),
      isSelected: Boolean(props.isSelected),
      isDragging: Boolean(props.isDragging),
      isResizing: Boolean(props.isResizing)
    };
    return y(ContentContainer, Object.assign({}, props, { elRef: this.handleEl, elClasses: [
      ...getEventClassNames(renderProps),
      ...seg.eventRange.ui.classNames,
      ...props.elClasses || []
    ], renderProps, generatorName: "eventContent", customGenerator: options.eventContent, defaultGenerator: props.defaultGenerator, classNameGenerator: options.eventClassNames, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount }));
  }
  componentDidUpdate(prevProps) {
    if (this.el && this.props.seg !== prevProps.seg) {
      setElSeg(this.el, this.props.seg);
    }
  }
};
var StandardEvent = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let { ui } = seg.eventRange;
    let timeFormat = options.eventTimeFormat || props.defaultTimeFormat;
    let timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elStyle: {
      borderColor: ui.borderColor,
      backgroundColor: ui.backgroundColor
    }, elAttrs: getSegAnchorAttrs(seg, context), defaultGenerator: renderInnerContent$1, timeText }), (InnerContent, eventContentArg) => y(
      _,
      null,
      y(InnerContent, { elTag: "div", elClasses: ["fc-event-main"], elStyle: { color: eventContentArg.textColor } }),
      Boolean(eventContentArg.isStartResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-start" }),
      Boolean(eventContentArg.isEndResizable) && y("div", { className: "fc-event-resizer fc-event-resizer-end" })
    ));
  }
};
function renderInnerContent$1(innerProps) {
  return y(
    "div",
    { className: "fc-event-main-frame" },
    innerProps.timeText && y("div", { className: "fc-event-time" }, innerProps.timeText),
    y(
      "div",
      { className: "fc-event-title-container" },
      y("div", { className: "fc-event-title fc-sticky" }, innerProps.event.title || y(_, null, "\xA0"))
    )
  );
}
var NowIndicatorContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
  let { options } = context;
  let renderProps = {
    isAxis: props.isAxis,
    date: context.dateEnv.toDate(props.date),
    view: context.viewApi
  };
  return y(ContentContainer, Object.assign({}, props, { elTag: props.elTag || "div", renderProps, generatorName: "nowIndicatorContent", customGenerator: options.nowIndicatorContent, classNameGenerator: options.nowIndicatorClassNames, didMount: options.nowIndicatorDidMount, willUnmount: options.nowIndicatorWillUnmount }));
});
var DAY_NUM_FORMAT = createFormatter({ day: "numeric" });
var DayCellContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.refineRenderProps = memoizeObjArg(refineRenderProps);
  }
  render() {
    let { props, context } = this;
    let { options } = context;
    let renderProps = this.refineRenderProps({
      date: props.date,
      dateProfile: props.dateProfile,
      todayRange: props.todayRange,
      isMonthStart: props.isMonthStart || false,
      showDayNumber: props.showDayNumber,
      extraRenderProps: props.extraRenderProps,
      viewApi: context.viewApi,
      dateEnv: context.dateEnv,
      monthStartFormat: options.monthStartFormat
    });
    return y(ContentContainer, Object.assign({}, props, { elClasses: [
      ...getDayClassNames(renderProps, context.theme),
      ...props.elClasses || []
    ], elAttrs: Object.assign(Object.assign({}, props.elAttrs), renderProps.isDisabled ? {} : { "data-date": formatDayString(props.date) }), renderProps, generatorName: "dayCellContent", customGenerator: options.dayCellContent, defaultGenerator: props.defaultGenerator, classNameGenerator: (
      // don't use custom classNames if disabled
      renderProps.isDisabled ? void 0 : options.dayCellClassNames
    ), didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount }));
  }
};
function hasCustomDayCellContent(options) {
  return Boolean(options.dayCellContent || hasCustomRenderingHandler("dayCellContent", options));
}
function refineRenderProps(raw) {
  let { date, dateEnv, dateProfile, isMonthStart } = raw;
  let dayMeta = getDateMeta(date, raw.todayRange, null, dateProfile);
  let dayNumberText = raw.showDayNumber ? dateEnv.format(date, isMonthStart ? raw.monthStartFormat : DAY_NUM_FORMAT) : "";
  return Object.assign(Object.assign(Object.assign({ date: dateEnv.toDate(date), view: raw.viewApi }, dayMeta), {
    isMonthStart,
    dayNumberText
  }), raw.extraRenderProps);
}
var BgEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    let { seg } = props;
    return y(EventContainer, { elTag: "div", elClasses: ["fc-bg-event"], elStyle: { backgroundColor: seg.eventRange.ui.backgroundColor }, defaultGenerator: renderInnerContent, seg, timeText: "", isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday, disableDragging: true, disableResizing: true });
  }
};
function renderInnerContent(props) {
  let { title } = props.event;
  return title && y("div", { className: "fc-event-title" }, props.event.title);
}
function renderFill(fillType) {
  return y("div", { className: `fc-${fillType}` });
}
var WeekNumberContainer = (props) => y(ViewContextType.Consumer, null, (context) => {
  let { dateEnv, options } = context;
  let { date } = props;
  let format = options.weekNumberFormat || props.defaultFormat;
  let num = dateEnv.computeWeekNumber(date);
  let text = dateEnv.format(date, format);
  let renderProps = { num, text, date };
  return y(
    ContentContainer,
    Object.assign({}, props, { renderProps, generatorName: "weekNumberContent", customGenerator: options.weekNumberContent, defaultGenerator: renderInner, classNameGenerator: options.weekNumberClassNames, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount })
  );
});
function renderInner(innerProps) {
  return innerProps.text;
}
var PADDING_FROM_VIEWPORT = 10;
var Popover = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      titleId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      this.rootEl = el;
      if (this.props.elRef) {
        setRef(this.props.elRef, el);
      }
    };
    this.handleDocumentMouseDown = (ev) => {
      const target = getEventTargetViaRoot(ev);
      if (!this.rootEl.contains(target)) {
        this.handleCloseClick();
      }
    };
    this.handleDocumentKeyDown = (ev) => {
      if (ev.key === "Escape") {
        this.handleCloseClick();
      }
    };
    this.handleCloseClick = () => {
      let { onClose } = this.props;
      if (onClose) {
        onClose();
      }
    };
  }
  render() {
    let { theme, options } = this.context;
    let { props, state } = this;
    let classNames = [
      "fc-popover",
      theme.getClass("popover")
    ].concat(props.extraClassNames || []);
    return j3(y(
      "div",
      Object.assign({}, props.extraAttrs, { id: props.id, className: classNames.join(" "), "aria-labelledby": state.titleId, ref: this.handleRootEl }),
      y(
        "div",
        { className: "fc-popover-header " + theme.getClass("popoverHeader") },
        y("span", { className: "fc-popover-title", id: state.titleId }, props.title),
        y("span", { className: "fc-popover-close " + theme.getIconClass("close"), title: options.closeHint, onClick: this.handleCloseClick })
      ),
      y("div", { className: "fc-popover-body " + theme.getClass("popoverContent") }, props.children)
    ), props.parentEl);
  }
  componentDidMount() {
    document.addEventListener("mousedown", this.handleDocumentMouseDown);
    document.addEventListener("keydown", this.handleDocumentKeyDown);
    this.updateSize();
  }
  componentWillUnmount() {
    document.removeEventListener("mousedown", this.handleDocumentMouseDown);
    document.removeEventListener("keydown", this.handleDocumentKeyDown);
  }
  updateSize() {
    let { isRtl } = this.context;
    let { alignmentEl, alignGridTop } = this.props;
    let { rootEl } = this;
    let alignmentRect = computeClippedClientRect(alignmentEl);
    if (alignmentRect) {
      let popoverDims = rootEl.getBoundingClientRect();
      let popoverTop = alignGridTop ? elementClosest(alignmentEl, ".fc-scrollgrid").getBoundingClientRect().top : alignmentRect.top;
      let popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;
      popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);
      popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);
      popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);
      let origin = rootEl.offsetParent.getBoundingClientRect();
      applyStyle(rootEl, {
        top: popoverTop - origin.top,
        left: popoverLeft - origin.left
      });
    }
  }
};
var MorePopover = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.handleRootEl = (rootEl) => {
      this.rootEl = rootEl;
      if (rootEl) {
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          useEventCenter: false
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
  }
  render() {
    let { options, dateEnv } = this.context;
    let { props } = this;
    let { startDate, todayRange, dateProfile } = props;
    let title = dateEnv.format(startDate, options.dayPopoverFormat);
    return y(DayCellContainer, { elRef: this.handleRootEl, date: startDate, dateProfile, todayRange }, (InnerContent, renderProps, elAttrs) => y(
      Popover,
      { elRef: elAttrs.ref, id: props.id, title, extraClassNames: ["fc-more-popover"].concat(elAttrs.className || []), extraAttrs: elAttrs, parentEl: props.parentEl, alignmentEl: props.alignmentEl, alignGridTop: props.alignGridTop, onClose: props.onClose },
      hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-more-popover-misc"] }),
      props.children
    ));
  }
  queryHit(positionLeft, positionTop, elWidth, elHeight) {
    let { rootEl, props } = this;
    if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {
      return {
        dateProfile: props.dateProfile,
        dateSpan: Object.assign({ allDay: !props.forceTimed, range: {
          start: props.startDate,
          end: props.endDate
        } }, props.extraDateSpan),
        dayEl: rootEl,
        rect: {
          left: 0,
          top: 0,
          right: elWidth,
          bottom: elHeight
        },
        layer: 1
        // important when comparing with hits from other components
      };
    }
    return null;
  }
};
var MoreLinkContainer = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      isPopoverOpen: false,
      popoverId: getUniqueDomId()
    };
    this.handleLinkEl = (linkEl) => {
      this.linkEl = linkEl;
      if (this.props.elRef) {
        setRef(this.props.elRef, linkEl);
      }
    };
    this.handleClick = (ev) => {
      let { props, context } = this;
      let { moreLinkClick } = context.options;
      let date = computeRange(props).start;
      function buildPublicSeg(seg) {
        let { def, instance, range: range2 } = seg.eventRange;
        return {
          event: new EventImpl(context, def, instance),
          start: context.dateEnv.toDate(range2.start),
          end: context.dateEnv.toDate(range2.end),
          isStart: seg.isStart,
          isEnd: seg.isEnd
        };
      }
      if (typeof moreLinkClick === "function") {
        moreLinkClick = moreLinkClick({
          date,
          allDay: Boolean(props.allDayDate),
          allSegs: props.allSegs.map(buildPublicSeg),
          hiddenSegs: props.hiddenSegs.map(buildPublicSeg),
          jsEvent: ev,
          view: context.viewApi
        });
      }
      if (!moreLinkClick || moreLinkClick === "popover") {
        this.setState({ isPopoverOpen: true });
      } else if (typeof moreLinkClick === "string") {
        context.calendarApi.zoomTo(date, moreLinkClick);
      }
    };
    this.handlePopoverClose = () => {
      this.setState({ isPopoverOpen: false });
    };
  }
  render() {
    let { props, state } = this;
    return y(ViewContextType.Consumer, null, (context) => {
      let { viewApi, options, calendarApi } = context;
      let { moreLinkText } = options;
      let { moreCnt } = props;
      let range2 = computeRange(props);
      let text = typeof moreLinkText === "function" ? moreLinkText.call(calendarApi, moreCnt) : `+${moreCnt} ${moreLinkText}`;
      let hint = formatWithOrdinals(options.moreLinkHint, [moreCnt], text);
      let renderProps = {
        num: moreCnt,
        shortText: `+${moreCnt}`,
        text,
        view: viewApi
      };
      return y(
        _,
        null,
        Boolean(props.moreCnt) && y(ContentContainer, { elTag: props.elTag || "a", elRef: this.handleLinkEl, elClasses: [
          ...props.elClasses || [],
          "fc-more-link"
        ], elStyle: props.elStyle, elAttrs: Object.assign(Object.assign(Object.assign({}, props.elAttrs), createAriaClickAttrs(this.handleClick)), { title: hint, "aria-expanded": state.isPopoverOpen, "aria-controls": state.isPopoverOpen ? state.popoverId : "" }), renderProps, generatorName: "moreLinkContent", customGenerator: options.moreLinkContent, defaultGenerator: props.defaultGenerator || renderMoreLinkInner, classNameGenerator: options.moreLinkClassNames, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, props.children),
        state.isPopoverOpen && y(MorePopover, { id: state.popoverId, startDate: range2.start, endDate: range2.end, dateProfile: props.dateProfile, todayRange: props.todayRange, extraDateSpan: props.extraDateSpan, parentEl: this.parentEl, alignmentEl: props.alignmentElRef ? props.alignmentElRef.current : this.linkEl, alignGridTop: props.alignGridTop, forceTimed: props.forceTimed, onClose: this.handlePopoverClose }, props.popoverContent())
      );
    });
  }
  componentDidMount() {
    this.updateParentEl();
  }
  componentDidUpdate() {
    this.updateParentEl();
  }
  updateParentEl() {
    if (this.linkEl) {
      this.parentEl = elementClosest(this.linkEl, ".fc-view-harness");
    }
  }
};
function renderMoreLinkInner(props) {
  return props.text;
}
function computeRange(props) {
  if (props.allDayDate) {
    return {
      start: props.allDayDate,
      end: addDays(props.allDayDate, 1)
    };
  }
  let { hiddenSegs } = props;
  return {
    start: computeEarliestSegStart(hiddenSegs),
    end: computeLatestSegEnd(hiddenSegs)
  };
}
function computeEarliestSegStart(segs) {
  return segs.reduce(pickEarliestStart).eventRange.range.start;
}
function pickEarliestStart(seg0, seg1) {
  return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;
}
function computeLatestSegEnd(segs) {
  return segs.reduce(pickLatestEnd).eventRange.range.end;
}
function pickLatestEnd(seg0, seg1) {
  return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;
}

// node_modules/@fullcalendar/core/index.js
var globalLocales = [];
var MINIMAL_RAW_EN_LOCALE = {
  code: "en",
  week: {
    dow: 0,
    doy: 4
    // 4 days need to be within the year to be considered the first week
  },
  direction: "ltr",
  buttonText: {
    prev: "prev",
    next: "next",
    prevYear: "prev year",
    nextYear: "next year",
    year: "year",
    today: "today",
    month: "month",
    week: "week",
    day: "day",
    list: "list"
  },
  weekText: "W",
  weekTextLong: "Week",
  closeHint: "Close",
  timeHint: "Time",
  eventHint: "Event",
  allDayText: "all-day",
  moreLinkText: "more",
  noEventsText: "No events to display"
};
var RAW_EN_LOCALE = Object.assign(Object.assign({}, MINIMAL_RAW_EN_LOCALE), {
  // Includes things we don't want other locales to inherit,
  // things that derive from other translatable strings.
  buttonHints: {
    prev: "Previous $0",
    next: "Next $0",
    today(buttonText, unit) {
      return unit === "day" ? "Today" : `This ${buttonText}`;
    }
  },
  viewHint: "$0 view",
  navLinkHint: "Go to $0",
  moreLinkHint(eventCnt) {
    return `Show ${eventCnt} more event${eventCnt === 1 ? "" : "s"}`;
  }
});
function organizeRawLocales(explicitRawLocales) {
  let defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : "en";
  let allRawLocales = globalLocales.concat(explicitRawLocales);
  let rawLocaleMap = {
    en: RAW_EN_LOCALE
  };
  for (let rawLocale of allRawLocales) {
    rawLocaleMap[rawLocale.code] = rawLocale;
  }
  return {
    map: rawLocaleMap,
    defaultCode
  };
}
function buildLocale(inputSingular, available) {
  if (typeof inputSingular === "object" && !Array.isArray(inputSingular)) {
    return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);
  }
  return queryLocale(inputSingular, available);
}
function queryLocale(codeArg, available) {
  let codes = [].concat(codeArg || []);
  let raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;
  return parseLocale(codeArg, codes, raw);
}
function queryRawLocale(codes, available) {
  for (let i3 = 0; i3 < codes.length; i3 += 1) {
    let parts = codes[i3].toLocaleLowerCase().split("-");
    for (let j4 = parts.length; j4 > 0; j4 -= 1) {
      let simpleId = parts.slice(0, j4).join("-");
      if (available[simpleId]) {
        return available[simpleId];
      }
    }
  }
  return null;
}
function parseLocale(codeArg, codes, raw) {
  let merged = mergeProps([MINIMAL_RAW_EN_LOCALE, raw], ["buttonText"]);
  delete merged.code;
  let { week } = merged;
  delete merged.week;
  return {
    codeArg,
    codes,
    week,
    simpleNumberFormat: new Intl.NumberFormat(codeArg),
    options: merged
  };
}
function createPlugin(input) {
  return {
    id: guid(),
    name: input.name,
    premiumReleaseDate: input.premiumReleaseDate ? new Date(input.premiumReleaseDate) : void 0,
    deps: input.deps || [],
    reducers: input.reducers || [],
    isLoadingFuncs: input.isLoadingFuncs || [],
    contextInit: [].concat(input.contextInit || []),
    eventRefiners: input.eventRefiners || {},
    eventDefMemberAdders: input.eventDefMemberAdders || [],
    eventSourceRefiners: input.eventSourceRefiners || {},
    isDraggableTransformers: input.isDraggableTransformers || [],
    eventDragMutationMassagers: input.eventDragMutationMassagers || [],
    eventDefMutationAppliers: input.eventDefMutationAppliers || [],
    dateSelectionTransformers: input.dateSelectionTransformers || [],
    datePointTransforms: input.datePointTransforms || [],
    dateSpanTransforms: input.dateSpanTransforms || [],
    views: input.views || {},
    viewPropsTransformers: input.viewPropsTransformers || [],
    isPropsValid: input.isPropsValid || null,
    externalDefTransforms: input.externalDefTransforms || [],
    viewContainerAppends: input.viewContainerAppends || [],
    eventDropTransformers: input.eventDropTransformers || [],
    componentInteractions: input.componentInteractions || [],
    calendarInteractions: input.calendarInteractions || [],
    themeClasses: input.themeClasses || {},
    eventSourceDefs: input.eventSourceDefs || [],
    cmdFormatter: input.cmdFormatter,
    recurringTypes: input.recurringTypes || [],
    namedTimeZonedImpl: input.namedTimeZonedImpl,
    initialView: input.initialView || "",
    elementDraggingImpl: input.elementDraggingImpl,
    optionChangeHandlers: input.optionChangeHandlers || {},
    scrollGridImpl: input.scrollGridImpl || null,
    listenerRefiners: input.listenerRefiners || {},
    optionRefiners: input.optionRefiners || {},
    propSetHandlers: input.propSetHandlers || {}
  };
}
function buildPluginHooks(pluginDefs, globalDefs) {
  let currentPluginIds = {};
  let hooks = {
    premiumReleaseDate: void 0,
    reducers: [],
    isLoadingFuncs: [],
    contextInit: [],
    eventRefiners: {},
    eventDefMemberAdders: [],
    eventSourceRefiners: {},
    isDraggableTransformers: [],
    eventDragMutationMassagers: [],
    eventDefMutationAppliers: [],
    dateSelectionTransformers: [],
    datePointTransforms: [],
    dateSpanTransforms: [],
    views: {},
    viewPropsTransformers: [],
    isPropsValid: null,
    externalDefTransforms: [],
    viewContainerAppends: [],
    eventDropTransformers: [],
    componentInteractions: [],
    calendarInteractions: [],
    themeClasses: {},
    eventSourceDefs: [],
    cmdFormatter: null,
    recurringTypes: [],
    namedTimeZonedImpl: null,
    initialView: "",
    elementDraggingImpl: null,
    optionChangeHandlers: {},
    scrollGridImpl: null,
    listenerRefiners: {},
    optionRefiners: {},
    propSetHandlers: {}
  };
  function addDefs(defs) {
    for (let def of defs) {
      const pluginName = def.name;
      const currentId = currentPluginIds[pluginName];
      if (currentId === void 0) {
        currentPluginIds[pluginName] = def.id;
        addDefs(def.deps);
        hooks = combineHooks(hooks, def);
      } else if (currentId !== def.id) {
        console.warn(`Duplicate plugin '${pluginName}'`);
      }
    }
  }
  if (pluginDefs) {
    addDefs(pluginDefs);
  }
  addDefs(globalDefs);
  return hooks;
}
function buildBuildPluginHooks() {
  let currentOverrideDefs = [];
  let currentGlobalDefs = [];
  let currentHooks;
  return (overrideDefs, globalDefs) => {
    if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {
      currentHooks = buildPluginHooks(overrideDefs, globalDefs);
    }
    currentOverrideDefs = overrideDefs;
    currentGlobalDefs = globalDefs;
    return currentHooks;
  };
}
function combineHooks(hooks0, hooks1) {
  return {
    premiumReleaseDate: compareOptionalDates(hooks0.premiumReleaseDate, hooks1.premiumReleaseDate),
    reducers: hooks0.reducers.concat(hooks1.reducers),
    isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),
    contextInit: hooks0.contextInit.concat(hooks1.contextInit),
    eventRefiners: Object.assign(Object.assign({}, hooks0.eventRefiners), hooks1.eventRefiners),
    eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),
    eventSourceRefiners: Object.assign(Object.assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),
    isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),
    eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),
    eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),
    dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),
    datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),
    dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),
    views: Object.assign(Object.assign({}, hooks0.views), hooks1.views),
    viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),
    isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,
    externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),
    viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),
    eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),
    calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),
    componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),
    themeClasses: Object.assign(Object.assign({}, hooks0.themeClasses), hooks1.themeClasses),
    eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),
    cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,
    recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),
    namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,
    initialView: hooks0.initialView || hooks1.initialView,
    elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,
    optionChangeHandlers: Object.assign(Object.assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),
    scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,
    listenerRefiners: Object.assign(Object.assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),
    optionRefiners: Object.assign(Object.assign({}, hooks0.optionRefiners), hooks1.optionRefiners),
    propSetHandlers: Object.assign(Object.assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)
  };
}
function compareOptionalDates(date0, date1) {
  if (date0 === void 0) {
    return date1;
  }
  if (date1 === void 0) {
    return date0;
  }
  return new Date(Math.max(date0.valueOf(), date1.valueOf()));
}
var StandardTheme = class extends Theme {
};
StandardTheme.prototype.classes = {
  root: "fc-theme-standard",
  tableCellShaded: "fc-cell-shaded",
  buttonGroup: "fc-button-group",
  button: "fc-button fc-button-primary",
  buttonActive: "fc-button-active"
};
StandardTheme.prototype.baseIconClass = "fc-icon";
StandardTheme.prototype.iconClasses = {
  close: "fc-icon-x",
  prev: "fc-icon-chevron-left",
  next: "fc-icon-chevron-right",
  prevYear: "fc-icon-chevrons-left",
  nextYear: "fc-icon-chevrons-right"
};
StandardTheme.prototype.rtlIconClasses = {
  prev: "fc-icon-chevron-right",
  next: "fc-icon-chevron-left",
  prevYear: "fc-icon-chevrons-right",
  nextYear: "fc-icon-chevrons-left"
};
StandardTheme.prototype.iconOverrideOption = "buttonIcons";
StandardTheme.prototype.iconOverrideCustomButtonOption = "icon";
StandardTheme.prototype.iconOverridePrefix = "fc-icon-";
function compileViewDefs(defaultConfigs, overrideConfigs) {
  let hash = {};
  let viewType;
  for (viewType in defaultConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  for (viewType in overrideConfigs) {
    ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  }
  return hash;
}
function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  if (hash[viewType]) {
    return hash[viewType];
  }
  let viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);
  if (viewDef) {
    hash[viewType] = viewDef;
  }
  return viewDef;
}
function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {
  let defaultConfig = defaultConfigs[viewType];
  let overrideConfig = overrideConfigs[viewType];
  let queryProp = (name) => defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;
  let theComponent = queryProp("component");
  let superType = queryProp("superType");
  let superDef = null;
  if (superType) {
    if (superType === viewType) {
      throw new Error("Can't have a custom view type that references itself");
    }
    superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);
  }
  if (!theComponent && superDef) {
    theComponent = superDef.component;
  }
  if (!theComponent) {
    return null;
  }
  return {
    type: viewType,
    component: theComponent,
    defaults: Object.assign(Object.assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),
    overrides: Object.assign(Object.assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})
  };
}
function parseViewConfigs(inputs) {
  return mapHash(inputs, parseViewConfig);
}
function parseViewConfig(input) {
  let rawOptions = typeof input === "function" ? { component: input } : input;
  let { component } = rawOptions;
  if (rawOptions.content) {
    component = createViewHookComponent(rawOptions);
  } else if (component && !(component.prototype instanceof BaseComponent)) {
    component = createViewHookComponent(Object.assign(Object.assign({}, rawOptions), { content: component }));
  }
  return {
    superType: rawOptions.type,
    component,
    rawOptions
    // includes type and component too :(
  };
}
function createViewHookComponent(options) {
  return (viewProps) => y(ViewContextType.Consumer, null, (context) => y(ContentContainer, { elTag: "div", elClasses: buildViewClassNames(context.viewSpec), renderProps: Object.assign(Object.assign({}, viewProps), { nextDayThreshold: context.options.nextDayThreshold }), generatorName: void 0, customGenerator: options.content, classNameGenerator: options.classNames, didMount: options.didMount, willUnmount: options.willUnmount }));
}
function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let defaultConfigs = parseViewConfigs(defaultInputs);
  let overrideConfigs = parseViewConfigs(optionOverrides.views);
  let viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);
  return mapHash(viewDefs, (viewDef) => buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults));
}
function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {
  let durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;
  let duration = null;
  let durationUnit = "";
  let singleUnit = "";
  let singleUnitOverrides = {};
  if (durationInput) {
    duration = createDurationCached(durationInput);
    if (duration) {
      let denom = greatestDurationDenominator(duration);
      durationUnit = denom.unit;
      if (denom.value === 1) {
        singleUnit = durationUnit;
        singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};
      }
    }
  }
  let queryButtonText = (optionsSubset) => {
    let buttonTextMap = optionsSubset.buttonText || {};
    let buttonTextKey = viewDef.defaults.buttonTextKey;
    if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {
      return buttonTextMap[buttonTextKey];
    }
    if (buttonTextMap[viewDef.type] != null) {
      return buttonTextMap[viewDef.type];
    }
    if (buttonTextMap[singleUnit] != null) {
      return buttonTextMap[singleUnit];
    }
    return null;
  };
  let queryButtonTitle = (optionsSubset) => {
    let buttonHints = optionsSubset.buttonHints || {};
    let buttonKey = viewDef.defaults.buttonTextKey;
    if (buttonKey != null && buttonHints[buttonKey] != null) {
      return buttonHints[buttonKey];
    }
    if (buttonHints[viewDef.type] != null) {
      return buttonHints[viewDef.type];
    }
    if (buttonHints[singleUnit] != null) {
      return buttonHints[singleUnit];
    }
    return null;
  };
  return {
    type: viewDef.type,
    component: viewDef.component,
    duration,
    durationUnit,
    singleUnit,
    optionDefaults: viewDef.defaults,
    optionOverrides: Object.assign(Object.assign({}, singleUnitOverrides), viewDef.overrides),
    buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence
    viewDef.overrides.buttonText,
    buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,
    // not DRY
    buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,
    buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)
    // will eventually fall back to buttonText
  };
}
var durationInputMap = {};
function createDurationCached(durationInput) {
  let json = JSON.stringify(durationInput);
  let res = durationInputMap[json];
  if (res === void 0) {
    res = createDuration(durationInput);
    durationInputMap[json] = res;
  }
  return res;
}
function reduceViewType(viewType, action) {
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      viewType = action.viewType;
  }
  return viewType;
}
function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {
  switch (action.type) {
    case "SET_OPTION":
      return Object.assign(Object.assign({}, dynamicOptionOverrides), { [action.optionName]: action.rawOptionValue });
    default:
      return dynamicOptionOverrides;
  }
}
function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {
  let dp;
  switch (action.type) {
    case "CHANGE_VIEW_TYPE":
      return dateProfileGenerator.build(action.dateMarker || currentDate);
    case "CHANGE_DATE":
      return dateProfileGenerator.build(action.dateMarker);
    case "PREV":
      dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
    case "NEXT":
      dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);
      if (dp.isValid) {
        return dp;
      }
      break;
  }
  return currentDateProfile;
}
function initEventSources(calendarOptions, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);
}
function reduceEventSources(eventSources, action, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  switch (action.type) {
    case "ADD_EVENT_SOURCES":
      return addSources(eventSources, action.sources, activeRange, context);
    case "REMOVE_EVENT_SOURCE":
      return removeSource(eventSources, action.sourceId);
    case "PREV":
    case "NEXT":
    case "CHANGE_DATE":
    case "CHANGE_VIEW_TYPE":
      if (dateProfile) {
        return fetchDirtySources(eventSources, activeRange, context);
      }
      return eventSources;
    case "FETCH_EVENT_SOURCES":
      return fetchSourcesByIds(eventSources, action.sourceIds ? (
        // why no type?
        arrayToHash(action.sourceIds)
      ) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);
    case "RECEIVE_EVENTS":
    case "RECEIVE_EVENT_ERROR":
      return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);
    case "REMOVE_ALL_EVENT_SOURCES":
      return {};
    default:
      return eventSources;
  }
}
function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {
  let activeRange = dateProfile ? dateProfile.activeRange : null;
  return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);
}
function computeEventSourcesLoading(eventSources) {
  for (let sourceId in eventSources) {
    if (eventSources[sourceId].isFetching) {
      return true;
    }
  }
  return false;
}
function addSources(eventSourceHash, sources, fetchRange, context) {
  let hash = {};
  for (let source of sources) {
    hash[source.sourceId] = source;
  }
  if (fetchRange) {
    hash = fetchDirtySources(hash, fetchRange, context);
  }
  return Object.assign(Object.assign({}, eventSourceHash), hash);
}
function removeSource(eventSourceHash, sourceId) {
  return filterHash(eventSourceHash, (eventSource) => eventSource.sourceId !== sourceId);
}
function fetchDirtySources(sourceHash, fetchRange, context) {
  return fetchSourcesByIds(sourceHash, filterHash(sourceHash, (eventSource) => isSourceDirty(eventSource, fetchRange, context)), fetchRange, false, context);
}
function isSourceDirty(eventSource, fetchRange, context) {
  if (!doesSourceNeedRange(eventSource, context)) {
    return !eventSource.latestFetchId;
  }
  return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches
  fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;
}
function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {
  let nextSources = {};
  for (let sourceId in prevSources) {
    let source = prevSources[sourceId];
    if (sourceIdHash[sourceId]) {
      nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);
    } else {
      nextSources[sourceId] = source;
    }
  }
  return nextSources;
}
function fetchSource(eventSource, fetchRange, isRefetch, context) {
  let { options, calendarApi } = context;
  let sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];
  let fetchId = guid();
  sourceDef.fetch({
    eventSource,
    range: fetchRange,
    isRefetch,
    context
  }, (res) => {
    let { rawEvents } = res;
    if (options.eventSourceSuccess) {
      rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    if (eventSource.success) {
      rawEvents = eventSource.success.call(calendarApi, rawEvents, res.response) || rawEvents;
    }
    context.dispatch({
      type: "RECEIVE_EVENTS",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      rawEvents
    });
  }, (error) => {
    let errorHandled = false;
    if (options.eventSourceFailure) {
      options.eventSourceFailure.call(calendarApi, error);
      errorHandled = true;
    }
    if (eventSource.failure) {
      eventSource.failure(error);
      errorHandled = true;
    }
    if (!errorHandled) {
      console.warn(error.message, error);
    }
    context.dispatch({
      type: "RECEIVE_EVENT_ERROR",
      sourceId: eventSource.sourceId,
      fetchId,
      fetchRange,
      error
    });
  });
  return Object.assign(Object.assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });
}
function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {
  let eventSource = sourceHash[sourceId];
  if (eventSource && // not already removed
  fetchId === eventSource.latestFetchId) {
    return Object.assign(Object.assign({}, sourceHash), { [sourceId]: Object.assign(Object.assign({}, eventSource), { isFetching: false, fetchRange }) });
  }
  return sourceHash;
}
function excludeStaticSources(eventSources, context) {
  return filterHash(eventSources, (eventSource) => doesSourceNeedRange(eventSource, context));
}
function parseInitialSources(rawOptions, context) {
  let refiners = buildEventSourceRefiners(context);
  let rawSources = [].concat(rawOptions.eventSources || []);
  let sources = [];
  if (rawOptions.initialEvents) {
    rawSources.unshift(rawOptions.initialEvents);
  }
  if (rawOptions.events) {
    rawSources.unshift(rawOptions.events);
  }
  for (let rawSource of rawSources) {
    let source = parseEventSource(rawSource, context, refiners);
    if (source) {
      sources.push(source);
    }
  }
  return sources;
}
function doesSourceNeedRange(eventSource, context) {
  let defs = context.pluginHooks.eventSourceDefs;
  return !defs[eventSource.sourceDefId].ignoreRange;
}
function reduceDateSelection(currentSelection, action) {
  switch (action.type) {
    case "UNSELECT_DATES":
      return null;
    case "SELECT_DATES":
      return action.selection;
    default:
      return currentSelection;
  }
}
function reduceSelectedEvent(currentInstanceId, action) {
  switch (action.type) {
    case "UNSELECT_EVENT":
      return "";
    case "SELECT_EVENT":
      return action.eventInstanceId;
    default:
      return currentInstanceId;
  }
}
function reduceEventDrag(currentDrag, action) {
  let newDrag;
  switch (action.type) {
    case "UNSET_EVENT_DRAG":
      return null;
    case "SET_EVENT_DRAG":
      newDrag = action.state;
      return {
        affectedEvents: newDrag.affectedEvents,
        mutatedEvents: newDrag.mutatedEvents,
        isEvent: newDrag.isEvent
      };
    default:
      return currentDrag;
  }
}
function reduceEventResize(currentResize, action) {
  let newResize;
  switch (action.type) {
    case "UNSET_EVENT_RESIZE":
      return null;
    case "SET_EVENT_RESIZE":
      newResize = action.state;
      return {
        affectedEvents: newResize.affectedEvents,
        mutatedEvents: newResize.mutatedEvents,
        isEvent: newResize.isEvent
      };
    default:
      return currentResize;
  }
}
function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  let footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;
  return { header, footer };
}
function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let sectionWidgets = {};
  let viewsWithButtons = [];
  let hasTitle = false;
  for (let sectionName in sectionStrHash) {
    let sectionStr = sectionStrHash[sectionName];
    let sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);
    sectionWidgets[sectionName] = sectionRes.widgets;
    viewsWithButtons.push(...sectionRes.viewsWithButtons);
    hasTitle = hasTitle || sectionRes.hasTitle;
  }
  return { sectionWidgets, viewsWithButtons, hasTitle };
}
function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {
  let isRtl = calendarOptions.direction === "rtl";
  let calendarCustomButtons = calendarOptions.customButtons || {};
  let calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};
  let calendarButtonText = calendarOptions.buttonText || {};
  let calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};
  let calendarButtonHints = calendarOptions.buttonHints || {};
  let sectionSubstrs = sectionStr ? sectionStr.split(" ") : [];
  let viewsWithButtons = [];
  let hasTitle = false;
  let widgets = sectionSubstrs.map((buttonGroupStr) => buttonGroupStr.split(",").map((buttonName) => {
    if (buttonName === "title") {
      hasTitle = true;
      return { buttonName };
    }
    let customButtonProps;
    let viewSpec;
    let buttonClick;
    let buttonIcon;
    let buttonText;
    let buttonHint;
    if (customButtonProps = calendarCustomButtons[buttonName]) {
      buttonClick = (ev) => {
        if (customButtonProps.click) {
          customButtonProps.click.call(ev.target, ev, ev.target);
        }
      };
      (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);
      buttonHint = customButtonProps.hint || customButtonProps.text;
    } else if (viewSpec = viewSpecs[buttonName]) {
      viewsWithButtons.push(buttonName);
      buttonClick = () => {
        calendarApi.changeView(buttonName);
      };
      (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);
      let textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;
      buttonHint = formatWithOrdinals(
        viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint,
        [textFallback, buttonName],
        // view-name = buttonName
        textFallback
      );
    } else if (calendarApi[buttonName]) {
      buttonClick = () => {
        calendarApi[buttonName]();
      };
      (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]);
      if (buttonName === "prevYear" || buttonName === "nextYear") {
        let prevOrNext = buttonName === "prevYear" ? "prev" : "next";
        buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [
          calendarButtonText.year || "year",
          "year"
        ], calendarButtonText[buttonName]);
      } else {
        buttonHint = (navUnit) => formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [
          calendarButtonText[navUnit] || navUnit,
          navUnit
        ], calendarButtonText[buttonName]);
      }
    }
    return { buttonName, buttonClick, buttonIcon, buttonText, buttonHint };
  }));
  return { widgets, viewsWithButtons, hasTitle };
}
var ViewImpl = class {
  constructor(type, getCurrentData, dateEnv) {
    this.type = type;
    this.getCurrentData = getCurrentData;
    this.dateEnv = dateEnv;
  }
  get calendar() {
    return this.getCurrentData().calendarApi;
  }
  get title() {
    return this.getCurrentData().viewTitle;
  }
  get activeStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);
  }
  get activeEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);
  }
  get currentStart() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);
  }
  get currentEnd() {
    return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);
  }
  getOption(name) {
    return this.getCurrentData().options[name];
  }
};
var eventSourceDef$2 = {
  ignoreRange: true,
  parseMeta(refined) {
    if (Array.isArray(refined.events)) {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback) {
    successCallback({
      rawEvents: arg.eventSource.meta
    });
  }
};
var arrayEventSourcePlugin = createPlugin({
  name: "array-event-source",
  eventSourceDefs: [eventSourceDef$2]
});
var eventSourceDef$1 = {
  parseMeta(refined) {
    if (typeof refined.events === "function") {
      return refined.events;
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { dateEnv } = arg.context;
    const func = arg.eventSource.meta;
    unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), (rawEvents) => successCallback({ rawEvents }), errorCallback);
  }
};
var funcEventSourcePlugin = createPlugin({
  name: "func-event-source",
  eventSourceDefs: [eventSourceDef$1]
});
var JSON_FEED_EVENT_SOURCE_REFINERS = {
  method: String,
  extraParams: identity,
  startParam: String,
  endParam: String,
  timeZoneParam: String
};
var eventSourceDef = {
  parseMeta(refined) {
    if (refined.url && (refined.format === "json" || !refined.format)) {
      return {
        url: refined.url,
        format: "json",
        method: (refined.method || "GET").toUpperCase(),
        extraParams: refined.extraParams,
        startParam: refined.startParam,
        endParam: refined.endParam,
        timeZoneParam: refined.timeZoneParam
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    const { meta } = arg.eventSource;
    const requestParams = buildRequestParams(meta, arg.range, arg.context);
    requestJson(meta.method, meta.url, requestParams).then(([rawEvents, response]) => {
      successCallback({ rawEvents, response });
    }, errorCallback);
  }
};
var jsonFeedEventSourcePlugin = createPlugin({
  name: "json-event-source",
  eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,
  eventSourceDefs: [eventSourceDef]
});
function buildRequestParams(meta, range2, context) {
  let { dateEnv, options } = context;
  let startParam;
  let endParam;
  let timeZoneParam;
  let customRequestParams;
  let params = {};
  startParam = meta.startParam;
  if (startParam == null) {
    startParam = options.startParam;
  }
  endParam = meta.endParam;
  if (endParam == null) {
    endParam = options.endParam;
  }
  timeZoneParam = meta.timeZoneParam;
  if (timeZoneParam == null) {
    timeZoneParam = options.timeZoneParam;
  }
  if (typeof meta.extraParams === "function") {
    customRequestParams = meta.extraParams();
  } else {
    customRequestParams = meta.extraParams || {};
  }
  Object.assign(params, customRequestParams);
  params[startParam] = dateEnv.formatIso(range2.start);
  params[endParam] = dateEnv.formatIso(range2.end);
  if (dateEnv.timeZone !== "local") {
    params[timeZoneParam] = dateEnv.timeZone;
  }
  return params;
}
var SIMPLE_RECURRING_REFINERS = {
  daysOfWeek: identity,
  startTime: createDuration,
  endTime: createDuration,
  duration: createDuration,
  startRecur: identity,
  endRecur: identity
};
var recurring = {
  parse(refined, dateEnv) {
    if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {
      let recurringData = {
        daysOfWeek: refined.daysOfWeek || null,
        startTime: refined.startTime || null,
        endTime: refined.endTime || null,
        startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,
        endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null
      };
      let duration;
      if (refined.duration) {
        duration = refined.duration;
      }
      if (!duration && refined.startTime && refined.endTime) {
        duration = subtractDurations(refined.endTime, refined.startTime);
      }
      return {
        allDayGuess: Boolean(!refined.startTime && !refined.endTime),
        duration,
        typeData: recurringData
        // doesn't need endTime anymore but oh well
      };
    }
    return null;
  },
  expand(typeData, framingRange, dateEnv) {
    let clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });
    if (clippedFramingRange) {
      return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);
    }
    return [];
  }
};
var simpleRecurringEventsPlugin = createPlugin({
  name: "simple-recurring-event",
  recurringTypes: [recurring],
  eventRefiners: SIMPLE_RECURRING_REFINERS
});
function expandRanges(daysOfWeek2, startTime, framingRange, dateEnv) {
  let dowHash = daysOfWeek2 ? arrayToHash(daysOfWeek2) : null;
  let dayMarker = startOfDay(framingRange.start);
  let endMarker = framingRange.end;
  let instanceStarts = [];
  while (dayMarker < endMarker) {
    let instanceStart;
    if (!dowHash || dowHash[dayMarker.getUTCDay()]) {
      if (startTime) {
        instanceStart = dateEnv.add(dayMarker, startTime);
      } else {
        instanceStart = dayMarker;
      }
      instanceStarts.push(instanceStart);
    }
    dayMarker = addDays(dayMarker, 1);
  }
  return instanceStarts;
}
var changeHandlerPlugin = createPlugin({
  name: "change-handler",
  optionChangeHandlers: {
    events(events, context) {
      handleEventSources([events], context);
    },
    eventSources: handleEventSources
  }
});
function handleEventSources(inputs, context) {
  let unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);
  if (unfoundSources.length === 1 && inputs.length === 1 && Array.isArray(unfoundSources[0]._raw) && Array.isArray(inputs[0])) {
    context.dispatch({
      type: "RESET_RAW_EVENTS",
      sourceId: unfoundSources[0].sourceId,
      rawEvents: inputs[0]
    });
    return;
  }
  let newInputs = [];
  for (let input of inputs) {
    let inputFound = false;
    for (let i3 = 0; i3 < unfoundSources.length; i3 += 1) {
      if (unfoundSources[i3]._raw === input) {
        unfoundSources.splice(i3, 1);
        inputFound = true;
        break;
      }
    }
    if (!inputFound) {
      newInputs.push(input);
    }
  }
  for (let unfoundSource of unfoundSources) {
    context.dispatch({
      type: "REMOVE_EVENT_SOURCE",
      sourceId: unfoundSource.sourceId
    });
  }
  for (let newInput of newInputs) {
    context.calendarApi.addEventSource(newInput);
  }
}
function handleDateProfile(dateProfile, context) {
  context.emitter.trigger("datesSet", Object.assign(Object.assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), { view: context.viewApi }));
}
function handleEventStore(eventStore, context) {
  let { emitter } = context;
  if (emitter.hasHandlers("eventsSet")) {
    emitter.trigger("eventsSet", buildEventApis(eventStore, context));
  }
}
var globalPlugins = [
  arrayEventSourcePlugin,
  funcEventSourcePlugin,
  jsonFeedEventSourcePlugin,
  simpleRecurringEventsPlugin,
  changeHandlerPlugin,
  createPlugin({
    name: "misc",
    isLoadingFuncs: [
      (state) => computeEventSourcesLoading(state.eventSources)
    ],
    propSetHandlers: {
      dateProfile: handleDateProfile,
      eventStore: handleEventStore
    }
  })
];
var TaskRunner = class {
  constructor(runTaskOption, drainedOption) {
    this.runTaskOption = runTaskOption;
    this.drainedOption = drainedOption;
    this.queue = [];
    this.delayedRunner = new DelayedRunner(this.drain.bind(this));
  }
  request(task, delay) {
    this.queue.push(task);
    this.delayedRunner.request(delay);
  }
  pause(scope) {
    this.delayedRunner.pause(scope);
  }
  resume(scope, force) {
    this.delayedRunner.resume(scope, force);
  }
  drain() {
    let { queue } = this;
    while (queue.length) {
      let completedTasks = [];
      let task;
      while (task = queue.shift()) {
        this.runTask(task);
        completedTasks.push(task);
      }
      this.drained(completedTasks);
    }
  }
  runTask(task) {
    if (this.runTaskOption) {
      this.runTaskOption(task);
    }
  }
  drained(completedTasks) {
    if (this.drainedOption) {
      this.drainedOption(completedTasks);
    }
  }
};
function buildTitle(dateProfile, viewOptions, dateEnv) {
  let range2;
  if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
    range2 = dateProfile.currentRange;
  } else {
    range2 = dateProfile.activeRange;
  }
  return dateEnv.formatRange(range2.start, range2.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {
    isEndExclusive: dateProfile.isRangeAllDay,
    defaultSeparator: viewOptions.titleRangeSeparator
  });
}
function buildTitleFormat(dateProfile) {
  let { currentRangeUnit } = dateProfile;
  if (currentRangeUnit === "year") {
    return { year: "numeric" };
  }
  if (currentRangeUnit === "month") {
    return { year: "numeric", month: "long" };
  }
  let days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);
  if (days !== null && days > 1) {
    return { year: "numeric", month: "short", day: "numeric" };
  }
  return { year: "numeric", month: "long", day: "numeric" };
}
var CalendarDataManager = class {
  constructor(props) {
    this.computeCurrentViewData = memoize(this._computeCurrentViewData);
    this.organizeRawLocales = memoize(organizeRawLocales);
    this.buildLocale = memoize(buildLocale);
    this.buildPluginHooks = buildBuildPluginHooks();
    this.buildDateEnv = memoize(buildDateEnv$1);
    this.buildTheme = memoize(buildTheme);
    this.parseToolbars = memoize(parseToolbars);
    this.buildViewSpecs = memoize(buildViewSpecs);
    this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);
    this.buildViewApi = memoize(buildViewApi);
    this.buildViewUiProps = memoizeObjArg(buildViewUiProps);
    this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);
    this.buildEventUiBases = memoize(buildEventUiBases);
    this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);
    this.buildTitle = memoize(buildTitle);
    this.emitter = new Emitter();
    this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));
    this.currentCalendarOptionsInput = {};
    this.currentCalendarOptionsRefined = {};
    this.currentViewOptionsInput = {};
    this.currentViewOptionsRefined = {};
    this.currentCalendarOptionsRefiners = {};
    this.optionsForRefining = [];
    this.optionsForHandling = [];
    this.getCurrentData = () => this.data;
    this.dispatch = (action) => {
      this.actionRunner.request(action);
    };
    this.props = props;
    this.actionRunner.pause();
    let dynamicOptionOverrides = {};
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    this.emitter.setThisContext(props.calendarApi);
    this.emitter.setOptions(currentViewData.options);
    let currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);
    let dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter: this.emitter,
      getCurrentData: this.getCurrentData
    };
    for (let callback of optionsData.pluginHooks.contextInit) {
      callback(calendarContext);
    }
    let eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);
    let initialState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      businessHours: this.parseContextBusinessHours(calendarContext),
      eventSources,
      eventUiBases: {},
      eventStore: createEmptyEventStore(),
      renderableEventStore: createEmptyEventStore(),
      dateSelection: null,
      eventSelection: "",
      eventDrag: null,
      eventResize: null,
      selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), initialState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(initialState, reducer(null, null, contextAndState));
    }
    if (computeIsLoading(initialState, calendarContext)) {
      this.emitter.trigger("loading", true);
    }
    this.state = initialState;
    this.updateData();
    this.actionRunner.resume();
  }
  resetOptions(optionOverrides, changedOptionNames) {
    let { props } = this;
    if (changedOptionNames === void 0) {
      props.optionOverrides = optionOverrides;
    } else {
      props.optionOverrides = Object.assign(Object.assign({}, props.optionOverrides || {}), optionOverrides);
      this.optionsForRefining.push(...changedOptionNames);
    }
    if (changedOptionNames === void 0 || changedOptionNames.length) {
      this.actionRunner.request({
        type: "NOTHING"
      });
    }
  }
  _handleAction(action) {
    let { props, state, emitter } = this;
    let dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);
    let optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);
    let currentViewType = reduceViewType(state.currentViewType, action);
    let currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);
    props.calendarApi.currentDataManager = this;
    emitter.setThisContext(props.calendarApi);
    emitter.setOptions(currentViewData.options);
    let calendarContext = {
      dateEnv: optionsData.dateEnv,
      options: optionsData.calendarOptions,
      pluginHooks: optionsData.pluginHooks,
      calendarApi: props.calendarApi,
      dispatch: this.dispatch,
      emitter,
      getCurrentData: this.getCurrentData
    };
    let { currentDate, dateProfile } = state;
    if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {
      dateProfile = currentViewData.dateProfileGenerator.build(currentDate);
    }
    currentDate = reduceCurrentDate(currentDate, action);
    dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);
    if (action.type === "PREV" || // TODO: move this logic into DateProfileGenerator
    action.type === "NEXT" || // "
    !rangeContainsMarker(dateProfile.currentRange, currentDate)) {
      currentDate = dateProfile.currentRange.start;
    }
    let eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);
    let eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);
    let isEventsLoading = computeEventSourcesLoading(eventSources);
    let renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : (
      // try from previous state
      eventStore
    );
    let { eventUiSingleBase, selectionConfig } = this.buildViewUiProps(calendarContext);
    let eventUiBySource = this.buildEventUiBySource(eventSources);
    let eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);
    let newState = {
      dynamicOptionOverrides,
      currentViewType,
      currentDate,
      dateProfile,
      eventSources,
      eventStore,
      renderableEventStore,
      selectionConfig,
      eventUiBases,
      businessHours: this.parseContextBusinessHours(calendarContext),
      dateSelection: reduceDateSelection(state.dateSelection, action),
      eventSelection: reduceSelectedEvent(state.eventSelection, action),
      eventDrag: reduceEventDrag(state.eventDrag, action),
      eventResize: reduceEventResize(state.eventResize, action)
    };
    let contextAndState = Object.assign(Object.assign({}, calendarContext), newState);
    for (let reducer of optionsData.pluginHooks.reducers) {
      Object.assign(newState, reducer(state, action, contextAndState));
    }
    let wasLoading = computeIsLoading(state, calendarContext);
    let isLoading = computeIsLoading(newState, calendarContext);
    if (!wasLoading && isLoading) {
      emitter.trigger("loading", true);
    } else if (wasLoading && !isLoading) {
      emitter.trigger("loading", false);
    }
    this.state = newState;
    if (props.onAction) {
      props.onAction(action);
    }
  }
  updateData() {
    let { props, state } = this;
    let oldData = this.data;
    let optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);
    let currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);
    let data = this.data = Object.assign(Object.assign(Object.assign({ viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);
    let changeHandlers = optionsData.pluginHooks.optionChangeHandlers;
    let oldCalendarOptions = oldData && oldData.calendarOptions;
    let newCalendarOptions = optionsData.calendarOptions;
    if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {
      if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {
        state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);
        state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);
        state.renderableEventStore = data.renderableEventStore = rezoneEventStoreDates(data.renderableEventStore, oldData.dateEnv, data.dateEnv);
      }
      for (let optionName in changeHandlers) {
        if (this.optionsForHandling.indexOf(optionName) !== -1 || oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {
          changeHandlers[optionName](newCalendarOptions[optionName], data);
        }
      }
    }
    this.optionsForHandling = [];
    if (props.onData) {
      props.onData(data);
    }
  }
  computeOptionsData(optionOverrides, dynamicOptionOverrides, calendarApi) {
    if (!this.optionsForRefining.length && optionOverrides === this.stableOptionOverrides && dynamicOptionOverrides === this.stableDynamicOptionOverrides) {
      return this.stableCalendarOptionsData;
    }
    let { refinedOptions, pluginHooks, localeDefaults, availableLocaleData, extra } = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);
    let viewSpecs = this.buildViewSpecs(pluginHooks.views, this.stableOptionOverrides, this.stableDynamicOptionOverrides, localeDefaults);
    let theme = this.buildTheme(refinedOptions, pluginHooks);
    let toolbarConfig = this.parseToolbars(refinedOptions, this.stableOptionOverrides, theme, viewSpecs, calendarApi);
    return this.stableCalendarOptionsData = {
      calendarOptions: refinedOptions,
      pluginHooks,
      dateEnv,
      viewSpecs,
      theme,
      toolbarConfig,
      localeDefaults,
      availableRawLocales: availableLocaleData.map
    };
  }
  // always called from behind a memoizer
  processRawCalendarOptions(optionOverrides, dynamicOptionOverrides) {
    let { locales, locale } = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let availableLocaleData = this.organizeRawLocales(locales);
    let availableRawLocales = availableLocaleData.map;
    let localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;
    let pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);
    let refiners = this.currentCalendarOptionsRefiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let extra = {};
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      localeDefaults,
      optionOverrides,
      dynamicOptionOverrides
    ]);
    let refined = {};
    let currentRaw = this.currentCalendarOptionsInput;
    let currentRefined = this.currentCalendarOptionsRefined;
    let anyChanges = false;
    for (let optionName in raw) {
      if (this.optionsForRefining.indexOf(optionName) === -1 && (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName]))) {
        refined[optionName] = currentRefined[optionName];
      } else if (refiners[optionName]) {
        refined[optionName] = refiners[optionName](raw[optionName]);
        anyChanges = true;
      } else {
        extra[optionName] = currentRaw[optionName];
      }
    }
    if (anyChanges) {
      this.currentCalendarOptionsInput = raw;
      this.currentCalendarOptionsRefined = refined;
      this.stableOptionOverrides = optionOverrides;
      this.stableDynamicOptionOverrides = dynamicOptionOverrides;
    }
    this.optionsForHandling.push(...this.optionsForRefining);
    this.optionsForRefining = [];
    return {
      rawOptions: this.currentCalendarOptionsInput,
      refinedOptions: this.currentCalendarOptionsRefined,
      pluginHooks,
      availableLocaleData,
      localeDefaults,
      extra
    };
  }
  _computeCurrentViewData(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {
    let viewSpec = optionsData.viewSpecs[viewType];
    if (!viewSpec) {
      throw new Error(`viewType "${viewType}" is not available. Please make sure you've loaded all neccessary plugins`);
    }
    let { refinedOptions, extra } = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides);
    warnUnknownOptions(extra);
    let dateProfileGenerator = this.buildDateProfileGenerator({
      dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,
      duration: viewSpec.duration,
      durationUnit: viewSpec.durationUnit,
      usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,
      dateEnv: optionsData.dateEnv,
      calendarApi: this.props.calendarApi,
      slotMinTime: refinedOptions.slotMinTime,
      slotMaxTime: refinedOptions.slotMaxTime,
      showNonCurrentDates: refinedOptions.showNonCurrentDates,
      dayCount: refinedOptions.dayCount,
      dateAlignment: refinedOptions.dateAlignment,
      dateIncrement: refinedOptions.dateIncrement,
      hiddenDays: refinedOptions.hiddenDays,
      weekends: refinedOptions.weekends,
      nowInput: refinedOptions.now,
      validRangeInput: refinedOptions.validRange,
      visibleRangeInput: refinedOptions.visibleRange,
      fixedWeekCount: refinedOptions.fixedWeekCount
    });
    let viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);
    return { viewSpec, options: refinedOptions, dateProfileGenerator, viewApi };
  }
  processRawViewOptions(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {
    let raw = mergeRawOptions([
      BASE_OPTION_DEFAULTS,
      viewSpec.optionDefaults,
      localeDefaults,
      optionOverrides,
      viewSpec.optionOverrides,
      dynamicOptionOverrides
    ]);
    let refiners = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);
    let refined = {};
    let currentRaw = this.currentViewOptionsInput;
    let currentRefined = this.currentViewOptionsRefined;
    let anyChanges = false;
    let extra = {};
    for (let optionName in raw) {
      if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {
        refined[optionName] = currentRefined[optionName];
      } else {
        if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {
          if (optionName in this.currentCalendarOptionsRefined) {
            refined[optionName] = this.currentCalendarOptionsRefined[optionName];
          }
        } else if (refiners[optionName]) {
          refined[optionName] = refiners[optionName](raw[optionName]);
        } else {
          extra[optionName] = raw[optionName];
        }
        anyChanges = true;
      }
    }
    if (anyChanges) {
      this.currentViewOptionsInput = raw;
      this.currentViewOptionsRefined = refined;
    }
    return {
      rawOptions: this.currentViewOptionsInput,
      refinedOptions: this.currentViewOptionsRefined,
      extra
    };
  }
};
function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {
  let locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);
  return new DateEnv({
    calendarSystem: "gregory",
    timeZone,
    namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,
    locale,
    weekNumberCalculation,
    firstDay,
    weekText,
    cmdFormatter: pluginHooks.cmdFormatter,
    defaultSeparator
  });
}
function buildTheme(options, pluginHooks) {
  let ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;
  return new ThemeClass(options);
}
function buildDateProfileGenerator(props) {
  let DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;
  return new DateProfileGeneratorClass(props);
}
function buildViewApi(type, getCurrentData, dateEnv) {
  return new ViewImpl(type, getCurrentData, dateEnv);
}
function buildEventUiBySource(eventSources) {
  return mapHash(eventSources, (eventSource) => eventSource.ui);
}
function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {
  let eventUiBases = { "": eventUiSingleBase };
  for (let defId in eventDefs) {
    let def = eventDefs[defId];
    if (def.sourceId && eventUiBySource[def.sourceId]) {
      eventUiBases[defId] = eventUiBySource[def.sourceId];
    }
  }
  return eventUiBases;
}
function buildViewUiProps(calendarContext) {
  let { options } = calendarContext;
  return {
    eventUiSingleBase: createEventUi({
      display: options.eventDisplay,
      editable: options.editable,
      startEditable: options.eventStartEditable,
      durationEditable: options.eventDurationEditable,
      constraint: options.eventConstraint,
      overlap: typeof options.eventOverlap === "boolean" ? options.eventOverlap : void 0,
      allow: options.eventAllow,
      backgroundColor: options.eventBackgroundColor,
      borderColor: options.eventBorderColor,
      textColor: options.eventTextColor,
      color: options.eventColor
      // classNames: options.eventClassNames // render hook will handle this
    }, calendarContext),
    selectionConfig: createEventUi({
      constraint: options.selectConstraint,
      overlap: typeof options.selectOverlap === "boolean" ? options.selectOverlap : void 0,
      allow: options.selectAllow
    }, calendarContext)
  };
}
function computeIsLoading(state, context) {
  for (let isLoadingFunc of context.pluginHooks.isLoadingFuncs) {
    if (isLoadingFunc(state)) {
      return true;
    }
  }
  return false;
}
function parseContextBusinessHours(calendarContext) {
  return parseBusinessHours(calendarContext.options.businessHours, calendarContext);
}
function warnUnknownOptions(options, viewName) {
  for (let optionName in options) {
    console.warn(`Unknown option '${optionName}'` + (viewName ? ` for view '${viewName}'` : ""));
  }
}
var ToolbarSection = class extends BaseComponent {
  render() {
    let children = this.props.widgetGroups.map((widgetGroup) => this.renderWidgetGroup(widgetGroup));
    return y("div", { className: "fc-toolbar-chunk" }, ...children);
  }
  renderWidgetGroup(widgetGroup) {
    let { props } = this;
    let { theme } = this.context;
    let children = [];
    let isOnlyButtons = true;
    for (let widget of widgetGroup) {
      let { buttonName, buttonClick, buttonText, buttonIcon, buttonHint } = widget;
      if (buttonName === "title") {
        isOnlyButtons = false;
        children.push(y("h2", { className: "fc-toolbar-title", id: props.titleId }, props.title));
      } else {
        let isPressed = buttonName === props.activeButton;
        let isDisabled = !props.isTodayEnabled && buttonName === "today" || !props.isPrevEnabled && buttonName === "prev" || !props.isNextEnabled && buttonName === "next";
        let buttonClasses = [`fc-${buttonName}-button`, theme.getClass("button")];
        if (isPressed) {
          buttonClasses.push(theme.getClass("buttonActive"));
        }
        children.push(y("button", { type: "button", title: typeof buttonHint === "function" ? buttonHint(props.navUnit) : buttonHint, disabled: isDisabled, "aria-pressed": isPressed, className: buttonClasses.join(" "), onClick: buttonClick }, buttonText || (buttonIcon ? y("span", { className: buttonIcon, role: "img" }) : "")));
      }
    }
    if (children.length > 1) {
      let groupClassName = isOnlyButtons && theme.getClass("buttonGroup") || "";
      return y("div", { className: groupClassName }, ...children);
    }
    return children[0];
  }
};
var Toolbar = class extends BaseComponent {
  render() {
    let { model, extraClassName } = this.props;
    let forceLtr = false;
    let startContent;
    let endContent;
    let sectionWidgets = model.sectionWidgets;
    let centerContent = sectionWidgets.center;
    if (sectionWidgets.left) {
      forceLtr = true;
      startContent = sectionWidgets.left;
    } else {
      startContent = sectionWidgets.start;
    }
    if (sectionWidgets.right) {
      forceLtr = true;
      endContent = sectionWidgets.right;
    } else {
      endContent = sectionWidgets.end;
    }
    let classNames = [
      extraClassName || "",
      "fc-toolbar",
      forceLtr ? "fc-toolbar-ltr" : ""
    ];
    return y(
      "div",
      { className: classNames.join(" ") },
      this.renderSection("start", startContent || []),
      this.renderSection("center", centerContent || []),
      this.renderSection("end", endContent || [])
    );
  }
  renderSection(key, widgetGroups) {
    let { props } = this;
    return y(ToolbarSection, { key, widgetGroups, title: props.title, navUnit: props.navUnit, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled, titleId: props.titleId });
  }
};
var ViewHarness = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      availableWidth: null
    };
    this.handleEl = (el) => {
      this.el = el;
      setRef(this.props.elRef, el);
      this.updateAvailableWidth();
    };
    this.handleResize = () => {
      this.updateAvailableWidth();
    };
  }
  render() {
    let { props, state } = this;
    let { aspectRatio } = props;
    let classNames = [
      "fc-view-harness",
      aspectRatio || props.liquid || props.height ? "fc-view-harness-active" : "fc-view-harness-passive"
      // let the view do the height
    ];
    let height = "";
    let paddingBottom = "";
    if (aspectRatio) {
      if (state.availableWidth !== null) {
        height = state.availableWidth / aspectRatio;
      } else {
        paddingBottom = `${1 / aspectRatio * 100}%`;
      }
    } else {
      height = props.height || "";
    }
    return y("div", { "aria-labelledby": props.labeledById, ref: this.handleEl, className: classNames.join(" "), style: { height, paddingBottom } }, props.children);
  }
  componentDidMount() {
    this.context.addResizeHandler(this.handleResize);
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  updateAvailableWidth() {
    if (this.el && // needed. but why?
    this.props.aspectRatio) {
      this.setState({ availableWidth: this.el.offsetWidth });
    }
  }
};
var EventClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleSegClick = (ev, segEl) => {
      let { component } = this;
      let { context } = component;
      let seg = getElSeg(segEl);
      if (seg && // might be the <div> surrounding the more link
      component.isValidSegDownEl(ev.target)) {
        let hasUrlContainer = elementClosest(ev.target, ".fc-event-forced-url");
        let url = hasUrlContainer ? hasUrlContainer.querySelector("a[href]").href : "";
        context.emitter.trigger("eventClick", {
          el: segEl,
          event: new EventImpl(component.context, seg.eventRange.def, seg.eventRange.instance),
          jsEvent: ev,
          view: context.viewApi
        });
        if (url && !ev.defaultPrevented) {
          window.location.href = url;
        }
      }
    };
    this.destroy = listenBySelector(
      settings.el,
      "click",
      ".fc-event",
      // on both fg and bg events
      this.handleSegClick
    );
  }
};
var EventHovering = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handleEventElRemove = (el) => {
      if (el === this.currentSegEl) {
        this.handleSegLeave(null, this.currentSegEl);
      }
    };
    this.handleSegEnter = (ev, segEl) => {
      if (getElSeg(segEl)) {
        this.currentSegEl = segEl;
        this.triggerEvent("eventMouseEnter", ev, segEl);
      }
    };
    this.handleSegLeave = (ev, segEl) => {
      if (this.currentSegEl) {
        this.currentSegEl = null;
        this.triggerEvent("eventMouseLeave", ev, segEl);
      }
    };
    this.removeHoverListeners = listenToHoverBySelector(
      settings.el,
      ".fc-event",
      // on both fg and bg events
      this.handleSegEnter,
      this.handleSegLeave
    );
  }
  destroy() {
    this.removeHoverListeners();
  }
  triggerEvent(publicEvName, ev, segEl) {
    let { component } = this;
    let { context } = component;
    let seg = getElSeg(segEl);
    if (!ev || component.isValidSegDownEl(ev.target)) {
      context.emitter.trigger(publicEvName, {
        el: segEl,
        event: new EventImpl(context, seg.eventRange.def, seg.eventRange.instance),
        jsEvent: ev,
        view: context.viewApi
      });
    }
  }
};
var CalendarContent = class extends PureComponent {
  constructor() {
    super(...arguments);
    this.buildViewContext = memoize(buildViewContext);
    this.buildViewPropTransformers = memoize(buildViewPropTransformers);
    this.buildToolbarProps = memoize(buildToolbarProps);
    this.headerRef = d();
    this.footerRef = d();
    this.interactionsStore = {};
    this.state = {
      viewLabelId: getUniqueDomId()
    };
    this.registerInteractiveComponent = (component, settingsInput) => {
      let settings = parseInteractionSettings(component, settingsInput);
      let DEFAULT_INTERACTIONS = [
        EventClicking,
        EventHovering
      ];
      let interactionClasses = DEFAULT_INTERACTIONS.concat(this.props.pluginHooks.componentInteractions);
      let interactions = interactionClasses.map((TheInteractionClass) => new TheInteractionClass(settings));
      this.interactionsStore[component.uid] = interactions;
      interactionSettingsStore[component.uid] = settings;
    };
    this.unregisterInteractiveComponent = (component) => {
      let listeners = this.interactionsStore[component.uid];
      if (listeners) {
        for (let listener of listeners) {
          listener.destroy();
        }
        delete this.interactionsStore[component.uid];
      }
      delete interactionSettingsStore[component.uid];
    };
    this.resizeRunner = new DelayedRunner(() => {
      this.props.emitter.trigger("_resize", true);
      this.props.emitter.trigger("windowResize", { view: this.props.viewApi });
    });
    this.handleWindowResize = (ev) => {
      let { options } = this.props;
      if (options.handleWindowResize && ev.target === window) {
        this.resizeRunner.request(options.windowResizeDelay);
      }
    };
  }
  /*
  renders INSIDE of an outer div
  */
  render() {
    let { props } = this;
    let { toolbarConfig, options } = props;
    let toolbarProps = this.buildToolbarProps(
      props.viewSpec,
      props.dateProfile,
      props.dateProfileGenerator,
      props.currentDate,
      getNow(props.options.now, props.dateEnv),
      // TODO: use NowTimer????
      props.viewTitle
    );
    let viewVGrow = false;
    let viewHeight = "";
    let viewAspectRatio;
    if (props.isHeightAuto || props.forPrint) {
      viewHeight = "";
    } else if (options.height != null) {
      viewVGrow = true;
    } else if (options.contentHeight != null) {
      viewHeight = options.contentHeight;
    } else {
      viewAspectRatio = Math.max(options.aspectRatio, 0.5);
    }
    let viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);
    let viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : void 0;
    return y(
      ViewContextType.Provider,
      { value: viewContext },
      toolbarConfig.header && y(Toolbar, Object.assign({ ref: this.headerRef, extraClassName: "fc-header-toolbar", model: toolbarConfig.header, titleId: viewLabelId }, toolbarProps)),
      y(
        ViewHarness,
        { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, labeledById: viewLabelId },
        this.renderView(props),
        this.buildAppendContent()
      ),
      toolbarConfig.footer && y(Toolbar, Object.assign({ ref: this.footerRef, extraClassName: "fc-footer-toolbar", model: toolbarConfig.footer, titleId: "" }, toolbarProps))
    );
  }
  componentDidMount() {
    let { props } = this;
    this.calendarInteractions = props.pluginHooks.calendarInteractions.map((CalendarInteractionClass) => new CalendarInteractionClass(props));
    window.addEventListener("resize", this.handleWindowResize);
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      propSetHandlers[propName](props[propName], props);
    }
  }
  componentDidUpdate(prevProps) {
    let { props } = this;
    let { propSetHandlers } = props.pluginHooks;
    for (let propName in propSetHandlers) {
      if (props[propName] !== prevProps[propName]) {
        propSetHandlers[propName](props[propName], props);
      }
    }
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.handleWindowResize);
    this.resizeRunner.clear();
    for (let interaction of this.calendarInteractions) {
      interaction.destroy();
    }
    this.props.emitter.trigger("_unmount");
  }
  buildAppendContent() {
    let { props } = this;
    let children = props.pluginHooks.viewContainerAppends.map((buildAppendContent) => buildAppendContent(props));
    return y(_, {}, ...children);
  }
  renderView(props) {
    let { pluginHooks } = props;
    let { viewSpec } = props;
    let viewProps = {
      dateProfile: props.dateProfile,
      businessHours: props.businessHours,
      eventStore: props.renderableEventStore,
      eventUiBases: props.eventUiBases,
      dateSelection: props.dateSelection,
      eventSelection: props.eventSelection,
      eventDrag: props.eventDrag,
      eventResize: props.eventResize,
      isHeightAuto: props.isHeightAuto,
      forPrint: props.forPrint
    };
    let transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);
    for (let transformer of transformers) {
      Object.assign(viewProps, transformer.transform(viewProps, props));
    }
    let ViewComponent = viewSpec.component;
    return y(ViewComponent, Object.assign({}, viewProps));
  }
};
function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {
  let todayInfo = dateProfileGenerator.build(now, void 0, false);
  let prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);
  let nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);
  return {
    title,
    activeButton: viewSpec.type,
    navUnit: viewSpec.singleUnit,
    isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),
    isPrevEnabled: prevInfo.isValid,
    isNextEnabled: nextInfo.isValid
  };
}
function buildViewPropTransformers(theClasses) {
  return theClasses.map((TheClass) => new TheClass());
}
var Calendar = class extends CalendarImpl {
  constructor(el, optionOverrides = {}) {
    super();
    this.isRendering = false;
    this.isRendered = false;
    this.currentClassNames = [];
    this.customContentRenderId = 0;
    this.handleAction = (action) => {
      switch (action.type) {
        case "SET_EVENT_DRAG":
        case "SET_EVENT_RESIZE":
          this.renderRunner.tryDrain();
      }
    };
    this.handleData = (data) => {
      this.currentData = data;
      this.renderRunner.request(data.calendarOptions.rerenderDelay);
    };
    this.handleRenderRequest = () => {
      if (this.isRendering) {
        this.isRendered = true;
        let { currentData } = this;
        flushSync(() => {
          D(y(CalendarRoot, { options: currentData.calendarOptions, theme: currentData.theme, emitter: currentData.emitter }, (classNames, height, isHeightAuto, forPrint) => {
            this.setClassNames(classNames);
            this.setHeight(height);
            return y(
              RenderId.Provider,
              { value: this.customContentRenderId },
              y(CalendarContent, Object.assign({ isHeightAuto, forPrint }, currentData))
            );
          }), this.el);
        });
      } else if (this.isRendered) {
        this.isRendered = false;
        D(null, this.el);
        this.setClassNames([]);
        this.setHeight("");
      }
    };
    ensureElHasStyles(el);
    this.el = el;
    this.renderRunner = new DelayedRunner(this.handleRenderRequest);
    new CalendarDataManager({
      optionOverrides,
      calendarApi: this,
      onAction: this.handleAction,
      onData: this.handleData
    });
  }
  render() {
    let wasRendering = this.isRendering;
    if (!wasRendering) {
      this.isRendering = true;
    } else {
      this.customContentRenderId += 1;
    }
    this.renderRunner.request();
    if (wasRendering) {
      this.updateSize();
    }
  }
  destroy() {
    if (this.isRendering) {
      this.isRendering = false;
      this.renderRunner.request();
    }
  }
  updateSize() {
    flushSync(() => {
      super.updateSize();
    });
  }
  batchRendering(func) {
    this.renderRunner.pause("batchRendering");
    func();
    this.renderRunner.resume("batchRendering");
  }
  pauseRendering() {
    this.renderRunner.pause("pauseRendering");
  }
  resumeRendering() {
    this.renderRunner.resume("pauseRendering", true);
  }
  resetOptions(optionOverrides, changedOptionNames) {
    this.currentDataManager.resetOptions(optionOverrides, changedOptionNames);
  }
  setClassNames(classNames) {
    if (!isArraysEqual(classNames, this.currentClassNames)) {
      let { classList } = this.el;
      for (let className of this.currentClassNames) {
        classList.remove(className);
      }
      for (let className of classNames) {
        classList.add(className);
      }
      this.currentClassNames = classNames;
    }
  }
  setHeight(height) {
    applyStyleProp(this.el, "height", height);
  }
};

// node_modules/@fullcalendar/daygrid/internal.js
var TableView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.headerElRef = d();
  }
  renderSimpleLayout(headerRowContent, bodyContent) {
    let { props, context } = this;
    let sections = [];
    let stickyHeaderDates = getStickyHeaderDates(context.options);
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunk: { content: bodyContent }
    });
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
      y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [], sections })
    );
  }
  renderHScrollLayout(headerRowContent, bodyContent, colCnt, dayMinWidth) {
    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
    if (!ScrollGrid) {
      throw new Error("No ScrollGrid implementation");
    }
    let { props, context } = this;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    let sections = [];
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunks: [{
          key: "main",
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }]
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      chunks: [{
        key: "main",
        content: bodyContent
      }]
    });
    if (stickyFooterScrollbar) {
      sections.push({
        type: "footer",
        key: "footer",
        isSticky: true,
        chunks: [{
          key: "main",
          content: renderScrollShim
        }]
      });
    }
    return y(
      ViewContainer,
      { elClasses: ["fc-daygrid"], viewSpec: context.viewSpec },
      y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections })
    );
  }
};
function splitSegsByRow(segs, rowCnt) {
  let byRow = [];
  for (let i3 = 0; i3 < rowCnt; i3 += 1) {
    byRow[i3] = [];
  }
  for (let seg of segs) {
    byRow[seg.row].push(seg);
  }
  return byRow;
}
function splitSegsByFirstCol(segs, colCnt) {
  let byCol = [];
  for (let i3 = 0; i3 < colCnt; i3 += 1) {
    byCol[i3] = [];
  }
  for (let seg of segs) {
    byCol[seg.firstCol].push(seg);
  }
  return byCol;
}
function splitInteractionByRow(ui, rowCnt) {
  let byRow = [];
  if (!ui) {
    for (let i3 = 0; i3 < rowCnt; i3 += 1) {
      byRow[i3] = null;
    }
  } else {
    for (let i3 = 0; i3 < rowCnt; i3 += 1) {
      byRow[i3] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (let seg of ui.segs) {
      byRow[seg.row].segs.push(seg);
    }
  }
  return byRow;
}
var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "narrow"
});
function hasListItemDisplay(seg) {
  let { display: display2 } = seg.eventRange.ui;
  return display2 === "list-item" || display2 === "auto" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day
  seg.isStart && // "
  seg.isEnd;
}
var TableBlockEvent = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(StandardEvent, Object.assign({}, props, { elClasses: ["fc-daygrid-event", "fc-daygrid-block-event", "fc-h-event"], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay }));
  }
};
var TableListItemEvent = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg } = props;
    let timeFormat = options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;
    let timeText = buildSegTimeText(seg, timeFormat, context, true, props.defaultDisplayEventEnd);
    return y(EventContainer, Object.assign({}, props, { elTag: "a", elClasses: ["fc-daygrid-event", "fc-daygrid-dot-event"], elAttrs: getSegAnchorAttrs(props.seg, context), defaultGenerator: renderInnerContent2, timeText, isResizing: false, isDateSelecting: false }));
  }
};
function renderInnerContent2(renderProps) {
  return y(
    _,
    null,
    y("div", { className: "fc-daygrid-event-dot", style: { borderColor: renderProps.borderColor || renderProps.backgroundColor } }),
    renderProps.timeText && y("div", { className: "fc-event-time" }, renderProps.timeText),
    y("div", { className: "fc-event-title" }, renderProps.event.title || y(_, null, "\xA0"))
  );
}
var TableCellMoreLink = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.compileSegs = memoize(compileSegs);
  }
  render() {
    let { props } = this;
    let { allSegs, invisibleSegs } = this.compileSegs(props.singlePlacements);
    return y(MoreLinkContainer, { elClasses: ["fc-daygrid-more-link"], dateProfile: props.dateProfile, todayRange: props.todayRange, allDayDate: props.allDayDate, moreCnt: props.moreCnt, allSegs, hiddenSegs: invisibleSegs, alignmentElRef: props.alignmentElRef, alignGridTop: props.alignGridTop, extraDateSpan: props.extraDateSpan, popoverContent: () => {
      let isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};
      return y(_, null, allSegs.map((seg) => {
        let instanceId = seg.eventRange.instance.instanceId;
        return y("div", { className: "fc-daygrid-event-harness", key: instanceId, style: {
          visibility: isForcedInvisible[instanceId] ? "hidden" : ""
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === props.eventSelection, defaultDisplayEventEnd: false }, getSegMeta(seg, props.todayRange))));
      }));
    } });
  }
};
function compileSegs(singlePlacements) {
  let allSegs = [];
  let invisibleSegs = [];
  for (let placement of singlePlacements) {
    allSegs.push(placement.seg);
    if (!placement.isVisible) {
      invisibleSegs.push(placement.seg);
    }
  }
  return { allSegs, invisibleSegs };
}
var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: "narrow" });
var TableCell = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.state = {
      dayNumberId: getUniqueDomId()
    };
    this.handleRootEl = (el) => {
      setRef(this.rootElRef, el);
      setRef(this.props.elRef, el);
    };
  }
  render() {
    let { context, props, state, rootElRef } = this;
    let { options, dateEnv } = context;
    let { date, dateProfile } = props;
    const isMonthStart = props.showDayNumber && shouldDisplayMonthStart(date, dateProfile.currentRange, dateEnv);
    return y(DayCellContainer, { elTag: "td", elRef: this.handleRootEl, elClasses: [
      "fc-daygrid-day",
      ...props.extraClassNames || []
    ], elAttrs: Object.assign(Object.assign(Object.assign({}, props.extraDataAttrs), props.showDayNumber ? { "aria-labelledby": state.dayNumberId } : {}), { role: "gridcell" }), defaultGenerator: renderTopInner, date, dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, isMonthStart, extraRenderProps: props.extraRenderProps }, (InnerContent, renderProps) => y(
      "div",
      { ref: props.innerElRef, className: "fc-daygrid-day-frame fc-scrollgrid-sync-inner", style: { minHeight: props.minHeight } },
      props.showWeekNumber && y(WeekNumberContainer, { elTag: "a", elClasses: ["fc-daygrid-week-number"], elAttrs: buildNavLinkAttrs(context, date, "week"), date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }),
      !renderProps.isDisabled && (props.showDayNumber || hasCustomDayCellContent(options) || props.forceDayTop) ? y(
        "div",
        { className: "fc-daygrid-day-top" },
        y(InnerContent, { elTag: "a", elClasses: [
          "fc-daygrid-day-number",
          isMonthStart && "fc-daygrid-month-start"
        ], elAttrs: Object.assign(Object.assign({}, buildNavLinkAttrs(context, date)), { id: state.dayNumberId }) })
      ) : props.showDayNumber ? (
        // for creating correct amount of space (see issue #7162)
        y(
          "div",
          { className: "fc-daygrid-day-top", style: { visibility: "hidden" } },
          y("a", { className: "fc-daygrid-day-number" }, "\xA0")
        )
      ) : void 0,
      y(
        "div",
        { className: "fc-daygrid-day-events", ref: props.fgContentElRef },
        props.fgContent,
        y(
          "div",
          { className: "fc-daygrid-day-bottom", style: { marginTop: props.moreMarginTop } },
          y(TableCellMoreLink, { allDayDate: date, singlePlacements: props.singlePlacements, moreCnt: props.moreCnt, alignmentElRef: rootElRef, alignGridTop: !props.showDayNumber, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange })
        )
      ),
      y("div", { className: "fc-daygrid-day-bg" }, props.bgContent)
    ));
  }
};
function renderTopInner(props) {
  return props.dayNumberText || y(_, null, "\xA0");
}
function shouldDisplayMonthStart(date, currentRange, dateEnv) {
  const { start: currentStart, end: currentEnd } = currentRange;
  const currentEndIncl = addMs(currentEnd, -1);
  const currentFirstYear = dateEnv.getYear(currentStart);
  const currentFirstMonth = dateEnv.getMonth(currentStart);
  const currentLastYear = dateEnv.getYear(currentEndIncl);
  const currentLastMonth = dateEnv.getMonth(currentEndIncl);
  return !(currentFirstYear === currentLastYear && currentFirstMonth === currentLastMonth) && Boolean(
    // first date in current view?
    date.valueOf() === currentStart.valueOf() || // a month-start that's within the current range?
    dateEnv.getDay(date) === 1 && date.valueOf() < currentEnd.valueOf()
  );
}
function generateSegKey(seg) {
  return seg.eventRange.instance.instanceId + ":" + seg.firstCol;
}
function generateSegUid(seg) {
  return generateSegKey(seg) + ":" + seg.lastCol;
}
function computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, segHeights, maxContentHeight, cells) {
  let hierarchy = new DayGridSegHierarchy((segEntry) => {
    let segUid = segs[segEntry.index].eventRange.instance.instanceId + ":" + segEntry.span.start + ":" + (segEntry.span.end - 1);
    return segHeights[segUid] || 1;
  });
  hierarchy.allowReslicing = true;
  hierarchy.strictOrder = strictOrder;
  if (dayMaxEvents === true || dayMaxEventRows === true) {
    hierarchy.maxCoord = maxContentHeight;
    hierarchy.hiddenConsumes = true;
  } else if (typeof dayMaxEvents === "number") {
    hierarchy.maxStackCnt = dayMaxEvents;
  } else if (typeof dayMaxEventRows === "number") {
    hierarchy.maxStackCnt = dayMaxEventRows;
    hierarchy.hiddenConsumes = true;
  }
  let segInputs = [];
  let unknownHeightSegs = [];
  for (let i3 = 0; i3 < segs.length; i3 += 1) {
    let seg = segs[i3];
    let segUid = generateSegUid(seg);
    let eventHeight = segHeights[segUid];
    if (eventHeight != null) {
      segInputs.push({
        index: i3,
        span: {
          start: seg.firstCol,
          end: seg.lastCol + 1
        }
      });
    } else {
      unknownHeightSegs.push(seg);
    }
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let segRects = hierarchy.toRects();
  let { singleColPlacements, multiColPlacements, leftoverMargins } = placeRects(segRects, segs, cells);
  let moreCnts = [];
  let moreMarginTops = [];
  for (let seg of unknownHeightSegs) {
    multiColPlacements[seg.firstCol].push({
      seg,
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = seg.firstCol; col <= seg.lastCol; col += 1) {
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreCnts.push(0);
  }
  for (let hiddenEntry of hiddenEntries) {
    let seg = segs[hiddenEntry.index];
    let hiddenSpan = hiddenEntry.span;
    multiColPlacements[hiddenSpan.start].push({
      seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),
      isVisible: false,
      isAbsolute: true,
      absoluteTop: 0,
      marginTop: 0
    });
    for (let col = hiddenSpan.start; col < hiddenSpan.end; col += 1) {
      moreCnts[col] += 1;
      singleColPlacements[col].push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: false,
        isAbsolute: false,
        absoluteTop: 0,
        marginTop: 0
      });
    }
  }
  for (let col = 0; col < cells.length; col += 1) {
    moreMarginTops.push(leftoverMargins[col]);
  }
  return { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops };
}
function placeRects(allRects, segs, cells) {
  let rectsByEachCol = groupRectsByEachCol(allRects, cells.length);
  let singleColPlacements = [];
  let multiColPlacements = [];
  let leftoverMargins = [];
  for (let col = 0; col < cells.length; col += 1) {
    let rects = rectsByEachCol[col];
    let singlePlacements = [];
    let currentHeight = 0;
    let currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      singlePlacements.push({
        seg: resliceSeg(seg, col, col + 1, cells),
        isVisible: true,
        isAbsolute: false,
        absoluteTop: rect.levelCoord,
        marginTop: rect.levelCoord - currentHeight
      });
      currentHeight = rect.levelCoord + rect.thickness;
    }
    let multiPlacements = [];
    currentHeight = 0;
    currentMarginTop = 0;
    for (let rect of rects) {
      let seg = segs[rect.index];
      let isAbsolute = rect.span.end - rect.span.start > 1;
      let isFirstCol = rect.span.start === col;
      currentMarginTop += rect.levelCoord - currentHeight;
      currentHeight = rect.levelCoord + rect.thickness;
      if (isAbsolute) {
        currentMarginTop += rect.thickness;
        if (isFirstCol) {
          multiPlacements.push({
            seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
            isVisible: true,
            isAbsolute: true,
            absoluteTop: rect.levelCoord,
            marginTop: 0
          });
        }
      } else if (isFirstCol) {
        multiPlacements.push({
          seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),
          isVisible: true,
          isAbsolute: false,
          absoluteTop: rect.levelCoord,
          marginTop: currentMarginTop
          // claim the margin
        });
        currentMarginTop = 0;
      }
    }
    singleColPlacements.push(singlePlacements);
    multiColPlacements.push(multiPlacements);
    leftoverMargins.push(currentMarginTop);
  }
  return { singleColPlacements, multiColPlacements, leftoverMargins };
}
function groupRectsByEachCol(rects, colCnt) {
  let rectsByEachCol = [];
  for (let col = 0; col < colCnt; col += 1) {
    rectsByEachCol.push([]);
  }
  for (let rect of rects) {
    for (let col = rect.span.start; col < rect.span.end; col += 1) {
      rectsByEachCol[col].push(rect);
    }
  }
  return rectsByEachCol;
}
function resliceSeg(seg, spanStart, spanEnd, cells) {
  if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {
    return seg;
  }
  let eventRange = seg.eventRange;
  let origRange = eventRange.range;
  let slicedRange = intersectRanges(origRange, {
    start: cells[spanStart].date,
    end: addDays(cells[spanEnd - 1].date, 1)
  });
  return Object.assign(Object.assign({}, seg), { firstCol: spanStart, lastCol: spanEnd - 1, eventRange: {
    def: eventRange.def,
    ui: Object.assign(Object.assign({}, eventRange.ui), { durationEditable: false }),
    instance: eventRange.instance,
    range: slicedRange
  }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() });
}
var DayGridSegHierarchy = class extends SegHierarchy {
  constructor() {
    super(...arguments);
    this.hiddenConsumes = false;
    this.forceHidden = {};
  }
  addSegs(segInputs) {
    const hiddenSegs = super.addSegs(segInputs);
    const { entriesByLevel } = this;
    const excludeHidden = (entry) => !this.forceHidden[buildEntryKey(entry)];
    for (let level = 0; level < entriesByLevel.length; level += 1) {
      entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);
    }
    return hiddenSegs;
  }
  handleInvalidInsertion(insertion, entry, hiddenEntries) {
    const { entriesByLevel, forceHidden } = this;
    const { touchingEntry, touchingLevel, touchingLateral } = insertion;
    if (this.hiddenConsumes && touchingEntry) {
      const touchingEntryId = buildEntryKey(touchingEntry);
      if (!forceHidden[touchingEntryId]) {
        if (this.allowReslicing) {
          const hiddenEntry = Object.assign(Object.assign({}, touchingEntry), { span: intersectSpans(touchingEntry.span, entry.span) });
          const hiddenEntryId = buildEntryKey(hiddenEntry);
          forceHidden[hiddenEntryId] = true;
          entriesByLevel[touchingLevel][touchingLateral] = hiddenEntry;
          hiddenEntries.push(hiddenEntry);
          this.splitEntry(touchingEntry, entry, hiddenEntries);
        } else {
          forceHidden[touchingEntryId] = true;
          hiddenEntries.push(touchingEntry);
        }
      }
    }
    super.handleInvalidInsertion(insertion, entry, hiddenEntries);
  }
};
var TableRow = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.cellElRefs = new RefMap();
    this.frameElRefs = new RefMap();
    this.fgElRefs = new RefMap();
    this.segHarnessRefs = new RefMap();
    this.rootElRef = d();
    this.state = {
      framePositions: null,
      maxContentHeight: null,
      segHeights: {}
    };
    this.handleResize = (isForced) => {
      if (isForced) {
        this.updateSizing(true);
      }
    };
  }
  render() {
    let { props, state, context } = this;
    let { options } = context;
    let colCnt = props.cells.length;
    let businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);
    let bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);
    let highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);
    let mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);
    let { singleColPlacements, multiColPlacements, moreCnts, moreMarginTops } = computeFgSegPlacement(sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.segHeights, state.maxContentHeight, props.cells);
    let isForcedInvisible = (
      // TODO: messy way to compute this
      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
    );
    return y(
      "tr",
      { ref: this.rootElRef, role: "row" },
      props.renderIntro && props.renderIntro(),
      props.cells.map((cell, col) => {
        let normalFgNodes = this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);
        let mirrorFgNodes = this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);
        return y(TableCell, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), innerElRef: this.frameElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers, todayRange: props.todayRange, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, moreCnt: moreCnts[col], moreMarginTop: moreMarginTops[col], singlePlacements: singleColPlacements[col], fgContentElRef: this.fgElRefs.createRef(cell.key), fgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            y(_, null, normalFgNodes),
            y(_, null, mirrorFgNodes)
          )
        ), bgContent: (
          // Fragment scopes the keys
          y(
            _,
            null,
            this.renderFillSegs(highlightSegsByCol[col], "highlight"),
            this.renderFillSegs(businessHoursByCol[col], "non-business"),
            this.renderFillSegs(bgEventSegsByCol[col], "bg-event")
          )
        ), minHeight: props.cellMinHeight });
      })
    );
  }
  componentDidMount() {
    this.updateSizing(true);
    this.context.addResizeHandler(this.handleResize);
  }
  componentDidUpdate(prevProps, prevState) {
    let currentProps = this.props;
    this.updateSizing(!isPropsEqual(prevProps, currentProps));
  }
  componentWillUnmount() {
    this.context.removeResizeHandler(this.handleResize);
  }
  getHighlightSegs() {
    let { props } = this;
    if (props.eventDrag && props.eventDrag.segs.length) {
      return props.eventDrag.segs;
    }
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return props.dateSelectionSegs;
  }
  getMirrorSegs() {
    let { props } = this;
    if (props.eventResize && props.eventResize.segs.length) {
      return props.eventResize.segs;
    }
    return [];
  }
  renderFgSegs(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {
    let { context } = this;
    let { eventSelection } = this.props;
    let { framePositions } = this.state;
    let defaultDisplayEventEnd = this.props.cells.length === 1;
    let isMirror = isDragging || isResizing || isDateSelecting;
    let nodes = [];
    if (framePositions) {
      for (let placement of segPlacements) {
        let { seg } = placement;
        let { instanceId } = seg.eventRange.instance;
        let isVisible = placement.isVisible && !isForcedInvisible[instanceId];
        let isAbsolute = placement.isAbsolute;
        let left = "";
        let right = "";
        if (isAbsolute) {
          if (context.isRtl) {
            right = 0;
            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];
          } else {
            left = 0;
            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];
          }
        }
        nodes.push(y("div", { className: "fc-daygrid-event-harness" + (isAbsolute ? " fc-daygrid-event-harness-abs" : ""), key: generateSegKey(seg), ref: isMirror ? null : this.segHarnessRefs.createRef(generateSegUid(seg)), style: {
          visibility: isVisible ? "" : "hidden",
          marginTop: isAbsolute ? "" : placement.marginTop,
          top: isAbsolute ? placement.absoluteTop : "",
          left,
          right
        } }, hasListItemDisplay(seg) ? y(TableListItemEvent, Object.assign({ seg, isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange))) : y(TableBlockEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))));
      }
    }
    return nodes;
  }
  renderFillSegs(segs, fillType) {
    let { isRtl } = this.context;
    let { todayRange } = this.props;
    let { framePositions } = this.state;
    let nodes = [];
    if (framePositions) {
      for (let seg of segs) {
        let leftRightCss = isRtl ? {
          right: 0,
          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]
        } : {
          left: 0,
          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]
        };
        nodes.push(y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-daygrid-bg-harness", style: leftRightCss }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, todayRange))) : renderFill(fillType)));
      }
    }
    return y(_, {}, ...nodes);
  }
  updateSizing(isExternalSizingChange) {
    let { props, state, frameElRefs } = this;
    if (!props.forPrint && props.clientWidth !== null) {
      if (isExternalSizingChange) {
        let frameEls = props.cells.map((cell) => frameElRefs.currentMap[cell.key]);
        if (frameEls.length) {
          let originEl = this.rootElRef.current;
          let newPositionCache = new PositionCache(
            originEl,
            frameEls,
            true,
            // isHorizontal
            false
          );
          if (!state.framePositions || !state.framePositions.similarTo(newPositionCache)) {
            this.setState({
              framePositions: new PositionCache(
                originEl,
                frameEls,
                true,
                // isHorizontal
                false
              )
            });
          }
        }
      }
      const oldSegHeights = this.state.segHeights;
      const newSegHeights = this.querySegHeights();
      const limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;
      this.safeSetState({
        // HACK to prevent oscillations of events being shown/hidden from max-event-rows
        // Essentially, once you compute an element's height, never null-out.
        // TODO: always display all events, as visibility:hidden?
        segHeights: Object.assign(Object.assign({}, oldSegHeights), newSegHeights),
        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null
      });
    }
  }
  querySegHeights() {
    let segElMap = this.segHarnessRefs.currentMap;
    let segHeights = {};
    for (let segUid in segElMap) {
      let height = Math.round(segElMap[segUid].getBoundingClientRect().height);
      segHeights[segUid] = Math.max(segHeights[segUid] || 0, height);
    }
    return segHeights;
  }
  computeMaxContentHeight() {
    let firstKey = this.props.cells[0].key;
    let cellEl = this.cellElRefs.currentMap[firstKey];
    let fcContainerEl = this.fgElRefs.currentMap[firstKey];
    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;
  }
  getCellEls() {
    let elMap = this.cellElRefs.currentMap;
    return this.props.cells.map((cell) => elMap[cell.key]);
  }
};
TableRow.addStateEquality({
  segHeights: isPropsEqual
});
function buildMirrorPlacements(mirrorSegs, colPlacements) {
  if (!mirrorSegs.length) {
    return [];
  }
  let topsByInstanceId = buildAbsoluteTopHash(colPlacements);
  return mirrorSegs.map((seg) => ({
    seg,
    isVisible: true,
    isAbsolute: true,
    absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],
    marginTop: 0
  }));
}
function buildAbsoluteTopHash(colPlacements) {
  let topsByInstanceId = {};
  for (let placements of colPlacements) {
    for (let placement of placements) {
      topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;
    }
  }
  return topsByInstanceId;
}
var TableRows = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.splitBusinessHourSegs = memoize(splitSegsByRow);
    this.splitBgEventSegs = memoize(splitSegsByRow);
    this.splitFgEventSegs = memoize(splitSegsByRow);
    this.splitDateSelectionSegs = memoize(splitSegsByRow);
    this.splitEventDrag = memoize(splitInteractionByRow);
    this.splitEventResize = memoize(splitInteractionByRow);
    this.rowRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    let rowCnt = props.cells.length;
    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);
    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);
    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);
    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);
    let eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);
    let eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);
    let cellMinHeight = rowCnt >= 7 && props.clientWidth ? props.clientWidth / context.options.aspectRatio / 6 : null;
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => y(_, null, props.cells.map((cells, row) => y(TableRow, {
      ref: this.rowRefs.createRef(row),
      key: cells.length ? cells[0].date.toISOString() : row,
      showDayNumbers: rowCnt > 1,
      showWeekNumbers: props.showWeekNumbers,
      todayRange,
      dateProfile: props.dateProfile,
      cells,
      renderIntro: props.renderRowIntro,
      businessHourSegs: businessHourSegsByRow[row],
      eventSelection: props.eventSelection,
      bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),
      fgEventSegs: fgEventSegsByRow[row],
      dateSelectionSegs: dateSelectionSegsByRow[row],
      eventDrag: eventDragByRow[row],
      eventResize: eventResizeByRow[row],
      dayMaxEvents: props.dayMaxEvents,
      dayMaxEventRows: props.dayMaxEventRows,
      clientWidth: props.clientWidth,
      clientHeight: props.clientHeight,
      cellMinHeight,
      forPrint: props.forPrint
    }))));
  }
  componentDidMount() {
    this.registerInteractiveComponent();
  }
  componentDidUpdate() {
    this.registerInteractiveComponent();
  }
  registerInteractiveComponent() {
    if (!this.rootEl) {
      const firstCellEl = this.rowRefs.currentMap[0].getCellEls()[0];
      const rootEl = firstCellEl ? firstCellEl.closest(".fc-daygrid-body") : null;
      if (rootEl) {
        this.rootEl = rootEl;
        this.context.registerInteractiveComponent(this, {
          el: rootEl,
          isHitComboAllowed: this.props.isHitComboAllowed
        });
      }
    }
  }
  componentWillUnmount() {
    if (this.rootEl) {
      this.context.unregisterInteractiveComponent(this);
      this.rootEl = null;
    }
  }
  // Hit System
  // ----------------------------------------------------------------------------------------------------
  prepareHits() {
    this.rowPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.collect().map((rowObj) => rowObj.getCellEls()[0]),
      // first cell el in each row. TODO: not optimal
      false,
      true
    );
    this.colPositions = new PositionCache(
      this.rootEl,
      this.rowRefs.currentMap[0].getCellEls(),
      // cell els in first row
      true,
      // horizontal
      false
    );
  }
  queryHit(positionLeft, positionTop) {
    let { colPositions, rowPositions } = this;
    let col = colPositions.leftToIndex(positionLeft);
    let row = rowPositions.topToIndex(positionTop);
    if (row != null && col != null) {
      let cell = this.props.cells[row][col];
      return {
        dateProfile: this.props.dateProfile,
        dateSpan: Object.assign({ range: this.getCellRange(row, col), allDay: true }, cell.extraDateSpan),
        dayEl: this.getCellEl(row, col),
        rect: {
          left: colPositions.lefts[col],
          right: colPositions.rights[col],
          top: rowPositions.tops[row],
          bottom: rowPositions.bottoms[row]
        },
        layer: 0
      };
    }
    return null;
  }
  getCellEl(row, col) {
    return this.rowRefs.currentMap[row].getCellEls()[col];
  }
  getCellRange(row, col) {
    let start = this.props.cells[row][col].date;
    let end = addDays(start, 1);
    return { start, end };
  }
};
function isSegAllDay(seg) {
  return seg.eventRange.def.allDay;
}
var Table = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.elRef = d();
    this.needsScrollReset = false;
  }
  render() {
    let { props } = this;
    let { dayMaxEventRows, dayMaxEvents, expandRows } = props;
    let limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;
    if (limitViaBalanced && !expandRows) {
      limitViaBalanced = false;
      dayMaxEventRows = null;
      dayMaxEvents = null;
    }
    let classNames = [
      "fc-daygrid-body",
      limitViaBalanced ? "fc-daygrid-body-balanced" : "fc-daygrid-body-unbalanced",
      expandRows ? "" : "fc-daygrid-body-natural"
      // will height of one row depend on the others?
    ];
    return y(
      "div",
      { ref: this.elRef, className: classNames.join(" "), style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      } },
      y(
        "table",
        { role: "presentation", className: "fc-scrollgrid-sync-table", style: {
          width: props.clientWidth,
          minWidth: props.tableMinWidth,
          height: expandRows ? props.clientHeight : ""
        } },
        props.colGroupNode,
        y(
          "tbody",
          { role: "presentation" },
          y(TableRows, { dateProfile: props.dateProfile, cells: props.cells, renderRowIntro: props.renderRowIntro, showWeekNumbers: props.showWeekNumbers, clientWidth: props.clientWidth, clientHeight: props.clientHeight, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, dayMaxEvents, dayMaxEventRows, forPrint: props.forPrint, isHitComboAllowed: props.isHitComboAllowed })
        )
      )
    );
  }
  componentDidMount() {
    this.requestScrollReset();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.dateProfile !== this.props.dateProfile) {
      this.requestScrollReset();
    } else {
      this.flushScrollReset();
    }
  }
  requestScrollReset() {
    this.needsScrollReset = true;
    this.flushScrollReset();
  }
  flushScrollReset() {
    if (this.needsScrollReset && this.props.clientWidth) {
      const subjectEl = getScrollSubjectEl(this.elRef.current, this.props.dateProfile);
      if (subjectEl) {
        const originEl = subjectEl.closest(".fc-daygrid-body");
        const scrollEl = originEl.closest(".fc-scroller");
        const scrollTop = subjectEl.getBoundingClientRect().top - originEl.getBoundingClientRect().top;
        scrollEl.scrollTop = scrollTop ? scrollTop + 1 : 0;
      }
      this.needsScrollReset = false;
    }
  }
};
function getScrollSubjectEl(containerEl, dateProfile) {
  let el;
  if (dateProfile.currentRangeUnit.match(/year|month/)) {
    el = containerEl.querySelector(`[data-date="${formatIsoMonthStr(dateProfile.currentDate)}-01"]`);
  }
  if (!el) {
    el = containerEl.querySelector(`[data-date="${formatDayString(dateProfile.currentDate)}"]`);
  }
  return el;
}
var DayTableSlicer = class extends Slicer {
  constructor() {
    super(...arguments);
    this.forceDayIfListItem = true;
  }
  sliceRange(dateRange, dayTableModel) {
    return dayTableModel.sliceRange(dateRange);
  }
};
var DayTable = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.slicer = new DayTableSlicer();
    this.tableRef = d();
  }
  render() {
    let { props, context } = this;
    return y(Table, Object.assign({ ref: this.tableRef }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint }));
  }
};
var DayTableView = class extends TableView {
  constructor() {
    super(...arguments);
    this.buildDayTableModel = memoize(buildDayTableModel);
    this.headerRef = d();
    this.tableRef = d();
  }
  render() {
    let { options, dateProfileGenerator } = this.context;
    let { props } = this;
    let dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);
    let headerContent = options.dayHeaders && y(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 });
    let bodyContent = (contentArg) => y(DayTable, { ref: this.tableRef, dateProfile: props.dateProfile, dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint });
    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);
  }
};
function buildDayTableModel(dateProfile, dateProfileGenerator) {
  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));
}
var TableDateProfileGenerator = class extends DateProfileGenerator {
  // Computes the date range that will be rendered
  buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay) {
    let renderRange = super.buildRenderRange(currentRange, currentRangeUnit, isRangeAllDay);
    let { props } = this;
    return buildDayTableRenderRange({
      currentRange: renderRange,
      snapToWeek: /^(year|month)$/.test(currentRangeUnit),
      fixedWeekCount: props.fixedWeekCount,
      dateEnv: props.dateEnv
    });
  }
};
function buildDayTableRenderRange(props) {
  let { dateEnv, currentRange } = props;
  let { start, end } = currentRange;
  let endOfWeek;
  if (props.snapToWeek) {
    start = dateEnv.startOfWeek(start);
    endOfWeek = dateEnv.startOfWeek(end);
    if (endOfWeek.valueOf() !== end.valueOf()) {
      end = addWeeks(endOfWeek, 1);
    }
  }
  if (props.fixedWeekCount) {
    let lastMonthRenderStart = dateEnv.startOfWeek(dateEnv.startOfMonth(addDays(currentRange.end, -1)));
    let rowCnt = Math.ceil(
      // could be partial weeks due to hiddenDays
      diffWeeks(lastMonthRenderStart, end)
    );
    end = addWeeks(end, 6 - rowCnt);
  }
  return { start, end };
}
var css_248z2 = ':root{--fc-daygrid-event-dot-width:8px}.fc-daygrid-day-events:after,.fc-daygrid-day-events:before,.fc-daygrid-day-frame:after,.fc-daygrid-day-frame:before,.fc-daygrid-event-harness:after,.fc-daygrid-event-harness:before{clear:both;content:"";display:table}.fc .fc-daygrid-body{position:relative;z-index:1}.fc .fc-daygrid-day.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-daygrid-day-frame{min-height:100%;position:relative}.fc .fc-daygrid-day-top{display:flex;flex-direction:row-reverse}.fc .fc-day-other .fc-daygrid-day-top{opacity:.3}.fc .fc-daygrid-day-number{padding:4px;position:relative;z-index:4}.fc .fc-daygrid-month-start{font-size:1.1em;font-weight:700}.fc .fc-daygrid-day-events{margin-top:1px}.fc .fc-daygrid-body-balanced .fc-daygrid-day-events{left:0;position:absolute;right:0}.fc .fc-daygrid-body-unbalanced .fc-daygrid-day-events{min-height:2em;position:relative}.fc .fc-daygrid-body-natural .fc-daygrid-day-events{margin-bottom:1em}.fc .fc-daygrid-event-harness{position:relative}.fc .fc-daygrid-event-harness-abs{left:0;position:absolute;right:0;top:0}.fc .fc-daygrid-bg-harness{bottom:0;position:absolute;top:0}.fc .fc-daygrid-day-bg .fc-non-business{z-index:1}.fc .fc-daygrid-day-bg .fc-bg-event{z-index:2}.fc .fc-daygrid-day-bg .fc-highlight{z-index:3}.fc .fc-daygrid-event{margin-top:1px;z-index:6}.fc .fc-daygrid-event.fc-event-mirror{z-index:7}.fc .fc-daygrid-day-bottom{font-size:.85em;margin:0 2px}.fc .fc-daygrid-day-bottom:after,.fc .fc-daygrid-day-bottom:before{clear:both;content:"";display:table}.fc .fc-daygrid-more-link{border-radius:3px;cursor:pointer;line-height:1;margin-top:1px;max-width:100%;overflow:hidden;padding:2px;position:relative;white-space:nowrap;z-index:4}.fc .fc-daygrid-more-link:hover{background-color:rgba(0,0,0,.1)}.fc .fc-daygrid-week-number{background-color:var(--fc-neutral-bg-color);color:var(--fc-neutral-text-color);min-width:1.5em;padding:2px;position:absolute;text-align:center;top:0;z-index:5}.fc .fc-more-popover .fc-popover-body{min-width:220px;padding:10px}.fc-direction-ltr .fc-daygrid-event.fc-event-start,.fc-direction-rtl .fc-daygrid-event.fc-event-end{margin-left:2px}.fc-direction-ltr .fc-daygrid-event.fc-event-end,.fc-direction-rtl .fc-daygrid-event.fc-event-start{margin-right:2px}.fc-direction-ltr .fc-daygrid-more-link{float:left}.fc-direction-ltr .fc-daygrid-week-number{border-radius:0 0 3px 0;left:0}.fc-direction-rtl .fc-daygrid-more-link{float:right}.fc-direction-rtl .fc-daygrid-week-number{border-radius:0 0 0 3px;right:0}.fc-liquid-hack .fc-daygrid-day-frame{position:static}.fc-daygrid-event{border-radius:3px;font-size:var(--fc-small-font-size);position:relative;white-space:nowrap}.fc-daygrid-block-event .fc-event-time{font-weight:700}.fc-daygrid-block-event .fc-event-time,.fc-daygrid-block-event .fc-event-title{padding:1px}.fc-daygrid-dot-event{align-items:center;display:flex;padding:2px 0}.fc-daygrid-dot-event .fc-event-title{flex-grow:1;flex-shrink:1;font-weight:700;min-width:0;overflow:hidden}.fc-daygrid-dot-event.fc-event-mirror,.fc-daygrid-dot-event:hover{background:rgba(0,0,0,.1)}.fc-daygrid-dot-event.fc-event-selected:before{bottom:-10px;top:-10px}.fc-daygrid-event-dot{border:calc(var(--fc-daygrid-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-daygrid-event-dot-width)/2);box-sizing:content-box;height:0;margin:0 4px;width:0}.fc-direction-ltr .fc-daygrid-event .fc-event-time{margin-right:3px}.fc-direction-rtl .fc-daygrid-event .fc-event-time{margin-left:3px}';
injectStyles(css_248z2);

// node_modules/@fullcalendar/daygrid/index.js
var index = createPlugin({
  name: "@fullcalendar/daygrid",
  initialView: "dayGridMonth",
  views: {
    dayGrid: {
      component: DayTableView,
      dateProfileGeneratorClass: TableDateProfileGenerator
    },
    dayGridDay: {
      type: "dayGrid",
      duration: { days: 1 }
    },
    dayGridWeek: {
      type: "dayGrid",
      duration: { weeks: 1 }
    },
    dayGridMonth: {
      type: "dayGrid",
      duration: { months: 1 },
      fixedWeekCount: true
    },
    dayGridYear: {
      type: "dayGrid",
      duration: { years: 1 }
    }
  }
});

// node_modules/@fullcalendar/timegrid/internal.js
var AllDaySplitter = class extends Splitter {
  getKeyInfo() {
    return {
      allDay: {},
      timed: {}
    };
  }
  getKeysForDateSpan(dateSpan) {
    if (dateSpan.allDay) {
      return ["allDay"];
    }
    return ["timed"];
  }
  getKeysForEventDef(eventDef) {
    if (!eventDef.allDay) {
      return ["timed"];
    }
    if (hasBgRendering(eventDef)) {
      return ["timed", "allDay"];
    }
    return ["allDay"];
  }
};
var DEFAULT_SLAT_LABEL_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  omitZeroMinute: true,
  meridiem: "short"
});
function TimeColsAxisCell(props) {
  let classNames = [
    "fc-timegrid-slot",
    "fc-timegrid-slot-label",
    props.isLabeled ? "fc-scrollgrid-shrink" : "fc-timegrid-slot-minor"
  ];
  return y(ViewContextType.Consumer, null, (context) => {
    if (!props.isLabeled) {
      return y("td", { className: classNames.join(" "), "data-time": props.isoTimeStr });
    }
    let { dateEnv, options, viewApi } = context;
    let labelFormat = (
      // TODO: fully pre-parse
      options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT : Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) : createFormatter(options.slotLabelFormat)
    );
    let renderProps = {
      level: 0,
      time: props.time,
      date: dateEnv.toDate(props.date),
      view: viewApi,
      text: dateEnv.format(props.date, labelFormat)
    };
    return y(ContentContainer, { elTag: "td", elClasses: classNames, elAttrs: {
      "data-time": props.isoTimeStr
    }, renderProps, generatorName: "slotLabelContent", customGenerator: options.slotLabelContent, defaultGenerator: renderInnerContent3, classNameGenerator: options.slotLabelClassNames, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, (InnerContent) => y(
      "div",
      { className: "fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame" },
      y(InnerContent, { elTag: "div", elClasses: [
        "fc-timegrid-slot-label-cushion",
        "fc-scrollgrid-shrink-cushion"
      ] })
    ));
  });
}
function renderInnerContent3(props) {
  return props.text;
}
var TimeBodyAxis = class extends BaseComponent {
  render() {
    return this.props.slatMetas.map((slatMeta) => y(
      "tr",
      { key: slatMeta.key },
      y(TimeColsAxisCell, Object.assign({}, slatMeta))
    ));
  }
};
var DEFAULT_WEEK_NUM_FORMAT2 = createFormatter({ week: "short" });
var AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;
var TimeColsView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.allDaySplitter = new AllDaySplitter();
    this.headerElRef = d();
    this.rootElRef = d();
    this.scrollerElRef = d();
    this.state = {
      slatCoords: null
    };
    this.handleScrollTopRequest = (scrollTop) => {
      let scrollerEl = this.scrollerElRef.current;
      if (scrollerEl) {
        scrollerEl.scrollTop = scrollTop;
      }
    };
    this.renderHeadAxis = (rowKey, frameHeight = "") => {
      let { options } = this.context;
      let { dateProfile } = this.props;
      let range2 = dateProfile.renderRange;
      let dayCnt = diffDays(range2.start, range2.end);
      let navLinkAttrs = dayCnt === 1 ? buildNavLinkAttrs(this.context, range2.start, "week") : {};
      if (options.weekNumbers && rowKey === "day") {
        return y(WeekNumberContainer, { elTag: "th", elClasses: [
          "fc-timegrid-axis",
          "fc-scrollgrid-shrink"
        ], elAttrs: {
          "aria-hidden": true
        }, date: range2.start, defaultFormat: DEFAULT_WEEK_NUM_FORMAT2 }, (InnerContent) => y(
          "div",
          { className: [
            "fc-timegrid-axis-frame",
            "fc-scrollgrid-shrink-frame",
            "fc-timegrid-axis-frame-liquid"
          ].join(" "), style: { height: frameHeight } },
          y(InnerContent, { elTag: "a", elClasses: [
            "fc-timegrid-axis-cushion",
            "fc-scrollgrid-shrink-cushion",
            "fc-scrollgrid-sync-inner"
          ], elAttrs: navLinkAttrs })
        ));
      }
      return y(
        "th",
        { "aria-hidden": true, className: "fc-timegrid-axis" },
        y("div", { className: "fc-timegrid-axis-frame", style: { height: frameHeight } })
      );
    };
    this.renderTableRowAxis = (rowHeight) => {
      let { options, viewApi } = this.context;
      let renderProps = {
        text: options.allDayText,
        view: viewApi
      };
      return (
        // TODO: make reusable hook. used in list view too
        y(ContentContainer, { elTag: "td", elClasses: [
          "fc-timegrid-axis",
          "fc-scrollgrid-shrink"
        ], elAttrs: {
          "aria-hidden": true
        }, renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }, (InnerContent) => y(
          "div",
          { className: [
            "fc-timegrid-axis-frame",
            "fc-scrollgrid-shrink-frame",
            rowHeight == null ? " fc-timegrid-axis-frame-liquid" : ""
          ].join(" "), style: { height: rowHeight } },
          y(InnerContent, { elTag: "span", elClasses: [
            "fc-timegrid-axis-cushion",
            "fc-scrollgrid-shrink-cushion",
            "fc-scrollgrid-sync-inner"
          ] })
        ))
      );
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
    };
  }
  // rendering
  // ----------------------------------------------------------------------------------------------------
  renderSimpleLayout(headerRowContent, allDayContent, timeContent) {
    let { context, props } = this;
    let sections = [];
    let stickyHeaderDates = getStickyHeaderDates(context.options);
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        chunk: {
          elRef: this.headerElRef,
          tableClassName: "fc-col-header",
          rowContent: headerRowContent
        }
      });
    }
    if (allDayContent) {
      sections.push({
        type: "body",
        key: "all-day",
        chunk: { content: allDayContent }
      });
      sections.push({
        type: "body",
        key: "all-day-divider",
        outerContent: (
          // TODO: rename to cellContent so don't need to define <tr>?
          y(
            "tr",
            { role: "presentation", className: "fc-scrollgrid-section" },
            y("td", { className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
          )
        )
      });
    }
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      expandRows: Boolean(context.options.expandRows),
      chunk: {
        scrollerElRef: this.scrollerElRef,
        content: timeContent
      }
    });
    return y(
      ViewContainer,
      { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: context.viewSpec },
      y(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, collapsibleWidth: props.forPrint, cols: [{ width: "shrink" }], sections })
    );
  }
  renderHScrollLayout(headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {
    let ScrollGrid = this.context.pluginHooks.scrollGridImpl;
    if (!ScrollGrid) {
      throw new Error("No ScrollGrid implementation");
    }
    let { context, props } = this;
    let stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);
    let stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);
    let sections = [];
    if (headerRowContent) {
      sections.push({
        type: "header",
        key: "header",
        isSticky: stickyHeaderDates,
        syncRowHeights: true,
        chunks: [
          {
            key: "axis",
            rowContent: (arg) => y("tr", { role: "presentation" }, this.renderHeadAxis("day", arg.rowSyncHeights[0]))
          },
          {
            key: "cols",
            elRef: this.headerElRef,
            tableClassName: "fc-col-header",
            rowContent: headerRowContent
          }
        ]
      });
    }
    if (allDayContent) {
      sections.push({
        type: "body",
        key: "all-day",
        syncRowHeights: true,
        chunks: [
          {
            key: "axis",
            rowContent: (contentArg) => y("tr", { role: "presentation" }, this.renderTableRowAxis(contentArg.rowSyncHeights[0]))
          },
          {
            key: "cols",
            content: allDayContent
          }
        ]
      });
      sections.push({
        key: "all-day-divider",
        type: "body",
        outerContent: (
          // TODO: rename to cellContent so don't need to define <tr>?
          y(
            "tr",
            { role: "presentation", className: "fc-scrollgrid-section" },
            y("td", { colSpan: 2, className: "fc-timegrid-divider " + context.theme.getClass("tableCellShaded") })
          )
        )
      });
    }
    let isNowIndicator = context.options.nowIndicator;
    sections.push({
      type: "body",
      key: "body",
      liquid: true,
      expandRows: Boolean(context.options.expandRows),
      chunks: [
        {
          key: "axis",
          content: (arg) => (
            // TODO: make this now-indicator arrow more DRY with TimeColsContent
            y(
              "div",
              { className: "fc-timegrid-axis-chunk" },
              y(
                "table",
                { "aria-hidden": true, style: { height: arg.expandRows ? arg.clientHeight : "" } },
                arg.tableColGroupNode,
                y(
                  "tbody",
                  null,
                  y(TimeBodyAxis, { slatMetas })
                )
              ),
              y(
                "div",
                { className: "fc-timegrid-now-indicator-container" },
                y(NowTimer, {
                  unit: isNowIndicator ? "minute" : "day"
                  /* hacky */
                }, (nowDate) => {
                  let nowIndicatorTop = isNowIndicator && slatCoords && slatCoords.safeComputeTop(nowDate);
                  if (typeof nowIndicatorTop === "number") {
                    return y(NowIndicatorContainer, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: nowIndicatorTop }, isAxis: true, date: nowDate });
                  }
                  return null;
                })
              )
            )
          )
        },
        {
          key: "cols",
          scrollerElRef: this.scrollerElRef,
          content: timeContent
        }
      ]
    });
    if (stickyFooterScrollbar) {
      sections.push({
        key: "footer",
        type: "footer",
        isSticky: true,
        chunks: [
          {
            key: "axis",
            content: renderScrollShim
          },
          {
            key: "cols",
            content: renderScrollShim
          }
        ]
      });
    }
    return y(
      ViewContainer,
      { elRef: this.rootElRef, elClasses: ["fc-timegrid"], viewSpec: context.viewSpec },
      y(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, forPrint: props.forPrint, collapsibleWidth: false, colGroups: [
        { width: "shrink", cols: [{ width: "shrink" }] },
        { cols: [{ span: colCnt, minWidth: dayMinWidth }] }
      ], sections })
    );
  }
  /* Dimensions
  ------------------------------------------------------------------------------------------------------------------*/
  getAllDayMaxEventProps() {
    let { dayMaxEvents, dayMaxEventRows } = this.context.options;
    if (dayMaxEvents === true || dayMaxEventRows === true) {
      dayMaxEvents = void 0;
      dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS;
    }
    return { dayMaxEvents, dayMaxEventRows };
  }
};
function renderAllDayInner(renderProps) {
  return renderProps.text;
}
var TimeColsSlatsCoords = class {
  constructor(positions, dateProfile, slotDuration) {
    this.positions = positions;
    this.dateProfile = dateProfile;
    this.slotDuration = slotDuration;
  }
  safeComputeTop(date) {
    let { dateProfile } = this;
    if (rangeContainsMarker(dateProfile.currentRange, date)) {
      let startOfDayDate = startOfDay(date);
      let timeMs = date.valueOf() - startOfDayDate.valueOf();
      if (timeMs >= asRoughMs(dateProfile.slotMinTime) && timeMs < asRoughMs(dateProfile.slotMaxTime)) {
        return this.computeTimeTop(createDuration(timeMs));
      }
    }
    return null;
  }
  // Computes the top coordinate, relative to the bounds of the grid, of the given date.
  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
  computeDateTop(when, startOfDayDate) {
    if (!startOfDayDate) {
      startOfDayDate = startOfDay(when);
    }
    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));
  }
  // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
  // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.
  // Eventually allow computation with arbirary slat dates.
  computeTimeTop(duration) {
    let { positions, dateProfile } = this;
    let len = positions.els.length;
    let slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / asRoughMs(this.slotDuration);
    let slatIndex;
    let slatRemainder;
    slatCoverage = Math.max(0, slatCoverage);
    slatCoverage = Math.min(len, slatCoverage);
    slatIndex = Math.floor(slatCoverage);
    slatIndex = Math.min(slatIndex, len - 1);
    slatRemainder = slatCoverage - slatIndex;
    return positions.tops[slatIndex] + positions.getHeight(slatIndex) * slatRemainder;
  }
};
var TimeColsSlatsBody = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { slatElRefs } = props;
    return y("tbody", null, props.slatMetas.map((slatMeta, i3) => {
      let renderProps = {
        time: slatMeta.time,
        date: context.dateEnv.toDate(slatMeta.date),
        view: context.viewApi
      };
      return y(
        "tr",
        { key: slatMeta.key, ref: slatElRefs.createRef(slatMeta.key) },
        props.axis && y(TimeColsAxisCell, Object.assign({}, slatMeta)),
        y(ContentContainer, { elTag: "td", elClasses: [
          "fc-timegrid-slot",
          "fc-timegrid-slot-lane",
          !slatMeta.isLabeled && "fc-timegrid-slot-minor"
        ], elAttrs: {
          "data-time": slatMeta.isoTimeStr
        }, renderProps, generatorName: "slotLaneContent", customGenerator: options.slotLaneContent, classNameGenerator: options.slotLaneClassNames, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount })
      );
    }));
  }
};
var TimeColsSlats = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.rootElRef = d();
    this.slatElRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    return y(
      "div",
      { ref: this.rootElRef, className: "fc-timegrid-slots" },
      y(
        "table",
        { "aria-hidden": true, className: context.theme.getClass("table"), style: {
          minWidth: props.tableMinWidth,
          width: props.clientWidth,
          height: props.minHeight
        } },
        props.tableColGroupNode,
        y(TimeColsSlatsBody, { slatElRefs: this.slatElRefs, axis: props.axis, slatMetas: props.slatMetas })
      )
    );
  }
  componentDidMount() {
    this.updateSizing();
  }
  componentDidUpdate() {
    this.updateSizing();
  }
  componentWillUnmount() {
    if (this.props.onCoords) {
      this.props.onCoords(null);
    }
  }
  updateSizing() {
    let { context, props } = this;
    if (props.onCoords && props.clientWidth !== null) {
      let rootEl = this.rootElRef.current;
      if (rootEl.offsetHeight) {
        props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, context.options.slotDuration));
      }
    }
  }
};
function collectSlatEls(elMap, slatMetas) {
  return slatMetas.map((slatMeta) => elMap[slatMeta.key]);
}
function splitSegsByCol(segs, colCnt) {
  let segsByCol = [];
  let i3;
  for (i3 = 0; i3 < colCnt; i3 += 1) {
    segsByCol.push([]);
  }
  if (segs) {
    for (i3 = 0; i3 < segs.length; i3 += 1) {
      segsByCol[segs[i3].col].push(segs[i3]);
    }
  }
  return segsByCol;
}
function splitInteractionByCol(ui, colCnt) {
  let byRow = [];
  if (!ui) {
    for (let i3 = 0; i3 < colCnt; i3 += 1) {
      byRow[i3] = null;
    }
  } else {
    for (let i3 = 0; i3 < colCnt; i3 += 1) {
      byRow[i3] = {
        affectedInstances: ui.affectedInstances,
        isEvent: ui.isEvent,
        segs: []
      };
    }
    for (let seg of ui.segs) {
      byRow[seg.col].segs.push(seg);
    }
  }
  return byRow;
}
var TimeColMoreLink = class extends BaseComponent {
  render() {
    let { props } = this;
    return y(MoreLinkContainer, { elClasses: ["fc-timegrid-more-link"], elStyle: {
      top: props.top,
      bottom: props.bottom
    }, allDayDate: null, moreCnt: props.hiddenSegs.length, allSegs: props.hiddenSegs, hiddenSegs: props.hiddenSegs, extraDateSpan: props.extraDateSpan, dateProfile: props.dateProfile, todayRange: props.todayRange, popoverContent: () => renderPlainFgSegs(props.hiddenSegs, props), defaultGenerator: renderMoreLinkInner2, forceTimed: true }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-timegrid-more-link-inner", "fc-sticky"] }));
  }
};
function renderMoreLinkInner2(props) {
  return props.shortText;
}
function buildPositioning(segInputs, strictOrder, maxStackCnt) {
  let hierarchy = new SegHierarchy();
  if (strictOrder != null) {
    hierarchy.strictOrder = strictOrder;
  }
  if (maxStackCnt != null) {
    hierarchy.maxStackCnt = maxStackCnt;
  }
  let hiddenEntries = hierarchy.addSegs(segInputs);
  let hiddenGroups = groupIntersectingEntries(hiddenEntries);
  let web = buildWeb(hierarchy);
  web = stretchWeb(web, 1);
  let segRects = webToRects(web);
  return { segRects, hiddenGroups };
}
function buildWeb(hierarchy) {
  const { entriesByLevel } = hierarchy;
  const buildNode = cacheable((level, lateral) => level + ":" + lateral, (level, lateral) => {
    let siblingRange = findNextLevelSegs(hierarchy, level, lateral);
    let nextLevelRes = buildNodes(siblingRange, buildNode);
    let entry = entriesByLevel[level][lateral];
    return [
      Object.assign(Object.assign({}, entry), { nextLevelNodes: nextLevelRes[0] }),
      entry.thickness + nextLevelRes[1]
      // the pressure builds
    ];
  });
  return buildNodes(entriesByLevel.length ? { level: 0, lateralStart: 0, lateralEnd: entriesByLevel[0].length } : null, buildNode)[0];
}
function buildNodes(siblingRange, buildNode) {
  if (!siblingRange) {
    return [[], 0];
  }
  let { level, lateralStart, lateralEnd } = siblingRange;
  let lateral = lateralStart;
  let pairs = [];
  while (lateral < lateralEnd) {
    pairs.push(buildNode(level, lateral));
    lateral += 1;
  }
  pairs.sort(cmpDescPressures);
  return [
    pairs.map(extractNode),
    pairs[0][1]
    // first item's pressure
  ];
}
function cmpDescPressures(a3, b3) {
  return b3[1] - a3[1];
}
function extractNode(a3) {
  return a3[0];
}
function findNextLevelSegs(hierarchy, subjectLevel, subjectLateral) {
  let { levelCoords, entriesByLevel } = hierarchy;
  let subjectEntry = entriesByLevel[subjectLevel][subjectLateral];
  let afterSubject = levelCoords[subjectLevel] + subjectEntry.thickness;
  let levelCnt = levelCoords.length;
  let level = subjectLevel;
  for (; level < levelCnt && levelCoords[level] < afterSubject; level += 1)
    ;
  for (; level < levelCnt; level += 1) {
    let entries = entriesByLevel[level];
    let entry;
    let searchIndex = binarySearch(entries, subjectEntry.span.start, getEntrySpanEnd);
    let lateralStart = searchIndex[0] + searchIndex[1];
    let lateralEnd = lateralStart;
    while (
      // loop through entries that horizontally intersect
      (entry = entries[lateralEnd]) && // but not past the whole seg list
      entry.span.start < subjectEntry.span.end
    ) {
      lateralEnd += 1;
    }
    if (lateralStart < lateralEnd) {
      return { level, lateralStart, lateralEnd };
    }
  }
  return null;
}
function stretchWeb(topLevelNodes, totalThickness) {
  const stretchNode = cacheable((node, startCoord, prevThickness) => buildEntryKey(node), (node, startCoord, prevThickness) => {
    let { nextLevelNodes, thickness } = node;
    let allThickness = thickness + prevThickness;
    let thicknessFraction = thickness / allThickness;
    let endCoord;
    let newChildren = [];
    if (!nextLevelNodes.length) {
      endCoord = totalThickness;
    } else {
      for (let childNode of nextLevelNodes) {
        if (endCoord === void 0) {
          let res = stretchNode(childNode, startCoord, allThickness);
          endCoord = res[0];
          newChildren.push(res[1]);
        } else {
          let res = stretchNode(childNode, endCoord, 0);
          newChildren.push(res[1]);
        }
      }
    }
    let newThickness = (endCoord - startCoord) * thicknessFraction;
    return [endCoord - newThickness, Object.assign(Object.assign({}, node), { thickness: newThickness, nextLevelNodes: newChildren })];
  });
  return topLevelNodes.map((node) => stretchNode(node, 0, 0)[1]);
}
function webToRects(topLevelNodes) {
  let rects = [];
  const processNode = cacheable((node, levelCoord, stackDepth) => buildEntryKey(node), (node, levelCoord, stackDepth) => {
    let rect = Object.assign(Object.assign({}, node), {
      levelCoord,
      stackDepth,
      stackForward: 0
    });
    rects.push(rect);
    return rect.stackForward = processNodes(node.nextLevelNodes, levelCoord + node.thickness, stackDepth + 1) + 1;
  });
  function processNodes(nodes, levelCoord, stackDepth) {
    let stackForward = 0;
    for (let node of nodes) {
      stackForward = Math.max(processNode(node, levelCoord, stackDepth), stackForward);
    }
    return stackForward;
  }
  processNodes(topLevelNodes, 0, 0);
  return rects;
}
function cacheable(keyFunc, workFunc) {
  const cache = {};
  return (...args) => {
    let key = keyFunc(...args);
    return key in cache ? cache[key] : cache[key] = workFunc(...args);
  };
}
function computeSegVCoords(segs, colDate, slatCoords = null, eventMinHeight = 0) {
  let vcoords = [];
  if (slatCoords) {
    for (let i3 = 0; i3 < segs.length; i3 += 1) {
      let seg = segs[i3];
      let spanStart = slatCoords.computeDateTop(seg.start, colDate);
      let spanEnd = Math.max(
        spanStart + (eventMinHeight || 0),
        // :(
        slatCoords.computeDateTop(seg.end, colDate)
      );
      vcoords.push({
        start: Math.round(spanStart),
        end: Math.round(spanEnd)
        //
      });
    }
  }
  return vcoords;
}
function computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack) {
  let segInputs = [];
  let dumbSegs = [];
  for (let i3 = 0; i3 < segs.length; i3 += 1) {
    let vcoords = segVCoords[i3];
    if (vcoords) {
      segInputs.push({
        index: i3,
        thickness: 1,
        span: vcoords
      });
    } else {
      dumbSegs.push(segs[i3]);
    }
  }
  let { segRects, hiddenGroups } = buildPositioning(segInputs, eventOrderStrict, eventMaxStack);
  let segPlacements = [];
  for (let segRect of segRects) {
    segPlacements.push({
      seg: segs[segRect.index],
      rect: segRect
    });
  }
  for (let dumbSeg of dumbSegs) {
    segPlacements.push({ seg: dumbSeg, rect: null });
  }
  return { segPlacements, hiddenGroups };
}
var DEFAULT_TIME_FORMAT = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  meridiem: false
});
var TimeColEvent = class extends BaseComponent {
  render() {
    return y(StandardEvent, Object.assign({}, this.props, { elClasses: [
      "fc-timegrid-event",
      "fc-v-event",
      this.props.isShort && "fc-timegrid-event-short"
    ], defaultTimeFormat: DEFAULT_TIME_FORMAT }));
  }
};
var TimeCol = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.sortEventSegs = memoize(sortEventSegs);
  }
  // TODO: memoize event-placement?
  render() {
    let { props, context } = this;
    let { options } = context;
    let isSelectMirror = options.selectMirror;
    let mirrorSegs = (
      // yuck
      props.eventDrag && props.eventDrag.segs || props.eventResize && props.eventResize.segs || isSelectMirror && props.dateSelectionSegs || []
    );
    let interactionAffectedInstances = (
      // TODO: messy way to compute this
      props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {}
    );
    let sortedFgSegs = this.sortEventSegs(props.fgEventSegs, options.eventOrder);
    return y(DayCellContainer, { elTag: "td", elRef: props.elRef, elClasses: [
      "fc-timegrid-col",
      ...props.extraClassNames || []
    ], elAttrs: Object.assign({ role: "gridcell" }, props.extraDataAttrs), date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraRenderProps: props.extraRenderProps }, (InnerContent) => y(
      "div",
      { className: "fc-timegrid-col-frame" },
      y(
        "div",
        { className: "fc-timegrid-col-bg" },
        this.renderFillSegs(props.businessHourSegs, "non-business"),
        this.renderFillSegs(props.bgEventSegs, "bg-event"),
        this.renderFillSegs(props.dateSelectionSegs, "highlight")
      ),
      y("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(sortedFgSegs, interactionAffectedInstances, false, false, false)),
      y("div", { className: "fc-timegrid-col-events" }, this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror), "mirror")),
      y("div", { className: "fc-timegrid-now-indicator-container" }, this.renderNowIndicator(props.nowIndicatorSegs)),
      hasCustomDayCellContent(options) && y(InnerContent, { elTag: "div", elClasses: ["fc-timegrid-col-misc"] })
    ));
  }
  renderFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
    let { props } = this;
    if (props.forPrint) {
      return renderPlainFgSegs(sortedFgSegs, props);
    }
    return this.renderPositionedFgSegs(sortedFgSegs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey);
  }
  renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting, forcedKey) {
    let { eventMaxStack, eventShortHeight, eventOrderStrict, eventMinHeight } = this.context.options;
    let { date, slatCoords, eventSelection, todayRange, nowDate } = this.props;
    let isMirror = isDragging || isResizing || isDateSelecting;
    let segVCoords = computeSegVCoords(segs, date, slatCoords, eventMinHeight);
    let { segPlacements, hiddenGroups } = computeFgSegPlacements(segs, segVCoords, eventOrderStrict, eventMaxStack);
    return y(
      _,
      null,
      this.renderHiddenGroups(hiddenGroups, segs),
      segPlacements.map((segPlacement) => {
        let { seg, rect } = segPlacement;
        let instanceId = seg.eventRange.instance.instanceId;
        let isVisible = isMirror || Boolean(!segIsInvisible[instanceId] && rect);
        let vStyle = computeSegVStyle(rect && rect.span);
        let hStyle = !isMirror && rect ? this.computeSegHStyle(rect) : { left: 0, right: 0 };
        let isInset = Boolean(rect) && rect.stackForward > 0;
        let isShort = Boolean(rect) && rect.span.end - rect.span.start < eventShortHeight;
        return y(
          "div",
          { className: "fc-timegrid-event-harness" + (isInset ? " fc-timegrid-event-harness-inset" : ""), key: forcedKey || instanceId, style: Object.assign(Object.assign({ visibility: isVisible ? "" : "hidden" }, vStyle), hStyle) },
          y(TimeColEvent, Object.assign({ seg, isDragging, isResizing, isDateSelecting, isSelected: instanceId === eventSelection, isShort }, getSegMeta(seg, todayRange, nowDate)))
        );
      })
    );
  }
  // will already have eventMinHeight applied because segInputs already had it
  renderHiddenGroups(hiddenGroups, segs) {
    let { extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize } = this.props;
    return y(_, null, hiddenGroups.map((hiddenGroup) => {
      let positionCss = computeSegVStyle(hiddenGroup.span);
      let hiddenSegs = compileSegsFromEntries(hiddenGroup.entries, segs);
      return y(TimeColMoreLink, { key: buildIsoString(computeEarliestSegStart(hiddenSegs)), hiddenSegs, top: positionCss.top, bottom: positionCss.bottom, extraDateSpan, dateProfile, todayRange, nowDate, eventSelection, eventDrag, eventResize });
    }));
  }
  renderFillSegs(segs, fillType) {
    let { props, context } = this;
    let segVCoords = computeSegVCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight);
    let children = segVCoords.map((vcoords, i3) => {
      let seg = segs[i3];
      return y("div", { key: buildEventRangeKey(seg.eventRange), className: "fc-timegrid-bg-harness", style: computeSegVStyle(vcoords) }, fillType === "bg-event" ? y(BgEvent, Object.assign({ seg }, getSegMeta(seg, props.todayRange, props.nowDate))) : renderFill(fillType));
    });
    return y(_, null, children);
  }
  renderNowIndicator(segs) {
    let { slatCoords, date } = this.props;
    if (!slatCoords) {
      return null;
    }
    return segs.map((seg, i3) => y(
      NowIndicatorContainer,
      {
        // key doesn't matter. will only ever be one
        key: i3,
        elClasses: ["fc-timegrid-now-indicator-line"],
        elStyle: {
          top: slatCoords.computeDateTop(seg.start, date)
        },
        isAxis: false,
        date
      }
    ));
  }
  computeSegHStyle(segHCoords) {
    let { isRtl, options } = this.context;
    let shouldOverlap = options.slotEventOverlap;
    let nearCoord = segHCoords.levelCoord;
    let farCoord = segHCoords.levelCoord + segHCoords.thickness;
    let left;
    let right;
    if (shouldOverlap) {
      farCoord = Math.min(1, nearCoord + (farCoord - nearCoord) * 2);
    }
    if (isRtl) {
      left = 1 - farCoord;
      right = nearCoord;
    } else {
      left = nearCoord;
      right = 1 - farCoord;
    }
    let props = {
      zIndex: segHCoords.stackDepth + 1,
      left: left * 100 + "%",
      right: right * 100 + "%"
    };
    if (shouldOverlap && !segHCoords.stackForward) {
      props[isRtl ? "marginLeft" : "marginRight"] = 10 * 2;
    }
    return props;
  }
};
function renderPlainFgSegs(sortedFgSegs, { todayRange, nowDate, eventSelection, eventDrag, eventResize }) {
  let hiddenInstances = (eventDrag ? eventDrag.affectedInstances : null) || (eventResize ? eventResize.affectedInstances : null) || {};
  return y(_, null, sortedFgSegs.map((seg) => {
    let instanceId = seg.eventRange.instance.instanceId;
    return y(
      "div",
      { key: instanceId, style: { visibility: hiddenInstances[instanceId] ? "hidden" : "" } },
      y(TimeColEvent, Object.assign({ seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === eventSelection, isShort: false }, getSegMeta(seg, todayRange, nowDate)))
    );
  }));
}
function computeSegVStyle(segVCoords) {
  if (!segVCoords) {
    return { top: "", bottom: "" };
  }
  return {
    top: segVCoords.start,
    bottom: -segVCoords.end
  };
}
function compileSegsFromEntries(segEntries, allSegs) {
  return segEntries.map((segEntry) => allSegs[segEntry.index]);
}
var TimeColsContent = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.splitFgEventSegs = memoize(splitSegsByCol);
    this.splitBgEventSegs = memoize(splitSegsByCol);
    this.splitBusinessHourSegs = memoize(splitSegsByCol);
    this.splitNowIndicatorSegs = memoize(splitSegsByCol);
    this.splitDateSelectionSegs = memoize(splitSegsByCol);
    this.splitEventDrag = memoize(splitInteractionByCol);
    this.splitEventResize = memoize(splitInteractionByCol);
    this.rootElRef = d();
    this.cellElRefs = new RefMap();
  }
  render() {
    let { props, context } = this;
    let nowIndicatorTop = context.options.nowIndicator && props.slatCoords && props.slatCoords.safeComputeTop(props.nowDate);
    let colCnt = props.cells.length;
    let fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);
    let bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);
    let businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);
    let nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);
    let dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);
    let eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);
    let eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);
    return y(
      "div",
      { className: "fc-timegrid-cols", ref: this.rootElRef },
      y(
        "table",
        { role: "presentation", style: {
          minWidth: props.tableMinWidth,
          width: props.clientWidth
        } },
        props.tableColGroupNode,
        y(
          "tbody",
          { role: "presentation" },
          y(
            "tr",
            { role: "row" },
            props.axis && y(
              "td",
              { "aria-hidden": true, className: "fc-timegrid-col fc-timegrid-axis" },
              y(
                "div",
                { className: "fc-timegrid-col-frame" },
                y("div", { className: "fc-timegrid-now-indicator-container" }, typeof nowIndicatorTop === "number" && y(NowIndicatorContainer, { elClasses: ["fc-timegrid-now-indicator-arrow"], elStyle: { top: nowIndicatorTop }, isAxis: true, date: props.nowDate }))
              )
            ),
            props.cells.map((cell, i3) => y(TimeCol, { key: cell.key, elRef: this.cellElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, nowDate: props.nowDate, todayRange: props.todayRange, extraRenderProps: cell.extraRenderProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, extraDateSpan: cell.extraDateSpan, fgEventSegs: fgEventSegsByRow[i3], bgEventSegs: bgEventSegsByRow[i3], businessHourSegs: businessHourSegsByRow[i3], nowIndicatorSegs: nowIndicatorSegsByRow[i3], dateSelectionSegs: dateSelectionSegsByRow[i3], eventDrag: eventDragByRow[i3], eventResize: eventResizeByRow[i3], slatCoords: props.slatCoords, eventSelection: props.eventSelection, forPrint: props.forPrint }))
          )
        )
      )
    );
  }
  componentDidMount() {
    this.updateCoords();
  }
  componentDidUpdate() {
    this.updateCoords();
  }
  updateCoords() {
    let { props } = this;
    if (props.onColCoords && props.clientWidth !== null) {
      props.onColCoords(new PositionCache(
        this.rootElRef.current,
        collectCellEls(this.cellElRefs.currentMap, props.cells),
        true,
        // horizontal
        false
      ));
    }
  }
};
function collectCellEls(elMap, cells) {
  return cells.map((cell) => elMap[cell.key]);
}
var TimeCols = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.processSlotOptions = memoize(processSlotOptions);
    this.state = {
      slatCoords: null
    };
    this.handleRootEl = (el) => {
      if (el) {
        this.context.registerInteractiveComponent(this, {
          el,
          isHitComboAllowed: this.props.isHitComboAllowed
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
    this.handleScrollRequest = (request) => {
      let { onScrollTopRequest } = this.props;
      let { slatCoords } = this.state;
      if (onScrollTopRequest && slatCoords) {
        if (request.time) {
          let top = slatCoords.computeTimeTop(request.time);
          top = Math.ceil(top);
          if (top) {
            top += 1;
          }
          onScrollTopRequest(top);
        }
        return true;
      }
      return false;
    };
    this.handleColCoords = (colCoords) => {
      this.colCoords = colCoords;
    };
    this.handleSlatCoords = (slatCoords) => {
      this.setState({ slatCoords });
      if (this.props.onSlatCoords) {
        this.props.onSlatCoords(slatCoords);
      }
    };
  }
  render() {
    let { props, state } = this;
    return y(
      "div",
      { className: "fc-timegrid-body", ref: this.handleRootEl, style: {
        // these props are important to give this wrapper correct dimensions for interactions
        // TODO: if we set it here, can we avoid giving to inner tables?
        width: props.clientWidth,
        minWidth: props.tableMinWidth
      } },
      y(TimeColsSlats, { axis: props.axis, dateProfile: props.dateProfile, slatMetas: props.slatMetas, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : "", tableMinWidth: props.tableMinWidth, tableColGroupNode: props.axis ? props.tableColGroupNode : null, onCoords: this.handleSlatCoords }),
      y(TimeColsContent, { cells: props.cells, axis: props.axis, dateProfile: props.dateProfile, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange, nowDate: props.nowDate, nowIndicatorSegs: props.nowIndicatorSegs, clientWidth: props.clientWidth, tableMinWidth: props.tableMinWidth, tableColGroupNode: props.tableColGroupNode, slatCoords: state.slatCoords, onColCoords: this.handleColCoords, forPrint: props.forPrint })
    );
  }
  componentDidMount() {
    this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);
  }
  componentDidUpdate(prevProps) {
    this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);
  }
  componentWillUnmount() {
    this.scrollResponder.detach();
  }
  queryHit(positionLeft, positionTop) {
    let { dateEnv, options } = this.context;
    let { colCoords } = this;
    let { dateProfile } = this.props;
    let { slatCoords } = this.state;
    let { snapDuration, snapsPerSlot } = this.processSlotOptions(this.props.slotDuration, options.snapDuration);
    let colIndex = colCoords.leftToIndex(positionLeft);
    let slatIndex = slatCoords.positions.topToIndex(positionTop);
    if (colIndex != null && slatIndex != null) {
      let cell = this.props.cells[colIndex];
      let slatTop = slatCoords.positions.tops[slatIndex];
      let slatHeight = slatCoords.positions.getHeight(slatIndex);
      let partial = (positionTop - slatTop) / slatHeight;
      let localSnapIndex = Math.floor(partial * snapsPerSlot);
      let snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
      let dayDate = this.props.cells[colIndex].date;
      let time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));
      let start = dateEnv.add(dayDate, time);
      let end = dateEnv.add(start, snapDuration);
      return {
        dateProfile,
        dateSpan: Object.assign({ range: { start, end }, allDay: false }, cell.extraDateSpan),
        dayEl: colCoords.els[colIndex],
        rect: {
          left: colCoords.lefts[colIndex],
          right: colCoords.rights[colIndex],
          top: slatTop,
          bottom: slatTop + slatHeight
        },
        layer: 0
      };
    }
    return null;
  }
};
function processSlotOptions(slotDuration, snapDurationOverride) {
  let snapDuration = snapDurationOverride || slotDuration;
  let snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);
  if (snapsPerSlot === null) {
    snapDuration = slotDuration;
    snapsPerSlot = 1;
  }
  return { snapDuration, snapsPerSlot };
}
var DayTimeColsSlicer = class extends Slicer {
  sliceRange(range2, dayRanges) {
    let segs = [];
    for (let col = 0; col < dayRanges.length; col += 1) {
      let segRange = intersectRanges(range2, dayRanges[col]);
      if (segRange) {
        segs.push({
          start: segRange.start,
          end: segRange.end,
          isStart: segRange.start.valueOf() === range2.start.valueOf(),
          isEnd: segRange.end.valueOf() === range2.end.valueOf(),
          col
        });
      }
    }
    return segs;
  }
};
var DayTimeCols = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.buildDayRanges = memoize(buildDayRanges);
    this.slicer = new DayTimeColsSlicer();
    this.timeColsRef = d();
  }
  render() {
    let { props, context } = this;
    let { dateProfile, dayTableModel } = props;
    let { nowIndicator, nextDayThreshold } = context.options;
    let dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);
    return y(NowTimer, { unit: nowIndicator ? "minute" : "day" }, (nowDate, todayRange) => y(TimeCols, Object.assign({ ref: this.timeColsRef }, this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), { forPrint: props.forPrint, axis: props.axis, dateProfile, slatMetas: props.slatMetas, slotDuration: props.slotDuration, cells: dayTableModel.cells[0], tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, clientWidth: props.clientWidth, clientHeight: props.clientHeight, expandRows: props.expandRows, nowDate, nowIndicatorSegs: nowIndicator && this.slicer.sliceNowDate(nowDate, dateProfile, nextDayThreshold, context, dayRanges), todayRange, onScrollTopRequest: props.onScrollTopRequest, onSlatCoords: props.onSlatCoords })));
  }
};
function buildDayRanges(dayTableModel, dateProfile, dateEnv) {
  let ranges = [];
  for (let date of dayTableModel.headerDates) {
    ranges.push({
      start: dateEnv.add(date, dateProfile.slotMinTime),
      end: dateEnv.add(date, dateProfile.slotMaxTime)
    });
  }
  return ranges;
}
var STOCK_SUB_DURATIONS = [
  { hours: 1 },
  { minutes: 30 },
  { minutes: 15 },
  { seconds: 30 },
  { seconds: 15 }
];
function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {
  let dayStart = new Date(0);
  let slatTime = slotMinTime;
  let slatIterator = createDuration(0);
  let labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);
  let metas = [];
  while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {
    let date = dateEnv.add(dayStart, slatTime);
    let isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;
    metas.push({
      date,
      time: slatTime,
      key: date.toISOString(),
      isoTimeStr: formatIsoTimeString(date),
      isLabeled
    });
    slatTime = addDurations(slatTime, slotDuration);
    slatIterator = addDurations(slatIterator, slotDuration);
  }
  return metas;
}
function computeLabelInterval(slotDuration) {
  let i3;
  let labelInterval;
  let slotsPerLabel;
  for (i3 = STOCK_SUB_DURATIONS.length - 1; i3 >= 0; i3 -= 1) {
    labelInterval = createDuration(STOCK_SUB_DURATIONS[i3]);
    slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);
    if (slotsPerLabel !== null && slotsPerLabel > 1) {
      return labelInterval;
    }
  }
  return slotDuration;
}
var DayTimeColsView = class extends TimeColsView {
  constructor() {
    super(...arguments);
    this.buildTimeColsModel = memoize(buildTimeColsModel);
    this.buildSlatMetas = memoize(buildSlatMetas);
  }
  render() {
    let { options, dateEnv, dateProfileGenerator } = this.context;
    let { props } = this;
    let { dateProfile } = props;
    let dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);
    let splitProps = this.allDaySplitter.splitProps(props);
    let slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);
    let { dayMinWidth } = options;
    let hasAttachedAxis = !dayMinWidth;
    let hasDetachedAxis = dayMinWidth;
    let headerContent = options.dayHeaders && y(DayHeader, { dates: dayTableModel.headerDates, dateProfile, datesRepDistinctDays: true, renderIntro: hasAttachedAxis ? this.renderHeadAxis : null });
    let allDayContent = options.allDaySlot !== false && ((contentArg) => y(DayTable, Object.assign({}, splitProps.allDay, { dateProfile, dayTableModel, nextDayThreshold: options.nextDayThreshold, tableMinWidth: contentArg.tableMinWidth, colGroupNode: contentArg.tableColGroupNode, renderRowIntro: hasAttachedAxis ? this.renderTableRowAxis : null, showWeekNumbers: false, expandRows: false, headerAlignElRef: this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }, this.getAllDayMaxEventProps())));
    let timeGridContent = (contentArg) => y(DayTimeCols, Object.assign({}, splitProps.timed, { dayTableModel, dateProfile, axis: hasAttachedAxis, slotDuration: options.slotDuration, slatMetas, forPrint: props.forPrint, tableColGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, onSlatCoords: this.handleSlatCoords, expandRows: contentArg.expandRows, onScrollTopRequest: this.handleScrollTopRequest }));
    return hasDetachedAxis ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords) : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);
  }
};
function buildTimeColsModel(dateProfile, dateProfileGenerator) {
  let daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);
  return new DayTableModel(daySeries, false);
}
var css_248z3 = '.fc-v-event{background-color:var(--fc-event-bg-color);border:1px solid var(--fc-event-border-color);display:block}.fc-v-event .fc-event-main{color:var(--fc-event-text-color);height:100%}.fc-v-event .fc-event-main-frame{display:flex;flex-direction:column;height:100%}.fc-v-event .fc-event-time{flex-grow:0;flex-shrink:0;max-height:100%;overflow:hidden}.fc-v-event .fc-event-title-container{flex-grow:1;flex-shrink:1;min-height:0}.fc-v-event .fc-event-title{bottom:0;max-height:100%;overflow:hidden;top:0}.fc-v-event:not(.fc-event-start){border-top-left-radius:0;border-top-right-radius:0;border-top-width:0}.fc-v-event:not(.fc-event-end){border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-width:0}.fc-v-event.fc-event-selected:before{left:-10px;right:-10px}.fc-v-event .fc-event-resizer-start{cursor:n-resize}.fc-v-event .fc-event-resizer-end{cursor:s-resize}.fc-v-event:not(.fc-event-selected) .fc-event-resizer{height:var(--fc-event-resizer-thickness);left:0;right:0}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-start{top:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event:not(.fc-event-selected) .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-thickness)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer{left:50%;margin-left:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-start{top:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc-v-event.fc-event-selected .fc-event-resizer-end{bottom:calc(var(--fc-event-resizer-dot-total-width)/-2)}.fc .fc-timegrid .fc-daygrid-body{z-index:2}.fc .fc-timegrid-divider{padding:0 0 2px}.fc .fc-timegrid-body{min-height:100%;position:relative;z-index:1}.fc .fc-timegrid-axis-chunk{position:relative}.fc .fc-timegrid-axis-chunk>table,.fc .fc-timegrid-slots{position:relative;z-index:1}.fc .fc-timegrid-slot{border-bottom:0;height:1.5em}.fc .fc-timegrid-slot:empty:before{content:"\\00a0"}.fc .fc-timegrid-slot-minor{border-top-style:dotted}.fc .fc-timegrid-slot-label-cushion{display:inline-block;white-space:nowrap}.fc .fc-timegrid-slot-label{vertical-align:middle}.fc .fc-timegrid-axis-cushion,.fc .fc-timegrid-slot-label-cushion{padding:0 4px}.fc .fc-timegrid-axis-frame-liquid{height:100%}.fc .fc-timegrid-axis-frame{align-items:center;display:flex;justify-content:flex-end;overflow:hidden}.fc .fc-timegrid-axis-cushion{flex-shrink:0;max-width:60px}.fc-direction-ltr .fc-timegrid-slot-label-frame{text-align:right}.fc-direction-rtl .fc-timegrid-slot-label-frame{text-align:left}.fc-liquid-hack .fc-timegrid-axis-frame-liquid{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col.fc-day-today{background-color:var(--fc-today-bg-color)}.fc .fc-timegrid-col-frame{min-height:100%;position:relative}.fc-media-screen.fc-liquid-hack .fc-timegrid-col-frame{bottom:0;height:auto;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols{bottom:0;left:0;position:absolute;right:0;top:0}.fc-media-screen .fc-timegrid-cols>table{height:100%}.fc-media-screen .fc-timegrid-col-bg,.fc-media-screen .fc-timegrid-col-events,.fc-media-screen .fc-timegrid-now-indicator-container{left:0;position:absolute;right:0;top:0}.fc .fc-timegrid-col-bg{z-index:2}.fc .fc-timegrid-col-bg .fc-non-business{z-index:1}.fc .fc-timegrid-col-bg .fc-bg-event{z-index:2}.fc .fc-timegrid-col-bg .fc-highlight{z-index:3}.fc .fc-timegrid-bg-harness{left:0;position:absolute;right:0}.fc .fc-timegrid-col-events{z-index:3}.fc .fc-timegrid-now-indicator-container{bottom:0;overflow:hidden}.fc-direction-ltr .fc-timegrid-col-events{margin:0 2.5% 0 2px}.fc-direction-rtl .fc-timegrid-col-events{margin:0 2px 0 2.5%}.fc-timegrid-event-harness{position:absolute}.fc-timegrid-event-harness>.fc-timegrid-event{bottom:0;left:0;position:absolute;right:0;top:0}.fc-timegrid-event-harness-inset .fc-timegrid-event,.fc-timegrid-event.fc-event-mirror,.fc-timegrid-more-link{box-shadow:0 0 0 1px var(--fc-page-bg-color)}.fc-timegrid-event,.fc-timegrid-more-link{border-radius:3px;font-size:var(--fc-small-font-size)}.fc-timegrid-event{margin-bottom:1px}.fc-timegrid-event .fc-event-main{padding:1px 1px 0}.fc-timegrid-event .fc-event-time{font-size:var(--fc-small-font-size);margin-bottom:1px;white-space:nowrap}.fc-timegrid-event-short .fc-event-main-frame{flex-direction:row;overflow:hidden}.fc-timegrid-event-short .fc-event-time:after{content:"\\00a0-\\00a0"}.fc-timegrid-event-short .fc-event-title{font-size:var(--fc-small-font-size)}.fc-timegrid-more-link{background:var(--fc-more-link-bg-color);color:var(--fc-more-link-text-color);cursor:pointer;margin-bottom:1px;position:absolute;z-index:9999}.fc-timegrid-more-link-inner{padding:3px 2px;top:0}.fc-direction-ltr .fc-timegrid-more-link{right:0}.fc-direction-rtl .fc-timegrid-more-link{left:0}.fc .fc-timegrid-now-indicator-arrow,.fc .fc-timegrid-now-indicator-line{pointer-events:none}.fc .fc-timegrid-now-indicator-line{border-color:var(--fc-now-indicator-color);border-style:solid;border-width:1px 0 0;left:0;position:absolute;right:0;z-index:4}.fc .fc-timegrid-now-indicator-arrow{border-color:var(--fc-now-indicator-color);border-style:solid;margin-top:-5px;position:absolute;z-index:4}.fc-direction-ltr .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 0 5px 6px;left:0}.fc-direction-rtl .fc-timegrid-now-indicator-arrow{border-bottom-color:transparent;border-top-color:transparent;border-width:5px 6px 5px 0;right:0}';
injectStyles(css_248z3);

// node_modules/@fullcalendar/timegrid/index.js
var OPTION_REFINERS = {
  allDaySlot: Boolean
};
var index2 = createPlugin({
  name: "@fullcalendar/timegrid",
  initialView: "timeGridWeek",
  optionRefiners: OPTION_REFINERS,
  views: {
    timeGrid: {
      component: DayTimeColsView,
      usesMinMaxTime: true,
      allDaySlot: true,
      slotDuration: "00:30:00",
      slotEventOverlap: true
      // a bad name. confused with overlap/constraint system
    },
    timeGridDay: {
      type: "timeGrid",
      duration: { days: 1 }
    },
    timeGridWeek: {
      type: "timeGrid",
      duration: { weeks: 1 }
    }
  }
});

// node_modules/rrule/dist/esm/weekday.js
var ALL_WEEKDAYS = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
];
var Weekday = (
  /** @class */
  function() {
    function Weekday2(weekday, n2) {
      if (n2 === 0)
        throw new Error("Can't create weekday with n == 0");
      this.weekday = weekday;
      this.n = n2;
    }
    Weekday2.fromStr = function(str) {
      return new Weekday2(ALL_WEEKDAYS.indexOf(str));
    };
    Weekday2.prototype.nth = function(n2) {
      return this.n === n2 ? this : new Weekday2(this.weekday, n2);
    };
    Weekday2.prototype.equals = function(other) {
      return this.weekday === other.weekday && this.n === other.n;
    };
    Weekday2.prototype.toString = function() {
      var s3 = ALL_WEEKDAYS[this.weekday];
      if (this.n)
        s3 = (this.n > 0 ? "+" : "") + String(this.n) + s3;
      return s3;
    };
    Weekday2.prototype.getJsWeekday = function() {
      return this.weekday === 6 ? 0 : this.weekday + 1;
    };
    return Weekday2;
  }()
);

// node_modules/rrule/dist/esm/helpers.js
var isPresent = function(value) {
  return value !== null && value !== void 0;
};
var isNumber = function(value) {
  return typeof value === "number";
};
var isWeekdayStr = function(value) {
  return typeof value === "string" && ALL_WEEKDAYS.includes(value);
};
var isArray = Array.isArray;
var range = function(start, end) {
  if (end === void 0) {
    end = start;
  }
  if (arguments.length === 1) {
    end = start;
    start = 0;
  }
  var rang = [];
  for (var i3 = start; i3 < end; i3++)
    rang.push(i3);
  return rang;
};
var repeat = function(value, times) {
  var i3 = 0;
  var array = [];
  if (isArray(value)) {
    for (; i3 < times; i3++)
      array[i3] = [].concat(value);
  } else {
    for (; i3 < times; i3++)
      array[i3] = value;
  }
  return array;
};
var toArray = function(item) {
  if (isArray(item)) {
    return item;
  }
  return [item];
};
function padStart2(item, targetLength, padString) {
  if (padString === void 0) {
    padString = " ";
  }
  var str = String(item);
  targetLength = targetLength >> 0;
  if (str.length > targetLength) {
    return String(str);
  }
  targetLength = targetLength - str.length;
  if (targetLength > padString.length) {
    padString += repeat(padString, targetLength / padString.length);
  }
  return padString.slice(0, targetLength) + String(str);
}
var split = function(str, sep, num) {
  var splits = str.split(sep);
  return num ? splits.slice(0, num).concat([splits.slice(num).join(sep)]) : splits;
};
var pymod = function(a3, b3) {
  var r3 = a3 % b3;
  return r3 * b3 < 0 ? r3 + b3 : r3;
};
var divmod = function(a3, b3) {
  return { div: Math.floor(a3 / b3), mod: pymod(a3, b3) };
};
var empty = function(obj) {
  return !isPresent(obj) || obj.length === 0;
};
var notEmpty = function(obj) {
  return !empty(obj);
};
var includes = function(arr, val) {
  return notEmpty(arr) && arr.indexOf(val) !== -1;
};

// node_modules/rrule/dist/esm/dateutil.js
var datetime = function(y3, m3, d2, h3, i3, s3) {
  if (h3 === void 0) {
    h3 = 0;
  }
  if (i3 === void 0) {
    i3 = 0;
  }
  if (s3 === void 0) {
    s3 = 0;
  }
  return new Date(Date.UTC(y3, m3 - 1, d2, h3, i3, s3));
};
var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var ONE_DAY = 1e3 * 60 * 60 * 24;
var MAXYEAR = 9999;
var ORDINAL_BASE = datetime(1970, 1, 1);
var PY_WEEKDAYS = [6, 0, 1, 2, 3, 4, 5];
var isLeapYear = function(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
};
var isDate = function(value) {
  return value instanceof Date;
};
var isValidDate2 = function(value) {
  return isDate(value) && !isNaN(value.getTime());
};
var daysBetween = function(date1, date2) {
  var date1ms = date1.getTime();
  var date2ms = date2.getTime();
  var differencems = date1ms - date2ms;
  return Math.round(differencems / ONE_DAY);
};
var toOrdinal = function(date) {
  return daysBetween(date, ORDINAL_BASE);
};
var fromOrdinal = function(ordinal) {
  return new Date(ORDINAL_BASE.getTime() + ordinal * ONE_DAY);
};
var getMonthDays = function(date) {
  var month = date.getUTCMonth();
  return month === 1 && isLeapYear(date.getUTCFullYear()) ? 29 : MONTH_DAYS[month];
};
var getWeekday = function(date) {
  return PY_WEEKDAYS[date.getUTCDay()];
};
var monthRange = function(year, month) {
  var date = datetime(year, month + 1, 1);
  return [getWeekday(date), getMonthDays(date)];
};
var combine = function(date, time) {
  time = time || date;
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds()));
};
var clone = function(date) {
  var dolly = new Date(date.getTime());
  return dolly;
};
var cloneDates = function(dates) {
  var clones = [];
  for (var i3 = 0; i3 < dates.length; i3++) {
    clones.push(clone(dates[i3]));
  }
  return clones;
};
var sort = function(dates) {
  dates.sort(function(a3, b3) {
    return a3.getTime() - b3.getTime();
  });
};
var timeToUntilString = function(time, utc) {
  if (utc === void 0) {
    utc = true;
  }
  var date = new Date(time);
  return [
    padStart2(date.getUTCFullYear().toString(), 4, "0"),
    padStart2(date.getUTCMonth() + 1, 2, "0"),
    padStart2(date.getUTCDate(), 2, "0"),
    "T",
    padStart2(date.getUTCHours(), 2, "0"),
    padStart2(date.getUTCMinutes(), 2, "0"),
    padStart2(date.getUTCSeconds(), 2, "0"),
    utc ? "Z" : ""
  ].join("");
};
var untilStringToDate = function(until) {
  var re = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/;
  var bits = re.exec(until);
  if (!bits)
    throw new Error("Invalid UNTIL value: ".concat(until));
  return new Date(Date.UTC(parseInt(bits[1], 10), parseInt(bits[2], 10) - 1, parseInt(bits[3], 10), parseInt(bits[5], 10) || 0, parseInt(bits[6], 10) || 0, parseInt(bits[7], 10) || 0));
};
var dateTZtoISO8601 = function(date, timeZone) {
  var dateStr = date.toLocaleString("sv-SE", { timeZone });
  return dateStr.replace(" ", "T") + "Z";
};
var dateInTimeZone = function(date, timeZone) {
  var localTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  var dateInLocalTZ = new Date(dateTZtoISO8601(date, localTimeZone));
  var dateInTargetTZ = new Date(dateTZtoISO8601(date, timeZone !== null && timeZone !== void 0 ? timeZone : "UTC"));
  var tzOffset = dateInTargetTZ.getTime() - dateInLocalTZ.getTime();
  return new Date(date.getTime() - tzOffset);
};

// node_modules/rrule/dist/esm/iterresult.js
var IterResult = (
  /** @class */
  function() {
    function IterResult2(method, args) {
      this.minDate = null;
      this.maxDate = null;
      this._result = [];
      this.total = 0;
      this.method = method;
      this.args = args;
      if (method === "between") {
        this.maxDate = args.inc ? args.before : new Date(args.before.getTime() - 1);
        this.minDate = args.inc ? args.after : new Date(args.after.getTime() + 1);
      } else if (method === "before") {
        this.maxDate = args.inc ? args.dt : new Date(args.dt.getTime() - 1);
      } else if (method === "after") {
        this.minDate = args.inc ? args.dt : new Date(args.dt.getTime() + 1);
      }
    }
    IterResult2.prototype.accept = function(date) {
      ++this.total;
      var tooEarly = this.minDate && date < this.minDate;
      var tooLate = this.maxDate && date > this.maxDate;
      if (this.method === "between") {
        if (tooEarly)
          return true;
        if (tooLate)
          return false;
      } else if (this.method === "before") {
        if (tooLate)
          return false;
      } else if (this.method === "after") {
        if (tooEarly)
          return true;
        this.add(date);
        return false;
      }
      return this.add(date);
    };
    IterResult2.prototype.add = function(date) {
      this._result.push(date);
      return true;
    };
    IterResult2.prototype.getValue = function() {
      var res = this._result;
      switch (this.method) {
        case "all":
        case "between":
          return res;
        case "before":
        case "after":
        default:
          return res.length ? res[res.length - 1] : null;
      }
    };
    IterResult2.prototype.clone = function() {
      return new IterResult2(this.method, this.args);
    };
    return IterResult2;
  }()
);
var iterresult_default = IterResult;

// node_modules/tslib/tslib.es6.js
var extendStatics = function(d2, b3) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
    d3.__proto__ = b4;
  } || function(d3, b4) {
    for (var p3 in b4)
      if (Object.prototype.hasOwnProperty.call(b4, p3))
        d3[p3] = b4[p3];
  };
  return extendStatics(d2, b3);
};
function __extends(d2, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s3, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
      s3 = arguments[i3];
      for (var p3 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p3))
          t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
      if (ar || !(i3 in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i3);
        ar[i3] = from[i3];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}

// node_modules/rrule/dist/esm/callbackiterresult.js
var CallbackIterResult = (
  /** @class */
  function(_super) {
    __extends(CallbackIterResult2, _super);
    function CallbackIterResult2(method, args, iterator) {
      var _this = _super.call(this, method, args) || this;
      _this.iterator = iterator;
      return _this;
    }
    CallbackIterResult2.prototype.add = function(date) {
      if (this.iterator(date, this._result.length)) {
        this._result.push(date);
        return true;
      }
      return false;
    };
    return CallbackIterResult2;
  }(iterresult_default)
);
var callbackiterresult_default = CallbackIterResult;

// node_modules/rrule/dist/esm/nlp/i18n.js
var ENGLISH = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
};
var i18n_default = ENGLISH;

// node_modules/rrule/dist/esm/nlp/totext.js
var contains = function(arr, val) {
  return arr.indexOf(val) !== -1;
};
var defaultGetText = function(id) {
  return id.toString();
};
var defaultDateFormatter = function(year, month, day) {
  return "".concat(month, " ").concat(day, ", ").concat(year);
};
var ToText = (
  /** @class */
  function() {
    function ToText2(rrule, gettext, language, dateFormatter) {
      if (gettext === void 0) {
        gettext = defaultGetText;
      }
      if (language === void 0) {
        language = i18n_default;
      }
      if (dateFormatter === void 0) {
        dateFormatter = defaultDateFormatter;
      }
      this.text = [];
      this.language = language || i18n_default;
      this.gettext = gettext;
      this.dateFormatter = dateFormatter;
      this.rrule = rrule;
      this.options = rrule.options;
      this.origOptions = rrule.origOptions;
      if (this.origOptions.bymonthday) {
        var bymonthday = [].concat(this.options.bymonthday);
        var bynmonthday = [].concat(this.options.bynmonthday);
        bymonthday.sort(function(a3, b3) {
          return a3 - b3;
        });
        bynmonthday.sort(function(a3, b3) {
          return b3 - a3;
        });
        this.bymonthday = bymonthday.concat(bynmonthday);
        if (!this.bymonthday.length)
          this.bymonthday = null;
      }
      if (isPresent(this.origOptions.byweekday)) {
        var byweekday = !isArray(this.origOptions.byweekday) ? [this.origOptions.byweekday] : this.origOptions.byweekday;
        var days = String(byweekday);
        this.byweekday = {
          allWeeks: byweekday.filter(function(weekday) {
            return !weekday.n;
          }),
          someWeeks: byweekday.filter(function(weekday) {
            return Boolean(weekday.n);
          }),
          isWeekdays: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") === -1 && days.indexOf("SU") === -1,
          isEveryDay: days.indexOf("MO") !== -1 && days.indexOf("TU") !== -1 && days.indexOf("WE") !== -1 && days.indexOf("TH") !== -1 && days.indexOf("FR") !== -1 && days.indexOf("SA") !== -1 && days.indexOf("SU") !== -1
        };
        var sortWeekDays = function(a3, b3) {
          return a3.weekday - b3.weekday;
        };
        this.byweekday.allWeeks.sort(sortWeekDays);
        this.byweekday.someWeeks.sort(sortWeekDays);
        if (!this.byweekday.allWeeks.length)
          this.byweekday.allWeeks = null;
        if (!this.byweekday.someWeeks.length)
          this.byweekday.someWeeks = null;
      } else {
        this.byweekday = null;
      }
    }
    ToText2.isFullyConvertible = function(rrule) {
      var canConvert = true;
      if (!(rrule.options.freq in ToText2.IMPLEMENTED))
        return false;
      if (rrule.origOptions.until && rrule.origOptions.count)
        return false;
      for (var key in rrule.origOptions) {
        if (contains(["dtstart", "tzid", "wkst", "freq"], key))
          return true;
        if (!contains(ToText2.IMPLEMENTED[rrule.options.freq], key))
          return false;
      }
      return canConvert;
    };
    ToText2.prototype.isFullyConvertible = function() {
      return ToText2.isFullyConvertible(this.rrule);
    };
    ToText2.prototype.toString = function() {
      var gettext = this.gettext;
      if (!(this.options.freq in ToText2.IMPLEMENTED)) {
        return gettext("RRule error: Unable to fully convert this rrule to text");
      }
      this.text = [gettext("every")];
      this[RRule.FREQUENCIES[this.options.freq]]();
      if (this.options.until) {
        this.add(gettext("until"));
        var until = this.options.until;
        this.add(this.dateFormatter(until.getUTCFullYear(), this.language.monthNames[until.getUTCMonth()], until.getUTCDate()));
      } else if (this.options.count) {
        this.add(gettext("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? gettext("times") : gettext("time"));
      }
      if (!this.isFullyConvertible())
        this.add(gettext("(~ approximate)"));
      return this.text.join("");
    };
    ToText2.prototype.HOURLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("hours") : gettext("hour"));
    };
    ToText2.prototype.MINUTELY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      this.add(this.plural(this.options.interval) ? gettext("minutes") : gettext("minute"));
    };
    ToText2.prototype.DAILY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1)
        this.add(this.options.interval.toString());
      if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
      } else {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      }
      if (this.origOptions.bymonth) {
        this.add(gettext("in"));
        this._bymonth();
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      } else if (this.origOptions.byhour) {
        this._byhour();
      }
    };
    ToText2.prototype.WEEKLY = function() {
      var gettext = this.gettext;
      if (this.options.interval !== 1) {
        this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? gettext("weeks") : gettext("week"));
      }
      if (this.byweekday && this.byweekday.isWeekdays) {
        if (this.options.interval === 1) {
          this.add(this.plural(this.options.interval) ? gettext("weekdays") : gettext("weekday"));
        } else {
          this.add(gettext("on")).add(gettext("weekdays"));
        }
      } else if (this.byweekday && this.byweekday.isEveryDay) {
        this.add(this.plural(this.options.interval) ? gettext("days") : gettext("day"));
      } else {
        if (this.options.interval === 1)
          this.add(gettext("week"));
        if (this.origOptions.bymonth) {
          this.add(gettext("in"));
          this._bymonth();
        }
        if (this.bymonthday) {
          this._bymonthday();
        } else if (this.byweekday) {
          this._byweekday();
        }
        if (this.origOptions.byhour) {
          this._byhour();
        }
      }
    };
    ToText2.prototype.MONTHLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString()).add(gettext("months"));
          if (this.plural(this.options.interval))
            this.add(gettext("in"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("months") : gettext("month"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday && this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(gettext("weekdays"));
      } else if (this.byweekday) {
        this._byweekday();
      }
    };
    ToText2.prototype.YEARLY = function() {
      var gettext = this.gettext;
      if (this.origOptions.bymonth) {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
          this.add(gettext("years"));
        } else {
        }
        this._bymonth();
      } else {
        if (this.options.interval !== 1) {
          this.add(this.options.interval.toString());
        }
        this.add(this.plural(this.options.interval) ? gettext("years") : gettext("year"));
      }
      if (this.bymonthday) {
        this._bymonthday();
      } else if (this.byweekday) {
        this._byweekday();
      }
      if (this.options.byyearday) {
        this.add(gettext("on the")).add(this.list(this.options.byyearday, this.nth, gettext("and"))).add(gettext("day"));
      }
      if (this.options.byweekno) {
        this.add(gettext("in")).add(this.plural(this.options.byweekno.length) ? gettext("weeks") : gettext("week")).add(this.list(this.options.byweekno, void 0, gettext("and")));
      }
    };
    ToText2.prototype._bymonthday = function() {
      var gettext = this.gettext;
      if (this.byweekday && this.byweekday.allWeeks) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, gettext("or"))).add(gettext("the")).add(this.list(this.bymonthday, this.nth, gettext("or")));
      } else {
        this.add(gettext("on the")).add(this.list(this.bymonthday, this.nth, gettext("and")));
      }
    };
    ToText2.prototype._byweekday = function() {
      var gettext = this.gettext;
      if (this.byweekday.allWeeks && !this.byweekday.isWeekdays) {
        this.add(gettext("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext));
      }
      if (this.byweekday.someWeeks) {
        if (this.byweekday.allWeeks)
          this.add(gettext("and"));
        this.add(gettext("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, gettext("and")));
      }
    };
    ToText2.prototype._byhour = function() {
      var gettext = this.gettext;
      this.add(gettext("at")).add(this.list(this.origOptions.byhour, void 0, gettext("and")));
    };
    ToText2.prototype._bymonth = function() {
      this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
    };
    ToText2.prototype.nth = function(n2) {
      n2 = parseInt(n2.toString(), 10);
      var nth;
      var gettext = this.gettext;
      if (n2 === -1)
        return gettext("last");
      var npos = Math.abs(n2);
      switch (npos) {
        case 1:
        case 21:
        case 31:
          nth = npos + gettext("st");
          break;
        case 2:
        case 22:
          nth = npos + gettext("nd");
          break;
        case 3:
        case 23:
          nth = npos + gettext("rd");
          break;
        default:
          nth = npos + gettext("th");
      }
      return n2 < 0 ? nth + " " + gettext("last") : nth;
    };
    ToText2.prototype.monthtext = function(m3) {
      return this.language.monthNames[m3 - 1];
    };
    ToText2.prototype.weekdaytext = function(wday) {
      var weekday = isNumber(wday) ? (wday + 1) % 7 : wday.getJsWeekday();
      return (wday.n ? this.nth(wday.n) + " " : "") + this.language.dayNames[weekday];
    };
    ToText2.prototype.plural = function(n2) {
      return n2 % 100 !== 1;
    };
    ToText2.prototype.add = function(s3) {
      this.text.push(" ");
      this.text.push(s3);
      return this;
    };
    ToText2.prototype.list = function(arr, callback, finalDelim, delim) {
      var _this = this;
      if (delim === void 0) {
        delim = ",";
      }
      if (!isArray(arr)) {
        arr = [arr];
      }
      var delimJoin = function(array, delimiter, finalDelimiter) {
        var list = "";
        for (var i3 = 0; i3 < array.length; i3++) {
          if (i3 !== 0) {
            if (i3 === array.length - 1) {
              list += " " + finalDelimiter + " ";
            } else {
              list += delimiter + " ";
            }
          }
          list += array[i3];
        }
        return list;
      };
      callback = callback || function(o2) {
        return o2.toString();
      };
      var realCallback = function(arg) {
        return callback && callback.call(_this, arg);
      };
      if (finalDelim) {
        return delimJoin(arr.map(realCallback), delim, finalDelim);
      } else {
        return arr.map(realCallback).join(delim + " ");
      }
    };
    return ToText2;
  }()
);
var totext_default = ToText;

// node_modules/rrule/dist/esm/nlp/parsetext.js
var Parser = (
  /** @class */
  function() {
    function Parser2(rules) {
      this.done = true;
      this.rules = rules;
    }
    Parser2.prototype.start = function(text) {
      this.text = text;
      this.done = false;
      return this.nextSymbol();
    };
    Parser2.prototype.isDone = function() {
      return this.done && this.symbol === null;
    };
    Parser2.prototype.nextSymbol = function() {
      var best;
      var bestSymbol;
      this.symbol = null;
      this.value = null;
      do {
        if (this.done)
          return false;
        var rule = void 0;
        best = null;
        for (var name_1 in this.rules) {
          rule = this.rules[name_1];
          var match = rule.exec(this.text);
          if (match) {
            if (best === null || match[0].length > best[0].length) {
              best = match;
              bestSymbol = name_1;
            }
          }
        }
        if (best != null) {
          this.text = this.text.substr(best[0].length);
          if (this.text === "")
            this.done = true;
        }
        if (best == null) {
          this.done = true;
          this.symbol = null;
          this.value = null;
          return;
        }
      } while (bestSymbol === "SKIP");
      this.symbol = bestSymbol;
      this.value = best;
      return true;
    };
    Parser2.prototype.accept = function(name) {
      if (this.symbol === name) {
        if (this.value) {
          var v3 = this.value;
          this.nextSymbol();
          return v3;
        }
        this.nextSymbol();
        return true;
      }
      return false;
    };
    Parser2.prototype.acceptNumber = function() {
      return this.accept("number");
    };
    Parser2.prototype.expect = function(name) {
      if (this.accept(name))
        return true;
      throw new Error("expected " + name + " but found " + this.symbol);
    };
    return Parser2;
  }()
);
function parseText(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  var options = {};
  var ttr = new Parser(language.tokens);
  if (!ttr.start(text))
    return null;
  S2();
  return options;
  function S2() {
    ttr.expect("every");
    var n2 = ttr.acceptNumber();
    if (n2)
      options.interval = parseInt(n2[0], 10);
    if (ttr.isDone())
      throw new Error("Unexpected end");
    switch (ttr.symbol) {
      case "day(s)":
        options.freq = RRule.DAILY;
        if (ttr.nextSymbol()) {
          AT();
          F4();
        }
        break;
      case "weekday(s)":
        options.freq = RRule.WEEKLY;
        options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        ttr.nextSymbol();
        AT();
        F4();
        break;
      case "week(s)":
        options.freq = RRule.WEEKLY;
        if (ttr.nextSymbol()) {
          ON();
          AT();
          F4();
        }
        break;
      case "hour(s)":
        options.freq = RRule.HOURLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "minute(s)":
        options.freq = RRule.MINUTELY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "month(s)":
        options.freq = RRule.MONTHLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "year(s)":
        options.freq = RRule.YEARLY;
        if (ttr.nextSymbol()) {
          ON();
          F4();
        }
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        options.freq = RRule.WEEKLY;
        var key = ttr.symbol.substr(0, 2).toUpperCase();
        options.byweekday = [RRule[key]];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var wkd = decodeWKD();
          if (!wkd) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected weekday");
          }
          options.byweekday.push(RRule[wkd]);
          ttr.nextSymbol();
        }
        AT();
        MDAYs();
        F4();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        options.freq = RRule.YEARLY;
        options.bymonth = [decodeM()];
        if (!ttr.nextSymbol())
          return;
        while (ttr.accept("comma")) {
          if (ttr.isDone())
            throw new Error("Unexpected end");
          var m3 = decodeM();
          if (!m3) {
            throw new Error("Unexpected symbol " + ttr.symbol + ", expected month");
          }
          options.bymonth.push(m3);
          ttr.nextSymbol();
        }
        ON();
        F4();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function ON() {
    var on = ttr.accept("on");
    var the = ttr.accept("the");
    if (!(on || the))
      return;
    do {
      var nth = decodeNTH();
      var wkd = decodeWKD();
      var m3 = decodeM();
      if (nth) {
        if (wkd) {
          ttr.nextSymbol();
          if (!options.byweekday)
            options.byweekday = [];
          options.byweekday.push(RRule[wkd].nth(nth));
        } else {
          if (!options.bymonthday)
            options.bymonthday = [];
          options.bymonthday.push(nth);
          ttr.accept("day(s)");
        }
      } else if (wkd) {
        ttr.nextSymbol();
        if (!options.byweekday)
          options.byweekday = [];
        options.byweekday.push(RRule[wkd]);
      } else if (ttr.symbol === "weekday(s)") {
        ttr.nextSymbol();
        if (!options.byweekday) {
          options.byweekday = [RRule.MO, RRule.TU, RRule.WE, RRule.TH, RRule.FR];
        }
      } else if (ttr.symbol === "week(s)") {
        ttr.nextSymbol();
        var n2 = ttr.acceptNumber();
        if (!n2) {
          throw new Error("Unexpected symbol " + ttr.symbol + ", expected week number");
        }
        options.byweekno = [parseInt(n2[0], 10)];
        while (ttr.accept("comma")) {
          n2 = ttr.acceptNumber();
          if (!n2) {
            throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
          }
          options.byweekno.push(parseInt(n2[0], 10));
        }
      } else if (m3) {
        ttr.nextSymbol();
        if (!options.bymonth)
          options.bymonth = [];
        options.bymonth.push(m3);
      } else {
        return;
      }
    } while (ttr.accept("comma") || ttr.accept("the") || ttr.accept("on"));
  }
  function AT() {
    var at = ttr.accept("at");
    if (!at)
      return;
    do {
      var n2 = ttr.acceptNumber();
      if (!n2) {
        throw new Error("Unexpected symbol " + ttr.symbol + ", expected hour");
      }
      options.byhour = [parseInt(n2[0], 10)];
      while (ttr.accept("comma")) {
        n2 = ttr.acceptNumber();
        if (!n2) {
          throw new Error("Unexpected symbol " + ttr.symbol + "; expected hour");
        }
        options.byhour.push(parseInt(n2[0], 10));
      }
    } while (ttr.accept("comma") || ttr.accept("at"));
  }
  function decodeM() {
    switch (ttr.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return false;
    }
  }
  function decodeWKD() {
    switch (ttr.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return ttr.symbol.substr(0, 2).toUpperCase();
      default:
        return false;
    }
  }
  function decodeNTH() {
    switch (ttr.symbol) {
      case "last":
        ttr.nextSymbol();
        return -1;
      case "first":
        ttr.nextSymbol();
        return 1;
      case "second":
        ttr.nextSymbol();
        return ttr.accept("last") ? -2 : 2;
      case "third":
        ttr.nextSymbol();
        return ttr.accept("last") ? -3 : 3;
      case "nth":
        var v3 = parseInt(ttr.value[1], 10);
        if (v3 < -366 || v3 > 366)
          throw new Error("Nth out of range: " + v3);
        ttr.nextSymbol();
        return ttr.accept("last") ? -v3 : v3;
      default:
        return false;
    }
  }
  function MDAYs() {
    ttr.accept("on");
    ttr.accept("the");
    var nth = decodeNTH();
    if (!nth)
      return;
    options.bymonthday = [nth];
    ttr.nextSymbol();
    while (ttr.accept("comma")) {
      nth = decodeNTH();
      if (!nth) {
        throw new Error("Unexpected symbol " + ttr.symbol + "; expected monthday");
      }
      options.bymonthday.push(nth);
      ttr.nextSymbol();
    }
  }
  function F4() {
    if (ttr.symbol === "until") {
      var date = Date.parse(ttr.text);
      if (!date)
        throw new Error("Cannot parse until date:" + ttr.text);
      options.until = new Date(date);
    } else if (ttr.accept("for")) {
      options.count = parseInt(ttr.value[0], 10);
      ttr.expect("number");
    }
  }
}

// node_modules/rrule/dist/esm/types.js
var Frequency;
(function(Frequency2) {
  Frequency2[Frequency2["YEARLY"] = 0] = "YEARLY";
  Frequency2[Frequency2["MONTHLY"] = 1] = "MONTHLY";
  Frequency2[Frequency2["WEEKLY"] = 2] = "WEEKLY";
  Frequency2[Frequency2["DAILY"] = 3] = "DAILY";
  Frequency2[Frequency2["HOURLY"] = 4] = "HOURLY";
  Frequency2[Frequency2["MINUTELY"] = 5] = "MINUTELY";
  Frequency2[Frequency2["SECONDLY"] = 6] = "SECONDLY";
})(Frequency || (Frequency = {}));
function freqIsDailyOrGreater(freq) {
  return freq < Frequency.HOURLY;
}

// node_modules/rrule/dist/esm/nlp/index.js
var fromText = function(text, language) {
  if (language === void 0) {
    language = i18n_default;
  }
  return new RRule(parseText(text, language) || void 0);
};
var common = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
totext_default.IMPLEMENTED = [];
totext_default.IMPLEMENTED[Frequency.HOURLY] = common;
totext_default.IMPLEMENTED[Frequency.MINUTELY] = common;
totext_default.IMPLEMENTED[Frequency.DAILY] = ["byhour"].concat(common);
totext_default.IMPLEMENTED[Frequency.WEEKLY] = common;
totext_default.IMPLEMENTED[Frequency.MONTHLY] = common;
totext_default.IMPLEMENTED[Frequency.YEARLY] = ["byweekno", "byyearday"].concat(common);
var toText = function(rrule, gettext, language, dateFormatter) {
  return new totext_default(rrule, gettext, language, dateFormatter).toString();
};
var isFullyConvertible = totext_default.isFullyConvertible;

// node_modules/rrule/dist/esm/datetime.js
var Time = (
  /** @class */
  function() {
    function Time2(hour, minute, second, millisecond) {
      this.hour = hour;
      this.minute = minute;
      this.second = second;
      this.millisecond = millisecond || 0;
    }
    Time2.prototype.getHours = function() {
      return this.hour;
    };
    Time2.prototype.getMinutes = function() {
      return this.minute;
    };
    Time2.prototype.getSeconds = function() {
      return this.second;
    };
    Time2.prototype.getMilliseconds = function() {
      return this.millisecond;
    };
    Time2.prototype.getTime = function() {
      return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
    };
    return Time2;
  }()
);
var DateTime = (
  /** @class */
  function(_super) {
    __extends(DateTime2, _super);
    function DateTime2(year, month, day, hour, minute, second, millisecond) {
      var _this = _super.call(this, hour, minute, second, millisecond) || this;
      _this.year = year;
      _this.month = month;
      _this.day = day;
      return _this;
    }
    DateTime2.fromDate = function(date) {
      return new this(date.getUTCFullYear(), date.getUTCMonth() + 1, date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.valueOf() % 1e3);
    };
    DateTime2.prototype.getWeekday = function() {
      return getWeekday(new Date(this.getTime()));
    };
    DateTime2.prototype.getTime = function() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
    };
    DateTime2.prototype.getDay = function() {
      return this.day;
    };
    DateTime2.prototype.getMonth = function() {
      return this.month;
    };
    DateTime2.prototype.getYear = function() {
      return this.year;
    };
    DateTime2.prototype.addYears = function(years) {
      this.year += years;
    };
    DateTime2.prototype.addMonths = function(months) {
      this.month += months;
      if (this.month > 12) {
        var yearDiv = Math.floor(this.month / 12);
        var monthMod = pymod(this.month, 12);
        this.month = monthMod;
        this.year += yearDiv;
        if (this.month === 0) {
          this.month = 12;
          --this.year;
        }
      }
    };
    DateTime2.prototype.addWeekly = function(days, wkst) {
      if (wkst > this.getWeekday()) {
        this.day += -(this.getWeekday() + 1 + (6 - wkst)) + days * 7;
      } else {
        this.day += -(this.getWeekday() - wkst) + days * 7;
      }
      this.fixDay();
    };
    DateTime2.prototype.addDaily = function(days) {
      this.day += days;
      this.fixDay();
    };
    DateTime2.prototype.addHours = function(hours, filtered, byhour) {
      if (filtered) {
        this.hour += Math.floor((23 - this.hour) / hours) * hours;
      }
      for (; ; ) {
        this.hour += hours;
        var _a = divmod(this.hour, 24), dayDiv = _a.div, hourMod = _a.mod;
        if (dayDiv) {
          this.hour = hourMod;
          this.addDaily(dayDiv);
        }
        if (empty(byhour) || includes(byhour, this.hour))
          break;
      }
    };
    DateTime2.prototype.addMinutes = function(minutes, filtered, byhour, byminute) {
      if (filtered) {
        this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / minutes) * minutes;
      }
      for (; ; ) {
        this.minute += minutes;
        var _a = divmod(this.minute, 60), hourDiv = _a.div, minuteMod = _a.mod;
        if (hourDiv) {
          this.minute = minuteMod;
          this.addHours(hourDiv, false, byhour);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute))) {
          break;
        }
      }
    };
    DateTime2.prototype.addSeconds = function(seconds, filtered, byhour, byminute, bysecond) {
      if (filtered) {
        this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / seconds) * seconds;
      }
      for (; ; ) {
        this.second += seconds;
        var _a = divmod(this.second, 60), minuteDiv = _a.div, secondMod = _a.mod;
        if (minuteDiv) {
          this.second = secondMod;
          this.addMinutes(minuteDiv, false, byhour, byminute);
        }
        if ((empty(byhour) || includes(byhour, this.hour)) && (empty(byminute) || includes(byminute, this.minute)) && (empty(bysecond) || includes(bysecond, this.second))) {
          break;
        }
      }
    };
    DateTime2.prototype.fixDay = function() {
      if (this.day <= 28) {
        return;
      }
      var daysinmonth = monthRange(this.year, this.month - 1)[1];
      if (this.day <= daysinmonth) {
        return;
      }
      while (this.day > daysinmonth) {
        this.day -= daysinmonth;
        ++this.month;
        if (this.month === 13) {
          this.month = 1;
          ++this.year;
          if (this.year > MAXYEAR) {
            return;
          }
        }
        daysinmonth = monthRange(this.year, this.month - 1)[1];
      }
    };
    DateTime2.prototype.add = function(options, filtered) {
      var freq = options.freq, interval = options.interval, wkst = options.wkst, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
      switch (freq) {
        case Frequency.YEARLY:
          return this.addYears(interval);
        case Frequency.MONTHLY:
          return this.addMonths(interval);
        case Frequency.WEEKLY:
          return this.addWeekly(interval, wkst);
        case Frequency.DAILY:
          return this.addDaily(interval);
        case Frequency.HOURLY:
          return this.addHours(interval, filtered, byhour);
        case Frequency.MINUTELY:
          return this.addMinutes(interval, filtered, byhour, byminute);
        case Frequency.SECONDLY:
          return this.addSeconds(interval, filtered, byhour, byminute, bysecond);
      }
    };
    return DateTime2;
  }(Time)
);

// node_modules/rrule/dist/esm/parseoptions.js
function initializeOptions(options) {
  var invalid = [];
  var keys = Object.keys(options);
  for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
    var key = keys_1[_i];
    if (!includes(defaultKeys, key))
      invalid.push(key);
    if (isDate(options[key]) && !isValidDate2(options[key])) {
      invalid.push(key);
    }
  }
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign({}, options);
}
function parseOptions(options) {
  var opts = __assign(__assign({}, DEFAULT_OPTIONS), initializeOptions(options));
  if (isPresent(opts.byeaster))
    opts.freq = RRule.YEARLY;
  if (!(isPresent(opts.freq) && RRule.FREQUENCIES[opts.freq])) {
    throw new Error("Invalid frequency: ".concat(opts.freq, " ").concat(options.freq));
  }
  if (!opts.dtstart)
    opts.dtstart = new Date(new Date().setMilliseconds(0));
  if (!isPresent(opts.wkst)) {
    opts.wkst = RRule.MO.weekday;
  } else if (isNumber(opts.wkst)) {
  } else {
    opts.wkst = opts.wkst.weekday;
  }
  if (isPresent(opts.bysetpos)) {
    if (isNumber(opts.bysetpos))
      opts.bysetpos = [opts.bysetpos];
    for (var i3 = 0; i3 < opts.bysetpos.length; i3++) {
      var v3 = opts.bysetpos[i3];
      if (v3 === 0 || !(v3 >= -366 && v3 <= 366)) {
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
      }
    }
  }
  if (!(Boolean(opts.byweekno) || notEmpty(opts.byweekno) || notEmpty(opts.byyearday) || Boolean(opts.bymonthday) || notEmpty(opts.bymonthday) || isPresent(opts.byweekday) || isPresent(opts.byeaster))) {
    switch (opts.freq) {
      case RRule.YEARLY:
        if (!opts.bymonth)
          opts.bymonth = opts.dtstart.getUTCMonth() + 1;
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.MONTHLY:
        opts.bymonthday = opts.dtstart.getUTCDate();
        break;
      case RRule.WEEKLY:
        opts.byweekday = [getWeekday(opts.dtstart)];
        break;
    }
  }
  if (isPresent(opts.bymonth) && !isArray(opts.bymonth)) {
    opts.bymonth = [opts.bymonth];
  }
  if (isPresent(opts.byyearday) && !isArray(opts.byyearday) && isNumber(opts.byyearday)) {
    opts.byyearday = [opts.byyearday];
  }
  if (!isPresent(opts.bymonthday)) {
    opts.bymonthday = [];
    opts.bynmonthday = [];
  } else if (isArray(opts.bymonthday)) {
    var bymonthday = [];
    var bynmonthday = [];
    for (var i3 = 0; i3 < opts.bymonthday.length; i3++) {
      var v3 = opts.bymonthday[i3];
      if (v3 > 0) {
        bymonthday.push(v3);
      } else if (v3 < 0) {
        bynmonthday.push(v3);
      }
    }
    opts.bymonthday = bymonthday;
    opts.bynmonthday = bynmonthday;
  } else if (opts.bymonthday < 0) {
    opts.bynmonthday = [opts.bymonthday];
    opts.bymonthday = [];
  } else {
    opts.bynmonthday = [];
    opts.bymonthday = [opts.bymonthday];
  }
  if (isPresent(opts.byweekno) && !isArray(opts.byweekno)) {
    opts.byweekno = [opts.byweekno];
  }
  if (!isPresent(opts.byweekday)) {
    opts.bynweekday = null;
  } else if (isNumber(opts.byweekday)) {
    opts.byweekday = [opts.byweekday];
    opts.bynweekday = null;
  } else if (isWeekdayStr(opts.byweekday)) {
    opts.byweekday = [Weekday.fromStr(opts.byweekday).weekday];
    opts.bynweekday = null;
  } else if (opts.byweekday instanceof Weekday) {
    if (!opts.byweekday.n || opts.freq > RRule.MONTHLY) {
      opts.byweekday = [opts.byweekday.weekday];
      opts.bynweekday = null;
    } else {
      opts.bynweekday = [[opts.byweekday.weekday, opts.byweekday.n]];
      opts.byweekday = null;
    }
  } else {
    var byweekday = [];
    var bynweekday = [];
    for (var i3 = 0; i3 < opts.byweekday.length; i3++) {
      var wday = opts.byweekday[i3];
      if (isNumber(wday)) {
        byweekday.push(wday);
        continue;
      } else if (isWeekdayStr(wday)) {
        byweekday.push(Weekday.fromStr(wday).weekday);
        continue;
      }
      if (!wday.n || opts.freq > RRule.MONTHLY) {
        byweekday.push(wday.weekday);
      } else {
        bynweekday.push([wday.weekday, wday.n]);
      }
    }
    opts.byweekday = notEmpty(byweekday) ? byweekday : null;
    opts.bynweekday = notEmpty(bynweekday) ? bynweekday : null;
  }
  if (!isPresent(opts.byhour)) {
    opts.byhour = opts.freq < RRule.HOURLY ? [opts.dtstart.getUTCHours()] : null;
  } else if (isNumber(opts.byhour)) {
    opts.byhour = [opts.byhour];
  }
  if (!isPresent(opts.byminute)) {
    opts.byminute = opts.freq < RRule.MINUTELY ? [opts.dtstart.getUTCMinutes()] : null;
  } else if (isNumber(opts.byminute)) {
    opts.byminute = [opts.byminute];
  }
  if (!isPresent(opts.bysecond)) {
    opts.bysecond = opts.freq < RRule.SECONDLY ? [opts.dtstart.getUTCSeconds()] : null;
  } else if (isNumber(opts.bysecond)) {
    opts.bysecond = [opts.bysecond];
  }
  return { parsedOptions: opts };
}
function buildTimeset(opts) {
  var millisecondModulo = opts.dtstart.getTime() % 1e3;
  if (!freqIsDailyOrGreater(opts.freq)) {
    return [];
  }
  var timeset = [];
  opts.byhour.forEach(function(hour) {
    opts.byminute.forEach(function(minute) {
      opts.bysecond.forEach(function(second) {
        timeset.push(new Time(hour, minute, second, millisecondModulo));
      });
    });
  });
  return timeset;
}

// node_modules/rrule/dist/esm/parsestring.js
function parseString2(rfcString) {
  var options = rfcString.split("\n").map(parseLine).filter(function(x4) {
    return x4 !== null;
  });
  return __assign(__assign({}, options[0]), options[1]);
}
function parseDtstart(line) {
  var options = {};
  var dtstartWithZone = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(line);
  if (!dtstartWithZone) {
    return options;
  }
  var tzid = dtstartWithZone[1], dtstart = dtstartWithZone[2];
  if (tzid) {
    options.tzid = tzid;
  }
  options.dtstart = untilStringToDate(dtstart);
  return options;
}
function parseLine(rfcString) {
  rfcString = rfcString.replace(/^\s+|\s+$/, "");
  if (!rfcString.length)
    return null;
  var header = /^([A-Z]+?)[:;]/.exec(rfcString.toUpperCase());
  if (!header) {
    return parseRrule(rfcString);
  }
  var key = header[1];
  switch (key.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return parseRrule(rfcString);
    case "DTSTART":
      return parseDtstart(rfcString);
    default:
      throw new Error("Unsupported RFC prop ".concat(key, " in ").concat(rfcString));
  }
}
function parseRrule(line) {
  var strippedLine = line.replace(/^RRULE:/i, "");
  var options = parseDtstart(strippedLine);
  var attrs = line.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  attrs.forEach(function(attr) {
    var _a = attr.split("="), key = _a[0], value = _a[1];
    switch (key.toUpperCase()) {
      case "FREQ":
        options.freq = Frequency[value.toUpperCase()];
        break;
      case "WKST":
        options.wkst = Days[value.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var num = parseNumber(value);
        var optionKey = key.toLowerCase();
        options[optionKey] = num;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        options.byweekday = parseWeekday(value);
        break;
      case "DTSTART":
      case "TZID":
        var dtstart = parseDtstart(line);
        options.tzid = dtstart.tzid;
        options.dtstart = dtstart.dtstart;
        break;
      case "UNTIL":
        options.until = untilStringToDate(value);
        break;
      case "BYEASTER":
        options.byeaster = Number(value);
        break;
      default:
        throw new Error("Unknown RRULE property '" + key + "'");
    }
  });
  return options;
}
function parseNumber(value) {
  if (value.indexOf(",") !== -1) {
    var values = value.split(",");
    return values.map(parseIndividualNumber);
  }
  return parseIndividualNumber(value);
}
function parseIndividualNumber(value) {
  if (/^[+-]?\d+$/.test(value)) {
    return Number(value);
  }
  return value;
}
function parseWeekday(value) {
  var days = value.split(",");
  return days.map(function(day) {
    if (day.length === 2) {
      return Days[day];
    }
    var parts = day.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!parts || parts.length < 3) {
      throw new SyntaxError("Invalid weekday string: ".concat(day));
    }
    var n2 = Number(parts[1]);
    var wdaypart = parts[2];
    var wday = Days[wdaypart].weekday;
    return new Weekday(wday, n2);
  });
}

// node_modules/rrule/dist/esm/datewithzone.js
var DateWithZone = (
  /** @class */
  function() {
    function DateWithZone2(date, tzid) {
      if (isNaN(date.getTime())) {
        throw new RangeError("Invalid date passed to DateWithZone");
      }
      this.date = date;
      this.tzid = tzid;
    }
    Object.defineProperty(DateWithZone2.prototype, "isUTC", {
      get: function() {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: false,
      configurable: true
    });
    DateWithZone2.prototype.toString = function() {
      var datestr = timeToUntilString(this.date.getTime(), this.isUTC);
      if (!this.isUTC) {
        return ";TZID=".concat(this.tzid, ":").concat(datestr);
      }
      return ":".concat(datestr);
    };
    DateWithZone2.prototype.getTime = function() {
      return this.date.getTime();
    };
    DateWithZone2.prototype.rezonedDate = function() {
      if (this.isUTC) {
        return this.date;
      }
      return dateInTimeZone(this.date, this.tzid);
    };
    return DateWithZone2;
  }()
);

// node_modules/rrule/dist/esm/optionstostring.js
function optionsToString(options) {
  var rrule = [];
  var dtstart = "";
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS);
  for (var i3 = 0; i3 < keys.length; i3++) {
    if (keys[i3] === "tzid")
      continue;
    if (!includes(defaultKeys2, keys[i3]))
      continue;
    var key = keys[i3].toUpperCase();
    var value = options[keys[i3]];
    var outValue = "";
    if (!isPresent(value) || isArray(value) && !value.length)
      continue;
    switch (key) {
      case "FREQ":
        outValue = RRule.FREQUENCIES[options.freq];
        break;
      case "WKST":
        if (isNumber(value)) {
          outValue = new Weekday(value).toString();
        } else {
          outValue = value.toString();
        }
        break;
      case "BYWEEKDAY":
        key = "BYDAY";
        outValue = toArray(value).map(function(wday) {
          if (wday instanceof Weekday) {
            return wday;
          }
          if (isArray(wday)) {
            return new Weekday(wday[0], wday[1]);
          }
          return new Weekday(wday);
        }).toString();
        break;
      case "DTSTART":
        dtstart = buildDtstart(value, options.tzid);
        break;
      case "UNTIL":
        outValue = timeToUntilString(value, !options.tzid);
        break;
      default:
        if (isArray(value)) {
          var strValues = [];
          for (var j4 = 0; j4 < value.length; j4++) {
            strValues[j4] = String(value[j4]);
          }
          outValue = strValues.toString();
        } else {
          outValue = String(value);
        }
    }
    if (outValue) {
      rrule.push([key, outValue]);
    }
  }
  var rules = rrule.map(function(_a) {
    var key2 = _a[0], value2 = _a[1];
    return "".concat(key2, "=").concat(value2.toString());
  }).join(";");
  var ruleString = "";
  if (rules !== "") {
    ruleString = "RRULE:".concat(rules);
  }
  return [dtstart, ruleString].filter(function(x4) {
    return !!x4;
  }).join("\n");
}
function buildDtstart(dtstart, tzid) {
  if (!dtstart) {
    return "";
  }
  return "DTSTART" + new DateWithZone(new Date(dtstart), tzid).toString();
}

// node_modules/rrule/dist/esm/cache.js
function argsMatch(left, right) {
  if (Array.isArray(left)) {
    if (!Array.isArray(right))
      return false;
    if (left.length !== right.length)
      return false;
    return left.every(function(date, i3) {
      return date.getTime() === right[i3].getTime();
    });
  }
  if (left instanceof Date) {
    return right instanceof Date && left.getTime() === right.getTime();
  }
  return left === right;
}
var Cache = (
  /** @class */
  function() {
    function Cache3() {
      this.all = false;
      this.before = [];
      this.after = [];
      this.between = [];
    }
    Cache3.prototype._cacheAdd = function(what, value, args) {
      if (value) {
        value = value instanceof Date ? clone(value) : cloneDates(value);
      }
      if (what === "all") {
        this.all = value;
      } else {
        args._value = value;
        this[what].push(args);
      }
    };
    Cache3.prototype._cacheGet = function(what, args) {
      var cached = false;
      var argsKeys = args ? Object.keys(args) : [];
      var findCacheDiff = function(item2) {
        for (var i4 = 0; i4 < argsKeys.length; i4++) {
          var key = argsKeys[i4];
          if (!argsMatch(args[key], item2[key])) {
            return true;
          }
        }
        return false;
      };
      var cachedObject = this[what];
      if (what === "all") {
        cached = this.all;
      } else if (isArray(cachedObject)) {
        for (var i3 = 0; i3 < cachedObject.length; i3++) {
          var item = cachedObject[i3];
          if (argsKeys.length && findCacheDiff(item))
            continue;
          cached = item._value;
          break;
        }
      }
      if (!cached && this.all) {
        var iterResult = new iterresult_default(what, args);
        for (var i3 = 0; i3 < this.all.length; i3++) {
          if (!iterResult.accept(this.all[i3]))
            break;
        }
        cached = iterResult.getValue();
        this._cacheAdd(what, cached, args);
      }
      return isArray(cached) ? cloneDates(cached) : cached instanceof Date ? clone(cached) : cached;
    };
    return Cache3;
  }()
);

// node_modules/rrule/dist/esm/masks.js
var M365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 28), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], repeat(1, 31), true), repeat(2, 29), true), repeat(3, 31), true), repeat(4, 30), true), repeat(5, 31), true), repeat(6, 30), true), repeat(7, 31), true), repeat(8, 31), true), repeat(9, 30), true), repeat(10, 31), true), repeat(11, 30), true), repeat(12, 31), true), repeat(1, 7), true);
var M28 = range(1, 29);
var M29 = range(1, 30);
var M30 = range(1, 31);
var M31 = range(1, 32);
var MDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M29, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var MDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], M31, true), M28, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31, true), M30, true), M31, true), M30, true), M31, true), M31.slice(0, 7), true);
var NM28 = range(-28, 0);
var NM29 = range(-29, 0);
var NM30 = range(-30, 0);
var NM31 = range(-31, 0);
var NMDAY366MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM29, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var NMDAY365MASK = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], NM31, true), NM28, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31, true), NM30, true), NM31, true), NM30, true), NM31, true), NM31.slice(0, 7), true);
var M366RANGE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366];
var M365RANGE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];
var WDAYMASK = function() {
  var wdaymask = [];
  for (var i3 = 0; i3 < 55; i3++)
    wdaymask = wdaymask.concat(range(7));
  return wdaymask;
}();

// node_modules/rrule/dist/esm/iterinfo/yearinfo.js
function rebuildYear(year, options) {
  var firstyday = datetime(year, 1, 1);
  var yearlen = isLeapYear(year) ? 366 : 365;
  var nextyearlen = isLeapYear(year + 1) ? 366 : 365;
  var yearordinal = toOrdinal(firstyday);
  var yearweekday = getWeekday(firstyday);
  var result = __assign(__assign({ yearlen, nextyearlen, yearordinal, yearweekday }, baseYearMasks(year)), { wnomask: null });
  if (empty(options.byweekno)) {
    return result;
  }
  result.wnomask = repeat(0, yearlen + 7);
  var firstwkst;
  var wyearlen;
  var no1wkst = firstwkst = pymod(7 - yearweekday + options.wkst, 7);
  if (no1wkst >= 4) {
    no1wkst = 0;
    wyearlen = result.yearlen + pymod(yearweekday - options.wkst, 7);
  } else {
    wyearlen = yearlen - no1wkst;
  }
  var div = Math.floor(wyearlen / 7);
  var mod = pymod(wyearlen, 7);
  var numweeks = Math.floor(div + mod / 4);
  for (var j4 = 0; j4 < options.byweekno.length; j4++) {
    var n2 = options.byweekno[j4];
    if (n2 < 0) {
      n2 += numweeks + 1;
    }
    if (!(n2 > 0 && n2 <= numweeks)) {
      continue;
    }
    var i3 = void 0;
    if (n2 > 1) {
      i3 = no1wkst + (n2 - 1) * 7;
      if (no1wkst !== firstwkst) {
        i3 -= 7 - firstwkst;
      }
    } else {
      i3 = no1wkst;
    }
    for (var k3 = 0; k3 < 7; k3++) {
      result.wnomask[i3] = 1;
      i3++;
      if (result.wdaymask[i3] === options.wkst)
        break;
    }
  }
  if (includes(options.byweekno, 1)) {
    var i3 = no1wkst + numweeks * 7;
    if (no1wkst !== firstwkst)
      i3 -= 7 - firstwkst;
    if (i3 < yearlen) {
      for (var j4 = 0; j4 < 7; j4++) {
        result.wnomask[i3] = 1;
        i3 += 1;
        if (result.wdaymask[i3] === options.wkst)
          break;
      }
    }
  }
  if (no1wkst) {
    var lnumweeks = void 0;
    if (!includes(options.byweekno, -1)) {
      var lyearweekday = getWeekday(datetime(year - 1, 1, 1));
      var lno1wkst = pymod(7 - lyearweekday.valueOf() + options.wkst, 7);
      var lyearlen = isLeapYear(year - 1) ? 366 : 365;
      var weekst = void 0;
      if (lno1wkst >= 4) {
        lno1wkst = 0;
        weekst = lyearlen + pymod(lyearweekday - options.wkst, 7);
      } else {
        weekst = yearlen - no1wkst;
      }
      lnumweeks = Math.floor(52 + pymod(weekst, 7) / 4);
    } else {
      lnumweeks = -1;
    }
    if (includes(options.byweekno, lnumweeks)) {
      for (var i3 = 0; i3 < no1wkst; i3++)
        result.wnomask[i3] = 1;
    }
  }
  return result;
}
function baseYearMasks(year) {
  var yearlen = isLeapYear(year) ? 366 : 365;
  var firstyday = datetime(year, 1, 1);
  var wday = getWeekday(firstyday);
  if (yearlen === 365) {
    return {
      mmask: M365MASK,
      mdaymask: MDAY365MASK,
      nmdaymask: NMDAY365MASK,
      wdaymask: WDAYMASK.slice(wday),
      mrange: M365RANGE
    };
  }
  return {
    mmask: M366MASK,
    mdaymask: MDAY366MASK,
    nmdaymask: NMDAY366MASK,
    wdaymask: WDAYMASK.slice(wday),
    mrange: M366RANGE
  };
}

// node_modules/rrule/dist/esm/iterinfo/monthinfo.js
function rebuildMonth(year, month, yearlen, mrange, wdaymask, options) {
  var result = {
    lastyear: year,
    lastmonth: month,
    nwdaymask: []
  };
  var ranges = [];
  if (options.freq === RRule.YEARLY) {
    if (empty(options.bymonth)) {
      ranges = [[0, yearlen]];
    } else {
      for (var j4 = 0; j4 < options.bymonth.length; j4++) {
        month = options.bymonth[j4];
        ranges.push(mrange.slice(month - 1, month + 1));
      }
    }
  } else if (options.freq === RRule.MONTHLY) {
    ranges = [mrange.slice(month - 1, month + 1)];
  }
  if (empty(ranges)) {
    return result;
  }
  result.nwdaymask = repeat(0, yearlen);
  for (var j4 = 0; j4 < ranges.length; j4++) {
    var rang = ranges[j4];
    var first = rang[0];
    var last = rang[1] - 1;
    for (var k3 = 0; k3 < options.bynweekday.length; k3++) {
      var i3 = void 0;
      var _a = options.bynweekday[k3], wday = _a[0], n2 = _a[1];
      if (n2 < 0) {
        i3 = last + (n2 + 1) * 7;
        i3 -= pymod(wdaymask[i3] - wday, 7);
      } else {
        i3 = first + (n2 - 1) * 7;
        i3 += pymod(7 - wdaymask[i3] + wday, 7);
      }
      if (first <= i3 && i3 <= last)
        result.nwdaymask[i3] = 1;
    }
  }
  return result;
}

// node_modules/rrule/dist/esm/iterinfo/easter.js
function easter(y3, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var a3 = y3 % 19;
  var b3 = Math.floor(y3 / 100);
  var c3 = y3 % 100;
  var d2 = Math.floor(b3 / 4);
  var e3 = b3 % 4;
  var f3 = Math.floor((b3 + 8) / 25);
  var g4 = Math.floor((b3 - f3 + 1) / 3);
  var h3 = Math.floor(19 * a3 + b3 - d2 - g4 + 15) % 30;
  var i3 = Math.floor(c3 / 4);
  var k3 = c3 % 4;
  var l3 = Math.floor(32 + 2 * e3 + 2 * i3 - h3 - k3) % 7;
  var m3 = Math.floor((a3 + 11 * h3 + 22 * l3) / 451);
  var month = Math.floor((h3 + l3 - 7 * m3 + 114) / 31);
  var day = (h3 + l3 - 7 * m3 + 114) % 31 + 1;
  var date = Date.UTC(y3, month - 1, day + offset);
  var yearStart = Date.UTC(y3, 0, 1);
  return [Math.ceil((date - yearStart) / (1e3 * 60 * 60 * 24))];
}

// node_modules/rrule/dist/esm/iterinfo/index.js
var Iterinfo = (
  /** @class */
  function() {
    function Iterinfo2(options) {
      this.options = options;
    }
    Iterinfo2.prototype.rebuild = function(year, month) {
      var options = this.options;
      if (year !== this.lastyear) {
        this.yearinfo = rebuildYear(year, options);
      }
      if (notEmpty(options.bynweekday) && (month !== this.lastmonth || year !== this.lastyear)) {
        var _a = this.yearinfo, yearlen = _a.yearlen, mrange = _a.mrange, wdaymask = _a.wdaymask;
        this.monthinfo = rebuildMonth(year, month, yearlen, mrange, wdaymask, options);
      }
      if (isPresent(options.byeaster)) {
        this.eastermask = easter(year, options.byeaster);
      }
    };
    Object.defineProperty(Iterinfo2.prototype, "lastyear", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "lastmonth", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearlen", {
      get: function() {
        return this.yearinfo.yearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "yearordinal", {
      get: function() {
        return this.yearinfo.yearordinal;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mrange", {
      get: function() {
        return this.yearinfo.mrange;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wdaymask", {
      get: function() {
        return this.yearinfo.wdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mmask", {
      get: function() {
        return this.yearinfo.mmask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "wnomask", {
      get: function() {
        return this.yearinfo.wnomask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nwdaymask", {
      get: function() {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nextyearlen", {
      get: function() {
        return this.yearinfo.nextyearlen;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "mdaymask", {
      get: function() {
        return this.yearinfo.mdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Iterinfo2.prototype, "nmdaymask", {
      get: function() {
        return this.yearinfo.nmdaymask;
      },
      enumerable: false,
      configurable: true
    });
    Iterinfo2.prototype.ydayset = function() {
      return [range(this.yearlen), 0, this.yearlen];
    };
    Iterinfo2.prototype.mdayset = function(_3, month) {
      var start = this.mrange[month - 1];
      var end = this.mrange[month];
      var set = repeat(null, this.yearlen);
      for (var i3 = start; i3 < end; i3++)
        set[i3] = i3;
      return [set, start, end];
    };
    Iterinfo2.prototype.wdayset = function(year, month, day) {
      var set = repeat(null, this.yearlen + 7);
      var i3 = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      var start = i3;
      for (var j4 = 0; j4 < 7; j4++) {
        set[i3] = i3;
        ++i3;
        if (this.wdaymask[i3] === this.options.wkst)
          break;
      }
      return [set, start, i3];
    };
    Iterinfo2.prototype.ddayset = function(year, month, day) {
      var set = repeat(null, this.yearlen);
      var i3 = toOrdinal(datetime(year, month, day)) - this.yearordinal;
      set[i3] = i3;
      return [set, i3, i3 + 1];
    };
    Iterinfo2.prototype.htimeset = function(hour, _3, second, millisecond) {
      var _this = this;
      var set = [];
      this.options.byminute.forEach(function(minute) {
        set = set.concat(_this.mtimeset(hour, minute, second, millisecond));
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.mtimeset = function(hour, minute, _3, millisecond) {
      var set = this.options.bysecond.map(function(second) {
        return new Time(hour, minute, second, millisecond);
      });
      sort(set);
      return set;
    };
    Iterinfo2.prototype.stimeset = function(hour, minute, second, millisecond) {
      return [new Time(hour, minute, second, millisecond)];
    };
    Iterinfo2.prototype.getdayset = function(freq) {
      switch (freq) {
        case Frequency.YEARLY:
          return this.ydayset.bind(this);
        case Frequency.MONTHLY:
          return this.mdayset.bind(this);
        case Frequency.WEEKLY:
          return this.wdayset.bind(this);
        case Frequency.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    };
    Iterinfo2.prototype.gettimeset = function(freq) {
      switch (freq) {
        case Frequency.HOURLY:
          return this.htimeset.bind(this);
        case Frequency.MINUTELY:
          return this.mtimeset.bind(this);
        case Frequency.SECONDLY:
          return this.stimeset.bind(this);
      }
    };
    return Iterinfo2;
  }()
);
var iterinfo_default = Iterinfo;

// node_modules/rrule/dist/esm/iter/poslist.js
function buildPoslist(bysetpos, timeset, start, end, ii, dayset) {
  var poslist = [];
  for (var j4 = 0; j4 < bysetpos.length; j4++) {
    var daypos = void 0;
    var timepos = void 0;
    var pos = bysetpos[j4];
    if (pos < 0) {
      daypos = Math.floor(pos / timeset.length);
      timepos = pymod(pos, timeset.length);
    } else {
      daypos = Math.floor((pos - 1) / timeset.length);
      timepos = pymod(pos - 1, timeset.length);
    }
    var tmp = [];
    for (var k3 = start; k3 < end; k3++) {
      var val = dayset[k3];
      if (!isPresent(val))
        continue;
      tmp.push(val);
    }
    var i3 = void 0;
    if (daypos < 0) {
      i3 = tmp.slice(daypos)[0];
    } else {
      i3 = tmp[daypos];
    }
    var time = timeset[timepos];
    var date = fromOrdinal(ii.yearordinal + i3);
    var res = combine(date, time);
    if (!includes(poslist, res))
      poslist.push(res);
  }
  sort(poslist);
  return poslist;
}

// node_modules/rrule/dist/esm/iter/index.js
function iter(iterResult, options) {
  var dtstart = options.dtstart, freq = options.freq, interval = options.interval, until = options.until, bysetpos = options.bysetpos;
  var count = options.count;
  if (count === 0 || interval === 0) {
    return emitResult(iterResult);
  }
  var counterDate = DateTime.fromDate(dtstart);
  var ii = new iterinfo_default(options);
  ii.rebuild(counterDate.year, counterDate.month);
  var timeset = makeTimeset(ii, counterDate, options);
  for (; ; ) {
    var _a = ii.getdayset(freq)(counterDate.year, counterDate.month, counterDate.day), dayset = _a[0], start = _a[1], end = _a[2];
    var filtered = removeFilteredDays(dayset, start, end, ii, options);
    if (notEmpty(bysetpos)) {
      var poslist = buildPoslist(bysetpos, timeset, start, end, ii, dayset);
      for (var j4 = 0; j4 < poslist.length; j4++) {
        var res = poslist[j4];
        if (until && res > until) {
          return emitResult(iterResult);
        }
        if (res >= dtstart) {
          var rezonedDate = rezoneIfNeeded(res, options);
          if (!iterResult.accept(rezonedDate)) {
            return emitResult(iterResult);
          }
          if (count) {
            --count;
            if (!count) {
              return emitResult(iterResult);
            }
          }
        }
      }
    } else {
      for (var j4 = start; j4 < end; j4++) {
        var currentDay = dayset[j4];
        if (!isPresent(currentDay)) {
          continue;
        }
        var date = fromOrdinal(ii.yearordinal + currentDay);
        for (var k3 = 0; k3 < timeset.length; k3++) {
          var time = timeset[k3];
          var res = combine(date, time);
          if (until && res > until) {
            return emitResult(iterResult);
          }
          if (res >= dtstart) {
            var rezonedDate = rezoneIfNeeded(res, options);
            if (!iterResult.accept(rezonedDate)) {
              return emitResult(iterResult);
            }
            if (count) {
              --count;
              if (!count) {
                return emitResult(iterResult);
              }
            }
          }
        }
      }
    }
    if (options.interval === 0) {
      return emitResult(iterResult);
    }
    counterDate.add(options, filtered);
    if (counterDate.year > MAXYEAR) {
      return emitResult(iterResult);
    }
    if (!freqIsDailyOrGreater(freq)) {
      timeset = ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, 0);
    }
    ii.rebuild(counterDate.year, counterDate.month);
  }
}
function isFiltered(ii, currentDay, options) {
  var bymonth = options.bymonth, byweekno = options.byweekno, byweekday = options.byweekday, byeaster = options.byeaster, bymonthday = options.bymonthday, bynmonthday = options.bynmonthday, byyearday = options.byyearday;
  return notEmpty(bymonth) && !includes(bymonth, ii.mmask[currentDay]) || notEmpty(byweekno) && !ii.wnomask[currentDay] || notEmpty(byweekday) && !includes(byweekday, ii.wdaymask[currentDay]) || notEmpty(ii.nwdaymask) && !ii.nwdaymask[currentDay] || byeaster !== null && !includes(ii.eastermask, currentDay) || (notEmpty(bymonthday) || notEmpty(bynmonthday)) && !includes(bymonthday, ii.mdaymask[currentDay]) && !includes(bynmonthday, ii.nmdaymask[currentDay]) || notEmpty(byyearday) && (currentDay < ii.yearlen && !includes(byyearday, currentDay + 1) && !includes(byyearday, -ii.yearlen + currentDay) || currentDay >= ii.yearlen && !includes(byyearday, currentDay + 1 - ii.yearlen) && !includes(byyearday, -ii.nextyearlen + currentDay - ii.yearlen));
}
function rezoneIfNeeded(date, options) {
  return new DateWithZone(date, options.tzid).rezonedDate();
}
function emitResult(iterResult) {
  return iterResult.getValue();
}
function removeFilteredDays(dayset, start, end, ii, options) {
  var filtered = false;
  for (var dayCounter = start; dayCounter < end; dayCounter++) {
    var currentDay = dayset[dayCounter];
    filtered = isFiltered(ii, currentDay, options);
    if (filtered)
      dayset[currentDay] = null;
  }
  return filtered;
}
function makeTimeset(ii, counterDate, options) {
  var freq = options.freq, byhour = options.byhour, byminute = options.byminute, bysecond = options.bysecond;
  if (freqIsDailyOrGreater(freq)) {
    return buildTimeset(options);
  }
  if (freq >= RRule.HOURLY && notEmpty(byhour) && !includes(byhour, counterDate.hour) || freq >= RRule.MINUTELY && notEmpty(byminute) && !includes(byminute, counterDate.minute) || freq >= RRule.SECONDLY && notEmpty(bysecond) && !includes(bysecond, counterDate.second)) {
    return [];
  }
  return ii.gettimeset(freq)(counterDate.hour, counterDate.minute, counterDate.second, counterDate.millisecond);
}

// node_modules/rrule/dist/esm/rrule.js
var Days = {
  MO: new Weekday(0),
  TU: new Weekday(1),
  WE: new Weekday(2),
  TH: new Weekday(3),
  FR: new Weekday(4),
  SA: new Weekday(5),
  SU: new Weekday(6)
};
var DEFAULT_OPTIONS = {
  freq: Frequency.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Days.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
};
var defaultKeys = Object.keys(DEFAULT_OPTIONS);
var RRule = (
  /** @class */
  function() {
    function RRule2(options, noCache) {
      if (options === void 0) {
        options = {};
      }
      if (noCache === void 0) {
        noCache = false;
      }
      this._cache = noCache ? null : new Cache();
      this.origOptions = initializeOptions(options);
      var parsedOptions = parseOptions(options).parsedOptions;
      this.options = parsedOptions;
    }
    RRule2.parseText = function(text, language) {
      return parseText(text, language);
    };
    RRule2.fromText = function(text, language) {
      return fromText(text, language);
    };
    RRule2.fromString = function(str) {
      return new RRule2(RRule2.parseString(str) || void 0);
    };
    RRule2.prototype._iter = function(iterResult) {
      return iter(iterResult, this.options);
    };
    RRule2.prototype._cacheGet = function(what, args) {
      if (!this._cache)
        return false;
      return this._cache._cacheGet(what, args);
    };
    RRule2.prototype._cacheAdd = function(what, value, args) {
      if (!this._cache)
        return;
      return this._cache._cacheAdd(what, value, args);
    };
    RRule2.prototype.all = function(iterator) {
      if (iterator) {
        return this._iter(new callbackiterresult_default("all", {}, iterator));
      }
      var result = this._cacheGet("all");
      if (result === false) {
        result = this._iter(new iterresult_default("all", {}));
        this._cacheAdd("all", result);
      }
      return result;
    };
    RRule2.prototype.between = function(after, before, inc, iterator) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(after) || !isValidDate2(before)) {
        throw new Error("Invalid date passed in to RRule.between");
      }
      var args = {
        before,
        after,
        inc
      };
      if (iterator) {
        return this._iter(new callbackiterresult_default("between", args, iterator));
      }
      var result = this._cacheGet("between", args);
      if (result === false) {
        result = this._iter(new iterresult_default("between", args));
        this._cacheAdd("between", result, args);
      }
      return result;
    };
    RRule2.prototype.before = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.before");
      }
      var args = { dt, inc };
      var result = this._cacheGet("before", args);
      if (result === false) {
        result = this._iter(new iterresult_default("before", args));
        this._cacheAdd("before", result, args);
      }
      return result;
    };
    RRule2.prototype.after = function(dt, inc) {
      if (inc === void 0) {
        inc = false;
      }
      if (!isValidDate2(dt)) {
        throw new Error("Invalid date passed in to RRule.after");
      }
      var args = { dt, inc };
      var result = this._cacheGet("after", args);
      if (result === false) {
        result = this._iter(new iterresult_default("after", args));
        this._cacheAdd("after", result, args);
      }
      return result;
    };
    RRule2.prototype.count = function() {
      return this.all().length;
    };
    RRule2.prototype.toString = function() {
      return optionsToString(this.origOptions);
    };
    RRule2.prototype.toText = function(gettext, language, dateFormatter) {
      return toText(this, gettext, language, dateFormatter);
    };
    RRule2.prototype.isFullyConvertibleToText = function() {
      return isFullyConvertible(this);
    };
    RRule2.prototype.clone = function() {
      return new RRule2(this.origOptions);
    };
    RRule2.FREQUENCIES = [
      "YEARLY",
      "MONTHLY",
      "WEEKLY",
      "DAILY",
      "HOURLY",
      "MINUTELY",
      "SECONDLY"
    ];
    RRule2.YEARLY = Frequency.YEARLY;
    RRule2.MONTHLY = Frequency.MONTHLY;
    RRule2.WEEKLY = Frequency.WEEKLY;
    RRule2.DAILY = Frequency.DAILY;
    RRule2.HOURLY = Frequency.HOURLY;
    RRule2.MINUTELY = Frequency.MINUTELY;
    RRule2.SECONDLY = Frequency.SECONDLY;
    RRule2.MO = Days.MO;
    RRule2.TU = Days.TU;
    RRule2.WE = Days.WE;
    RRule2.TH = Days.TH;
    RRule2.FR = Days.FR;
    RRule2.SA = Days.SA;
    RRule2.SU = Days.SU;
    RRule2.parseString = parseString2;
    RRule2.optionsToString = optionsToString;
    return RRule2;
  }()
);

// node_modules/rrule/dist/esm/iterset.js
function iterSet(iterResult, _rrule, _exrule, _rdate, _exdate, tzid) {
  var _exdateHash = {};
  var _accept = iterResult.accept;
  function evalExdate(after, before) {
    _exrule.forEach(function(rrule) {
      rrule.between(after, before, true).forEach(function(date) {
        _exdateHash[Number(date)] = true;
      });
    });
  }
  _exdate.forEach(function(date) {
    var zonedDate2 = new DateWithZone(date, tzid).rezonedDate();
    _exdateHash[Number(zonedDate2)] = true;
  });
  iterResult.accept = function(date) {
    var dt = Number(date);
    if (isNaN(dt))
      return _accept.call(this, date);
    if (!_exdateHash[dt]) {
      evalExdate(new Date(dt - 1), new Date(dt + 1));
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
    }
    return true;
  };
  if (iterResult.method === "between") {
    evalExdate(iterResult.args.after, iterResult.args.before);
    iterResult.accept = function(date) {
      var dt = Number(date);
      if (!_exdateHash[dt]) {
        _exdateHash[dt] = true;
        return _accept.call(this, date);
      }
      return true;
    };
  }
  for (var i3 = 0; i3 < _rdate.length; i3++) {
    var zonedDate = new DateWithZone(_rdate[i3], tzid).rezonedDate();
    if (!iterResult.accept(new Date(zonedDate.getTime())))
      break;
  }
  _rrule.forEach(function(rrule) {
    iter(iterResult, rrule.options);
  });
  var res = iterResult._result;
  sort(res);
  switch (iterResult.method) {
    case "all":
    case "between":
      return res;
    case "before":
      return res.length && res[res.length - 1] || null;
    case "after":
    default:
      return res.length && res[0] || null;
  }
}

// node_modules/rrule/dist/esm/rrulestr.js
var DEFAULT_OPTIONS2 = {
  dtstart: null,
  cache: false,
  unfold: false,
  forceset: false,
  compatible: false,
  tzid: null
};
function parseInput(s3, options) {
  var rrulevals = [];
  var rdatevals = [];
  var exrulevals = [];
  var exdatevals = [];
  var parsedDtstart = parseDtstart(s3);
  var dtstart = parsedDtstart.dtstart;
  var tzid = parsedDtstart.tzid;
  var lines = splitIntoLines(s3, options.unfold);
  lines.forEach(function(line) {
    var _a;
    if (!line)
      return;
    var _b = breakDownLine(line), name = _b.name, parms = _b.parms, value = _b.value;
    switch (name.toUpperCase()) {
      case "RRULE":
        if (parms.length) {
          throw new Error("unsupported RRULE parm: ".concat(parms.join(",")));
        }
        rrulevals.push(parseString2(line));
        break;
      case "RDATE":
        var _c = (_a = /RDATE(?:;TZID=([^:=]+))?/i.exec(line)) !== null && _a !== void 0 ? _a : [], rdateTzid = _c[1];
        if (rdateTzid && !tzid) {
          tzid = rdateTzid;
        }
        rdatevals = rdatevals.concat(parseRDate(value, parms));
        break;
      case "EXRULE":
        if (parms.length) {
          throw new Error("unsupported EXRULE parm: ".concat(parms.join(",")));
        }
        exrulevals.push(parseString2(value));
        break;
      case "EXDATE":
        exdatevals = exdatevals.concat(parseRDate(value, parms));
        break;
      case "DTSTART":
        break;
      default:
        throw new Error("unsupported property: " + name);
    }
  });
  return {
    dtstart,
    tzid,
    rrulevals,
    rdatevals,
    exrulevals,
    exdatevals
  };
}
function buildRule(s3, options) {
  var _a = parseInput(s3, options), rrulevals = _a.rrulevals, rdatevals = _a.rdatevals, exrulevals = _a.exrulevals, exdatevals = _a.exdatevals, dtstart = _a.dtstart, tzid = _a.tzid;
  var noCache = options.cache === false;
  if (options.compatible) {
    options.forceset = true;
    options.unfold = true;
  }
  if (options.forceset || rrulevals.length > 1 || rdatevals.length || exrulevals.length || exdatevals.length) {
    var rset_1 = new RRuleSet(noCache);
    rset_1.dtstart(dtstart);
    rset_1.tzid(tzid || void 0);
    rrulevals.forEach(function(val2) {
      rset_1.rrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    rdatevals.forEach(function(date) {
      rset_1.rdate(date);
    });
    exrulevals.forEach(function(val2) {
      rset_1.exrule(new RRule(groomRruleOptions(val2, dtstart, tzid), noCache));
    });
    exdatevals.forEach(function(date) {
      rset_1.exdate(date);
    });
    if (options.compatible && options.dtstart)
      rset_1.rdate(dtstart);
    return rset_1;
  }
  var val = rrulevals[0] || {};
  return new RRule(groomRruleOptions(val, val.dtstart || options.dtstart || dtstart, val.tzid || options.tzid || tzid), noCache);
}
function rrulestr(s3, options) {
  if (options === void 0) {
    options = {};
  }
  return buildRule(s3, initializeOptions2(options));
}
function groomRruleOptions(val, dtstart, tzid) {
  return __assign(__assign({}, val), { dtstart, tzid });
}
function initializeOptions2(options) {
  var invalid = [];
  var keys = Object.keys(options);
  var defaultKeys2 = Object.keys(DEFAULT_OPTIONS2);
  keys.forEach(function(key) {
    if (!includes(defaultKeys2, key))
      invalid.push(key);
  });
  if (invalid.length) {
    throw new Error("Invalid options: " + invalid.join(", "));
  }
  return __assign(__assign({}, DEFAULT_OPTIONS2), options);
}
function extractName(line) {
  if (line.indexOf(":") === -1) {
    return {
      name: "RRULE",
      value: line
    };
  }
  var _a = split(line, ":", 1), name = _a[0], value = _a[1];
  return {
    name,
    value
  };
}
function breakDownLine(line) {
  var _a = extractName(line), name = _a.name, value = _a.value;
  var parms = name.split(";");
  if (!parms)
    throw new Error("empty property name");
  return {
    name: parms[0].toUpperCase(),
    parms: parms.slice(1),
    value
  };
}
function splitIntoLines(s3, unfold) {
  if (unfold === void 0) {
    unfold = false;
  }
  s3 = s3 && s3.trim();
  if (!s3)
    throw new Error("Invalid empty string");
  if (!unfold) {
    return s3.split(/\s/);
  }
  var lines = s3.split("\n");
  var i3 = 0;
  while (i3 < lines.length) {
    var line = lines[i3] = lines[i3].replace(/\s+$/g, "");
    if (!line) {
      lines.splice(i3, 1);
    } else if (i3 > 0 && line[0] === " ") {
      lines[i3 - 1] += line.slice(1);
      lines.splice(i3, 1);
    } else {
      i3 += 1;
    }
  }
  return lines;
}
function validateDateParm(parms) {
  parms.forEach(function(parm) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(parm)) {
      throw new Error("unsupported RDATE/EXDATE parm: " + parm);
    }
  });
}
function parseRDate(rdateval, parms) {
  validateDateParm(parms);
  return rdateval.split(",").map(function(datestr) {
    return untilStringToDate(datestr);
  });
}

// node_modules/rrule/dist/esm/rruleset.js
function createGetterSetter(fieldName) {
  var _this = this;
  return function(field) {
    if (field !== void 0) {
      _this["_".concat(fieldName)] = field;
    }
    if (_this["_".concat(fieldName)] !== void 0) {
      return _this["_".concat(fieldName)];
    }
    for (var i3 = 0; i3 < _this._rrule.length; i3++) {
      var field_1 = _this._rrule[i3].origOptions[fieldName];
      if (field_1) {
        return field_1;
      }
    }
  };
}
var RRuleSet = (
  /** @class */
  function(_super) {
    __extends(RRuleSet2, _super);
    function RRuleSet2(noCache) {
      if (noCache === void 0) {
        noCache = false;
      }
      var _this = _super.call(this, {}, noCache) || this;
      _this.dtstart = createGetterSetter.apply(_this, ["dtstart"]);
      _this.tzid = createGetterSetter.apply(_this, ["tzid"]);
      _this._rrule = [];
      _this._rdate = [];
      _this._exrule = [];
      _this._exdate = [];
      return _this;
    }
    RRuleSet2.prototype._iter = function(iterResult) {
      return iterSet(iterResult, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
    };
    RRuleSet2.prototype.rrule = function(rrule) {
      _addRule(rrule, this._rrule);
    };
    RRuleSet2.prototype.exrule = function(rrule) {
      _addRule(rrule, this._exrule);
    };
    RRuleSet2.prototype.rdate = function(date) {
      _addDate(date, this._rdate);
    };
    RRuleSet2.prototype.exdate = function(date) {
      _addDate(date, this._exdate);
    };
    RRuleSet2.prototype.rrules = function() {
      return this._rrule.map(function(e3) {
        return rrulestr(e3.toString());
      });
    };
    RRuleSet2.prototype.exrules = function() {
      return this._exrule.map(function(e3) {
        return rrulestr(e3.toString());
      });
    };
    RRuleSet2.prototype.rdates = function() {
      return this._rdate.map(function(e3) {
        return new Date(e3.getTime());
      });
    };
    RRuleSet2.prototype.exdates = function() {
      return this._exdate.map(function(e3) {
        return new Date(e3.getTime());
      });
    };
    RRuleSet2.prototype.valueOf = function() {
      var result = [];
      if (!this._rrule.length && this._dtstart) {
        result = result.concat(optionsToString({ dtstart: this._dtstart }));
      }
      this._rrule.forEach(function(rrule) {
        result = result.concat(rrule.toString().split("\n"));
      });
      this._exrule.forEach(function(exrule) {
        result = result.concat(exrule.toString().split("\n").map(function(line) {
          return line.replace(/^RRULE:/, "EXRULE:");
        }).filter(function(line) {
          return !/^DTSTART/.test(line);
        }));
      });
      if (this._rdate.length) {
        result.push(rdatesToString("RDATE", this._rdate, this.tzid()));
      }
      if (this._exdate.length) {
        result.push(rdatesToString("EXDATE", this._exdate, this.tzid()));
      }
      return result;
    };
    RRuleSet2.prototype.toString = function() {
      return this.valueOf().join("\n");
    };
    RRuleSet2.prototype.clone = function() {
      var rrs = new RRuleSet2(!!this._cache);
      this._rrule.forEach(function(rule) {
        return rrs.rrule(rule.clone());
      });
      this._exrule.forEach(function(rule) {
        return rrs.exrule(rule.clone());
      });
      this._rdate.forEach(function(date) {
        return rrs.rdate(new Date(date.getTime()));
      });
      this._exdate.forEach(function(date) {
        return rrs.exdate(new Date(date.getTime()));
      });
      return rrs;
    };
    return RRuleSet2;
  }(RRule)
);
function _addRule(rrule, collection) {
  if (!(rrule instanceof RRule)) {
    throw new TypeError(String(rrule) + " is not RRule instance");
  }
  if (!includes(collection.map(String), String(rrule))) {
    collection.push(rrule);
  }
}
function _addDate(date, collection) {
  if (!(date instanceof Date)) {
    throw new TypeError(String(date) + " is not Date instance");
  }
  if (!includes(collection.map(Number), Number(date))) {
    collection.push(date);
    sort(collection);
  }
}
function rdatesToString(param, rdates, tzid) {
  var isUTC = !tzid || tzid.toUpperCase() === "UTC";
  var header = isUTC ? "".concat(param, ":") : "".concat(param, ";TZID=").concat(tzid, ":");
  var dateString = rdates.map(function(rdate) {
    return timeToUntilString(rdate.valueOf(), isUTC);
  }).join(",");
  return "".concat(header).concat(dateString);
}

// node_modules/@fullcalendar/rrule/index.js
var recurringType = {
  parse(eventProps, dateEnv) {
    if (eventProps.rrule != null) {
      let eventRRuleData = parseEventRRule(eventProps, dateEnv);
      if (eventRRuleData) {
        return {
          typeData: { rruleSet: eventRRuleData.rruleSet, isTimeZoneSpecified: eventRRuleData.isTimeZoneSpecified },
          allDayGuess: !eventRRuleData.isTimeSpecified,
          duration: eventProps.duration
        };
      }
    }
    return null;
  },
  expand(eventRRuleData, framingRange, dateEnv) {
    let dates;
    if (eventRRuleData.isTimeZoneSpecified) {
      dates = eventRRuleData.rruleSet.between(
        dateEnv.toDate(framingRange.start),
        // rrule lib will treat as UTC-zoned
        dateEnv.toDate(framingRange.end),
        // (same)
        true
      ).map((date) => dateEnv.createMarker(date));
    } else {
      dates = eventRRuleData.rruleSet.between(framingRange.start, framingRange.end, true);
    }
    return dates;
  }
};
function parseEventRRule(eventProps, dateEnv) {
  let rruleSet;
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  if (typeof eventProps.rrule === "string") {
    let res = parseRRuleString(eventProps.rrule);
    rruleSet = res.rruleSet;
    isTimeSpecified = res.isTimeSpecified;
    isTimeZoneSpecified = res.isTimeZoneSpecified;
  }
  if (typeof eventProps.rrule === "object" && eventProps.rrule) {
    let res = parseRRuleObject(eventProps.rrule, dateEnv);
    rruleSet = new RRuleSet();
    rruleSet.rrule(res.rrule);
    isTimeSpecified = res.isTimeSpecified;
    isTimeZoneSpecified = res.isTimeZoneSpecified;
  }
  let exdateInputs = [].concat(eventProps.exdate || []);
  let exruleInputs = [].concat(eventProps.exrule || []);
  for (let exdateInput of exdateInputs) {
    let res = parse(exdateInput);
    isTimeSpecified = isTimeSpecified || !res.isTimeUnspecified;
    isTimeZoneSpecified = isTimeZoneSpecified || res.timeZoneOffset !== null;
    rruleSet.exdate(new Date(res.marker.valueOf() - (res.timeZoneOffset || 0) * 60 * 1e3));
  }
  for (let exruleInput of exruleInputs) {
    let res = parseRRuleObject(exruleInput, dateEnv);
    isTimeSpecified = isTimeSpecified || res.isTimeSpecified;
    isTimeZoneSpecified = isTimeZoneSpecified || res.isTimeZoneSpecified;
    rruleSet.exrule(res.rrule);
  }
  return { rruleSet, isTimeSpecified, isTimeZoneSpecified };
}
function parseRRuleObject(rruleInput, dateEnv) {
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  function processDateInput(dateInput) {
    if (typeof dateInput === "string") {
      let markerData = parse(dateInput);
      if (markerData) {
        isTimeSpecified = isTimeSpecified || !markerData.isTimeUnspecified;
        isTimeZoneSpecified = isTimeZoneSpecified || markerData.timeZoneOffset !== null;
        return new Date(markerData.marker.valueOf() - (markerData.timeZoneOffset || 0) * 60 * 1e3);
      }
      return null;
    }
    return dateInput;
  }
  let rruleOptions = Object.assign(Object.assign({}, rruleInput), { dtstart: processDateInput(rruleInput.dtstart), until: processDateInput(rruleInput.until), freq: convertConstant(rruleInput.freq), wkst: rruleInput.wkst == null ? (dateEnv.weekDow - 1 + 7) % 7 : convertConstant(rruleInput.wkst), byweekday: convertConstants(rruleInput.byweekday) });
  return { rrule: new RRule(rruleOptions), isTimeSpecified, isTimeZoneSpecified };
}
function parseRRuleString(str) {
  let rruleSet = rrulestr(str, { forceset: true });
  let analysis = analyzeRRuleString(str);
  return Object.assign({ rruleSet }, analysis);
}
function analyzeRRuleString(str) {
  let isTimeSpecified = false;
  let isTimeZoneSpecified = false;
  function processMatch(whole, introPart, datePart) {
    let result = parse(datePart);
    isTimeSpecified = isTimeSpecified || !result.isTimeUnspecified;
    isTimeZoneSpecified = isTimeZoneSpecified || result.timeZoneOffset !== null;
  }
  str.replace(/\b(DTSTART:)([^\n]*)/, processMatch);
  str.replace(/\b(EXDATE:)([^\n]*)/, processMatch);
  str.replace(/\b(UNTIL=)([^;\n]*)/, processMatch);
  return { isTimeSpecified, isTimeZoneSpecified };
}
function convertConstants(input) {
  if (Array.isArray(input)) {
    return input.map(convertConstant);
  }
  return convertConstant(input);
}
function convertConstant(input) {
  if (typeof input === "string") {
    return RRule[input.toUpperCase()];
  }
  return input;
}
var RRULE_EVENT_REFINERS = {
  rrule: identity,
  exrule: identity,
  exdate: identity,
  duration: createDuration
};
var index3 = createPlugin({
  name: "@fullcalendar/rrule",
  recurringTypes: [recurringType],
  eventRefiners: RRULE_EVENT_REFINERS
});

// node_modules/@fullcalendar/list/internal.js
var ListViewHeaderRow = class extends BaseComponent {
  constructor() {
    super(...arguments);
    this.state = {
      textId: getUniqueDomId()
    };
  }
  render() {
    let { theme, dateEnv, options, viewApi } = this.context;
    let { cellId, dayDate, todayRange } = this.props;
    let { textId } = this.state;
    let dayMeta = getDateMeta(dayDate, todayRange);
    let text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : "";
    let sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : "";
    let renderProps = Object.assign({
      date: dateEnv.toDate(dayDate),
      view: viewApi,
      textId,
      text,
      sideText,
      navLinkAttrs: buildNavLinkAttrs(this.context, dayDate),
      sideNavLinkAttrs: buildNavLinkAttrs(this.context, dayDate, "day", false)
    }, dayMeta);
    return y(ContentContainer, { elTag: "tr", elClasses: [
      "fc-list-day",
      ...getDayClassNames(dayMeta, theme)
    ], elAttrs: {
      "data-date": formatDayString(dayDate)
    }, renderProps, generatorName: "dayHeaderContent", customGenerator: options.dayHeaderContent, defaultGenerator: renderInnerContent4, classNameGenerator: options.dayHeaderClassNames, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, (InnerContent) => (
      // TODO: force-hide top border based on :first-child
      y(
        "th",
        { scope: "colgroup", colSpan: 3, id: cellId, "aria-labelledby": textId },
        y(InnerContent, { elTag: "div", elClasses: [
          "fc-list-day-cushion",
          theme.getClass("tableCellShaded")
        ] })
      )
    ));
  }
};
function renderInnerContent4(props) {
  return y(
    _,
    null,
    props.text && y("a", Object.assign({ id: props.textId, className: "fc-list-day-text" }, props.navLinkAttrs), props.text),
    props.sideText && /* not keyboard tabbable */
    y("a", Object.assign({ "aria-hidden": true, className: "fc-list-day-side-text" }, props.sideNavLinkAttrs), props.sideText)
  );
}
var DEFAULT_TIME_FORMAT2 = createFormatter({
  hour: "numeric",
  minute: "2-digit",
  meridiem: "short"
});
var ListViewEventRow = class extends BaseComponent {
  render() {
    let { props, context } = this;
    let { options } = context;
    let { seg, timeHeaderId, eventHeaderId, dateHeaderId } = props;
    let timeFormat = options.eventTimeFormat || DEFAULT_TIME_FORMAT2;
    return y(EventContainer, Object.assign({}, props, { elTag: "tr", elClasses: [
      "fc-list-event",
      seg.eventRange.def.url && "fc-event-forced-url"
    ], defaultGenerator: () => renderEventInnerContent(seg, context), seg, timeText: "", disableDragging: true, disableResizing: true }), (InnerContent, eventContentArg) => y(
      _,
      null,
      buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId),
      y(
        "td",
        { "aria-hidden": true, className: "fc-list-event-graphic" },
        y("span", { className: "fc-list-event-dot", style: {
          borderColor: eventContentArg.borderColor || eventContentArg.backgroundColor
        } })
      ),
      y(InnerContent, { elTag: "td", elClasses: ["fc-list-event-title"], elAttrs: { headers: `${eventHeaderId} ${dateHeaderId}` } })
    ));
  }
};
function renderEventInnerContent(seg, context) {
  let interactiveAttrs = getSegAnchorAttrs(seg, context);
  return y("a", Object.assign({}, interactiveAttrs), seg.eventRange.def.title);
}
function buildTimeContent(seg, timeFormat, context, timeHeaderId, dateHeaderId) {
  let { options } = context;
  if (options.displayEventTime !== false) {
    let eventDef = seg.eventRange.def;
    let eventInstance = seg.eventRange.instance;
    let doAllDay = false;
    let timeText;
    if (eventDef.allDay) {
      doAllDay = true;
    } else if (isMultiDayRange(seg.eventRange.range)) {
      if (seg.isStart) {
        timeText = buildSegTimeText(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);
      } else if (seg.isEnd) {
        timeText = buildSegTimeText(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);
      } else {
        doAllDay = true;
      }
    } else {
      timeText = buildSegTimeText(seg, timeFormat, context);
    }
    if (doAllDay) {
      let renderProps = {
        text: context.options.allDayText,
        view: context.viewApi
      };
      return y(ContentContainer, { elTag: "td", elClasses: ["fc-list-event-time"], elAttrs: {
        headers: `${timeHeaderId} ${dateHeaderId}`
      }, renderProps, generatorName: "allDayContent", customGenerator: options.allDayContent, defaultGenerator: renderAllDayInner2, classNameGenerator: options.allDayClassNames, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount });
    }
    return y("td", { className: "fc-list-event-time" }, timeText);
  }
  return null;
}
function renderAllDayInner2(renderProps) {
  return renderProps.text;
}
var ListView = class extends DateComponent {
  constructor() {
    super(...arguments);
    this.computeDateVars = memoize(computeDateVars);
    this.eventStoreToSegs = memoize(this._eventStoreToSegs);
    this.state = {
      timeHeaderId: getUniqueDomId(),
      eventHeaderId: getUniqueDomId(),
      dateHeaderIdRoot: getUniqueDomId()
    };
    this.setRootEl = (rootEl) => {
      if (rootEl) {
        this.context.registerInteractiveComponent(this, {
          el: rootEl
        });
      } else {
        this.context.unregisterInteractiveComponent(this);
      }
    };
  }
  render() {
    let { props, context } = this;
    let { dayDates, dayRanges } = this.computeDateVars(props.dateProfile);
    let eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);
    return y(
      ViewContainer,
      { elRef: this.setRootEl, elClasses: [
        "fc-list",
        context.theme.getClass("table"),
        context.options.stickyHeaderDates !== false ? "fc-list-sticky" : ""
      ], viewSpec: context.viewSpec },
      y(Scroller, { liquid: !props.isHeightAuto, overflowX: props.isHeightAuto ? "visible" : "hidden", overflowY: props.isHeightAuto ? "visible" : "auto" }, eventSegs.length > 0 ? this.renderSegList(eventSegs, dayDates) : this.renderEmptyMessage())
    );
  }
  renderEmptyMessage() {
    let { options, viewApi } = this.context;
    let renderProps = {
      text: options.noEventsText,
      view: viewApi
    };
    return y(ContentContainer, { elTag: "div", elClasses: ["fc-list-empty"], renderProps, generatorName: "noEventsContent", customGenerator: options.noEventsContent, defaultGenerator: renderNoEventsInner, classNameGenerator: options.noEventsClassNames, didMount: options.noEventsDidMount, willUnmount: options.noEventsWillUnmount }, (InnerContent) => y(InnerContent, { elTag: "div", elClasses: ["fc-list-empty-cushion"] }));
  }
  renderSegList(allSegs, dayDates) {
    let { theme, options } = this.context;
    let { timeHeaderId, eventHeaderId, dateHeaderIdRoot } = this.state;
    let segsByDay = groupSegsByDay(allSegs);
    return y(NowTimer, { unit: "day" }, (nowDate, todayRange) => {
      let innerNodes = [];
      for (let dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1) {
        let daySegs = segsByDay[dayIndex];
        if (daySegs) {
          let dayStr = formatDayString(dayDates[dayIndex]);
          let dateHeaderId = dateHeaderIdRoot + "-" + dayStr;
          innerNodes.push(y(ListViewHeaderRow, { key: dayStr, cellId: dateHeaderId, dayDate: dayDates[dayIndex], todayRange }));
          daySegs = sortEventSegs(daySegs, options.eventOrder);
          for (let seg of daySegs) {
            innerNodes.push(y(ListViewEventRow, Object.assign({ key: dayStr + ":" + seg.eventRange.instance.instanceId, seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, timeHeaderId, eventHeaderId, dateHeaderId }, getSegMeta(seg, todayRange, nowDate))));
          }
        }
      }
      return y(
        "table",
        { className: "fc-list-table " + theme.getClass("table") },
        y(
          "thead",
          null,
          y(
            "tr",
            null,
            y("th", { scope: "col", id: timeHeaderId }, options.timeHint),
            y("th", { scope: "col", "aria-hidden": true }),
            y("th", { scope: "col", id: eventHeaderId }, options.eventHint)
          )
        ),
        y("tbody", null, innerNodes)
      );
    });
  }
  _eventStoreToSegs(eventStore, eventUiBases, dayRanges) {
    return this.eventRangesToSegs(sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);
  }
  eventRangesToSegs(eventRanges, dayRanges) {
    let segs = [];
    for (let eventRange of eventRanges) {
      segs.push(...this.eventRangeToSegs(eventRange, dayRanges));
    }
    return segs;
  }
  eventRangeToSegs(eventRange, dayRanges) {
    let { dateEnv } = this.context;
    let { nextDayThreshold } = this.context.options;
    let range2 = eventRange.range;
    let allDay = eventRange.def.allDay;
    let dayIndex;
    let segRange;
    let seg;
    let segs = [];
    for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1) {
      segRange = intersectRanges(range2, dayRanges[dayIndex]);
      if (segRange) {
        seg = {
          component: this,
          eventRange,
          start: segRange.start,
          end: segRange.end,
          isStart: eventRange.isStart && segRange.start.valueOf() === range2.start.valueOf(),
          isEnd: eventRange.isEnd && segRange.end.valueOf() === range2.end.valueOf(),
          dayIndex
        };
        segs.push(seg);
        if (!seg.isEnd && !allDay && dayIndex + 1 < dayRanges.length && range2.end < dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {
          seg.end = range2.end;
          seg.isEnd = true;
          break;
        }
      }
    }
    return segs;
  }
};
function renderNoEventsInner(renderProps) {
  return renderProps.text;
}
function computeDateVars(dateProfile) {
  let dayStart = startOfDay(dateProfile.renderRange.start);
  let viewEnd = dateProfile.renderRange.end;
  let dayDates = [];
  let dayRanges = [];
  while (dayStart < viewEnd) {
    dayDates.push(dayStart);
    dayRanges.push({
      start: dayStart,
      end: addDays(dayStart, 1)
    });
    dayStart = addDays(dayStart, 1);
  }
  return { dayDates, dayRanges };
}
function groupSegsByDay(segs) {
  let segsByDay = [];
  let i3;
  let seg;
  for (i3 = 0; i3 < segs.length; i3 += 1) {
    seg = segs[i3];
    (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = [])).push(seg);
  }
  return segsByDay;
}
var css_248z4 = ':root{--fc-list-event-dot-width:10px;--fc-list-event-hover-bg-color:#f5f5f5}.fc-theme-standard .fc-list{border:1px solid var(--fc-border-color)}.fc .fc-list-empty{align-items:center;background-color:var(--fc-neutral-bg-color);display:flex;height:100%;justify-content:center}.fc .fc-list-empty-cushion{margin:5em 0}.fc .fc-list-table{border-style:hidden;width:100%}.fc .fc-list-table tr>*{border-left:0;border-right:0}.fc .fc-list-sticky .fc-list-day>*{background:var(--fc-page-bg-color);position:sticky;top:0}.fc .fc-list-table thead{left:-10000px;position:absolute}.fc .fc-list-table tbody>tr:first-child th{border-top:0}.fc .fc-list-table th{padding:0}.fc .fc-list-day-cushion,.fc .fc-list-table td{padding:8px 14px}.fc .fc-list-day-cushion:after{clear:both;content:"";display:table}.fc-theme-standard .fc-list-day-cushion{background-color:var(--fc-neutral-bg-color)}.fc-direction-ltr .fc-list-day-text,.fc-direction-rtl .fc-list-day-side-text{float:left}.fc-direction-ltr .fc-list-day-side-text,.fc-direction-rtl .fc-list-day-text{float:right}.fc-direction-ltr .fc-list-table .fc-list-event-graphic{padding-right:0}.fc-direction-rtl .fc-list-table .fc-list-event-graphic{padding-left:0}.fc .fc-list-event.fc-event-forced-url{cursor:pointer}.fc .fc-list-event:hover td{background-color:var(--fc-list-event-hover-bg-color)}.fc .fc-list-event-graphic,.fc .fc-list-event-time{white-space:nowrap;width:1px}.fc .fc-list-event-dot{border:calc(var(--fc-list-event-dot-width)/2) solid var(--fc-event-border-color);border-radius:calc(var(--fc-list-event-dot-width)/2);box-sizing:content-box;display:inline-block;height:0;width:0}.fc .fc-list-event-title a{color:inherit;text-decoration:none}.fc .fc-list-event.fc-event-forced-url:hover a{text-decoration:underline}';
injectStyles(css_248z4);

// node_modules/@fullcalendar/list/index.js
var OPTION_REFINERS2 = {
  listDayFormat: createFalsableFormatter,
  listDaySideFormat: createFalsableFormatter,
  noEventsClassNames: identity,
  noEventsContent: identity,
  noEventsDidMount: identity,
  noEventsWillUnmount: identity
  // noEventsText is defined in base options
};
function createFalsableFormatter(input) {
  return input === false ? null : createFormatter(input);
}
var index4 = createPlugin({
  name: "@fullcalendar/list",
  optionRefiners: OPTION_REFINERS2,
  views: {
    list: {
      component: ListView,
      buttonTextKey: "list",
      listDayFormat: { month: "long", day: "numeric", year: "numeric" }
      // like "January 1, 2016"
    },
    listDay: {
      type: "list",
      duration: { days: 1 },
      listDayFormat: { weekday: "long" }
      // day-of-week is all we need. full date is probably in headerToolbar
    },
    listWeek: {
      type: "list",
      duration: { weeks: 1 },
      listDayFormat: { weekday: "long" },
      listDaySideFormat: { month: "long", day: "numeric", year: "numeric" }
    },
    listMonth: {
      type: "list",
      duration: { month: 1 },
      listDaySideFormat: { weekday: "long" }
      // day-of-week is nice-to-have
    },
    listYear: {
      type: "list",
      duration: { year: 1 },
      listDaySideFormat: { weekday: "long" }
      // day-of-week is nice-to-have
    }
  }
});

// node_modules/@fullcalendar/interaction/index.js
config.touchMouseIgnoreWait = 500;
var ignoreMouseDepth = 0;
var listenerCnt = 0;
var isWindowTouchMoveCancelled = false;
var PointerDragging = class {
  constructor(containerEl) {
    this.subjectEl = null;
    this.selector = "";
    this.handleSelector = "";
    this.shouldIgnoreMove = false;
    this.shouldWatchScroll = true;
    this.isDragging = false;
    this.isTouchDragging = false;
    this.wasTouchScroll = false;
    this.handleMouseDown = (ev) => {
      if (!this.shouldIgnoreMouse() && isPrimaryMouseButton(ev) && this.tryStart(ev)) {
        let pev = this.createEventFromMouse(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        if (!this.shouldIgnoreMove) {
          document.addEventListener("mousemove", this.handleMouseMove);
        }
        document.addEventListener("mouseup", this.handleMouseUp);
      }
    };
    this.handleMouseMove = (ev) => {
      let pev = this.createEventFromMouse(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleMouseUp = (ev) => {
      document.removeEventListener("mousemove", this.handleMouseMove);
      document.removeEventListener("mouseup", this.handleMouseUp);
      this.emitter.trigger("pointerup", this.createEventFromMouse(ev));
      this.cleanup();
    };
    this.handleTouchStart = (ev) => {
      if (this.tryStart(ev)) {
        this.isTouchDragging = true;
        let pev = this.createEventFromTouch(ev, true);
        this.emitter.trigger("pointerdown", pev);
        this.initScrollWatch(pev);
        let targetEl = ev.target;
        if (!this.shouldIgnoreMove) {
          targetEl.addEventListener("touchmove", this.handleTouchMove);
        }
        targetEl.addEventListener("touchend", this.handleTouchEnd);
        targetEl.addEventListener("touchcancel", this.handleTouchEnd);
        window.addEventListener("scroll", this.handleTouchScroll, true);
      }
    };
    this.handleTouchMove = (ev) => {
      let pev = this.createEventFromTouch(ev);
      this.recordCoords(pev);
      this.emitter.trigger("pointermove", pev);
    };
    this.handleTouchEnd = (ev) => {
      if (this.isDragging) {
        let targetEl = ev.target;
        targetEl.removeEventListener("touchmove", this.handleTouchMove);
        targetEl.removeEventListener("touchend", this.handleTouchEnd);
        targetEl.removeEventListener("touchcancel", this.handleTouchEnd);
        window.removeEventListener("scroll", this.handleTouchScroll, true);
        this.emitter.trigger("pointerup", this.createEventFromTouch(ev));
        this.cleanup();
        this.isTouchDragging = false;
        startIgnoringMouse();
      }
    };
    this.handleTouchScroll = () => {
      this.wasTouchScroll = true;
    };
    this.handleScroll = (ev) => {
      if (!this.shouldIgnoreMove) {
        let pageX = window.scrollX - this.prevScrollX + this.prevPageX;
        let pageY = window.scrollY - this.prevScrollY + this.prevPageY;
        this.emitter.trigger("pointermove", {
          origEvent: ev,
          isTouch: this.isTouchDragging,
          subjectEl: this.subjectEl,
          pageX,
          pageY,
          deltaX: pageX - this.origPageX,
          deltaY: pageY - this.origPageY
        });
      }
    };
    this.containerEl = containerEl;
    this.emitter = new Emitter();
    containerEl.addEventListener("mousedown", this.handleMouseDown);
    containerEl.addEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerCreated();
  }
  destroy() {
    this.containerEl.removeEventListener("mousedown", this.handleMouseDown);
    this.containerEl.removeEventListener("touchstart", this.handleTouchStart, { passive: true });
    listenerDestroyed();
  }
  tryStart(ev) {
    let subjectEl = this.querySubjectEl(ev);
    let downEl = ev.target;
    if (subjectEl && (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {
      this.subjectEl = subjectEl;
      this.isDragging = true;
      this.wasTouchScroll = false;
      return true;
    }
    return false;
  }
  cleanup() {
    isWindowTouchMoveCancelled = false;
    this.isDragging = false;
    this.subjectEl = null;
    this.destroyScrollWatch();
  }
  querySubjectEl(ev) {
    if (this.selector) {
      return elementClosest(ev.target, this.selector);
    }
    return this.containerEl;
  }
  shouldIgnoreMouse() {
    return ignoreMouseDepth || this.isTouchDragging;
  }
  // can be called by user of this class, to cancel touch-based scrolling for the current drag
  cancelTouchScroll() {
    if (this.isDragging) {
      isWindowTouchMoveCancelled = true;
    }
  }
  // Scrolling that simulates pointermoves
  // ----------------------------------------------------------------------------------------------------
  initScrollWatch(ev) {
    if (this.shouldWatchScroll) {
      this.recordCoords(ev);
      window.addEventListener("scroll", this.handleScroll, true);
    }
  }
  recordCoords(ev) {
    if (this.shouldWatchScroll) {
      this.prevPageX = ev.pageX;
      this.prevPageY = ev.pageY;
      this.prevScrollX = window.scrollX;
      this.prevScrollY = window.scrollY;
    }
  }
  destroyScrollWatch() {
    if (this.shouldWatchScroll) {
      window.removeEventListener("scroll", this.handleScroll, true);
    }
  }
  // Event Normalization
  // ----------------------------------------------------------------------------------------------------
  createEventFromMouse(ev, isFirst) {
    let deltaX = 0;
    let deltaY = 0;
    if (isFirst) {
      this.origPageX = ev.pageX;
      this.origPageY = ev.pageY;
    } else {
      deltaX = ev.pageX - this.origPageX;
      deltaY = ev.pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: false,
      subjectEl: this.subjectEl,
      pageX: ev.pageX,
      pageY: ev.pageY,
      deltaX,
      deltaY
    };
  }
  createEventFromTouch(ev, isFirst) {
    let touches = ev.touches;
    let pageX;
    let pageY;
    let deltaX = 0;
    let deltaY = 0;
    if (touches && touches.length) {
      pageX = touches[0].pageX;
      pageY = touches[0].pageY;
    } else {
      pageX = ev.pageX;
      pageY = ev.pageY;
    }
    if (isFirst) {
      this.origPageX = pageX;
      this.origPageY = pageY;
    } else {
      deltaX = pageX - this.origPageX;
      deltaY = pageY - this.origPageY;
    }
    return {
      origEvent: ev,
      isTouch: true,
      subjectEl: this.subjectEl,
      pageX,
      pageY,
      deltaX,
      deltaY
    };
  }
};
function isPrimaryMouseButton(ev) {
  return ev.button === 0 && !ev.ctrlKey;
}
function startIgnoringMouse() {
  ignoreMouseDepth += 1;
  setTimeout(() => {
    ignoreMouseDepth -= 1;
  }, config.touchMouseIgnoreWait);
}
function listenerCreated() {
  listenerCnt += 1;
  if (listenerCnt === 1) {
    window.addEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function listenerDestroyed() {
  listenerCnt -= 1;
  if (!listenerCnt) {
    window.removeEventListener("touchmove", onWindowTouchMove, { passive: false });
  }
}
function onWindowTouchMove(ev) {
  if (isWindowTouchMoveCancelled) {
    ev.preventDefault();
  }
}
var ElementMirror = class {
  constructor() {
    this.isVisible = false;
    this.sourceEl = null;
    this.mirrorEl = null;
    this.sourceElRect = null;
    this.parentNode = document.body;
    this.zIndex = 9999;
    this.revertDuration = 0;
  }
  start(sourceEl, pageX, pageY) {
    this.sourceEl = sourceEl;
    this.sourceElRect = this.sourceEl.getBoundingClientRect();
    this.origScreenX = pageX - window.scrollX;
    this.origScreenY = pageY - window.scrollY;
    this.deltaX = 0;
    this.deltaY = 0;
    this.updateElPosition();
  }
  handleMove(pageX, pageY) {
    this.deltaX = pageX - window.scrollX - this.origScreenX;
    this.deltaY = pageY - window.scrollY - this.origScreenY;
    this.updateElPosition();
  }
  // can be called before start
  setIsVisible(bool) {
    if (bool) {
      if (!this.isVisible) {
        if (this.mirrorEl) {
          this.mirrorEl.style.display = "";
        }
        this.isVisible = bool;
        this.updateElPosition();
      }
    } else if (this.isVisible) {
      if (this.mirrorEl) {
        this.mirrorEl.style.display = "none";
      }
      this.isVisible = bool;
    }
  }
  // always async
  stop(needsRevertAnimation, callback) {
    let done = () => {
      this.cleanup();
      callback();
    };
    if (needsRevertAnimation && this.mirrorEl && this.isVisible && this.revertDuration && // if 0, transition won't work
    (this.deltaX || this.deltaY)) {
      this.doRevertAnimation(done, this.revertDuration);
    } else {
      setTimeout(done, 0);
    }
  }
  doRevertAnimation(callback, revertDuration) {
    let mirrorEl = this.mirrorEl;
    let finalSourceElRect = this.sourceEl.getBoundingClientRect();
    mirrorEl.style.transition = "top " + revertDuration + "ms,left " + revertDuration + "ms";
    applyStyle(mirrorEl, {
      left: finalSourceElRect.left,
      top: finalSourceElRect.top
    });
    whenTransitionDone(mirrorEl, () => {
      mirrorEl.style.transition = "";
      callback();
    });
  }
  cleanup() {
    if (this.mirrorEl) {
      removeElement(this.mirrorEl);
      this.mirrorEl = null;
    }
    this.sourceEl = null;
  }
  updateElPosition() {
    if (this.sourceEl && this.isVisible) {
      applyStyle(this.getMirrorEl(), {
        left: this.sourceElRect.left + this.deltaX,
        top: this.sourceElRect.top + this.deltaY
      });
    }
  }
  getMirrorEl() {
    let sourceElRect = this.sourceElRect;
    let mirrorEl = this.mirrorEl;
    if (!mirrorEl) {
      mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true);
      mirrorEl.style.userSelect = "none";
      mirrorEl.style.webkitUserSelect = "none";
      mirrorEl.style.pointerEvents = "none";
      mirrorEl.classList.add("fc-event-dragging");
      applyStyle(mirrorEl, {
        position: "fixed",
        zIndex: this.zIndex,
        visibility: "",
        boxSizing: "border-box",
        width: sourceElRect.right - sourceElRect.left,
        height: sourceElRect.bottom - sourceElRect.top,
        right: "auto",
        bottom: "auto",
        margin: 0
      });
      this.parentNode.appendChild(mirrorEl);
    }
    return mirrorEl;
  }
};
var ScrollGeomCache = class extends ScrollController {
  constructor(scrollController, doesListening) {
    super();
    this.handleScroll = () => {
      this.scrollTop = this.scrollController.getScrollTop();
      this.scrollLeft = this.scrollController.getScrollLeft();
      this.handleScrollChange();
    };
    this.scrollController = scrollController;
    this.doesListening = doesListening;
    this.scrollTop = this.origScrollTop = scrollController.getScrollTop();
    this.scrollLeft = this.origScrollLeft = scrollController.getScrollLeft();
    this.scrollWidth = scrollController.getScrollWidth();
    this.scrollHeight = scrollController.getScrollHeight();
    this.clientWidth = scrollController.getClientWidth();
    this.clientHeight = scrollController.getClientHeight();
    this.clientRect = this.computeClientRect();
    if (this.doesListening) {
      this.getEventTarget().addEventListener("scroll", this.handleScroll);
    }
  }
  destroy() {
    if (this.doesListening) {
      this.getEventTarget().removeEventListener("scroll", this.handleScroll);
    }
  }
  getScrollTop() {
    return this.scrollTop;
  }
  getScrollLeft() {
    return this.scrollLeft;
  }
  setScrollTop(top) {
    this.scrollController.setScrollTop(top);
    if (!this.doesListening) {
      this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);
      this.handleScrollChange();
    }
  }
  setScrollLeft(top) {
    this.scrollController.setScrollLeft(top);
    if (!this.doesListening) {
      this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);
      this.handleScrollChange();
    }
  }
  getClientWidth() {
    return this.clientWidth;
  }
  getClientHeight() {
    return this.clientHeight;
  }
  getScrollWidth() {
    return this.scrollWidth;
  }
  getScrollHeight() {
    return this.scrollHeight;
  }
  handleScrollChange() {
  }
};
var ElementScrollGeomCache = class extends ScrollGeomCache {
  constructor(el, doesListening) {
    super(new ElementScrollController(el), doesListening);
  }
  getEventTarget() {
    return this.scrollController.el;
  }
  computeClientRect() {
    return computeInnerRect(this.scrollController.el);
  }
};
var WindowScrollGeomCache = class extends ScrollGeomCache {
  constructor(doesListening) {
    super(new WindowScrollController(), doesListening);
  }
  getEventTarget() {
    return window;
  }
  computeClientRect() {
    return {
      left: this.scrollLeft,
      right: this.scrollLeft + this.clientWidth,
      top: this.scrollTop,
      bottom: this.scrollTop + this.clientHeight
    };
  }
  // the window is the only scroll object that changes it's rectangle relative
  // to the document's topleft as it scrolls
  handleScrollChange() {
    this.clientRect = this.computeClientRect();
  }
};
var getTime = typeof performance === "function" ? performance.now : Date.now;
var AutoScroller = class {
  constructor() {
    this.isEnabled = true;
    this.scrollQuery = [window, ".fc-scroller"];
    this.edgeThreshold = 50;
    this.maxVelocity = 300;
    this.pointerScreenX = null;
    this.pointerScreenY = null;
    this.isAnimating = false;
    this.scrollCaches = null;
    this.everMovedUp = false;
    this.everMovedDown = false;
    this.everMovedLeft = false;
    this.everMovedRight = false;
    this.animate = () => {
      if (this.isAnimating) {
        let edge = this.computeBestEdge(this.pointerScreenX + window.scrollX, this.pointerScreenY + window.scrollY);
        if (edge) {
          let now = getTime();
          this.handleSide(edge, (now - this.msSinceRequest) / 1e3);
          this.requestAnimation(now);
        } else {
          this.isAnimating = false;
        }
      }
    };
  }
  start(pageX, pageY, scrollStartEl) {
    if (this.isEnabled) {
      this.scrollCaches = this.buildCaches(scrollStartEl);
      this.pointerScreenX = null;
      this.pointerScreenY = null;
      this.everMovedUp = false;
      this.everMovedDown = false;
      this.everMovedLeft = false;
      this.everMovedRight = false;
      this.handleMove(pageX, pageY);
    }
  }
  handleMove(pageX, pageY) {
    if (this.isEnabled) {
      let pointerScreenX = pageX - window.scrollX;
      let pointerScreenY = pageY - window.scrollY;
      let yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;
      let xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;
      if (yDelta < 0) {
        this.everMovedUp = true;
      } else if (yDelta > 0) {
        this.everMovedDown = true;
      }
      if (xDelta < 0) {
        this.everMovedLeft = true;
      } else if (xDelta > 0) {
        this.everMovedRight = true;
      }
      this.pointerScreenX = pointerScreenX;
      this.pointerScreenY = pointerScreenY;
      if (!this.isAnimating) {
        this.isAnimating = true;
        this.requestAnimation(getTime());
      }
    }
  }
  stop() {
    if (this.isEnabled) {
      this.isAnimating = false;
      for (let scrollCache of this.scrollCaches) {
        scrollCache.destroy();
      }
      this.scrollCaches = null;
    }
  }
  requestAnimation(now) {
    this.msSinceRequest = now;
    requestAnimationFrame(this.animate);
  }
  handleSide(edge, seconds) {
    let { scrollCache } = edge;
    let { edgeThreshold } = this;
    let invDistance = edgeThreshold - edge.distance;
    let velocity = (
      // the closer to the edge, the faster we scroll
      invDistance * invDistance / (edgeThreshold * edgeThreshold) * // quadratic
      this.maxVelocity * seconds
    );
    let sign = 1;
    switch (edge.name) {
      case "left":
        sign = -1;
      case "right":
        scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);
        break;
      case "top":
        sign = -1;
      case "bottom":
        scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);
        break;
    }
  }
  // left/top are relative to document topleft
  computeBestEdge(left, top) {
    let { edgeThreshold } = this;
    let bestSide = null;
    let scrollCaches = this.scrollCaches || [];
    for (let scrollCache of scrollCaches) {
      let rect = scrollCache.clientRect;
      let leftDist = left - rect.left;
      let rightDist = rect.right - left;
      let topDist = top - rect.top;
      let bottomDist = rect.bottom - top;
      if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {
        if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() && (!bestSide || bestSide.distance > topDist)) {
          bestSide = { scrollCache, name: "top", distance: topDist };
        }
        if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() && (!bestSide || bestSide.distance > bottomDist)) {
          bestSide = { scrollCache, name: "bottom", distance: bottomDist };
        }
        if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() && (!bestSide || bestSide.distance > leftDist)) {
          bestSide = { scrollCache, name: "left", distance: leftDist };
        }
        if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() && (!bestSide || bestSide.distance > rightDist)) {
          bestSide = { scrollCache, name: "right", distance: rightDist };
        }
      }
    }
    return bestSide;
  }
  buildCaches(scrollStartEl) {
    return this.queryScrollEls(scrollStartEl).map((el) => {
      if (el === window) {
        return new WindowScrollGeomCache(false);
      }
      return new ElementScrollGeomCache(el, false);
    });
  }
  queryScrollEls(scrollStartEl) {
    let els = [];
    for (let query of this.scrollQuery) {
      if (typeof query === "object") {
        els.push(query);
      } else {
        els.push(...Array.prototype.slice.call(scrollStartEl.getRootNode().querySelectorAll(query)));
      }
    }
    return els;
  }
};
var FeaturefulElementDragging = class extends ElementDragging {
  constructor(containerEl, selector) {
    super(containerEl);
    this.containerEl = containerEl;
    this.delay = null;
    this.minDistance = 0;
    this.touchScrollAllowed = true;
    this.mirrorNeedsRevert = false;
    this.isInteracting = false;
    this.isDragging = false;
    this.isDelayEnded = false;
    this.isDistanceSurpassed = false;
    this.delayTimeoutId = null;
    this.onPointerDown = (ev) => {
      if (!this.isDragging) {
        this.isInteracting = true;
        this.isDelayEnded = false;
        this.isDistanceSurpassed = false;
        preventSelection(document.body);
        preventContextMenu(document.body);
        if (!ev.isTouch) {
          ev.origEvent.preventDefault();
        }
        this.emitter.trigger("pointerdown", ev);
        if (this.isInteracting && // not destroyed via pointerdown handler
        !this.pointer.shouldIgnoreMove) {
          this.mirror.setIsVisible(false);
          this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY);
          this.startDelay(ev);
          if (!this.minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
      }
    };
    this.onPointerMove = (ev) => {
      if (this.isInteracting) {
        this.emitter.trigger("pointermove", ev);
        if (!this.isDistanceSurpassed) {
          let minDistance = this.minDistance;
          let distanceSq;
          let { deltaX, deltaY } = ev;
          distanceSq = deltaX * deltaX + deltaY * deltaY;
          if (distanceSq >= minDistance * minDistance) {
            this.handleDistanceSurpassed(ev);
          }
        }
        if (this.isDragging) {
          if (ev.origEvent.type !== "scroll") {
            this.mirror.handleMove(ev.pageX, ev.pageY);
            this.autoScroller.handleMove(ev.pageX, ev.pageY);
          }
          this.emitter.trigger("dragmove", ev);
        }
      }
    };
    this.onPointerUp = (ev) => {
      if (this.isInteracting) {
        this.isInteracting = false;
        allowSelection(document.body);
        allowContextMenu(document.body);
        this.emitter.trigger("pointerup", ev);
        if (this.isDragging) {
          this.autoScroller.stop();
          this.tryStopDrag(ev);
        }
        if (this.delayTimeoutId) {
          clearTimeout(this.delayTimeoutId);
          this.delayTimeoutId = null;
        }
      }
    };
    let pointer = this.pointer = new PointerDragging(containerEl);
    pointer.emitter.on("pointerdown", this.onPointerDown);
    pointer.emitter.on("pointermove", this.onPointerMove);
    pointer.emitter.on("pointerup", this.onPointerUp);
    if (selector) {
      pointer.selector = selector;
    }
    this.mirror = new ElementMirror();
    this.autoScroller = new AutoScroller();
  }
  destroy() {
    this.pointer.destroy();
    this.onPointerUp({});
  }
  startDelay(ev) {
    if (typeof this.delay === "number") {
      this.delayTimeoutId = setTimeout(() => {
        this.delayTimeoutId = null;
        this.handleDelayEnd(ev);
      }, this.delay);
    } else {
      this.handleDelayEnd(ev);
    }
  }
  handleDelayEnd(ev) {
    this.isDelayEnded = true;
    this.tryStartDrag(ev);
  }
  handleDistanceSurpassed(ev) {
    this.isDistanceSurpassed = true;
    this.tryStartDrag(ev);
  }
  tryStartDrag(ev) {
    if (this.isDelayEnded && this.isDistanceSurpassed) {
      if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {
        this.isDragging = true;
        this.mirrorNeedsRevert = false;
        this.autoScroller.start(ev.pageX, ev.pageY, this.containerEl);
        this.emitter.trigger("dragstart", ev);
        if (this.touchScrollAllowed === false) {
          this.pointer.cancelTouchScroll();
        }
      }
    }
  }
  tryStopDrag(ev) {
    this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));
  }
  stopDrag(ev) {
    this.isDragging = false;
    this.emitter.trigger("dragend", ev);
  }
  // fill in the implementations...
  setIgnoreMove(bool) {
    this.pointer.shouldIgnoreMove = bool;
  }
  setMirrorIsVisible(bool) {
    this.mirror.setIsVisible(bool);
  }
  setMirrorNeedsRevert(bool) {
    this.mirrorNeedsRevert = bool;
  }
  setAutoScrollEnabled(bool) {
    this.autoScroller.isEnabled = bool;
  }
};
var OffsetTracker = class {
  constructor(el) {
    this.el = el;
    this.origRect = computeRect(el);
    this.scrollCaches = getClippingParents(el).map((scrollEl) => new ElementScrollGeomCache(scrollEl, true));
  }
  destroy() {
    for (let scrollCache of this.scrollCaches) {
      scrollCache.destroy();
    }
  }
  computeLeft() {
    let left = this.origRect.left;
    for (let scrollCache of this.scrollCaches) {
      left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();
    }
    return left;
  }
  computeTop() {
    let top = this.origRect.top;
    for (let scrollCache of this.scrollCaches) {
      top += scrollCache.origScrollTop - scrollCache.getScrollTop();
    }
    return top;
  }
  isWithinClipping(pageX, pageY) {
    let point = { left: pageX, top: pageY };
    for (let scrollCache of this.scrollCaches) {
      if (!isIgnoredClipping(scrollCache.getEventTarget()) && !pointInsideRect(point, scrollCache.clientRect)) {
        return false;
      }
    }
    return true;
  }
};
function isIgnoredClipping(node) {
  let tagName = node.tagName;
  return tagName === "HTML" || tagName === "BODY";
}
var HitDragging = class {
  constructor(dragging, droppableStore) {
    this.useSubjectCenter = false;
    this.requireInitial = true;
    this.disablePointCheck = false;
    this.initialHit = null;
    this.movingHit = null;
    this.finalHit = null;
    this.handlePointerDown = (ev) => {
      let { dragging: dragging2 } = this;
      this.initialHit = null;
      this.movingHit = null;
      this.finalHit = null;
      this.prepareHits();
      this.processFirstCoord(ev);
      if (this.initialHit || !this.requireInitial) {
        dragging2.setIgnoreMove(false);
        this.emitter.trigger("pointerdown", ev);
      } else {
        dragging2.setIgnoreMove(true);
      }
    };
    this.handleDragStart = (ev) => {
      this.emitter.trigger("dragstart", ev);
      this.handleMove(ev, true);
    };
    this.handleDragMove = (ev) => {
      this.emitter.trigger("dragmove", ev);
      this.handleMove(ev);
    };
    this.handlePointerUp = (ev) => {
      this.releaseHits();
      this.emitter.trigger("pointerup", ev);
    };
    this.handleDragEnd = (ev) => {
      if (this.movingHit) {
        this.emitter.trigger("hitupdate", null, true, ev);
      }
      this.finalHit = this.movingHit;
      this.movingHit = null;
      this.emitter.trigger("dragend", ev);
    };
    this.droppableStore = droppableStore;
    dragging.emitter.on("pointerdown", this.handlePointerDown);
    dragging.emitter.on("dragstart", this.handleDragStart);
    dragging.emitter.on("dragmove", this.handleDragMove);
    dragging.emitter.on("pointerup", this.handlePointerUp);
    dragging.emitter.on("dragend", this.handleDragEnd);
    this.dragging = dragging;
    this.emitter = new Emitter();
  }
  // sets initialHit
  // sets coordAdjust
  processFirstCoord(ev) {
    let origPoint = { left: ev.pageX, top: ev.pageY };
    let adjustedPoint = origPoint;
    let subjectEl = ev.subjectEl;
    let subjectRect;
    if (subjectEl instanceof HTMLElement) {
      subjectRect = computeRect(subjectEl);
      adjustedPoint = constrainPoint(adjustedPoint, subjectRect);
    }
    let initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);
    if (initialHit) {
      if (this.useSubjectCenter && subjectRect) {
        let slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);
        if (slicedSubjectRect) {
          adjustedPoint = getRectCenter(slicedSubjectRect);
        }
      }
      this.coordAdjust = diffPoints(adjustedPoint, origPoint);
    } else {
      this.coordAdjust = { left: 0, top: 0 };
    }
  }
  handleMove(ev, forceHandle) {
    let hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);
    if (forceHandle || !isHitsEqual(this.movingHit, hit)) {
      this.movingHit = hit;
      this.emitter.trigger("hitupdate", hit, false, ev);
    }
  }
  prepareHits() {
    this.offsetTrackers = mapHash(this.droppableStore, (interactionSettings) => {
      interactionSettings.component.prepareHits();
      return new OffsetTracker(interactionSettings.el);
    });
  }
  releaseHits() {
    let { offsetTrackers } = this;
    for (let id in offsetTrackers) {
      offsetTrackers[id].destroy();
    }
    this.offsetTrackers = {};
  }
  queryHitForOffset(offsetLeft, offsetTop) {
    let { droppableStore, offsetTrackers } = this;
    let bestHit = null;
    for (let id in droppableStore) {
      let component = droppableStore[id].component;
      let offsetTracker = offsetTrackers[id];
      if (offsetTracker && // wasn't destroyed mid-drag
      offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {
        let originLeft = offsetTracker.computeLeft();
        let originTop = offsetTracker.computeTop();
        let positionLeft = offsetLeft - originLeft;
        let positionTop = offsetTop - originTop;
        let { origRect } = offsetTracker;
        let width = origRect.right - origRect.left;
        let height = origRect.bottom - origRect.top;
        if (
          // must be within the element's bounds
          positionLeft >= 0 && positionLeft < width && positionTop >= 0 && positionTop < height
        ) {
          let hit = component.queryHit(positionLeft, positionTop, width, height);
          if (hit && // make sure the hit is within activeRange, meaning it's not a dead cell
          rangeContainsRange(hit.dateProfile.activeRange, hit.dateSpan.range) && // Ensure the component we are querying for the hit is accessibly my the pointer
          // Prevents obscured calendars (ex: under a modal dialog) from accepting hit
          // https://github.com/fullcalendar/fullcalendar/issues/5026
          (this.disablePointCheck || offsetTracker.el.contains(offsetTracker.el.getRootNode().elementFromPoint(
            // add-back origins to get coordinate relative to top-left of window viewport
            positionLeft + originLeft - window.scrollX,
            positionTop + originTop - window.scrollY
          ))) && (!bestHit || hit.layer > bestHit.layer)) {
            hit.componentId = id;
            hit.context = component.context;
            hit.rect.left += originLeft;
            hit.rect.right += originLeft;
            hit.rect.top += originTop;
            hit.rect.bottom += originTop;
            bestHit = hit;
          }
        }
      }
    }
    return bestHit;
  }
};
function isHitsEqual(hit0, hit1) {
  if (!hit0 && !hit1) {
    return true;
  }
  if (Boolean(hit0) !== Boolean(hit1)) {
    return false;
  }
  return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);
}
function buildDatePointApiWithContext(dateSpan, context) {
  let props = {};
  for (let transform of context.pluginHooks.datePointTransforms) {
    Object.assign(props, transform(dateSpan, context));
  }
  Object.assign(props, buildDatePointApi(dateSpan, context.dateEnv));
  return props;
}
function buildDatePointApi(span, dateEnv) {
  return {
    date: dateEnv.toDate(span.range.start),
    dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),
    allDay: span.allDay
  };
}
var DateClicking = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.handlePointerDown = (pev) => {
      let { dragging } = this;
      let downEl = pev.origEvent.target;
      dragging.setIgnoreMove(!this.component.isValidDateDownEl(downEl));
    };
    this.handleDragEnd = (ev) => {
      let { component } = this;
      let { pointer } = this.dragging;
      if (!pointer.wasTouchScroll) {
        let { initialHit, finalHit } = this.hitDragging;
        if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {
          let { context } = component;
          let arg = Object.assign(Object.assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context.viewApi || context.calendarApi.view });
          context.emitter.trigger("dateClick", arg);
        }
      }
    };
    this.dragging = new FeaturefulElementDragging(settings.el);
    this.dragging.autoScroller.isEnabled = false;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
};
var DateSelecting = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.dragSelection = null;
    this.handlePointerDown = (ev) => {
      let { component: component2, dragging: dragging2 } = this;
      let { options: options2 } = component2.context;
      let canSelect = options2.selectable && component2.isValidDateDownEl(ev.origEvent.target);
      dragging2.setIgnoreMove(!canSelect);
      dragging2.delay = ev.isTouch ? getComponentTouchDelay$1(component2) : null;
    };
    this.handleDragStart = (ev) => {
      this.component.context.calendarApi.unselect(ev);
    };
    this.handleHitUpdate = (hit, isFinal) => {
      let { context } = this.component;
      let dragSelection = null;
      let isInvalid = false;
      if (hit) {
        let initialHit = this.hitDragging.initialHit;
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          dragSelection = joinHitsIntoSelection(initialHit, hit, context.pluginHooks.dateSelectionTransformers);
        }
        if (!dragSelection || !isDateSelectionValid(dragSelection, hit.dateProfile, context)) {
          isInvalid = true;
          dragSelection = null;
        }
      }
      if (dragSelection) {
        context.dispatch({ type: "SELECT_DATES", selection: dragSelection });
      } else if (!isFinal) {
        context.dispatch({ type: "UNSELECT_DATES" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        this.dragSelection = dragSelection;
      }
    };
    this.handlePointerUp = (pev) => {
      if (this.dragSelection) {
        triggerDateSelect(this.dragSelection, pev, this.component.context);
        this.dragSelection = null;
      }
    };
    let { component } = settings;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.touchScrollAllowed = false;
    dragging.minDistance = options.selectMinDistance || 0;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
  }
  destroy() {
    this.dragging.destroy();
  }
};
function getComponentTouchDelay$1(component) {
  let { options } = component.context;
  let delay = options.selectLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let ms = [
    dateSpan0.range.start,
    dateSpan0.range.end,
    dateSpan1.range.start,
    dateSpan1.range.end
  ];
  ms.sort(compareNumbers);
  let props = {};
  for (let transformer of dateSelectionTransformers) {
    let res = transformer(hit0, hit1);
    if (res === false) {
      return null;
    }
    if (res) {
      Object.assign(props, res);
    }
  }
  props.range = { start: ms[0], end: ms[3] };
  props.allDay = dateSpan0.allDay;
  return props;
}
var EventDragging = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.subjectEl = null;
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let origTarget = ev.origEvent.target;
      let { component: component2, dragging: dragging2 } = this;
      let { mirror } = dragging2;
      let { options: options2 } = component2.context;
      let initialContext = component2.context;
      this.subjectEl = ev.subjectEl;
      let subjectSeg = this.subjectSeg = getElSeg(ev.subjectEl);
      let eventRange = this.eventRange = subjectSeg.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);
      dragging2.minDistance = ev.isTouch ? 0 : options2.eventDragMinDistance;
      dragging2.delay = // only do a touch delay if touch and this event hasn't been selected yet
      ev.isTouch && eventInstanceId !== component2.props.eventSelection ? getComponentTouchDelay(component2) : null;
      if (options2.fixedMirrorParent) {
        mirror.parentNode = options2.fixedMirrorParent;
      } else {
        mirror.parentNode = elementClosest(origTarget, ".fc");
      }
      mirror.revertDuration = options2.dragRevertDuration;
      let isValid = component2.isValidSegDownEl(origTarget) && !elementClosest(origTarget, ".fc-event-resizer");
      dragging2.setIgnoreMove(!isValid);
      this.isDragging = isValid && ev.subjectEl.classList.contains("fc-event-draggable");
    };
    this.handleDragStart = (ev) => {
      let initialContext = this.component.context;
      let eventRange = this.eventRange;
      let eventInstanceId = eventRange.instance.instanceId;
      if (ev.isTouch) {
        if (eventInstanceId !== this.component.props.eventSelection) {
          initialContext.dispatch({ type: "SELECT_EVENT", eventInstanceId });
        }
      } else {
        initialContext.dispatch({ type: "UNSELECT_EVENT" });
      }
      if (this.isDragging) {
        initialContext.calendarApi.unselect(ev);
        initialContext.emitter.trigger("eventDragStart", {
          el: this.subjectEl,
          event: new EventImpl(initialContext, eventRange.def, eventRange.instance),
          jsEvent: ev.origEvent,
          view: initialContext.viewApi
        });
      }
    };
    this.handleHitUpdate = (hit, isFinal) => {
      if (!this.isDragging) {
        return;
      }
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let initialContext = this.component.context;
      let receivingContext = null;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        receivingContext = hit.context;
        let receivingOptions = receivingContext.options;
        if (initialContext === receivingContext || receivingOptions.editable && receivingOptions.droppable) {
          mutation = computeEventMutation(initialHit, hit, this.eventRange.instance.range.start, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);
          if (mutation) {
            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);
            interaction.mutatedEvents = mutatedRelevantEvents;
            if (!isInteractionValid(interaction, hit.dateProfile, receivingContext)) {
              isInvalid = true;
              mutation = null;
              mutatedRelevantEvents = null;
              interaction.mutatedEvents = createEmptyEventStore();
            }
          }
        } else {
          receivingContext = null;
        }
      }
      this.displayDrag(receivingContext, interaction);
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (initialContext === receivingContext && // TODO: write test for this
        isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.dragging.setMirrorNeedsRevert(!mutation);
        this.dragging.setMirrorIsVisible(!hit || !this.subjectEl.getRootNode().querySelector(".fc-event-mirror"));
        this.receivingContext = receivingContext;
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handlePointerUp = () => {
      if (!this.isDragging) {
        this.cleanup();
      }
    };
    this.handleDragEnd = (ev) => {
      if (this.isDragging) {
        let initialContext = this.component.context;
        let initialView = initialContext.viewApi;
        let { receivingContext, validMutation } = this;
        let eventDef = this.eventRange.def;
        let eventInstance = this.eventRange.instance;
        let eventApi = new EventImpl(initialContext, eventDef, eventInstance);
        let relevantEvents = this.relevantEvents;
        let mutatedRelevantEvents = this.mutatedRelevantEvents;
        let { finalHit } = this.hitDragging;
        this.clearDrag();
        initialContext.emitter.trigger("eventDragStop", {
          el: this.subjectEl,
          event: eventApi,
          jsEvent: ev.origEvent,
          view: initialView
        });
        if (validMutation) {
          if (receivingContext === initialContext) {
            let updatedEventApi = new EventImpl(initialContext, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
            initialContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventChangeArg = {
              oldEvent: eventApi,
              event: updatedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                  // the pre-change data
                });
              }
            };
            let transformed = {};
            for (let transformer of initialContext.getCurrentData().pluginHooks.eventDropTransformers) {
              Object.assign(transformed, transformer(validMutation, initialContext));
            }
            initialContext.emitter.trigger("eventDrop", Object.assign(Object.assign(Object.assign({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));
            initialContext.emitter.trigger("eventChange", eventChangeArg);
          } else if (receivingContext) {
            let eventRemoveArg = {
              event: eventApi,
              relatedEvents: buildEventApis(relevantEvents, initialContext, eventInstance),
              revert() {
                initialContext.dispatch({
                  type: "MERGE_EVENTS",
                  eventStore: relevantEvents
                });
              }
            };
            initialContext.emitter.trigger("eventLeave", Object.assign(Object.assign({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));
            initialContext.dispatch({
              type: "REMOVE_EVENTS",
              eventStore: relevantEvents
            });
            initialContext.emitter.trigger("eventRemove", eventRemoveArg);
            let addedEventDef = mutatedRelevantEvents.defs[eventDef.defId];
            let addedEventInstance = mutatedRelevantEvents.instances[eventInstance.instanceId];
            let addedEventApi = new EventImpl(receivingContext, addedEventDef, addedEventInstance);
            receivingContext.dispatch({
              type: "MERGE_EVENTS",
              eventStore: mutatedRelevantEvents
            });
            let eventAddArg = {
              event: addedEventApi,
              relatedEvents: buildEventApis(mutatedRelevantEvents, receivingContext, addedEventInstance),
              revert() {
                receivingContext.dispatch({
                  type: "REMOVE_EVENTS",
                  eventStore: mutatedRelevantEvents
                });
              }
            };
            receivingContext.emitter.trigger("eventAdd", eventAddArg);
            if (ev.isTouch) {
              receivingContext.dispatch({
                type: "SELECT_EVENT",
                eventInstanceId: eventInstance.instanceId
              });
            }
            receivingContext.emitter.trigger("drop", Object.assign(Object.assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.context.viewApi }));
            receivingContext.emitter.trigger("eventReceive", Object.assign(Object.assign({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.context.viewApi }));
          }
        } else {
          initialContext.emitter.trigger("_noEventDrop");
        }
      }
      this.cleanup();
    };
    let { component } = this;
    let { options } = component.context;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = EventDragging.SELECTOR;
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsStore);
    hitDragging.useSubjectCenter = settings.useEventCenter;
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("pointerup", this.handlePointerUp);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  // render a drag state on the next receivingCalendar
  displayDrag(nextContext, state) {
    let initialContext = this.component.context;
    let prevContext = this.receivingContext;
    if (prevContext && prevContext !== nextContext) {
      if (prevContext === initialContext) {
        prevContext.dispatch({
          type: "SET_EVENT_DRAG",
          state: {
            affectedEvents: state.affectedEvents,
            mutatedEvents: createEmptyEventStore(),
            isEvent: true
          }
        });
      } else {
        prevContext.dispatch({ type: "UNSET_EVENT_DRAG" });
      }
    }
    if (nextContext) {
      nextContext.dispatch({ type: "SET_EVENT_DRAG", state });
    }
  }
  clearDrag() {
    let initialCalendar = this.component.context;
    let { receivingContext } = this;
    if (receivingContext) {
      receivingContext.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
    if (initialCalendar !== receivingContext) {
      initialCalendar.dispatch({ type: "UNSET_EVENT_DRAG" });
    }
  }
  cleanup() {
    this.subjectSeg = null;
    this.isDragging = false;
    this.eventRange = null;
    this.relevantEvents = null;
    this.receivingContext = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
  }
};
EventDragging.SELECTOR = ".fc-event-draggable, .fc-event-resizable";
function computeEventMutation(hit0, hit1, eventInstanceStart, massagers) {
  let dateSpan0 = hit0.dateSpan;
  let dateSpan1 = hit1.dateSpan;
  let date0 = dateSpan0.range.start;
  let date1 = dateSpan1.range.start;
  let standardProps = {};
  if (dateSpan0.allDay !== dateSpan1.allDay) {
    standardProps.allDay = dateSpan1.allDay;
    standardProps.hasEnd = hit1.context.options.allDayMaintainDuration;
    if (dateSpan1.allDay) {
      date0 = startOfDay(eventInstanceStart);
    } else {
      date0 = eventInstanceStart;
    }
  }
  let delta = diffDates(date0, date1, hit0.context.dateEnv, hit0.componentId === hit1.componentId ? hit0.largeUnit : null);
  if (delta.milliseconds) {
    standardProps.allDay = false;
  }
  let mutation = {
    datesDelta: delta,
    standardProps
  };
  for (let massager of massagers) {
    massager(mutation, hit0, hit1);
  }
  return mutation;
}
function getComponentTouchDelay(component) {
  let { options } = component.context;
  let delay = options.eventLongPressDelay;
  if (delay == null) {
    delay = options.longPressDelay;
  }
  return delay;
}
var EventResizing = class extends Interaction {
  constructor(settings) {
    super(settings);
    this.draggingSegEl = null;
    this.draggingSeg = null;
    this.eventRange = null;
    this.relevantEvents = null;
    this.validMutation = null;
    this.mutatedRelevantEvents = null;
    this.handlePointerDown = (ev) => {
      let { component: component2 } = this;
      let segEl = this.querySegEl(ev);
      let seg = getElSeg(segEl);
      let eventRange = this.eventRange = seg.eventRange;
      this.dragging.minDistance = component2.context.options.eventDragMinDistance;
      this.dragging.setIgnoreMove(!this.component.isValidSegDownEl(ev.origEvent.target) || ev.isTouch && this.component.props.eventSelection !== eventRange.instance.instanceId);
    };
    this.handleDragStart = (ev) => {
      let { context } = this.component;
      let eventRange = this.eventRange;
      this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, this.eventRange.instance.instanceId);
      let segEl = this.querySegEl(ev);
      this.draggingSegEl = segEl;
      this.draggingSeg = getElSeg(segEl);
      context.calendarApi.unselect();
      context.emitter.trigger("eventResizeStart", {
        el: segEl,
        event: new EventImpl(context, eventRange.def, eventRange.instance),
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
    };
    this.handleHitUpdate = (hit, isFinal, ev) => {
      let { context } = this.component;
      let relevantEvents = this.relevantEvents;
      let initialHit = this.hitDragging.initialHit;
      let eventInstance = this.eventRange.instance;
      let mutation = null;
      let mutatedRelevantEvents = null;
      let isInvalid = false;
      let interaction = {
        affectedEvents: relevantEvents,
        mutatedEvents: createEmptyEventStore(),
        isEvent: true
      };
      if (hit) {
        let disallowed = hit.componentId === initialHit.componentId && this.isHitComboAllowed && !this.isHitComboAllowed(initialHit, hit);
        if (!disallowed) {
          mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains("fc-event-resizer-start"), eventInstance.range);
        }
      }
      if (mutation) {
        mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);
        interaction.mutatedEvents = mutatedRelevantEvents;
        if (!isInteractionValid(interaction, hit.dateProfile, context)) {
          isInvalid = true;
          mutation = null;
          mutatedRelevantEvents = null;
          interaction.mutatedEvents = null;
        }
      }
      if (mutatedRelevantEvents) {
        context.dispatch({
          type: "SET_EVENT_RESIZE",
          state: interaction
        });
      } else {
        context.dispatch({ type: "UNSET_EVENT_RESIZE" });
      }
      if (!isInvalid) {
        enableCursor();
      } else {
        disableCursor();
      }
      if (!isFinal) {
        if (mutation && isHitsEqual(initialHit, hit)) {
          mutation = null;
        }
        this.validMutation = mutation;
        this.mutatedRelevantEvents = mutatedRelevantEvents;
      }
    };
    this.handleDragEnd = (ev) => {
      let { context } = this.component;
      let eventDef = this.eventRange.def;
      let eventInstance = this.eventRange.instance;
      let eventApi = new EventImpl(context, eventDef, eventInstance);
      let relevantEvents = this.relevantEvents;
      let mutatedRelevantEvents = this.mutatedRelevantEvents;
      context.emitter.trigger("eventResizeStop", {
        el: this.draggingSegEl,
        event: eventApi,
        jsEvent: ev.origEvent,
        view: context.viewApi
      });
      if (this.validMutation) {
        let updatedEventApi = new EventImpl(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);
        context.dispatch({
          type: "MERGE_EVENTS",
          eventStore: mutatedRelevantEvents
        });
        let eventChangeArg = {
          oldEvent: eventApi,
          event: updatedEventApi,
          relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),
          revert() {
            context.dispatch({
              type: "MERGE_EVENTS",
              eventStore: relevantEvents
              // the pre-change events
            });
          }
        };
        context.emitter.trigger("eventResize", Object.assign(Object.assign({}, eventChangeArg), { el: this.draggingSegEl, startDelta: this.validMutation.startDelta || createDuration(0), endDelta: this.validMutation.endDelta || createDuration(0), jsEvent: ev.origEvent, view: context.viewApi }));
        context.emitter.trigger("eventChange", eventChangeArg);
      } else {
        context.emitter.trigger("_noEventResize");
      }
      this.draggingSeg = null;
      this.relevantEvents = null;
      this.validMutation = null;
    };
    let { component } = settings;
    let dragging = this.dragging = new FeaturefulElementDragging(settings.el);
    dragging.pointer.selector = ".fc-event-resizer";
    dragging.touchScrollAllowed = false;
    dragging.autoScroller.isEnabled = component.context.options.dragScroll;
    let hitDragging = this.hitDragging = new HitDragging(this.dragging, interactionSettingsToStore(settings));
    hitDragging.emitter.on("pointerdown", this.handlePointerDown);
    hitDragging.emitter.on("dragstart", this.handleDragStart);
    hitDragging.emitter.on("hitupdate", this.handleHitUpdate);
    hitDragging.emitter.on("dragend", this.handleDragEnd);
  }
  destroy() {
    this.dragging.destroy();
  }
  querySegEl(ev) {
    return elementClosest(ev.subjectEl, ".fc-event");
  }
};
function computeMutation(hit0, hit1, isFromStart, instanceRange) {
  let dateEnv = hit0.context.dateEnv;
  let date0 = hit0.dateSpan.range.start;
  let date1 = hit1.dateSpan.range.start;
  let delta = diffDates(date0, date1, dateEnv, hit0.largeUnit);
  if (isFromStart) {
    if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {
      return { startDelta: delta };
    }
  } else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {
    return { endDelta: delta };
  }
  return null;
}
var UnselectAuto = class {
  constructor(context) {
    this.context = context;
    this.isRecentPointerDateSelect = false;
    this.matchesCancel = false;
    this.matchesEvent = false;
    this.onSelect = (selectInfo) => {
      if (selectInfo.jsEvent) {
        this.isRecentPointerDateSelect = true;
      }
    };
    this.onDocumentPointerDown = (pev) => {
      let unselectCancel = this.context.options.unselectCancel;
      let downEl = getEventTargetViaRoot(pev.origEvent);
      this.matchesCancel = !!elementClosest(downEl, unselectCancel);
      this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR);
    };
    this.onDocumentPointerUp = (pev) => {
      let { context: context2 } = this;
      let { documentPointer: documentPointer2 } = this;
      let calendarState = context2.getCurrentData();
      if (!documentPointer2.wasTouchScroll) {
        if (calendarState.dateSelection && // an existing date selection?
        !this.isRecentPointerDateSelect) {
          let unselectAuto = context2.options.unselectAuto;
          if (unselectAuto && (!unselectAuto || !this.matchesCancel)) {
            context2.calendarApi.unselect(pev);
          }
        }
        if (calendarState.eventSelection && // an existing event selected?
        !this.matchesEvent) {
          context2.dispatch({ type: "UNSELECT_EVENT" });
        }
      }
      this.isRecentPointerDateSelect = false;
    };
    let documentPointer = this.documentPointer = new PointerDragging(document);
    documentPointer.shouldIgnoreMove = true;
    documentPointer.shouldWatchScroll = false;
    documentPointer.emitter.on("pointerdown", this.onDocumentPointerDown);
    documentPointer.emitter.on("pointerup", this.onDocumentPointerUp);
    context.emitter.on("select", this.onSelect);
  }
  destroy() {
    this.context.emitter.off("select", this.onSelect);
    this.documentPointer.destroy();
  }
};
var OPTION_REFINERS3 = {
  fixedMirrorParent: identity
};
var LISTENER_REFINERS = {
  dateClick: identity,
  eventDragStart: identity,
  eventDragStop: identity,
  eventDrop: identity,
  eventResizeStart: identity,
  eventResizeStop: identity,
  eventResize: identity,
  drop: identity,
  eventReceive: identity,
  eventLeave: identity
};
config.dataAttrPrefix = "";
var index5 = createPlugin({
  name: "@fullcalendar/interaction",
  componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],
  calendarInteractions: [UnselectAuto],
  elementDraggingImpl: FeaturefulElementDragging,
  optionRefiners: OPTION_REFINERS3,
  listenerRefiners: LISTENER_REFINERS
});

// node_modules/@fullcalendar/google-calendar/index.js
var API_BASE = "https://www.googleapis.com/calendar/v3/calendars";
var eventSourceDef2 = {
  parseMeta(refined) {
    let { googleCalendarId } = refined;
    if (!googleCalendarId && refined.url) {
      googleCalendarId = parseGoogleCalendarId(refined.url);
    }
    if (googleCalendarId) {
      return {
        googleCalendarId,
        googleCalendarApiKey: refined.googleCalendarApiKey,
        googleCalendarApiBase: refined.googleCalendarApiBase,
        extraParams: refined.extraParams
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    let { dateEnv, options } = arg.context;
    let meta = arg.eventSource.meta;
    let apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey;
    if (!apiKey) {
      errorCallback(new Error("Specify a googleCalendarApiKey. See https://fullcalendar.io/docs/google-calendar"));
    } else {
      let url = buildUrl(meta);
      let { extraParams } = meta;
      let extraParamsObj = typeof extraParams === "function" ? extraParams() : extraParams;
      let requestParams = buildRequestParams2(arg.range, apiKey, extraParamsObj, dateEnv);
      return requestJson("GET", url, requestParams).then(([body, response]) => {
        if (body.error) {
          errorCallback(new JsonRequestError("Google Calendar API: " + body.error.message, response));
        } else {
          successCallback({
            rawEvents: gcalItemsToRawEventDefs(body.items, requestParams.timeZone),
            response
          });
        }
      }, errorCallback);
    }
  }
};
function parseGoogleCalendarId(url) {
  let match;
  if (/^[^/]+@([^/.]+\.)*(google|googlemail|gmail)\.com$/.test(url)) {
    return url;
  }
  if ((match = /^https:\/\/www.googleapis.com\/calendar\/v3\/calendars\/([^/]*)/.exec(url)) || (match = /^https?:\/\/www.google.com\/calendar\/feeds\/([^/]*)/.exec(url))) {
    return decodeURIComponent(match[1]);
  }
  return null;
}
function buildUrl(meta) {
  let apiBase = meta.googleCalendarApiBase;
  if (!apiBase) {
    apiBase = API_BASE;
  }
  return apiBase + "/" + encodeURIComponent(meta.googleCalendarId) + "/events";
}
function buildRequestParams2(range2, apiKey, extraParams, dateEnv) {
  let params;
  let startStr;
  let endStr;
  if (dateEnv.canComputeOffset) {
    startStr = dateEnv.formatIso(range2.start);
    endStr = dateEnv.formatIso(range2.end);
  } else {
    startStr = addDays(range2.start, -1).toISOString();
    endStr = addDays(range2.end, 1).toISOString();
  }
  params = Object.assign(Object.assign({}, extraParams || {}), { key: apiKey, timeMin: startStr, timeMax: endStr, singleEvents: true, maxResults: 9999 });
  if (dateEnv.timeZone !== "local") {
    params.timeZone = dateEnv.timeZone;
  }
  return params;
}
function gcalItemsToRawEventDefs(items, gcalTimezone) {
  return items.map((item) => gcalItemToRawEventDef(item, gcalTimezone));
}
function gcalItemToRawEventDef(item, gcalTimezone) {
  let url = item.htmlLink || null;
  if (url && gcalTimezone) {
    url = injectQsComponent(url, "ctz=" + gcalTimezone);
  }
  return {
    id: item.id,
    title: item.summary,
    start: item.start.dateTime || item.start.date,
    end: item.end.dateTime || item.end.date,
    url,
    location: item.location,
    description: item.description,
    attachments: item.attachments || [],
    extendedProps: (item.extendedProperties || {}).shared || {}
  };
}
function injectQsComponent(url, component) {
  return url.replace(/(\?.*?)?(#|$)/, (whole, qs, hash) => (qs ? qs + "&" : "?") + component + hash);
}
var OPTION_REFINERS4 = {
  googleCalendarApiKey: String
};
var EVENT_SOURCE_REFINERS2 = {
  googleCalendarApiKey: String,
  googleCalendarId: String,
  googleCalendarApiBase: String,
  extraParams: identity
};
var index6 = createPlugin({
  name: "@fullcalendar/google-calendar",
  eventSourceDefs: [eventSourceDef2],
  optionRefiners: OPTION_REFINERS4,
  eventSourceRefiners: EVENT_SOURCE_REFINERS2
});

// node_modules/@fullcalendar/icalendar/index.js
var ICAL = __toESM(require_ical(), 1);
var IcalExpander = class {
  constructor(opts) {
    this.maxIterations = opts.maxIterations != null ? opts.maxIterations : 1e3;
    this.skipInvalidDates = opts.skipInvalidDates != null ? opts.skipInvalidDates : false;
    this.jCalData = ICAL.parse(opts.ics);
    this.component = new ICAL.Component(this.jCalData);
    this.events = this.component.getAllSubcomponents("vevent").map((vevent) => new ICAL.Event(vevent));
    if (this.skipInvalidDates) {
      this.events = this.events.filter((evt) => {
        try {
          evt.startDate.toJSDate();
          evt.endDate.toJSDate();
          return true;
        } catch (err) {
          return false;
        }
      });
    }
  }
  between(after, before) {
    function isEventWithinRange(startTime, endTime) {
      return (!after || endTime >= after.getTime()) && (!before || startTime <= before.getTime());
    }
    function getTimes(eventOrOccurrence) {
      const startTime = eventOrOccurrence.startDate.toJSDate().getTime();
      let endTime = eventOrOccurrence.endDate.toJSDate().getTime();
      if (eventOrOccurrence.endDate.isDate && endTime > startTime) {
        endTime -= 1;
      }
      return { startTime, endTime };
    }
    const exceptions = [];
    this.events.forEach((event) => {
      if (event.isRecurrenceException())
        exceptions.push(event);
    });
    const ret = {
      events: [],
      occurrences: []
    };
    this.events.filter((e3) => !e3.isRecurrenceException()).forEach((event) => {
      const exdates = [];
      event.component.getAllProperties("exdate").forEach((exdateProp) => {
        const exdate = exdateProp.getFirstValue();
        exdates.push(exdate.toJSDate().getTime());
      });
      if (event.isRecurring()) {
        const iterator = event.iterator();
        let next;
        let i3 = 0;
        do {
          i3 += 1;
          next = iterator.next();
          if (next) {
            const occurrence = event.getOccurrenceDetails(next);
            const { startTime: startTime2, endTime: endTime2 } = getTimes(occurrence);
            const isOccurrenceExcluded = exdates.indexOf(startTime2) !== -1;
            const exception = exceptions.find((ex) => ex.uid === event.uid && ex.recurrenceId.toJSDate().getTime() === occurrence.startDate.toJSDate().getTime());
            if (before && startTime2 > before.getTime())
              break;
            if (isEventWithinRange(startTime2, endTime2)) {
              if (exception) {
                ret.events.push(exception);
              } else if (!isOccurrenceExcluded) {
                ret.occurrences.push(occurrence);
              }
            }
          }
        } while (next && (!this.maxIterations || i3 < this.maxIterations));
        return;
      }
      const { startTime, endTime } = getTimes(event);
      if (isEventWithinRange(startTime, endTime))
        ret.events.push(event);
    });
    return ret;
  }
  before(before) {
    return this.between(void 0, before);
  }
  after(after) {
    return this.between(after);
  }
  all() {
    return this.between();
  }
};
var eventSourceDef3 = {
  parseMeta(refined) {
    if (refined.url && refined.format === "ics") {
      return {
        url: refined.url,
        format: "ics"
      };
    }
    return null;
  },
  fetch(arg, successCallback, errorCallback) {
    let meta = arg.eventSource.meta;
    let { internalState } = meta;
    if (!internalState || arg.isRefetch) {
      internalState = meta.internalState = {
        response: null,
        iCalExpanderPromise: fetch(meta.url, { method: "GET" }).then((response) => {
          return response.text().then((icsText) => {
            internalState.response = response;
            return new IcalExpander({
              ics: icsText,
              skipInvalidDates: true
            });
          });
        })
      };
    }
    internalState.iCalExpanderPromise.then((iCalExpander) => {
      successCallback({
        rawEvents: expandICalEvents(iCalExpander, arg.range),
        response: internalState.response
      });
    }, errorCallback);
  }
};
function expandICalEvents(iCalExpander, range2) {
  let rangeStart = addDays(range2.start, -1);
  let rangeEnd = addDays(range2.end, 1);
  let iCalRes = iCalExpander.between(rangeStart, rangeEnd);
  let expanded = [];
  for (let iCalEvent of iCalRes.events) {
    expanded.push(Object.assign(Object.assign({}, buildNonDateProps(iCalEvent)), { start: iCalEvent.startDate.toString(), end: specifiesEnd(iCalEvent) && iCalEvent.endDate ? iCalEvent.endDate.toString() : null }));
  }
  for (let iCalOccurence of iCalRes.occurrences) {
    let iCalEvent = iCalOccurence.item;
    expanded.push(Object.assign(Object.assign({}, buildNonDateProps(iCalEvent)), { start: iCalOccurence.startDate.toString(), end: specifiesEnd(iCalEvent) && iCalOccurence.endDate ? iCalOccurence.endDate.toString() : null }));
  }
  return expanded;
}
function buildNonDateProps(iCalEvent) {
  return {
    title: iCalEvent.summary,
    url: extractEventUrl(iCalEvent),
    extendedProps: {
      location: iCalEvent.location,
      organizer: iCalEvent.organizer,
      description: iCalEvent.description
    }
  };
}
function extractEventUrl(iCalEvent) {
  let urlProp = iCalEvent.component.getFirstProperty("url");
  return urlProp ? urlProp.getFirstValue() : "";
}
function specifiesEnd(iCalEvent) {
  return Boolean(iCalEvent.component.getFirstProperty("dtend")) || Boolean(iCalEvent.component.getFirstProperty("duration"));
}
var index7 = createPlugin({
  name: "@fullcalendar/icalendar",
  eventSourceDefs: [eventSourceDef3]
});

// lib/obsidian-full-calendar/calendar.ts
index3.recurringTypes[0].expand = function(errd, fr, de) {
  const hours = errd.rruleSet._dtstart.getHours();
  return errd.rruleSet.between(de.toDate(fr.start), de.toDate(fr.end), true).map((d2) => {
    return new Date(
      Date.UTC(
        d2.getFullYear(),
        d2.getMonth(),
        d2.getDate(),
        hours,
        d2.getMinutes()
      )
    );
  });
};
function renderCalendar(containerEl, eventSources, settings) {
  var _a;
  const isMobile = window.innerWidth < 500;
  const isNarrow = (settings == null ? void 0 : settings.forceNarrow) || isMobile;
  const {
    eventClick,
    select,
    modifyEvent,
    eventMouseEnter,
    openContextMenuForEvent,
    toggleTask
  } = settings || {};
  const modifyEventCallback = modifyEvent && (async ({
    event,
    oldEvent,
    revert
  }) => {
    const success = await modifyEvent(event, oldEvent);
    if (!success) {
      revert();
    }
  });
  const cal = new Calendar(containerEl, {
    plugins: [
      // View plugins
      index,
      index2,
      index4,
      // multiMonthPlugin,
      // Drag + drop and editing
      index5,
      // Remote sources
      index6,
      index7,
      index3
    ],
    googleCalendarApiKey: "AIzaSyDIiklFwJXaLWuT_4y6I9ZRVVsPuf4xGrk",
    initialView: ((_a = settings == null ? void 0 : settings.initialView) == null ? void 0 : _a[isNarrow ? "mobile" : "desktop"]) || (isNarrow ? "timeGrid3Days" : "timeGridWeek"),
    nowIndicator: true,
    scrollTimeReset: false,
    dayMaxEvents: true,
    expandRows: true,
    slotDuration: (settings == null ? void 0 : settings.slotDuration) || "00:30:00",
    // multiMonthMaxColumns: 1,
    headerToolbar: !isNarrow ? {
      left: "prev,next today",
      center: "title",
      right: "timeGrid5Days,timeGridWeek,listWeek,dayGridMonth,dayGridYear"
    } : !isMobile ? {
      right: "today,prev,next",
      left: "dayGridMonth,timeGrid3Days,listWeek,dayGridYear"
    } : false,
    footerToolbar: isMobile ? {
      right: "today,prev,next",
      left: "timeGrid3Days,dayGridMonth,dayGridYear,timeGridWeek,listWeek"
    } : false,
    views: {
      timeGrid3Days: {
        type: "timeGrid",
        duration: { days: 3 },
        buttonText: "3"
      },
      timeGrid5Days: {
        type: "timeGrid",
        duration: { days: 5 },
        buttonText: "5"
      },
      dayGridMonth: {
        dayMaxEvents: false
      },
      dayGridYear: {
        dayMaxEvents: false
      }
    },
    firstDay: settings == null ? void 0 : settings.firstDay,
    ...(settings == null ? void 0 : settings.timeFormat24h) && {
      eventTimeFormat: {
        hour: "numeric",
        minute: "2-digit",
        hour12: false
      },
      slotLabelFormat: {
        hour: "numeric",
        minute: "2-digit",
        hour12: false
      }
    },
    eventSources,
    eventClick,
    selectable: select && true,
    selectMirror: select && true,
    select: select && (async (info) => {
      await select(info.start, info.end, info.allDay, info.view.type);
      info.view.calendar.unselect();
    }),
    editable: modifyEvent && true,
    eventDrop: modifyEventCallback,
    eventResize: modifyEventCallback,
    eventMouseEnter,
    eventDidMount: ({ event, el, textColor }) => {
      el.addEventListener("contextmenu", (e3) => {
        e3.preventDefault();
        openContextMenuForEvent && openContextMenuForEvent(event, e3);
      });
      if (toggleTask) {
        if (event.extendedProps.isTask) {
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = event.extendedProps.taskCompleted !== false;
          checkbox.onclick = async (e3) => {
            e3.stopPropagation();
            if (e3.target) {
              let ret = await toggleTask(
                event,
                e3.target.checked
              );
              if (!ret) {
                e3.target.checked = !e3.target.checked;
              }
            }
          };
          if (textColor == "black") {
            checkbox.addClass("ofc-checkbox-black");
          } else {
            checkbox.addClass("ofc-checkbox-white");
          }
          if (checkbox.checked) {
            el.addClass("ofc-task-completed");
          }
          const container = el.querySelector(".fc-event-time") || el.querySelector(".fc-event-title") || el.querySelector(".fc-list-event-title");
          container == null ? void 0 : container.addClass("ofc-has-checkbox");
          container == null ? void 0 : container.prepend(checkbox);
        }
      }
    },
    longPressDelay: 250
  });
  cal.render();
  return cal;
}

// src/views/CalendarView.ts
var CalendarView = class extends import_obsidian.ItemView {
  constructor(leaf, cache, idForCache, event_src, calendarSettings, fileManager, placeForCreatingNote) {
    super(leaf);
    this.calendar = null;
    this.selectedSrcPaths = /* @__PURE__ */ new Set();
    this.cache = cache;
    this.idForCache = idForCache;
    this.event_src = event_src;
    this.fileManager = fileManager;
    this.calendarSettings = calendarSettings;
    this.placeForCreatingNote = placeForCreatingNote;
    for (let src of event_src) {
      this.selectedSrcPaths.add(src.path);
    }
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Calendar";
  }
  async onOpen() {
    if (import_obsidian.Platform.isMobile)
      this.containerEl.style.height = "95vh";
    const container = this.containerEl.children[1];
    container.empty();
    this.render(container);
  }
  onResize() {
    var _a;
    (_a = this.calendar) == null ? void 0 : _a.render();
  }
  addFile(page) {
    var _a;
    if (!this.isPageInSelectedSrc(page.file.path)) {
      return;
    }
    const events = pageToEvents(page);
    for (let event of events)
      (_a = this.calendar) == null ? void 0 : _a.addEvent(event);
  }
  changeFile(newPage, oldPage) {
    var _a, _b;
    (_a = this.calendar) == null ? void 0 : _a.pauseRendering();
    this.deleteFile(oldPage);
    this.addFile(newPage);
    (_b = this.calendar) == null ? void 0 : _b.resumeRendering();
  }
  renameFile(newPage, oldPage) {
    this.changeFile(newPage, oldPage);
  }
  deleteFile(page) {
    var _a, _b;
    if (!this.calendar)
      return;
    (_a = this.calendar.getEventById(page.file.path)) == null ? void 0 : _a.remove();
    for (let tick of page.ticks) {
      (_b = this.calendar.getEventById(
        templateIDTick(page.file.path, tick.name)
      )) == null ? void 0 : _b.remove();
    }
  }
  reset() {
    this.onunload();
    this.onOpen();
  }
  onunload() {
    if (!this.calendar)
      return;
    this.calendar.destroy();
    this.calendar = null;
    this.parrentPointer.cache.unsubscribe(this.idForCache);
  }
  renderSrcCheckboxes() {
    if (!this.srcCheckboxContainer)
      return;
    this.srcCheckboxContainer.empty();
    this.event_src.forEach((src) => {
      const checkboxContainer = this.srcCheckboxContainer.createDiv({ cls: "src-checkbox-item" });
      const checkbox = checkboxContainer.createEl("input", {
        type: "checkbox",
        attr: {
          id: `src-checkbox-${src.path}`,
          checked: this.selectedSrcPaths.has(src.path) ? "checked" : null
        }
      });
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          this.selectedSrcPaths.add(src.path);
        } else {
          this.selectedSrcPaths.delete(src.path);
        }
        this.refreshCalendar();
      });
      checkboxContainer.createEl("label", {
        text: src.path,
        attr: { for: `src-checkbox-${src.path}` }
      });
    });
  }
  isPageInSelectedSrc(pagePath) {
    for (const srcPath of this.selectedSrcPaths) {
      if (pagePath.startsWith(srcPath)) {
        return true;
      }
    }
    return false;
  }
  async refreshCalendar() {
    if (!this.calendar)
      return;
    this.calendar.getEvents().forEach((event) => event.remove());
    const subscribeData = await this.cache.subscribe(this.idForCache, this.event_src, this);
    const events = [];
    for (const data of subscribeData) {
      if (this.selectedSrcPaths.has(data.src.path)) {
        for (let page of data.pages) {
          events.push(...pageToEvents(page));
        }
      }
    }
    events.forEach((event) => {
      var _a;
      return (_a = this.calendar) == null ? void 0 : _a.addEvent(event);
    });
  }
  async render(container) {
    this.localStorage = /* @__PURE__ */ new Map();
    const subscribedData = await this.cache.subscribe(this.idForCache, this.event_src, this);
    for (let data of subscribedData) {
      this.localStorage.set(data.src.path, data.pages);
    }
    const events = [];
    for (const data of subscribedData) {
      if (!this.selectedSrcPaths.has(data.src.path))
        continue;
      for (let page of data.pages) {
        events.push(...pageToEvents(page));
      }
    }
    this.calendar = renderCalendar(
      container,
      {
        //@ts-ignore // TODO remove
        events: [
          ...this.calendarSettings.restTime,
          ...events
        ]
      },
      // as EventSource,
      this.getSettingsCalendar()
    );
    this.calendar.setOption("weekNumbers", true);
    window.setTimeout(
      (_3) => {
        var _a, _b;
        if (import_obsidian.Platform.isMobile)
          (_a = this.calendar) == null ? void 0 : _a.changeView("timeGrid3Days");
        else
          (_b = this.calendar) == null ? void 0 : _b.changeView("timeGridWeek");
      },
      1
    );
    this.calendar.render();
  }
  getSettingsCalendar() {
    const result = {
      firstDay: 1,
      weekNumbers: true,
      timeFormat24h: true,
      // TODO remove any
      eventClick: (arg) => {
        const { event, jsEvent } = arg;
        this.fileManager.openNote(event);
      },
      // TODO remove any
      modifyEvent: async (newPos, oldPos) => {
        var _a, _b;
        const props = newPos.extendedProps;
        const event = {
          start: newPos.start,
          end: newPos.end,
          allDay: newPos.allDay
        };
        if (props.notePath) {
          const page = this.cache.getPage(props.notePath);
          if (!page) {
            console.warn(`${MSG_PLG_NAME}: can't find page by Event. eventID: ${props.notePath}`);
            return false;
          }
          const tick = page.ticks.find(
            (el) => el.name == props.tickName
          );
          if (!tick) {
            console.warn(`${MSG_PLG_NAME}: can't find tick by page. Page - tickName: ${props.notePath} - ${props.tickName}`);
            return false;
          }
          if (tick.ff_duration && oldPos.allDay && !newPos.allDay) {
            event.end = timeAdd(newPos.start, tick.ff_duration);
            newPos.setEnd(event.end);
          }
          const newProp = CalendarEventToIDate(event);
          if (newPos.allDay) {
            newProp["ff_duration"] = millisecToString(
              (_a = tick.ff_duration) == null ? void 0 : _a.as("milliseconds")
            );
          }
          this.fileManager.changeTickFile(props.notePath, props.tickName, newProp);
        } else {
          const page = this.cache.getPage(newPos.id);
          if (!page) {
            console.warn(`${MSG_PLG_NAME}: can't find page by Event. eventID: ${newPos.id}`);
            return false;
          }
          if (page.ff_duration && oldPos.allDay && !newPos.allDay) {
            event.end = timeAdd(newPos.start, page.ff_duration);
            newPos.setEnd(event.end);
          }
          const newProp = CalendarEventToIDate(event);
          if (newPos.allDay) {
            newProp["ff_duration"] = millisecToString(
              (_b = page.ff_duration) == null ? void 0 : _b.as("milliseconds")
            );
          }
          this.fileManager.changePropertyFile(newPos.id, newProp);
        }
        return true;
      },
      select: (start, end, allDay, __viewMode) => {
        new nameModal(
          this.app,
          async (nameOfFile) => {
            try {
              if (!nameOfFile)
                throw 1;
              const pathOfFile = this.placeForCreatingNote + `/${nameOfFile}.md`;
              await this.fileManager.createFile(pathOfFile);
              setTimeout(
                () => this.fileManager.changePropertyFile(
                  pathOfFile,
                  CalendarEventToIDate({ start, end, allDay })
                ),
                1500
              );
            } catch (e3) {
              console.error(e3);
              new import_obsidian.Notice("Hm... error...");
            }
          }
        ).open();
      },
      openContextMenuForEvent: (e3, mouseEvent) => {
        this.contextMenuForEvent(e3, mouseEvent);
      },
      slotDuration: this.calendarSettings.slotDuration
    };
    if (import_obsidian.Platform.isMobile) {
      result.eventClick = (arg) => {
        const { event, jsEvent } = arg;
        this.contextMenuForEvent(event, jsEvent);
      };
      result.openContextMenuForEvent = (_3, __) => {
      };
    }
    return result;
  }
  contextMenuForEvent(event, mouseEvent) {
    const menu = new import_obsidian.Menu();
    menu.addItem(
      (item) => item.setTitle(event.id).onClick(async () => this.fileManager.openNote(event))
    );
    menu.showAtMouseEvent(mouseEvent);
  }
};
var nameModal = class extends import_obsidian.Modal {
  constructor(app, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "Name of task" });
    new import_obsidian.Setting(contentEl).setName("Name").addText(
      (text) => text.onChange((value) => this.result = value)
    );
    new import_obsidian.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Submit").setCta().onClick(() => {
        this.close();
        this.onSubmit(this.result);
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/cache.ts
var import_obsidian2 = require("obsidian");
var Cache2 = class {
  constructor(parrentPointer, fileManager) {
    this.storage = /* @__PURE__ */ new Map();
    this.subscribers = /* @__PURE__ */ new Map();
    this.initSync = new Promise(
      (resolve) => this.initSyncResolve = resolve
    );
    this.isInited = false;
    this.parrentPointer = parrentPointer;
    this.parrentPointer.app.workspace.onLayoutReady(() => this.initStorage());
  }
  getPage(path) {
    return this.storage.get(path);
  }
  log() {
    console.log("storage", this.storage);
    console.log("subscribers", this.subscribers);
  }
  async subscribe(id, paths, subscriber) {
    this.subscribers.set(
      id,
      {
        paths,
        subscriber
      }
    );
    if (!this.isInited)
      await this.initSync;
    const result = [];
    for (let path of paths) {
      const pages = [];
      for (let [key, value] of this.storage) {
        if (key.startsWith(path.path)) {
          pages.push(value);
        }
      }
      result.push({
        src: path,
        pages
      });
    }
    return result;
  }
  unsubscribe(id) {
    this.subscribers.delete(id);
  }
  renameFile(file, oldPath) {
    if (!this.isInited)
      return;
    const oldPage = this.storage.get(oldPath);
    const page = { ...oldPage };
    page.file = { ...oldPage.file };
    page.file.path = file.path;
    page.file.name = file.basename;
    this.storage.delete(oldPath);
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      for (let path of paths) {
        if (file.path.startsWith(path.path) && oldPath.startsWith(path.path))
          subscriber.renameFile(page, oldPage);
        else if (oldPath.startsWith(path.path))
          subscriber.deleteFile(oldPage);
        else if (file.path.startsWith(path.path))
          subscriber.addFile(page);
      }
    }
  }
  async addFile(file) {
    if (!this.isInited)
      return;
    const page = await this.parrentPointer.fileManager.getPage(file);
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      for (let path of paths) {
        if (!file.path.startsWith(path.path))
          continue;
        subscriber.addFile(page);
      }
    }
  }
  async changeFile(file) {
    if (!this.isInited)
      return;
    const page = await this.parrentPointer.fileManager.getPage(file);
    const oldPage = this.storage.get(file.path);
    if (isEqualObj(page, oldPage))
      return;
    this.storage.set(file.path, page);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      for (let path of paths) {
        if (!file.path.startsWith(path.path))
          continue;
        subscriber.changeFile(page, oldPage);
      }
    }
  }
  deleteFile(file) {
    if (!this.isInited)
      return;
    const page = this.storage.get(file.path);
    this.storage.delete(file.path);
    for (let [_3, { paths, subscriber }] of this.subscribers) {
      for (let path of paths) {
        if (!file.path.startsWith(path.path))
          continue;
        subscriber.deleteFile(page);
      }
    }
  }
  async reset() {
    this.isInited = false;
    this.storage.clear();
    const tmp = this.subscribers;
    this.subscribers = /* @__PURE__ */ new Map();
    await this.initStorage();
    for (let [_3, { subscriber }] of tmp)
      subscriber.reset();
  }
  async initStorage() {
    const tFiles = this.parrentPointer.app.vault.getMarkdownFiles();
    const notice = new import_obsidian2.Notice(
      `${MSG_PLG_NAME}: there are ${tFiles.length} notes`,
      1e3 * 60
      // 60 seconds
    );
    for (let i3 in tFiles) {
      const tFile = tFiles[i3];
      notice.setMessage(`${MSG_PLG_NAME}: (${i3}/${tFiles.length}) added ${tFile.path}`);
      this.storage.set(
        tFile.path,
        await this.parrentPointer.fileManager.getPage(tFile)
      );
    }
    notice.hide();
    new import_obsidian2.Notice(`${MSG_PLG_NAME}: cache has been inited`);
    this.initSyncResolve();
    this.isInited = true;
  }
};

// src/setting.ts
var import_obsidian3 = require("obsidian");
var MySettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    const settings = this.plugin.getSettings();
    new import_obsidian3.Setting(containerEl).setHeading().setName("It's recommended to reload ObsidianApp after changing the settings");
    new import_obsidian3.Setting(containerEl).addButton(
      (btn) => {
        btn.setButtonText("Set Default Values").onClick(
          () => {
            this.plugin.saveSettings(DEFAULT_SETTINGS);
            new import_obsidian3.Notice(MSG_PLG_NAME + "The default settings has been applied");
          }
        );
      }
    );
    new import_obsidian3.Setting(containerEl).setHeading();
    new import_obsidian3.Setting(containerEl).setName("Calendar").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Slot duration").setDesc(`Default: ${DEFAULT_SETTINGS.calendar.slotDuration}`).addText(
      (component) => {
        component.setPlaceholder("hh:mm:ss").setValue(settings.calendar.slotDuration).onChange(
          (value) => {
            settings.calendar.slotDuration = value;
            this.plugin.saveSettings(settings);
          }
        );
      }
    );
    new import_obsidian3.Setting(containerEl).setName("Colours").setHeading();
    for (let key of Object.keys(settings.calendar.colours)) {
      this.addColourSetting(
        containerEl,
        key,
        DEFAULT_SETTINGS.calendar.colours[key],
        settings.calendar.colours[key],
        (val) => {
          settings.calendar.colours[key] = val;
          this.plugin.saveSettings(settings);
        }
      );
    }
    new import_obsidian3.Setting(containerEl).setName("RestTime").setHeading();
    for (let index8 in settings.calendar.restTime) {
      const el = settings.calendar.restTime[index8];
      let name = "";
      if (el.color === COLOUR_REST) {
        name = "Rest time";
      } else if (el.color === COLOUR_SLEEP) {
        name = "Sleep time";
      } else
        continue;
      new import_obsidian3.Setting(containerEl).setName(`Start of ${name} (${index8})`).addText(
        (text) => {
          text.setValue(el.startTime).setPlaceholder("hh:mm:ss").onChange(
            (val) => {
              settings.calendar.restTime[index8].startTime = val;
              this.plugin.saveSettings(settings);
            }
          );
        }
      );
      new import_obsidian3.Setting(containerEl).setName(`End of ${name} (${index8})`).addText(
        (text) => {
          text.setValue(el.endTime).setPlaceholder("hh:mm:ss").onChange(
            (val) => {
              settings.calendar.restTime[index8].endTime = val;
              this.plugin.saveSettings(settings);
            }
          );
        }
      );
    }
    new import_obsidian3.Setting(containerEl).setHeading();
    new import_obsidian3.Setting(containerEl).setName("StatusCorrector").setHeading();
    const statusCorrector = settings.statusCorrector.isOn;
    new import_obsidian3.Setting(containerEl).setName("Enable tool").addToggle(
      (toggle) => toggle.setValue(statusCorrector).onChange(
        (value) => {
          settings.statusCorrector.isOn = value;
          this.plugin.saveSettings(settings);
          this.display();
        }
      )
    );
    if (statusCorrector) {
      new import_obsidian3.Setting(containerEl).setName("Start on Start Up").addToggle(
        (toggle) => toggle.setValue(settings.statusCorrector.startOnStartUp).onChange(
          (val) => {
            settings.statusCorrector.startOnStartUp = val;
            this.plugin.saveSettings(settings);
          }
        )
      );
    }
  }
  addColourSetting(containerEl, name, defaultValue, currentValue, callback) {
    new import_obsidian3.Setting(containerEl).setName(name).setDesc(`Default: ${defaultValue}`).addText(
      (component) => {
        component.setPlaceholder("#0f0f0f").setValue(currentValue).onChange((val) => callback(val));
      }
    );
  }
};

// src/fileManager.ts
var import_obsidian4 = require("obsidian");
var FileManager = class {
  constructor(plg) {
    this.app = plg.app;
  }
  async createFile(path) {
    await this.app.vault.create(path, "");
    new import_obsidian4.Notice(MSG_PLG_NAME + "created " + path);
  }
  async changePropertyFile(path, event) {
    const tFile = this.app.metadataCache.getFirstLinkpathDest(path, "");
    await this.app.fileManager.processFrontMatter(
      tFile,
      (property) => {
        property["ff_date"] = event["ff_date"].toISOString().slice(0, -14);
        property["ff_timeStart"] = event["ff_timeStart"];
        property["ff_duration"] = event["ff_duration"];
      }
    );
  }
  async changeStatusFile(path, status) {
    const tFile = this.app.metadataCache.getFirstLinkpathDest(path, "");
    await this.app.fileManager.processFrontMatter(
      tFile,
      (property) => {
        property["ff_status"] = status;
      }
    );
  }
  async changeTickFile(path, tickname, event) {
    const tFile = this.app.metadataCache.getFirstLinkpathDest(path, "");
    const text = await this.app.vault.read(tFile);
    const regExp = new RegExp(`\\[t::\\s*${tickname}(,[^\\]]*|)\\]`, "gm");
    const date = event["ff_date"].toISOString().slice(0, -14);
    const newString = `[t::${tickname},${date},${event["ff_timeStart"]},${event["ff_duration"]}]`;
    await this.app.vault.modify(
      tFile,
      text.replace(regExp, newString)
    );
  }
  openNote(event) {
    var _a;
    const tFile = this.app.metadataCache.getFirstLinkpathDest(
      ((_a = event == null ? void 0 : event.extendedProps) == null ? void 0 : _a.notePath) || event.id,
      ""
    );
    const leaf = this.app.workspace.getLeaf(true);
    tFile && leaf.openFile(tFile);
  }
  async getPage(file) {
    var _a;
    const result = {
      file: {
        path: file.path,
        name: file.basename
      },
      ticks: getTicksFromText(await this.app.vault.cachedRead(file)),
      ff_duration: "",
      ff_timeStart: "",
      // TODO из-за того, что не все заметки имеют ff_date, он должен возвращать null, но это bad practice
      //@ts-ignore
      ff_date: null
    };
    const property = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    if (!property) {
      return result;
    }
    const added = {
      ff_duration: dv.duration(property.ff_duration),
      ff_timeStart: dv.duration(property.ff_timeStart),
      ff_date: dv.date(property.ff_date),
      ff_status: property.ff_status
    };
    return {
      ...result,
      ...added
    };
  }
  getTaskCount(page) {
    var _a;
    const result = {
      done: 0,
      all: 0
    };
    const tFile = this.app.vault.getFileByPath(page.file.path);
    if (!tFile)
      return result;
    const items = (_a = this.app.metadataCache.getFileCache(tFile)) == null ? void 0 : _a.listItems;
    if (items)
      for (let item of items) {
        if (item.task == void 0)
          continue;
        if (item.task == "x") {
          ++result.done;
        }
        ++result.all;
      }
    return result;
  }
  async getText(path) {
    const tFile = this.app.metadataCache.getFirstLinkpathDest(path, "");
    const text = await this.app.vault.read(tFile);
    return text;
  }
  async setText(path, text) {
    const tFile = this.app.metadataCache.getFirstLinkpathDest(path, "");
    await this.app.vault.modify(tFile, text);
  }
};

// src/views/TickCheker.ts
var import_obsidian5 = require("obsidian");
var TickChecker = class {
  constructor(idForCache, event_src, ptr) {
    this.parent = ptr;
    this.idForCache = idForCache;
    this.parent.cache.subscribe(idForCache, event_src, this).then((data) => this.process(data));
  }
  async process(pages) {
    for (let page of pages) {
      for (let tick of page.ticks) {
        if (isNaN(safeParseInt(tick.name)))
          continue;
        let text = await this.parent.fileManager.getText(page.file.path);
        const regExp = new RegExp(`\\[t::\\s*${tick.name}(,[^\\]]*|)\\]`, "gm");
        await this.parent.fileManager.setText(
          page.file.path,
          text.replace(regExp, `[t::${tick.name}_$1]`)
        );
        new import_obsidian5.Notice(MSG_PLG_NAME + `change tickname in ${page.file.name}: ${tick.name}`);
      }
    }
    this.parent.cache.unsubscribe(this.idForCache);
  }
  renameFile(newPage, oldPage) {
  }
  deleteFile(page) {
  }
  addFile(page) {
  }
  changeFile(newPage, oldPage) {
  }
  reset() {
  }
};

// src/main.ts
var MyPlugin = class extends import_obsidian6.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    const fileManager = new FileManager(this);
    this.fileManager = fileManager;
    this.cache = new Cache2(this, fileManager);
  }
  async onload() {
    await this.loadSettings();
    this.initRegister();
    await new TickChecker(3 /* TICK_CHECKER */, this.settings.source.noteSources, this);
    this.registerView(
      VIEW_TYPE,
      (leaf) => new CalendarView(
        leaf,
        1 /* CALENDAR */,
        this.settings.source.noteSources,
        this,
        this.settings.source.defaultCreatePath
      )
    );
    this.addRibbonIcon("info", MSG_PLG_NAME + "Open Calendar", () => this.activateView());
    this.addCommand({
      id: "reset-cache",
      name: MSG_PLG_NAME + "Reset Cache",
      callback: () => {
        this.cache.reset();
      }
    });
    this.addCommand({
      id: "log-cache",
      name: MSG_PLG_NAME + "Log Cache",
      callback: () => {
        this.cache.log();
      }
    });
  }
  onunload() {
    if (this.settings.statusCorrector.isOn)
      this.statusCorrector.destroy();
  }
  initRegister() {
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        this.cache.changeFile(file);
      })
    );
    this.registerEvent(
      this.app.vault.on(
        "rename",
        (file, oldPath) => {
          if (!file.basename)
            return;
          this.cache.renameFile(file, oldPath);
        }
      )
    );
    this.registerEvent(
      this.app.vault.on(
        "delete",
        (file) => this.cache.deleteFile(file)
      )
    );
    this.registerEvent(
      this.app.vault.on(
        "create",
        (file) => {
          if (!file.basename)
            return;
          this.cache.addFile(file);
        }
      )
    );
  }
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
    if (leaves.length === 0) {
      const leaf = this.app.workspace.getLeaf(false);
      await leaf.setViewState({
        type: VIEW_TYPE,
        active: true
      });
    } else if (leaves.length === 1) {
      leaves[0].view.onOpen();
      this.app.workspace.setActiveLeaf(leaves[0]);
    } else
      for (let leaf of leaves)
        leaf.detach();
  }
  // Settings
  getSettings() {
    return JSON.parse(
      JSON.stringify(this.settings)
    );
  }
  async saveSettings(settings) {
    this.settings = settings;
    await this.saveData(this.settings);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.addSettingTab(new MySettingTab(this.app, this));
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZm9ybWF0cy5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy96b25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL3N5c3RlbVpvbmUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvSUFOQVpvbmUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9sb2NhbGUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvem9uZXMvZml4ZWRPZmZzZXRab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL3pvbmVzL2ludmFsaWRab25lLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvem9uZVV0aWwuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvc2V0dGluZ3MuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC91dGlsLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZW5nbGlzaC5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2Zvcm1hdHRlci5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2ludmFsaWQuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvaW1wbC9yZWdleFBhcnNlci5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9kdXJhdGlvbi5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbnRlcnZhbC5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbmZvLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvZGlmZi5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL2RpZ2l0cy5qcyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvbm9kZV9tb2R1bGVzL2x1eG9uL3NyYy9pbXBsL3Rva2VuUGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9ub2RlX21vZHVsZXMvbHV4b24vc3JjL2ltcGwvY29udmVyc2lvbnMuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9sdXhvbi9zcmMvZGF0ZXRpbWUuanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9zZXR0aW5ncy50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2FwaS9yZXN1bHQudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9wYXJzaW1tb24vYnVpbGQvcGFyc2ltbW9uLnVtZC5taW4uanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L25vZGVfbW9kdWxlcy9lbW9qaS1yZWdleC9pbmRleC5tanMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy91dGlsL25vcm1hbGl6ZS50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2RhdGEtbW9kZWwvdmFsdWUudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9leHByZXNzaW9uL2ZpZWxkLnRzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9zcmMvZGF0YS1pbmRleC9zb3VyY2UudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9leHByZXNzaW9uL3BhcnNlLnRzIiwgIm5vZGVfbW9kdWxlcy9vYnNpZGlhbi1kYXRhdmlldy9zcmMvcXVlcnkvcXVlcnkudHMiLCAibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhdGF2aWV3L3NyYy9xdWVyeS9wYXJzZS50cyIsICJub2RlX21vZHVsZXMvb2JzaWRpYW4tZGF0YXZpZXcvc3JjL2luZGV4LnRzIiwgIm5vZGVfbW9kdWxlcy9pY2FsLmpzL2J1aWxkL2ljYWwuanMiLCAic3JjL21haW4udHMiLCAic3JjL3ZpZXdzL0NhbGVuZGFyVmlldy50cyIsICJzcmMvdHlwZXMudHMiLCAic3JjL2NvbnN0YW50cy50cyIsICJzcmMvdXRpbC50cyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL3V0aWwuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9vcHRpb25zLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL3Byb3BzLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY29tcG9uZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWNvbnRleHQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NoaWxkcmVuLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL3JlbmRlci5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2Nsb25lLWVsZW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9ob29rcy9zcmMvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvdXRpbC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9QdXJlQ29tcG9uZW50LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL21lbW8uanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvZm9yd2FyZFJlZi5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9DaGlsZHJlbi5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb3JlL25vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9zdXNwZW5zZS1saXN0LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3BvcnRhbHMuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29yZS9ub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcmVuZGVyLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvbm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwtY29tbW9uLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvZGF5Z3JpZC9pbnRlcm5hbC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3RpbWVncmlkL2ludGVybmFsLmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3RpbWVncmlkL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvd2Vla2RheS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2hlbHBlcnMudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9kYXRldXRpbC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJyZXN1bHQudHMiLCAibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2NhbGxiYWNraXRlcnJlc3VsdC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9pMThuLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvbmxwL3RvdGV4dC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9wYXJzZXRleHQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy90eXBlcy50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL25scC9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2RhdGV0aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcGFyc2VvcHRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvcGFyc2VzdHJpbmcudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9kYXRld2l0aHpvbmUudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9vcHRpb25zdG9zdHJpbmcudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9jYWNoZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL21hc2tzLnRzIiwgIm5vZGVfbW9kdWxlcy9ycnVsZS9zcmMvaXRlcmluZm8veWVhcmluZm8udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9tb250aGluZm8udHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9lYXN0ZXIudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9pdGVyaW5mby9pbmRleC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXIvcG9zbGlzdC50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXIvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ycnVsZS50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL2l0ZXJzZXQudHMiLCAibm9kZV9tb2R1bGVzL3JydWxlL3NyYy9ycnVsZXN0ci50cyIsICJub2RlX21vZHVsZXMvcnJ1bGUvc3JjL3JydWxlc2V0LnRzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3JydWxlL2luZGV4LmpzIiwgIm5vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2xpc3QvaW50ZXJuYWwuanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvbGlzdC9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbi9pbmRleC5qcyIsICJub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9nb29nbGUtY2FsZW5kYXIvaW5kZXguanMiLCAibm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvaWNhbGVuZGFyL2luZGV4LmpzIiwgImxpYi9vYnNpZGlhbi1mdWxsLWNhbGVuZGFyL2NhbGVuZGFyLnRzIiwgInNyYy9jYWNoZS50cyIsICJzcmMvc2V0dGluZy50cyIsICJzcmMvZmlsZU1hbmFnZXIudHMiLCAic3JjL3ZpZXdzL1RpY2tDaGVrZXIudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIHRoZXNlIGFyZW4ndCByZWFsbHkgcHJpdmF0ZSwgYnV0IG5vciBhcmUgdGhleSByZWFsbHkgdXNlZnVsIHRvIGRvY3VtZW50XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgTHV4b25FcnJvciBleHRlbmRzIEVycm9yIHt9XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREYXRlVGltZUVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbikge1xuICAgIHN1cGVyKGBJbnZhbGlkIERhdGVUaW1lOiAke3JlYXNvbi50b01lc3NhZ2UoKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSW50ZXJ2YWxFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBzdXBlcihgSW52YWxpZCBJbnRlcnZhbDogJHtyZWFzb24udG9NZXNzYWdlKCl9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZER1cmF0aW9uRXJyb3IgZXh0ZW5kcyBMdXhvbkVycm9yIHtcbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgc3VwZXIoYEludmFsaWQgRHVyYXRpb246ICR7cmVhc29uLnRvTWVzc2FnZSgpfWApO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7fVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVW5pdEVycm9yIGV4dGVuZHMgTHV4b25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHVuaXQpIHtcbiAgICBzdXBlcihgSW52YWxpZCB1bml0ICR7dW5pdH1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQXJndW1lbnRFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige31cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgWm9uZUlzQWJzdHJhY3RFcnJvciBleHRlbmRzIEx1eG9uRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlpvbmUgaXMgYW4gYWJzdHJhY3QgY2xhc3NcIik7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY29uc3QgbiA9IFwibnVtZXJpY1wiLFxuICBzID0gXCJzaG9ydFwiLFxuICBsID0gXCJsb25nXCI7XG5cbmV4cG9ydCBjb25zdCBEQVRFX1NIT1JUID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbixcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfTUVEID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogcyxcbiAgZGF5OiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVfTUVEX1dJVEhfV0VFS0RBWSA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgd2Vla2RheTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFX0ZVTEwgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBsLFxuICBkYXk6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgREFURV9IVUdFID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfU0lNUExFID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX1NFQ09ORFMgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfV0lUSF9TSE9SVF9PRkZTRVQgPSB7XG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV9XSVRIX0xPTkdfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgdGltZVpvbmVOYW1lOiBsLFxufTtcblxuZXhwb3J0IGNvbnN0IFRJTUVfMjRfU0lNUExFID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfU0VDT05EUyA9IHtcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIGhvdXJDeWNsZTogXCJoMjNcIixcbn07XG5cbmV4cG9ydCBjb25zdCBUSU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICB0aW1lWm9uZU5hbWU6IHMsXG59O1xuXG5leHBvcnQgY29uc3QgVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUID0ge1xuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHNlY29uZDogbixcbiAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICB0aW1lWm9uZU5hbWU6IGwsXG59O1xuXG5leHBvcnQgY29uc3QgREFURVRJTUVfU0hPUlQgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9TSE9SVF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBuLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRCA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IHMsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbiAgc2Vjb25kOiBuLFxufTtcblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX01FRF9XSVRIX1dFRUtEQVkgPSB7XG4gIHllYXI6IG4sXG4gIG1vbnRoOiBzLFxuICBkYXk6IG4sXG4gIHdlZWtkYXk6IHMsXG4gIGhvdXI6IG4sXG4gIG1pbnV0ZTogbixcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9GVUxMID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogcyxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9IVUdFID0ge1xuICB5ZWFyOiBuLFxuICBtb250aDogbCxcbiAgZGF5OiBuLFxuICB3ZWVrZGF5OiBsLFxuICBob3VyOiBuLFxuICBtaW51dGU6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9IVUdFX1dJVEhfU0VDT05EUyA9IHtcbiAgeWVhcjogbixcbiAgbW9udGg6IGwsXG4gIGRheTogbixcbiAgd2Vla2RheTogbCxcbiAgaG91cjogbixcbiAgbWludXRlOiBuLFxuICBzZWNvbmQ6IG4sXG4gIHRpbWVab25lTmFtZTogbCxcbn07XG4iLCAiaW1wb3J0IHsgWm9uZUlzQWJzdHJhY3RFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWm9uZSB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB6b25lXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGlzIHpvbmUuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIGdldCBpYW5hTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgb2Zmc2V0IGlzIGtub3duIHRvIGJlIGZpeGVkIGZvciB0aGUgd2hvbGUgeWVhci5cbiAgICogQGFic3RyYWN0XG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgY29tbW9uIG5hbWUgKHN1Y2ggYXMgRVNUKSBhdCB0aGUgc3BlY2lmaWVkIHRpbWVzdGFtcFxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRzIC0gRXBvY2ggbWlsbGlzZWNvbmRzIGZvciB3aGljaCB0byBnZXQgdGhlIG5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIGFmZmVjdCB0aGUgZm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLmZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi4gQWNjZXB0cyAnbG9uZycgb3IgJ3Nob3J0Jy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubG9jYWxlIC0gV2hhdCBsb2NhbGUgdG8gcmV0dXJuIHRoZSBvZmZzZXQgbmFtZSBpbi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgb2Zmc2V0TmFtZSh0cywgb3B0cykge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0J3MgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cyAtIEVwb2NoIG1pbGxpc2Vjb25kcyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBvZmZzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIFdoYXQgc3R5bGUgb2Ygb2Zmc2V0IHRvIHJldHVybi5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIEFjY2VwdHMgJ25hcnJvdycsICdzaG9ydCcsIG9yICd0ZWNoaWUnLiBSZXR1cm5pbmcgJys2JywgJyswNjowMCcsIG9yICcrMDYwMCcgcmVzcGVjdGl2ZWx5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IFpvbmVJc0Fic3RyYWN0RXJyb3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG9mZnNldCBpbiBtaW51dGVzIGZvciB0aGlzIHpvbmUgYXQgdGhlIHNwZWNpZmllZCB0aW1lc3RhbXAuXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge251bWJlcn0gdHMgLSBFcG9jaCBtaWxsaXNlY29uZHMgZm9yIHdoaWNoIHRvIGNvbXB1dGUgdGhlIG9mZnNldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBvZmZzZXQodHMpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgWm9uZSBpcyBlcXVhbCB0byBhbm90aGVyIHpvbmVcbiAgICogQGFic3RyYWN0XG4gICAqIEBwYXJhbSB7Wm9uZX0gb3RoZXJab25lIC0gdGhlIHpvbmUgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXF1YWxzKG90aGVyWm9uZSkge1xuICAgIHRocm93IG5ldyBab25lSXNBYnN0cmFjdEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBab25lIGlzIHZhbGlkLlxuICAgKiBAYWJzdHJhY3RcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICB0aHJvdyBuZXcgWm9uZUlzQWJzdHJhY3RFcnJvcigpO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZm9ybWF0T2Zmc2V0LCBwYXJzZVpvbmVJbmZvIH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbG9jYWwgem9uZSBmb3IgdGhpcyBKYXZhU2NyaXB0IGVudmlyb25tZW50LlxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN5c3RlbVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiB0aGUgbG9jYWwgem9uZVxuICAgKiBAcmV0dXJuIHtTeXN0ZW1ab25lfVxuICAgKi9cbiAgc3RhdGljIGdldCBpbnN0YW5jZSgpIHtcbiAgICBpZiAoc2luZ2xldG9uID09PSBudWxsKSB7XG4gICAgICBzaW5nbGV0b24gPSBuZXcgU3lzdGVtWm9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2luZ2xldG9uO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIFwic3lzdGVtXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoKS5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKHRzLCB7IGZvcm1hdCwgbG9jYWxlIH0pIHtcbiAgICByZXR1cm4gcGFyc2Vab25lSW5mbyh0cywgZm9ybWF0LCBsb2NhbGUpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZm9ybWF0T2Zmc2V0KHRzLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHRoaXMub2Zmc2V0KHRzKSwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCh0cykge1xuICAgIHJldHVybiAtbmV3IERhdGUodHMpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcInN5c3RlbVwiO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBmb3JtYXRPZmZzZXQsIHBhcnNlWm9uZUluZm8sIGlzVW5kZWZpbmVkLCBvYmpUb0xvY2FsVFMgfSBmcm9tIFwiLi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgWm9uZSBmcm9tIFwiLi4vem9uZS5qc1wiO1xuXG5sZXQgZHRmQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIG1ha2VEVEYoem9uZSkge1xuICBpZiAoIWR0ZkNhY2hlW3pvbmVdKSB7XG4gICAgZHRmQ2FjaGVbem9uZV0gPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChcImVuLVVTXCIsIHtcbiAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICB0aW1lWm9uZTogem9uZSxcbiAgICAgIHllYXI6IFwibnVtZXJpY1wiLFxuICAgICAgbW9udGg6IFwiMi1kaWdpdFwiLFxuICAgICAgZGF5OiBcIjItZGlnaXRcIixcbiAgICAgIGhvdXI6IFwiMi1kaWdpdFwiLFxuICAgICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICAgIHNlY29uZDogXCIyLWRpZ2l0XCIsXG4gICAgICBlcmE6IFwic2hvcnRcIixcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZHRmQ2FjaGVbem9uZV07XG59XG5cbmNvbnN0IHR5cGVUb1BvcyA9IHtcbiAgeWVhcjogMCxcbiAgbW9udGg6IDEsXG4gIGRheTogMixcbiAgZXJhOiAzLFxuICBob3VyOiA0LFxuICBtaW51dGU6IDUsXG4gIHNlY29uZDogNixcbn07XG5cbmZ1bmN0aW9uIGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSkge1xuICBjb25zdCBmb3JtYXR0ZWQgPSBkdGYuZm9ybWF0KGRhdGUpLnJlcGxhY2UoL1xcdTIwMEUvZywgXCJcIiksXG4gICAgcGFyc2VkID0gLyhcXGQrKVxcLyhcXGQrKVxcLyhcXGQrKSAoQUR8QkMpLD8gKFxcZCspOihcXGQrKTooXFxkKykvLmV4ZWMoZm9ybWF0dGVkKSxcbiAgICBbLCBmTW9udGgsIGZEYXksIGZZZWFyLCBmYWRPckJjLCBmSG91ciwgZk1pbnV0ZSwgZlNlY29uZF0gPSBwYXJzZWQ7XG4gIHJldHVybiBbZlllYXIsIGZNb250aCwgZkRheSwgZmFkT3JCYywgZkhvdXIsIGZNaW51dGUsIGZTZWNvbmRdO1xufVxuXG5mdW5jdGlvbiBwYXJ0c09mZnNldChkdGYsIGRhdGUpIHtcbiAgY29uc3QgZm9ybWF0dGVkID0gZHRmLmZvcm1hdFRvUGFydHMoZGF0ZSk7XG4gIGNvbnN0IGZpbGxlZCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZvcm1hdHRlZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IGZvcm1hdHRlZFtpXTtcbiAgICBjb25zdCBwb3MgPSB0eXBlVG9Qb3NbdHlwZV07XG5cbiAgICBpZiAodHlwZSA9PT0gXCJlcmFcIikge1xuICAgICAgZmlsbGVkW3Bvc10gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKCFpc1VuZGVmaW5lZChwb3MpKSB7XG4gICAgICBmaWxsZWRbcG9zXSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaWxsZWQ7XG59XG5cbmxldCBpYW5hWm9uZUNhY2hlID0ge307XG4vKipcbiAqIEEgem9uZSBpZGVudGlmaWVkIGJ5IGFuIElBTkEgaWRlbnRpZmllciwgbGlrZSBBbWVyaWNhL05ld19Zb3JrXG4gKiBAaW1wbGVtZW50cyB7Wm9uZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSUFOQVpvbmUgZXh0ZW5kcyBab25lIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gWm9uZSBuYW1lXG4gICAqIEByZXR1cm4ge0lBTkFab25lfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShuYW1lKSB7XG4gICAgaWYgKCFpYW5hWm9uZUNhY2hlW25hbWVdKSB7XG4gICAgICBpYW5hWm9uZUNhY2hlW25hbWVdID0gbmV3IElBTkFab25lKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gaWFuYVpvbmVDYWNoZVtuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCBsb2NhbCBjYWNoZXMuIFNob3VsZCBvbmx5IGJlIG5lY2Vzc2FyeSBpbiB0ZXN0aW5nIHNjZW5hcmlvcy5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHN0YXRpYyByZXNldENhY2hlKCkge1xuICAgIGlhbmFab25lQ2FjaGUgPSB7fTtcbiAgICBkdGZDYWNoZSA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgc3RyaW5nIGlzIGEgdmFsaWQgc3BlY2lmaWVyLiBUaGlzIG9ubHkgY2hlY2tzIHRoZSBzdHJpbmcncyBmb3JtYXQsIG5vdCB0aGF0IHRoZSBzcGVjaWZpZXIgaWRlbnRpZmllcyBhIGtub3duIHpvbmU7IHNlZSBpc1ZhbGlkWm9uZSBmb3IgdGhhdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSBUaGUgc3RyaW5nIHRvIGNoZWNrIHZhbGlkaXR5IG9uXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRTcGVjaWZpZXIoXCJBbWVyaWNhL05ld19Zb3JrXCIpIC8vPT4gdHJ1ZVxuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkU3BlY2lmaWVyKFwiU3BvcnR+fmJsb3JwXCIpIC8vPT4gZmFsc2VcbiAgICogQGRlcHJlY2F0ZWQgVGhpcyBtZXRob2QgcmV0dXJucyBmYWxzZSBmb3Igc29tZSB2YWxpZCBJQU5BIG5hbWVzLiBVc2UgaXNWYWxpZFpvbmUgaW5zdGVhZC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc1ZhbGlkU3BlY2lmaWVyKHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkWm9uZShzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHN0cmluZyBpZGVudGlmaWVzIGEgcmVhbCB6b25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6b25lIC0gVGhlIHN0cmluZyB0byBjaGVja1xuICAgKiBAZXhhbXBsZSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShcIkFtZXJpY2EvTmV3X1lvcmtcIikgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIElBTkFab25lLmlzVmFsaWRab25lKFwiRmFudGFzaWEvQ2FzdGxlXCIpIC8vPT4gZmFsc2VcbiAgICogQGV4YW1wbGUgSUFOQVpvbmUuaXNWYWxpZFpvbmUoXCJTcG9ydH5+YmxvcnBcIikgLy89PiBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzVmFsaWRab25lKHpvbmUpIHtcbiAgICBpZiAoIXpvbmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyB0aW1lWm9uZTogem9uZSB9KS5mb3JtYXQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy56b25lTmFtZSA9IG5hbWU7XG4gICAgLyoqIEBwcml2YXRlICoqL1xuICAgIHRoaXMudmFsaWQgPSBJQU5BWm9uZS5pc1ZhbGlkWm9uZShuYW1lKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImlhbmFcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUodHMsIHsgZm9ybWF0LCBsb2NhbGUgfSkge1xuICAgIHJldHVybiBwYXJzZVpvbmVJbmZvKHRzLCBmb3JtYXQsIGxvY2FsZSwgdGhpcy5uYW1lKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGZvcm1hdE9mZnNldCh0cywgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdE9mZnNldCh0aGlzLm9mZnNldCh0cyksIGZvcm1hdCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQodHMpIHtcbiAgICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpO1xuXG4gICAgaWYgKGlzTmFOKGRhdGUpKSByZXR1cm4gTmFOO1xuXG4gICAgY29uc3QgZHRmID0gbWFrZURURih0aGlzLm5hbWUpO1xuICAgIGxldCBbeWVhciwgbW9udGgsIGRheSwgYWRPckJjLCBob3VyLCBtaW51dGUsIHNlY29uZF0gPSBkdGYuZm9ybWF0VG9QYXJ0c1xuICAgICAgPyBwYXJ0c09mZnNldChkdGYsIGRhdGUpXG4gICAgICA6IGhhY2t5T2Zmc2V0KGR0ZiwgZGF0ZSk7XG5cbiAgICBpZiAoYWRPckJjID09PSBcIkJDXCIpIHtcbiAgICAgIHllYXIgPSAtTWF0aC5hYnMoeWVhcikgKyAxO1xuICAgIH1cblxuICAgIC8vIGJlY2F1c2Ugd2UncmUgdXNpbmcgaG91cjEyIGFuZCBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDI1NTY0JmNhbj0yJnE9JTIyMjQlM0EwMCUyMiUyMGRhdGV0aW1lZm9ybWF0XG4gICAgY29uc3QgYWRqdXN0ZWRIb3VyID0gaG91ciA9PT0gMjQgPyAwIDogaG91cjtcblxuICAgIGNvbnN0IGFzVVRDID0gb2JqVG9Mb2NhbFRTKHtcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheSxcbiAgICAgIGhvdXI6IGFkanVzdGVkSG91cixcbiAgICAgIG1pbnV0ZSxcbiAgICAgIHNlY29uZCxcbiAgICAgIG1pbGxpc2Vjb25kOiAwLFxuICAgIH0pO1xuXG4gICAgbGV0IGFzVFMgPSArZGF0ZTtcbiAgICBjb25zdCBvdmVyID0gYXNUUyAlIDEwMDA7XG4gICAgYXNUUyAtPSBvdmVyID49IDAgPyBvdmVyIDogMTAwMCArIG92ZXI7XG4gICAgcmV0dXJuIChhc1VUQyAtIGFzVFMpIC8gKDYwICogMTAwMCk7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBlcXVhbHMob3RoZXJab25lKSB7XG4gICAgcmV0dXJuIG90aGVyWm9uZS50eXBlID09PSBcImlhbmFcIiAmJiBvdGhlclpvbmUubmFtZSA9PT0gdGhpcy5uYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWQ7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBwYWRTdGFydCwgcm91bmRUbywgaGFzUmVsYXRpdmUsIGZvcm1hdE9mZnNldCB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCAqIGFzIEVuZ2xpc2ggZnJvbSBcIi4vZW5nbGlzaC5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuLi9zZXR0aW5ncy5qc1wiO1xuaW1wb3J0IERhdGVUaW1lIGZyb20gXCIuLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuXG4vLyB0b2RvIC0gcmVtYXAgY2FjaGluZ1xuXG5sZXQgaW50bExGQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZExGKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGR0ZiA9IGludGxMRkNhY2hlW2tleV07XG4gIGlmICghZHRmKSB7XG4gICAgZHRmID0gbmV3IEludGwuTGlzdEZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxMRkNhY2hlW2tleV0gPSBkdGY7XG4gIH1cbiAgcmV0dXJuIGR0Zjtcbn1cblxubGV0IGludGxEVENhY2hlID0ge307XG5mdW5jdGlvbiBnZXRDYWNoZWREVEYobG9jU3RyaW5nLCBvcHRzID0ge30pIHtcbiAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkoW2xvY1N0cmluZywgb3B0c10pO1xuICBsZXQgZHRmID0gaW50bERUQ2FjaGVba2V5XTtcbiAgaWYgKCFkdGYpIHtcbiAgICBkdGYgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxEVENhY2hlW2tleV0gPSBkdGY7XG4gIH1cbiAgcmV0dXJuIGR0Zjtcbn1cblxubGV0IGludGxOdW1DYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0Q2FjaGVkSU5GKGxvY1N0cmluZywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KFtsb2NTdHJpbmcsIG9wdHNdKTtcbiAgbGV0IGluZiA9IGludGxOdW1DYWNoZVtrZXldO1xuICBpZiAoIWluZikge1xuICAgIGluZiA9IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxOdW1DYWNoZVtrZXldID0gaW5mO1xuICB9XG4gIHJldHVybiBpbmY7XG59XG5cbmxldCBpbnRsUmVsQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldENhY2hlZFJURihsb2NTdHJpbmcsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IGJhc2UsIC4uLmNhY2hlS2V5T3B0cyB9ID0gb3B0czsgLy8gZXhjbHVkZSBgYmFzZWAgZnJvbSB0aGUgb3B0aW9uc1xuICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShbbG9jU3RyaW5nLCBjYWNoZUtleU9wdHNdKTtcbiAgbGV0IGluZiA9IGludGxSZWxDYWNoZVtrZXldO1xuICBpZiAoIWluZikge1xuICAgIGluZiA9IG5ldyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdChsb2NTdHJpbmcsIG9wdHMpO1xuICAgIGludGxSZWxDYWNoZVtrZXldID0gaW5mO1xuICB9XG4gIHJldHVybiBpbmY7XG59XG5cbmxldCBzeXNMb2NhbGVDYWNoZSA9IG51bGw7XG5mdW5jdGlvbiBzeXN0ZW1Mb2NhbGUoKSB7XG4gIGlmIChzeXNMb2NhbGVDYWNoZSkge1xuICAgIHJldHVybiBzeXNMb2NhbGVDYWNoZTtcbiAgfSBlbHNlIHtcbiAgICBzeXNMb2NhbGVDYWNoZSA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KCkucmVzb2x2ZWRPcHRpb25zKCkubG9jYWxlO1xuICAgIHJldHVybiBzeXNMb2NhbGVDYWNoZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUxvY2FsZVN0cmluZyhsb2NhbGVTdHIpIHtcbiAgLy8gSSByZWFsbHkgd2FudCB0byBhdm9pZCB3cml0aW5nIGEgQkNQIDQ3IHBhcnNlclxuICAvLyBzZWUsIGUuZy4gaHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9iY3AtNDdcbiAgLy8gSW5zdGVhZCwgd2UnbGwgZG8gdGhpczpcblxuICAvLyBhKSBpZiB0aGUgc3RyaW5nIGhhcyBubyAtdSBleHRlbnNpb25zLCBqdXN0IGxlYXZlIGl0IGFsb25lXG4gIC8vIGIpIGlmIGl0IGRvZXMsIHVzZSBJbnRsIHRvIHJlc29sdmUgZXZlcnl0aGluZ1xuICAvLyBjKSBpZiBJbnRsIGZhaWxzLCB0cnkgYWdhaW4gd2l0aG91dCB0aGUgLXVcblxuICAvLyBwcml2YXRlIHN1YnRhZ3MgYW5kIHVuaWNvZGUgc3VidGFncyBoYXZlIG9yZGVyaW5nIHJlcXVpcmVtZW50cyxcbiAgLy8gYW5kIHdlJ3JlIG5vdCBwcm9wZXJseSBwYXJzaW5nIHRoaXMsIHNvIGp1c3Qgc3RyaXAgb3V0IHRoZVxuICAvLyBwcml2YXRlIG9uZXMgaWYgdGhleSBleGlzdC5cbiAgY29uc3QgeEluZGV4ID0gbG9jYWxlU3RyLmluZGV4T2YoXCIteC1cIik7XG4gIGlmICh4SW5kZXggIT09IC0xKSB7XG4gICAgbG9jYWxlU3RyID0gbG9jYWxlU3RyLnN1YnN0cmluZygwLCB4SW5kZXgpO1xuICB9XG5cbiAgY29uc3QgdUluZGV4ID0gbG9jYWxlU3RyLmluZGV4T2YoXCItdS1cIik7XG4gIGlmICh1SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIFtsb2NhbGVTdHJdO1xuICB9IGVsc2Uge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGxldCBzZWxlY3RlZFN0cjtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucyA9IGdldENhY2hlZERURihsb2NhbGVTdHIpLnJlc29sdmVkT3B0aW9ucygpO1xuICAgICAgc2VsZWN0ZWRTdHIgPSBsb2NhbGVTdHI7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc3Qgc21hbGxlciA9IGxvY2FsZVN0ci5zdWJzdHJpbmcoMCwgdUluZGV4KTtcbiAgICAgIG9wdGlvbnMgPSBnZXRDYWNoZWREVEYoc21hbGxlcikucmVzb2x2ZWRPcHRpb25zKCk7XG4gICAgICBzZWxlY3RlZFN0ciA9IHNtYWxsZXI7XG4gICAgfVxuXG4gICAgY29uc3QgeyBudW1iZXJpbmdTeXN0ZW0sIGNhbGVuZGFyIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBbc2VsZWN0ZWRTdHIsIG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXJdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGxDb25maWdTdHJpbmcobG9jYWxlU3RyLCBudW1iZXJpbmdTeXN0ZW0sIG91dHB1dENhbGVuZGFyKSB7XG4gIGlmIChvdXRwdXRDYWxlbmRhciB8fCBudW1iZXJpbmdTeXN0ZW0pIHtcbiAgICBpZiAoIWxvY2FsZVN0ci5pbmNsdWRlcyhcIi11LVwiKSkge1xuICAgICAgbG9jYWxlU3RyICs9IFwiLXVcIjtcbiAgICB9XG5cbiAgICBpZiAob3V0cHV0Q2FsZW5kYXIpIHtcbiAgICAgIGxvY2FsZVN0ciArPSBgLWNhLSR7b3V0cHV0Q2FsZW5kYXJ9YDtcbiAgICB9XG5cbiAgICBpZiAobnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgICBsb2NhbGVTdHIgKz0gYC1udS0ke251bWJlcmluZ1N5c3RlbX1gO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlU3RyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsb2NhbGVTdHI7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwTW9udGhzKGYpIHtcbiAgY29uc3QgbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gMTI7IGkrKykge1xuICAgIGNvbnN0IGR0ID0gRGF0ZVRpbWUudXRjKDIwMDksIGksIDEpO1xuICAgIG1zLnB1c2goZihkdCkpO1xuICB9XG4gIHJldHVybiBtcztcbn1cblxuZnVuY3Rpb24gbWFwV2Vla2RheXMoZikge1xuICBjb25zdCBtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSA3OyBpKyspIHtcbiAgICBjb25zdCBkdCA9IERhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMgKyBpKTtcbiAgICBtcy5wdXNoKGYoZHQpKTtcbiAgfVxuICByZXR1cm4gbXM7XG59XG5cbmZ1bmN0aW9uIGxpc3RTdHVmZihsb2MsIGxlbmd0aCwgZW5nbGlzaEZuLCBpbnRsRm4pIHtcbiAgY29uc3QgbW9kZSA9IGxvYy5saXN0aW5nTW9kZSgpO1xuXG4gIGlmIChtb2RlID09PSBcImVycm9yXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBcImVuXCIpIHtcbiAgICByZXR1cm4gZW5nbGlzaEZuKGxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGludGxGbihsZW5ndGgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzRmFzdE51bWJlcnMobG9jKSB7XG4gIGlmIChsb2MubnVtYmVyaW5nU3lzdGVtICYmIGxvYy5udW1iZXJpbmdTeXN0ZW0gIT09IFwibGF0blwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoXG4gICAgICBsb2MubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIiB8fFxuICAgICAgIWxvYy5sb2NhbGUgfHxcbiAgICAgIGxvYy5sb2NhbGUuc3RhcnRzV2l0aChcImVuXCIpIHx8XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2MuaW50bCkucmVzb2x2ZWRPcHRpb25zKCkubnVtYmVyaW5nU3lzdGVtID09PSBcImxhdG5cIlxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmNsYXNzIFBvbHlOdW1iZXJGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBmb3JjZVNpbXBsZSwgb3B0cykge1xuICAgIHRoaXMucGFkVG8gPSBvcHRzLnBhZFRvIHx8IDA7XG4gICAgdGhpcy5mbG9vciA9IG9wdHMuZmxvb3IgfHwgZmFsc2U7XG5cbiAgICBjb25zdCB7IHBhZFRvLCBmbG9vciwgLi4ub3RoZXJPcHRzIH0gPSBvcHRzO1xuXG4gICAgaWYgKCFmb3JjZVNpbXBsZSB8fCBPYmplY3Qua2V5cyhvdGhlck9wdHMpLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGludGxPcHRzID0geyB1c2VHcm91cGluZzogZmFsc2UsIC4uLm9wdHMgfTtcbiAgICAgIGlmIChvcHRzLnBhZFRvID4gMCkgaW50bE9wdHMubWluaW11bUludGVnZXJEaWdpdHMgPSBvcHRzLnBhZFRvO1xuICAgICAgdGhpcy5pbmYgPSBnZXRDYWNoZWRJTkYoaW50bCwgaW50bE9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChpKSB7XG4gICAgaWYgKHRoaXMuaW5mKSB7XG4gICAgICBjb25zdCBmaXhlZCA9IHRoaXMuZmxvb3IgPyBNYXRoLmZsb29yKGkpIDogaTtcbiAgICAgIHJldHVybiB0aGlzLmluZi5mb3JtYXQoZml4ZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0byBtYXRjaCB0aGUgYnJvd3NlcidzIG51bWJlcmZvcm1hdHRlciBkZWZhdWx0c1xuICAgICAgY29uc3QgZml4ZWQgPSB0aGlzLmZsb29yID8gTWF0aC5mbG9vcihpKSA6IHJvdW5kVG8oaSwgMyk7XG4gICAgICByZXR1cm4gcGFkU3RhcnQoZml4ZWQsIHRoaXMucGFkVG8pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuY2xhc3MgUG9seURhdGVGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihkdCwgaW50bCwgb3B0cykge1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5vcmlnaW5hbFpvbmUgPSB1bmRlZmluZWQ7XG5cbiAgICBsZXQgeiA9IHVuZGVmaW5lZDtcbiAgICBpZiAodGhpcy5vcHRzLnRpbWVab25lKSB7XG4gICAgICAvLyBEb24ndCBhcHBseSBhbnkgd29ya2Fyb3VuZHMgaWYgYSB0aW1lWm9uZSBpcyBleHBsaWNpdGx5IHByb3ZpZGVkIGluIG9wdHNcbiAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICB9IGVsc2UgaWYgKGR0LnpvbmUudHlwZSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAvLyBVVEMtOCBvciBFdGMvVVRDLTggYXJlIG5vdCBwYXJ0IG9mIHR6ZGF0YSwgb25seSBFdGMvR01UKzggYW5kIHRoZSBsaWtlLlxuICAgICAgLy8gVGhhdCBpcyB3aHkgZml4ZWQtb2Zmc2V0IFRaIGlzIHNldCB0byB0aGF0IHVubGVzcyBpdCBpczpcbiAgICAgIC8vIDEuIFJlcHJlc2VudGluZyBvZmZzZXQgMCB3aGVuIFVUQyBpcyB1c2VkIHRvIG1haW50YWluIHByZXZpb3VzIGJlaGF2aW9yIGFuZCBkb2VzIG5vdCBiZWNvbWUgR01ULlxuICAgICAgLy8gMi4gVW5zdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXI6XG4gICAgICAvLyAgICAtIHNvbWUgZG8gbm90IHN1cHBvcnQgRXRjL1xuICAgICAgLy8gICAgLSA8IEV0Yy9HTVQtMTQsID4gRXRjL0dNVCsxMiwgYW5kIDMwLW1pbnV0ZSBvciA0NS1taW51dGUgb2Zmc2V0cyBhcmUgbm90IHBhcnQgb2YgdHpkYXRhXG4gICAgICBjb25zdCBnbXRPZmZzZXQgPSAtMSAqIChkdC5vZmZzZXQgLyA2MCk7XG4gICAgICBjb25zdCBvZmZzZXRaID0gZ210T2Zmc2V0ID49IDAgPyBgRXRjL0dNVCske2dtdE9mZnNldH1gIDogYEV0Yy9HTVQke2dtdE9mZnNldH1gO1xuICAgICAgaWYgKGR0Lm9mZnNldCAhPT0gMCAmJiBJQU5BWm9uZS5jcmVhdGUob2Zmc2V0WikudmFsaWQpIHtcbiAgICAgICAgeiA9IG9mZnNldFo7XG4gICAgICAgIHRoaXMuZHQgPSBkdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBhbGwgZml4ZWQtb2Zmc2V0IHpvbmVzIGxpa2UgRXRjLys0OjMwIGFyZSBwcmVzZW50IGluIHR6ZGF0YSBzb1xuICAgICAgICAvLyB3ZSBtYW51YWxseSBhcHBseSB0aGUgb2Zmc2V0IGFuZCBzdWJzdGl0dXRlIHRoZSB6b25lIGFzIG5lZWRlZC5cbiAgICAgICAgeiA9IFwiVVRDXCI7XG4gICAgICAgIHRoaXMuZHQgPSBkdC5vZmZzZXQgPT09IDAgPyBkdCA6IGR0LnNldFpvbmUoXCJVVENcIikucGx1cyh7IG1pbnV0ZXM6IGR0Lm9mZnNldCB9KTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFpvbmUgPSBkdC56b25lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZHQuem9uZS50eXBlID09PSBcInN5c3RlbVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgfSBlbHNlIGlmIChkdC56b25lLnR5cGUgPT09IFwiaWFuYVwiKSB7XG4gICAgICB0aGlzLmR0ID0gZHQ7XG4gICAgICB6ID0gZHQuem9uZS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDdXN0b20gem9uZXMgY2FuIGhhdmUgYW55IG9mZnNldCAvIG9mZnNldE5hbWUgc28gd2UganVzdCBtYW51YWxseVxuICAgICAgLy8gYXBwbHkgdGhlIG9mZnNldCBhbmQgc3Vic3RpdHV0ZSB0aGUgem9uZSBhcyBuZWVkZWQuXG4gICAgICB6ID0gXCJVVENcIjtcbiAgICAgIHRoaXMuZHQgPSBkdC5zZXRab25lKFwiVVRDXCIpLnBsdXMoeyBtaW51dGVzOiBkdC5vZmZzZXQgfSk7XG4gICAgICB0aGlzLm9yaWdpbmFsWm9uZSA9IGR0LnpvbmU7XG4gICAgfVxuXG4gICAgY29uc3QgaW50bE9wdHMgPSB7IC4uLnRoaXMub3B0cyB9O1xuICAgIGludGxPcHRzLnRpbWVab25lID0gaW50bE9wdHMudGltZVpvbmUgfHwgejtcbiAgICB0aGlzLmR0ZiA9IGdldENhY2hlZERURihpbnRsLCBpbnRsT3B0cyk7XG4gIH1cblxuICBmb3JtYXQoKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxab25lKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHRvIHN1YnN0aXR1dGUgaW4gdGhlIGFjdHVhbCB6b25lIG5hbWUsIHdlIGhhdmUgdG8gdXNlXG4gICAgICAvLyBmb3JtYXRUb1BhcnRzIHNvIHRoYXQgdGhlIHRpbWV6b25lIGNhbiBiZSByZXBsYWNlZC5cbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdFRvUGFydHMoKVxuICAgICAgICAubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKVxuICAgICAgICAuam9pbihcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZHRmLmZvcm1hdCh0aGlzLmR0LnRvSlNEYXRlKCkpO1xuICB9XG5cbiAgZm9ybWF0VG9QYXJ0cygpIHtcbiAgICBjb25zdCBwYXJ0cyA9IHRoaXMuZHRmLmZvcm1hdFRvUGFydHModGhpcy5kdC50b0pTRGF0ZSgpKTtcbiAgICBpZiAodGhpcy5vcmlnaW5hbFpvbmUpIHtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0aW1lWm9uZU5hbWVcIikge1xuICAgICAgICAgIGNvbnN0IG9mZnNldE5hbWUgPSB0aGlzLm9yaWdpbmFsWm9uZS5vZmZzZXROYW1lKHRoaXMuZHQudHMsIHtcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5kdC5sb2NhbGUsXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMub3B0cy50aW1lWm9uZU5hbWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnBhcnQsXG4gICAgICAgICAgICB2YWx1ZTogb2Zmc2V0TmFtZSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzO1xuICB9XG5cbiAgcmVzb2x2ZWRPcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmR0Zi5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFBvbHlSZWxGb3JtYXR0ZXIge1xuICBjb25zdHJ1Y3RvcihpbnRsLCBpc0VuZ2xpc2gsIG9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSB7IHN0eWxlOiBcImxvbmdcIiwgLi4ub3B0cyB9O1xuICAgIGlmICghaXNFbmdsaXNoICYmIGhhc1JlbGF0aXZlKCkpIHtcbiAgICAgIHRoaXMucnRmID0gZ2V0Q2FjaGVkUlRGKGludGwsIG9wdHMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdChjb3VudCwgdW5pdCkge1xuICAgIGlmICh0aGlzLnJ0Zikge1xuICAgICAgcmV0dXJuIHRoaXMucnRmLmZvcm1hdChjb3VudCwgdW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBFbmdsaXNoLmZvcm1hdFJlbGF0aXZlVGltZSh1bml0LCBjb3VudCwgdGhpcy5vcHRzLm51bWVyaWMsIHRoaXMub3B0cy5zdHlsZSAhPT0gXCJsb25nXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1hdFRvUGFydHMoY291bnQsIHVuaXQpIHtcbiAgICBpZiAodGhpcy5ydGYpIHtcbiAgICAgIHJldHVybiB0aGlzLnJ0Zi5mb3JtYXRUb1BhcnRzKGNvdW50LCB1bml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9jYWxlIHtcbiAgc3RhdGljIGZyb21PcHRzKG9wdHMpIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShvcHRzLmxvY2FsZSwgb3B0cy5udW1iZXJpbmdTeXN0ZW0sIG9wdHMub3V0cHV0Q2FsZW5kYXIsIG9wdHMuZGVmYXVsdFRvRU4pO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIsIGRlZmF1bHRUb0VOID0gZmFsc2UpIHtcbiAgICBjb25zdCBzcGVjaWZpZWRMb2NhbGUgPSBsb2NhbGUgfHwgU2V0dGluZ3MuZGVmYXVsdExvY2FsZTtcbiAgICAvLyB0aGUgc3lzdGVtIGxvY2FsZSBpcyB1c2VmdWwgZm9yIGh1bWFuIHJlYWRhYmxlIHN0cmluZ3MgYnV0IGFubm95aW5nIGZvciBwYXJzaW5nL2Zvcm1hdHRpbmcga25vd24gZm9ybWF0c1xuICAgIGNvbnN0IGxvY2FsZVIgPSBzcGVjaWZpZWRMb2NhbGUgfHwgKGRlZmF1bHRUb0VOID8gXCJlbi1VU1wiIDogc3lzdGVtTG9jYWxlKCkpO1xuICAgIGNvbnN0IG51bWJlcmluZ1N5c3RlbVIgPSBudW1iZXJpbmdTeXN0ZW0gfHwgU2V0dGluZ3MuZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgICBjb25zdCBvdXRwdXRDYWxlbmRhclIgPSBvdXRwdXRDYWxlbmRhciB8fCBTZXR0aW5ncy5kZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gICAgcmV0dXJuIG5ldyBMb2NhbGUobG9jYWxlUiwgbnVtYmVyaW5nU3lzdGVtUiwgb3V0cHV0Q2FsZW5kYXJSLCBzcGVjaWZpZWRMb2NhbGUpO1xuICB9XG5cbiAgc3RhdGljIHJlc2V0Q2FjaGUoKSB7XG4gICAgc3lzTG9jYWxlQ2FjaGUgPSBudWxsO1xuICAgIGludGxEVENhY2hlID0ge307XG4gICAgaW50bE51bUNhY2hlID0ge307XG4gICAgaW50bFJlbENhY2hlID0ge307XG4gIH1cblxuICBzdGF0aWMgZnJvbU9iamVjdCh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9ID0ge30pIHtcbiAgICByZXR1cm4gTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpO1xuICB9XG5cbiAgY29uc3RydWN0b3IobG9jYWxlLCBudW1iZXJpbmcsIG91dHB1dENhbGVuZGFyLCBzcGVjaWZpZWRMb2NhbGUpIHtcbiAgICBjb25zdCBbcGFyc2VkTG9jYWxlLCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0sIHBhcnNlZE91dHB1dENhbGVuZGFyXSA9IHBhcnNlTG9jYWxlU3RyaW5nKGxvY2FsZSk7XG5cbiAgICB0aGlzLmxvY2FsZSA9IHBhcnNlZExvY2FsZTtcbiAgICB0aGlzLm51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZyB8fCBwYXJzZWROdW1iZXJpbmdTeXN0ZW0gfHwgbnVsbDtcbiAgICB0aGlzLm91dHB1dENhbGVuZGFyID0gb3V0cHV0Q2FsZW5kYXIgfHwgcGFyc2VkT3V0cHV0Q2FsZW5kYXIgfHwgbnVsbDtcbiAgICB0aGlzLmludGwgPSBpbnRsQ29uZmlnU3RyaW5nKHRoaXMubG9jYWxlLCB0aGlzLm51bWJlcmluZ1N5c3RlbSwgdGhpcy5vdXRwdXRDYWxlbmRhcik7XG5cbiAgICB0aGlzLndlZWtkYXlzQ2FjaGUgPSB7IGZvcm1hdDoge30sIHN0YW5kYWxvbmU6IHt9IH07XG4gICAgdGhpcy5tb250aHNDYWNoZSA9IHsgZm9ybWF0OiB7fSwgc3RhbmRhbG9uZToge30gfTtcbiAgICB0aGlzLm1lcmlkaWVtQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMuZXJhQ2FjaGUgPSB7fTtcblxuICAgIHRoaXMuc3BlY2lmaWVkTG9jYWxlID0gc3BlY2lmaWVkTG9jYWxlO1xuICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGZhc3ROdW1iZXJzKCkge1xuICAgIGlmICh0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkID09IG51bGwpIHtcbiAgICAgIHRoaXMuZmFzdE51bWJlcnNDYWNoZWQgPSBzdXBwb3J0c0Zhc3ROdW1iZXJzKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZhc3ROdW1iZXJzQ2FjaGVkO1xuICB9XG5cbiAgbGlzdGluZ01vZGUoKSB7XG4gICAgY29uc3QgaXNBY3R1YWxseUVuID0gdGhpcy5pc0VuZ2xpc2goKTtcbiAgICBjb25zdCBoYXNOb1dlaXJkbmVzcyA9XG4gICAgICAodGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IG51bGwgfHwgdGhpcy5udW1iZXJpbmdTeXN0ZW0gPT09IFwibGF0blwiKSAmJlxuICAgICAgKHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG51bGwgfHwgdGhpcy5vdXRwdXRDYWxlbmRhciA9PT0gXCJncmVnb3J5XCIpO1xuICAgIHJldHVybiBpc0FjdHVhbGx5RW4gJiYgaGFzTm9XZWlyZG5lc3MgPyBcImVuXCIgOiBcImludGxcIjtcbiAgfVxuXG4gIGNsb25lKGFsdHMpIHtcbiAgICBpZiAoIWFsdHMgfHwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYWx0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIExvY2FsZS5jcmVhdGUoXG4gICAgICAgIGFsdHMubG9jYWxlIHx8IHRoaXMuc3BlY2lmaWVkTG9jYWxlLFxuICAgICAgICBhbHRzLm51bWJlcmluZ1N5c3RlbSB8fCB0aGlzLm51bWJlcmluZ1N5c3RlbSxcbiAgICAgICAgYWx0cy5vdXRwdXRDYWxlbmRhciB8fCB0aGlzLm91dHB1dENhbGVuZGFyLFxuICAgICAgICBhbHRzLmRlZmF1bHRUb0VOIHx8IGZhbHNlXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJlZGVmYXVsdFRvRU4oYWx0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoeyAuLi5hbHRzLCBkZWZhdWx0VG9FTjogdHJ1ZSB9KTtcbiAgfVxuXG4gIHJlZGVmYXVsdFRvU3lzdGVtKGFsdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKHsgLi4uYWx0cywgZGVmYXVsdFRvRU46IGZhbHNlIH0pO1xuICB9XG5cbiAgbW9udGhzKGxlbmd0aCwgZm9ybWF0ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgRW5nbGlzaC5tb250aHMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSBmb3JtYXQgPyB7IG1vbnRoOiBsZW5ndGgsIGRheTogXCJudW1lcmljXCIgfSA6IHsgbW9udGg6IGxlbmd0aCB9LFxuICAgICAgICBmb3JtYXRTdHIgPSBmb3JtYXQgPyBcImZvcm1hdFwiIDogXCJzdGFuZGFsb25lXCI7XG4gICAgICBpZiAoIXRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMubW9udGhzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdID0gbWFwTW9udGhzKChkdCkgPT4gdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcIm1vbnRoXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1vbnRoc0NhY2hlW2Zvcm1hdFN0cl1bbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIHdlZWtkYXlzKGxlbmd0aCwgZm9ybWF0ID0gZmFsc2UpIHtcbiAgICByZXR1cm4gbGlzdFN0dWZmKHRoaXMsIGxlbmd0aCwgRW5nbGlzaC53ZWVrZGF5cywgKCkgPT4ge1xuICAgICAgY29uc3QgaW50bCA9IGZvcm1hdFxuICAgICAgICAgID8geyB3ZWVrZGF5OiBsZW5ndGgsIHllYXI6IFwibnVtZXJpY1wiLCBtb250aDogXCJsb25nXCIsIGRheTogXCJudW1lcmljXCIgfVxuICAgICAgICAgIDogeyB3ZWVrZGF5OiBsZW5ndGggfSxcbiAgICAgICAgZm9ybWF0U3RyID0gZm9ybWF0ID8gXCJmb3JtYXRcIiA6IFwic3RhbmRhbG9uZVwiO1xuICAgICAgaWYgKCF0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMud2Vla2RheXNDYWNoZVtmb3JtYXRTdHJdW2xlbmd0aF0gPSBtYXBXZWVrZGF5cygoZHQpID0+XG4gICAgICAgICAgdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcIndlZWtkYXlcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndlZWtkYXlzQ2FjaGVbZm9ybWF0U3RyXVtsZW5ndGhdO1xuICAgIH0pO1xuICB9XG5cbiAgbWVyaWRpZW1zKCkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYoXG4gICAgICB0aGlzLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgKCkgPT4gRW5nbGlzaC5tZXJpZGllbXMsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIC8vIEluIHRoZW9yeSB0aGVyZSBjb3VsZCBiZSBhcmliaXRyYXJ5IGRheSBwZXJpb2RzLiBXZSdyZSBnb25uYSBhc3N1bWUgdGhlcmUgYXJlIGV4YWN0bHkgdHdvXG4gICAgICAgIC8vIGZvciBBTSBhbmQgUE0uIFRoaXMgaXMgcHJvYmFibHkgd3JvbmcsIGJ1dCBpdCdzIG1ha2VzIHBhcnNpbmcgd2F5IGVhc2llci5cbiAgICAgICAgaWYgKCF0aGlzLm1lcmlkaWVtQ2FjaGUpIHtcbiAgICAgICAgICBjb25zdCBpbnRsID0geyBob3VyOiBcIm51bWVyaWNcIiwgaG91ckN5Y2xlOiBcImgxMlwiIH07XG4gICAgICAgICAgdGhpcy5tZXJpZGllbUNhY2hlID0gW0RhdGVUaW1lLnV0YygyMDE2LCAxMSwgMTMsIDkpLCBEYXRlVGltZS51dGMoMjAxNiwgMTEsIDEzLCAxOSldLm1hcChcbiAgICAgICAgICAgIChkdCkgPT4gdGhpcy5leHRyYWN0KGR0LCBpbnRsLCBcImRheXBlcmlvZFwiKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5tZXJpZGllbUNhY2hlO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBlcmFzKGxlbmd0aCkge1xuICAgIHJldHVybiBsaXN0U3R1ZmYodGhpcywgbGVuZ3RoLCBFbmdsaXNoLmVyYXMsICgpID0+IHtcbiAgICAgIGNvbnN0IGludGwgPSB7IGVyYTogbGVuZ3RoIH07XG5cbiAgICAgIC8vIFRoaXMgaXMgcHJvYmxlbWF0aWMuIERpZmZlcmVudCBjYWxlbmRhcnMgYXJlIGdvaW5nIHRvIGRlZmluZSBlcmFzIHRvdGFsbHkgZGlmZmVyZW50bHkuIFdoYXQgSSBuZWVkIGlzIHRoZSBtaW5pbXVtIHNldCBvZiBkYXRlc1xuICAgICAgLy8gdG8gZGVmaW5pdGVseSBlbnVtZXJhdGUgdGhlbS5cbiAgICAgIGlmICghdGhpcy5lcmFDYWNoZVtsZW5ndGhdKSB7XG4gICAgICAgIHRoaXMuZXJhQ2FjaGVbbGVuZ3RoXSA9IFtEYXRlVGltZS51dGMoLTQwLCAxLCAxKSwgRGF0ZVRpbWUudXRjKDIwMTcsIDEsIDEpXS5tYXAoKGR0KSA9PlxuICAgICAgICAgIHRoaXMuZXh0cmFjdChkdCwgaW50bCwgXCJlcmFcIilcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZXJhQ2FjaGVbbGVuZ3RoXTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4dHJhY3QoZHQsIGludGxPcHRzLCBmaWVsZCkge1xuICAgIGNvbnN0IGRmID0gdGhpcy5kdEZvcm1hdHRlcihkdCwgaW50bE9wdHMpLFxuICAgICAgcmVzdWx0cyA9IGRmLmZvcm1hdFRvUGFydHMoKSxcbiAgICAgIG1hdGNoaW5nID0gcmVzdWx0cy5maW5kKChtKSA9PiBtLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gZmllbGQpO1xuICAgIHJldHVybiBtYXRjaGluZyA/IG1hdGNoaW5nLnZhbHVlIDogbnVsbDtcbiAgfVxuXG4gIG51bWJlckZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICAvLyB0aGlzIGZvcmNlc2ltcGxlIG9wdGlvbiBpcyBuZXZlciB1c2VkICh0aGUgb25seSBjYWxsZXIgc2hvcnQtY2lyY3VpdHMgb24gaXQsIGJ1dCBpdCBzZWVtcyBzYWZlciB0byBsZWF2ZSlcbiAgICAvLyAoaW4gY29udHJhc3QsIHRoZSByZXN0IG9mIHRoZSBjb25kaXRpb24gaXMgdXNlZCBoZWF2aWx5KVxuICAgIHJldHVybiBuZXcgUG9seU51bWJlckZvcm1hdHRlcih0aGlzLmludGwsIG9wdHMuZm9yY2VTaW1wbGUgfHwgdGhpcy5mYXN0TnVtYmVycywgb3B0cyk7XG4gIH1cblxuICBkdEZvcm1hdHRlcihkdCwgaW50bE9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUG9seURhdGVGb3JtYXR0ZXIoZHQsIHRoaXMuaW50bCwgaW50bE9wdHMpO1xuICB9XG5cbiAgcmVsRm9ybWF0dGVyKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUG9seVJlbEZvcm1hdHRlcih0aGlzLmludGwsIHRoaXMuaXNFbmdsaXNoKCksIG9wdHMpO1xuICB9XG5cbiAgbGlzdEZvcm1hdHRlcihvcHRzID0ge30pIHtcbiAgICByZXR1cm4gZ2V0Q2FjaGVkTEYodGhpcy5pbnRsLCBvcHRzKTtcbiAgfVxuXG4gIGlzRW5nbGlzaCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2NhbGUgPT09IFwiZW5cIiB8fFxuICAgICAgdGhpcy5sb2NhbGUudG9Mb3dlckNhc2UoKSA9PT0gXCJlbi11c1wiIHx8XG4gICAgICBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLmludGwpLnJlc29sdmVkT3B0aW9ucygpLmxvY2FsZS5zdGFydHNXaXRoKFwiZW4tdXNcIilcbiAgICApO1xuICB9XG5cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMubG9jYWxlID09PSBvdGhlci5sb2NhbGUgJiZcbiAgICAgIHRoaXMubnVtYmVyaW5nU3lzdGVtID09PSBvdGhlci5udW1iZXJpbmdTeXN0ZW0gJiZcbiAgICAgIHRoaXMub3V0cHV0Q2FsZW5kYXIgPT09IG90aGVyLm91dHB1dENhbGVuZGFyXG4gICAgKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IGZvcm1hdE9mZnNldCwgc2lnbmVkT2Zmc2V0IH0gZnJvbSBcIi4uL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcblxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5cbi8qKlxuICogQSB6b25lIHdpdGggYSBmaXhlZCBvZmZzZXQgKG1lYW5pbmcgbm8gRFNUKVxuICogQGltcGxlbWVudHMge1pvbmV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpeGVkT2Zmc2V0Wm9uZSBleHRlbmRzIFpvbmUge1xuICAvKipcbiAgICogR2V0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIFVUQ1xuICAgKiBAcmV0dXJuIHtGaXhlZE9mZnNldFpvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IHV0Y0luc3RhbmNlKCkge1xuICAgIGlmIChzaW5nbGV0b24gPT09IG51bGwpIHtcbiAgICAgIHNpbmdsZXRvbiA9IG5ldyBGaXhlZE9mZnNldFpvbmUoMCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgb2Zmc2V0IGluIG1pbnV0ZXNcbiAgICogQHJldHVybiB7Rml4ZWRPZmZzZXRab25lfVxuICAgKi9cbiAgc3RhdGljIGluc3RhbmNlKG9mZnNldCkge1xuICAgIHJldHVybiBvZmZzZXQgPT09IDAgPyBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2UgOiBuZXcgRml4ZWRPZmZzZXRab25lKG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGluc3RhbmNlIG9mIEZpeGVkT2Zmc2V0Wm9uZSBmcm9tIGEgVVRDIG9mZnNldCBzdHJpbmcsIGxpa2UgXCJVVEMrNlwiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIC0gVGhlIG9mZnNldCBzdHJpbmcgdG8gcGFyc2VcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzZcIilcbiAgICogQGV4YW1wbGUgRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKFwiVVRDKzA2XCIpXG4gICAqIEBleGFtcGxlIEZpeGVkT2Zmc2V0Wm9uZS5wYXJzZVNwZWNpZmllcihcIlVUQy02OjAwXCIpXG4gICAqIEByZXR1cm4ge0ZpeGVkT2Zmc2V0Wm9uZX1cbiAgICovXG4gIHN0YXRpYyBwYXJzZVNwZWNpZmllcihzKSB7XG4gICAgaWYgKHMpIHtcbiAgICAgIGNvbnN0IHIgPSBzLm1hdGNoKC9edXRjKD86KFsrLV1cXGR7MSwyfSkoPzo6KFxcZHsyfSkpPyk/JC9pKTtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRml4ZWRPZmZzZXRab25lKHNpZ25lZE9mZnNldChyWzFdLCByWzJdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3RydWN0b3Iob2Zmc2V0KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKiogQHByaXZhdGUgKiovXG4gICAgdGhpcy5maXhlZCA9IG9mZnNldDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImZpeGVkXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZCA9PT0gMCA/IFwiVVRDXCIgOiBgVVRDJHtmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgfVxuXG4gIGdldCBpYW5hTmFtZSgpIHtcbiAgICBpZiAodGhpcy5maXhlZCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiRXRjL1VUQ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYEV0Yy9HTVQke2Zvcm1hdE9mZnNldCgtdGhpcy5maXhlZCwgXCJuYXJyb3dcIil9YDtcbiAgICB9XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5hbWU7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQodHMsIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXRPZmZzZXQodGhpcy5maXhlZCwgZm9ybWF0KTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBpc1VuaXZlcnNhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5maXhlZDtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscyhvdGhlclpvbmUpIHtcbiAgICByZXR1cm4gb3RoZXJab25lLnR5cGUgPT09IFwiZml4ZWRcIiAmJiBvdGhlclpvbmUuZml4ZWQgPT09IHRoaXMuZml4ZWQ7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwgImltcG9ydCBab25lIGZyb20gXCIuLi96b25lLmpzXCI7XG5cbi8qKlxuICogQSB6b25lIHRoYXQgZmFpbGVkIHRvIHBhcnNlLiBZb3Ugc2hvdWxkIG5ldmVyIG5lZWQgdG8gaW5zdGFudGlhdGUgdGhpcy5cbiAqIEBpbXBsZW1lbnRzIHtab25lfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnZhbGlkWm9uZSBleHRlbmRzIFpvbmUge1xuICBjb25zdHJ1Y3Rvcih6b25lTmFtZSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqICBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuem9uZU5hbWUgPSB6b25lTmFtZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiBcImludmFsaWRcIjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLnpvbmVOYW1lO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqKi9cbiAgZ2V0IGlzVW5pdmVyc2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIG9mZnNldE5hbWUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBmb3JtYXRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKiovXG4gIGVxdWFscygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICoqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbiIsICIvKipcbiAqIEBwcml2YXRlXG4gKi9cblxuaW1wb3J0IFpvbmUgZnJvbSBcIi4uL3pvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IEludmFsaWRab25lIGZyb20gXCIuLi96b25lcy9pbnZhbGlkWm9uZS5qc1wiO1xuXG5pbXBvcnQgeyBpc1VuZGVmaW5lZCwgaXNTdHJpbmcsIGlzTnVtYmVyIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IFN5c3RlbVpvbmUgZnJvbSBcIi4uL3pvbmVzL3N5c3RlbVpvbmUuanNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVpvbmUoaW5wdXQsIGRlZmF1bHRab25lKSB7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChpc1VuZGVmaW5lZChpbnB1dCkgfHwgaW5wdXQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFpvbmU7XG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBab25lKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9IGVsc2UgaWYgKGlzU3RyaW5nKGlucHV0KSkge1xuICAgIGNvbnN0IGxvd2VyZWQgPSBpbnB1dC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsb3dlcmVkID09PSBcImRlZmF1bHRcIikgcmV0dXJuIGRlZmF1bHRab25lO1xuICAgIGVsc2UgaWYgKGxvd2VyZWQgPT09IFwibG9jYWxcIiB8fCBsb3dlcmVkID09PSBcInN5c3RlbVwiKSByZXR1cm4gU3lzdGVtWm9uZS5pbnN0YW5jZTtcbiAgICBlbHNlIGlmIChsb3dlcmVkID09PSBcInV0Y1wiIHx8IGxvd2VyZWQgPT09IFwiZ210XCIpIHJldHVybiBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2U7XG4gICAgZWxzZSByZXR1cm4gRml4ZWRPZmZzZXRab25lLnBhcnNlU3BlY2lmaWVyKGxvd2VyZWQpIHx8IElBTkFab25lLmNyZWF0ZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgcmV0dXJuIEZpeGVkT2Zmc2V0Wm9uZS5pbnN0YW5jZShpbnB1dCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiICYmIFwib2Zmc2V0XCIgaW4gaW5wdXQgJiYgdHlwZW9mIGlucHV0Lm9mZnNldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gVGhpcyBpcyBkdW1iLCBidXQgdGhlIGluc3RhbmNlb2YgY2hlY2sgYWJvdmUgZG9lc24ndCBzZWVtIHRvIHJlYWxseSB3b3JrXG4gICAgLy8gc28gd2UncmUgZHVjayBjaGVja2luZyBpdFxuICAgIHJldHVybiBpbnB1dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEludmFsaWRab25lKGlucHV0KTtcbiAgfVxufVxuIiwgImltcG9ydCBTeXN0ZW1ab25lIGZyb20gXCIuL3pvbmVzL3N5c3RlbVpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuaW1wb3J0IExvY2FsZSBmcm9tIFwiLi9pbXBsL2xvY2FsZS5qc1wiO1xuXG5pbXBvcnQgeyBub3JtYWxpemVab25lIH0gZnJvbSBcIi4vaW1wbC96b25lVXRpbC5qc1wiO1xuXG5sZXQgbm93ID0gKCkgPT4gRGF0ZS5ub3coKSxcbiAgZGVmYXVsdFpvbmUgPSBcInN5c3RlbVwiLFxuICBkZWZhdWx0TG9jYWxlID0gbnVsbCxcbiAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bGwsXG4gIGRlZmF1bHRPdXRwdXRDYWxlbmRhciA9IG51bGwsXG4gIHR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDYwLFxuICB0aHJvd09uSW52YWxpZDtcblxuLyoqXG4gKiBTZXR0aW5ncyBjb250YWlucyBzdGF0aWMgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IGNvbnRyb2wgTHV4b24ncyBvdmVyYWxsIGJlaGF2aW9yLiBMdXhvbiBpcyBhIHNpbXBsZSBsaWJyYXJ5IHdpdGggZmV3IG9wdGlvbnMsIGJ1dCB0aGUgb25lcyBpdCBkb2VzIGhhdmUgbGl2ZSBoZXJlLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXR0aW5ncyB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNhbGxiYWNrIGZvciByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdGltZXN0YW1wLlxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAqL1xuICBzdGF0aWMgZ2V0IG5vdygpIHtcbiAgICByZXR1cm4gbm93O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY2FsbGJhY2sgZm9yIHJldHVybmluZyB0aGUgY3VycmVudCB0aW1lc3RhbXAuXG4gICAqIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGEgbnVtYmVyLCB3aGljaCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFuIEVwb2NoIG1pbGxpc2Vjb25kIGNvdW50XG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICogQGV4YW1wbGUgU2V0dGluZ3Mubm93ID0gKCkgPT4gRGF0ZS5ub3coKSArIDMwMDAgLy8gcHJldGVuZCBpdCBpcyAzIHNlY29uZHMgaW4gdGhlIGZ1dHVyZVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy5ub3cgPSAoKSA9PiAwIC8vIGFsd2F5cyBwcmV0ZW5kIGl0J3MgSmFuIDEsIDE5NzAgYXQgbWlkbmlnaHQgaW4gVVRDIHRpbWVcbiAgICovXG4gIHN0YXRpYyBzZXQgbm93KG4pIHtcbiAgICBub3cgPSBuO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZGVmYXVsdCB0aW1lIHpvbmUgdG8gY3JlYXRlIERhdGVUaW1lcyBpbi4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogVXNlIHRoZSB2YWx1ZSBcInN5c3RlbVwiIHRvIHJlc2V0IHRoaXMgdmFsdWUgdG8gdGhlIHN5c3RlbSdzIHRpbWUgem9uZS5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdFpvbmUoem9uZSkge1xuICAgIGRlZmF1bHRab25lID0gem9uZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgdGltZSB6b25lIG9iamVjdCBjdXJyZW50bHkgdXNlZCB0byBjcmVhdGUgRGF0ZVRpbWVzLiBEb2VzIG5vdCBhZmZlY3QgZXhpc3RpbmcgaW5zdGFuY2VzLlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0aGUgc3lzdGVtJ3MgdGltZSB6b25lICh0aGUgb25lIHNldCBvbiB0aGUgbWFjaGluZSB0aGF0IHJ1bnMgdGhpcyBjb2RlKS5cbiAgICogQHR5cGUge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRab25lKCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGRlZmF1bHRab25lLCBTeXN0ZW1ab25lLmluc3RhbmNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdExvY2FsZSgpIHtcbiAgICByZXR1cm4gZGVmYXVsdExvY2FsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgbG9jYWxlIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzZXQgZGVmYXVsdExvY2FsZShsb2NhbGUpIHtcbiAgICBkZWZhdWx0TG9jYWxlID0gbG9jYWxlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBudW1iZXJpbmcgc3lzdGVtIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gZGVmYXVsdE51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIGRlZmF1bHQgbnVtYmVyaW5nIHN5c3RlbSB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHROdW1iZXJpbmdTeXN0ZW0obnVtYmVyaW5nU3lzdGVtKSB7XG4gICAgZGVmYXVsdE51bWJlcmluZ1N5c3RlbSA9IG51bWJlcmluZ1N5c3RlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlZmF1bHQgb3V0cHV0IGNhbGVuZGFyIHRvIGNyZWF0ZSBEYXRlVGltZXMgd2l0aC4gRG9lcyBub3QgYWZmZWN0IGV4aXN0aW5nIGluc3RhbmNlcy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdE91dHB1dENhbGVuZGFyKCkge1xuICAgIHJldHVybiBkZWZhdWx0T3V0cHV0Q2FsZW5kYXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkZWZhdWx0IG91dHB1dCBjYWxlbmRhciB0byBjcmVhdGUgRGF0ZVRpbWVzIHdpdGguIERvZXMgbm90IGFmZmVjdCBleGlzdGluZyBpbnN0YW5jZXMuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgc2V0IGRlZmF1bHRPdXRwdXRDYWxlbmRhcihvdXRwdXRDYWxlbmRhcikge1xuICAgIGRlZmF1bHRPdXRwdXRDYWxlbmRhciA9IG91dHB1dENhbGVuZGFyO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY3V0b2ZmIHllYXIgYWZ0ZXIgd2hpY2ggYSBzdHJpbmcgZW5jb2RpbmcgYSB5ZWFyIGFzIHR3byBkaWdpdHMgaXMgaW50ZXJwcmV0ZWQgdG8gb2NjdXIgaW4gdGhlIGN1cnJlbnQgY2VudHVyeS5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgdHdvRGlnaXRDdXRvZmZZZWFyKCkge1xuICAgIHJldHVybiB0d29EaWdpdEN1dG9mZlllYXI7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXRvZmYgeWVhciBhZnRlciB3aGljaCBhIHN0cmluZyBlbmNvZGluZyBhIHllYXIgYXMgdHdvIGRpZ2l0cyBpcyBpbnRlcnByZXRlZCB0byBvY2N1ciBpbiB0aGUgY3VycmVudCBjZW50dXJ5LlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAZXhhbXBsZSBTZXR0aW5ncy50d29EaWdpdEN1dG9mZlllYXIgPSAwIC8vIGN1dC1vZmYgeWVhciBpcyAwLCBzbyBhbGwgJ3l5JyBhcmUgaW50ZXJwcmV0ZWQgYXMgY3VycmVudCBjZW50dXJ5XG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDUwIC8vICc0OScgLT4gMTk0OTsgJzUwJyAtPiAyMDUwXG4gICAqIEBleGFtcGxlIFNldHRpbmdzLnR3b0RpZ2l0Q3V0b2ZmWWVhciA9IDE5NTAgLy8gaW50ZXJwcmV0ZWQgYXMgNTBcbiAgICogQGV4YW1wbGUgU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID0gMjA1MCAvLyBBTFNPIGludGVycHJldGVkIGFzIDUwXG4gICAqL1xuICBzdGF0aWMgc2V0IHR3b0RpZ2l0Q3V0b2ZmWWVhcihjdXRvZmZZZWFyKSB7XG4gICAgdHdvRGlnaXRDdXRvZmZZZWFyID0gY3V0b2ZmWWVhciAlIDEwMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgZ2V0IHRocm93T25JbnZhbGlkKCkge1xuICAgIHJldHVybiB0aHJvd09uSW52YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciBMdXhvbiB3aWxsIHRocm93IHdoZW4gaXQgZW5jb3VudGVycyBpbnZhbGlkIERhdGVUaW1lcywgRHVyYXRpb25zLCBvciBJbnRlcnZhbHNcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgc2V0IHRocm93T25JbnZhbGlkKHQpIHtcbiAgICB0aHJvd09uSW52YWxpZCA9IHQ7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgTHV4b24ncyBnbG9iYWwgY2FjaGVzLiBTaG91bGQgb25seSBiZSBuZWNlc3NhcnkgaW4gdGVzdGluZyBzY2VuYXJpb3MuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzdGF0aWMgcmVzZXRDYWNoZXMoKSB7XG4gICAgTG9jYWxlLnJlc2V0Q2FjaGUoKTtcbiAgICBJQU5BWm9uZS5yZXNldENhY2hlKCk7XG4gIH1cbn1cbiIsICIvKlxuICBUaGlzIGlzIGp1c3QgYSBqdW5rIGRyYXdlciwgY29udGFpbmluZyBhbnl0aGluZyB1c2VkIGFjcm9zcyBtdWx0aXBsZSBjbGFzc2VzLlxuICBCZWNhdXNlIEx1eG9uIGlzIHNtYWxsKGlzaCksIHRoaXMgc2hvdWxkIHN0YXkgc21hbGwgYW5kIHdlIHdvbid0IHdvcnJ5IGFib3V0IHNwbGl0dGluZ1xuICBpdCB1cCBpbnRvLCBzYXksIHBhcnNpbmdVdGlsLmpzIGFuZCBiYXNpY1V0aWwuanMgYW5kIHNvIG9uLiBCdXQgdGhleSBhcmUgZGl2aWRlZCB1cCBieSBmZWF0dXJlIGFyZWEuXG4qL1xuXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCBTZXR0aW5ncyBmcm9tIFwiLi4vc2V0dGluZ3MuanNcIjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbi8vIFRZUEVTXG5cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gXCJ1bmRlZmluZWRcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm51bWJlclwiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNJbnRlZ2VyKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSBcIm51bWJlclwiICYmIG8gJSAxID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09IFwic3RyaW5nXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbn1cblxuLy8gQ0FQQUJJTElUSUVTXG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNSZWxhdGl2ZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gdHlwZW9mIEludGwgIT09IFwidW5kZWZpbmVkXCIgJiYgISFJbnRsLlJlbGF0aXZlVGltZUZvcm1hdDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBPQkpFQ1RTIEFORCBBUlJBWVNcblxuZXhwb3J0IGZ1bmN0aW9uIG1heWJlQXJyYXkodGhpbmcpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodGhpbmcpID8gdGhpbmcgOiBbdGhpbmddO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVzdEJ5KGFyciwgYnksIGNvbXBhcmUpIHtcbiAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBhcnIucmVkdWNlKChiZXN0LCBuZXh0KSA9PiB7XG4gICAgY29uc3QgcGFpciA9IFtieShuZXh0KSwgbmV4dF07XG4gICAgaWYgKCFiZXN0KSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9IGVsc2UgaWYgKGNvbXBhcmUoYmVzdFswXSwgcGFpclswXSkgPT09IGJlc3RbMF0pIHtcbiAgICAgIHJldHVybiBiZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9XG4gIH0sIG51bGwpWzFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGljayhvYmosIGtleXMpIHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKChhLCBrKSA9PiB7XG4gICAgYVtrXSA9IG9ialtrXTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuLy8gTlVNQkVSUyBBTkQgU1RSSU5HU1xuXG5leHBvcnQgZnVuY3Rpb24gaW50ZWdlckJldHdlZW4odGhpbmcsIGJvdHRvbSwgdG9wKSB7XG4gIHJldHVybiBpc0ludGVnZXIodGhpbmcpICYmIHRoaW5nID49IGJvdHRvbSAmJiB0aGluZyA8PSB0b3A7XG59XG5cbi8vIHggJSBuIGJ1dCB0YWtlcyB0aGUgc2lnbiBvZiBuIGluc3RlYWQgb2YgeFxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yTW9kKHgsIG4pIHtcbiAgcmV0dXJuIHggLSBuICogTWF0aC5mbG9vcih4IC8gbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYWRTdGFydChpbnB1dCwgbiA9IDIpIHtcbiAgY29uc3QgaXNOZWcgPSBpbnB1dCA8IDA7XG4gIGxldCBwYWRkZWQ7XG4gIGlmIChpc05lZykge1xuICAgIHBhZGRlZCA9IFwiLVwiICsgKFwiXCIgKyAtaW5wdXQpLnBhZFN0YXJ0KG4sIFwiMFwiKTtcbiAgfSBlbHNlIHtcbiAgICBwYWRkZWQgPSAoXCJcIiArIGlucHV0KS5wYWRTdGFydChuLCBcIjBcIik7XG4gIH1cbiAgcmV0dXJuIHBhZGRlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW50ZWdlcihzdHJpbmcpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHN0cmluZykgfHwgc3RyaW5nID09PSBudWxsIHx8IHN0cmluZyA9PT0gXCJcIikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgMTApO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZsb2F0aW5nKHN0cmluZykge1xuICBpZiAoaXNVbmRlZmluZWQoc3RyaW5nKSB8fCBzdHJpbmcgPT09IG51bGwgfHwgc3RyaW5nID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzdHJpbmcpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZU1pbGxpcyhmcmFjdGlvbikge1xuICAvLyBSZXR1cm4gdW5kZWZpbmVkIChpbnN0ZWFkIG9mIDApIGluIHRoZXNlIGNhc2VzLCB3aGVyZSBmcmFjdGlvbiBpcyBub3Qgc2V0XG4gIGlmIChpc1VuZGVmaW5lZChmcmFjdGlvbikgfHwgZnJhY3Rpb24gPT09IG51bGwgfHwgZnJhY3Rpb24gPT09IFwiXCIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGYgPSBwYXJzZUZsb2F0KFwiMC5cIiArIGZyYWN0aW9uKSAqIDEwMDA7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVG8obnVtYmVyLCBkaWdpdHMsIHRvd2FyZFplcm8gPSBmYWxzZSkge1xuICBjb25zdCBmYWN0b3IgPSAxMCAqKiBkaWdpdHMsXG4gICAgcm91bmRlciA9IHRvd2FyZFplcm8gPyBNYXRoLnRydW5jIDogTWF0aC5yb3VuZDtcbiAgcmV0dXJuIHJvdW5kZXIobnVtYmVyICogZmFjdG9yKSAvIGZhY3Rvcjtcbn1cblxuLy8gREFURSBCQVNJQ1NcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICBjb25zdCBtb2RNb250aCA9IGZsb29yTW9kKG1vbnRoIC0gMSwgMTIpICsgMSxcbiAgICBtb2RZZWFyID0geWVhciArIChtb250aCAtIG1vZE1vbnRoKSAvIDEyO1xuXG4gIGlmIChtb2RNb250aCA9PT0gMikge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKG1vZFllYXIpID8gMjkgOiAyODtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWzMxLCBudWxsLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9kTW9udGggLSAxXTtcbiAgfVxufVxuXG4vLyBjb252ZXJ0IGEgY2FsZW5kYXIgb2JqZWN0IHRvIGEgbG9jYWwgdGltZXN0YW1wIChlcG9jaCwgYnV0IHdpdGggdGhlIG9mZnNldCBiYWtlZCBpbilcbmV4cG9ydCBmdW5jdGlvbiBvYmpUb0xvY2FsVFMob2JqKSB7XG4gIGxldCBkID0gRGF0ZS5VVEMoXG4gICAgb2JqLnllYXIsXG4gICAgb2JqLm1vbnRoIC0gMSxcbiAgICBvYmouZGF5LFxuICAgIG9iai5ob3VyLFxuICAgIG9iai5taW51dGUsXG4gICAgb2JqLnNlY29uZCxcbiAgICBvYmoubWlsbGlzZWNvbmRcbiAgKTtcblxuICAvLyBmb3IgbGVnYWN5IHJlYXNvbnMsIHllYXJzIGJldHdlZW4gMCBhbmQgOTkgYXJlIGludGVycHJldGVkIGFzIDE5WFg7IHJldmVydCB0aGF0XG4gIGlmIChvYmoueWVhciA8IDEwMCAmJiBvYmoueWVhciA+PSAwKSB7XG4gICAgZCA9IG5ldyBEYXRlKGQpO1xuICAgIC8vIHNldCB0aGUgbW9udGggYW5kIGRheSBhZ2FpbiwgdGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB5ZWFyIDIwMDAgaXMgYSBsZWFwIHllYXIsIGJ1dCB5ZWFyIDEwMCBpcyBub3RcbiAgICAvLyBzbyBpZiBvYmoueWVhciBpcyBpbiA5OSwgYnV0IG9iai5kYXkgbWFrZXMgaXQgcm9sbCBvdmVyIGludG8geWVhciAxMDAsXG4gICAgLy8gdGhlIGNhbGN1bGF0aW9ucyBkb25lIGJ5IERhdGUuVVRDIGFyZSB1c2luZyB5ZWFyIDIwMDAgLSB3aGljaCBpcyBpbmNvcnJlY3RcbiAgICBkLnNldFVUQ0Z1bGxZZWFyKG9iai55ZWFyLCBvYmoubW9udGggLSAxLCBvYmouZGF5KTtcbiAgfVxuICByZXR1cm4gK2Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3ZWVrc0luV2Vla1llYXIod2Vla1llYXIpIHtcbiAgY29uc3QgcDEgPVxuICAgICAgKHdlZWtZZWFyICtcbiAgICAgICAgTWF0aC5mbG9vcih3ZWVrWWVhciAvIDQpIC1cbiAgICAgICAgTWF0aC5mbG9vcih3ZWVrWWVhciAvIDEwMCkgK1xuICAgICAgICBNYXRoLmZsb29yKHdlZWtZZWFyIC8gNDAwKSkgJVxuICAgICAgNyxcbiAgICBsYXN0ID0gd2Vla1llYXIgLSAxLFxuICAgIHAyID0gKGxhc3QgKyBNYXRoLmZsb29yKGxhc3QgLyA0KSAtIE1hdGguZmxvb3IobGFzdCAvIDEwMCkgKyBNYXRoLmZsb29yKGxhc3QgLyA0MDApKSAlIDc7XG4gIHJldHVybiBwMSA9PT0gNCB8fCBwMiA9PT0gMyA/IDUzIDogNTI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyKSB7XG4gIGlmICh5ZWFyID4gOTkpIHtcbiAgICByZXR1cm4geWVhcjtcbiAgfSBlbHNlIHJldHVybiB5ZWFyID4gU2V0dGluZ3MudHdvRGlnaXRDdXRvZmZZZWFyID8gMTkwMCArIHllYXIgOiAyMDAwICsgeWVhcjtcbn1cblxuLy8gUEFSU0lOR1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Vab25lSW5mbyh0cywgb2Zmc2V0Rm9ybWF0LCBsb2NhbGUsIHRpbWVab25lID0gbnVsbCkge1xuICBjb25zdCBkYXRlID0gbmV3IERhdGUodHMpLFxuICAgIGludGxPcHRzID0ge1xuICAgICAgaG91ckN5Y2xlOiBcImgyM1wiLFxuICAgICAgeWVhcjogXCJudW1lcmljXCIsXG4gICAgICBtb250aDogXCIyLWRpZ2l0XCIsXG4gICAgICBkYXk6IFwiMi1kaWdpdFwiLFxuICAgICAgaG91cjogXCIyLWRpZ2l0XCIsXG4gICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgIH07XG5cbiAgaWYgKHRpbWVab25lKSB7XG4gICAgaW50bE9wdHMudGltZVpvbmUgPSB0aW1lWm9uZTtcbiAgfVxuXG4gIGNvbnN0IG1vZGlmaWVkID0geyB0aW1lWm9uZU5hbWU6IG9mZnNldEZvcm1hdCwgLi4uaW50bE9wdHMgfTtcblxuICBjb25zdCBwYXJzZWQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG1vZGlmaWVkKVxuICAgIC5mb3JtYXRUb1BhcnRzKGRhdGUpXG4gICAgLmZpbmQoKG0pID0+IG0udHlwZS50b0xvd2VyQ2FzZSgpID09PSBcInRpbWV6b25lbmFtZVwiKTtcbiAgcmV0dXJuIHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IG51bGw7XG59XG5cbi8vIHNpZ25lZE9mZnNldCgnLTUnLCAnMzAnKSAtPiAtMzMwXG5leHBvcnQgZnVuY3Rpb24gc2lnbmVkT2Zmc2V0KG9mZkhvdXJTdHIsIG9mZk1pbnV0ZVN0cikge1xuICBsZXQgb2ZmSG91ciA9IHBhcnNlSW50KG9mZkhvdXJTdHIsIDEwKTtcblxuICAvLyBkb24ndCB8fCB0aGlzIGJlY2F1c2Ugd2Ugd2FudCB0byBwcmVzZXJ2ZSAtMFxuICBpZiAoTnVtYmVyLmlzTmFOKG9mZkhvdXIpKSB7XG4gICAgb2ZmSG91ciA9IDA7XG4gIH1cblxuICBjb25zdCBvZmZNaW4gPSBwYXJzZUludChvZmZNaW51dGVTdHIsIDEwKSB8fCAwLFxuICAgIG9mZk1pblNpZ25lZCA9IG9mZkhvdXIgPCAwIHx8IE9iamVjdC5pcyhvZmZIb3VyLCAtMCkgPyAtb2ZmTWluIDogb2ZmTWluO1xuICByZXR1cm4gb2ZmSG91ciAqIDYwICsgb2ZmTWluU2lnbmVkO1xufVxuXG4vLyBDT0VSQ0lPTlxuXG5leHBvcnQgZnVuY3Rpb24gYXNOdW1iZXIodmFsdWUpIHtcbiAgY29uc3QgbnVtZXJpY1ZhbHVlID0gTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIgfHwgdmFsdWUgPT09IFwiXCIgfHwgTnVtYmVyLmlzTmFOKG51bWVyaWNWYWx1ZSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBJbnZhbGlkIHVuaXQgdmFsdWUgJHt2YWx1ZX1gKTtcbiAgcmV0dXJuIG51bWVyaWNWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdChvYmosIG5vcm1hbGl6ZXIpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHt9O1xuICBmb3IgKGNvbnN0IHUgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KG9iaiwgdSkpIHtcbiAgICAgIGNvbnN0IHYgPSBvYmpbdV07XG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgbm9ybWFsaXplZFtub3JtYWxpemVyKHUpXSA9IGFzTnVtYmVyKHYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE9mZnNldChvZmZzZXQsIGZvcm1hdCkge1xuICBjb25zdCBob3VycyA9IE1hdGgudHJ1bmMoTWF0aC5hYnMob2Zmc2V0IC8gNjApKSxcbiAgICBtaW51dGVzID0gTWF0aC50cnVuYyhNYXRoLmFicyhvZmZzZXQgJSA2MCkpLFxuICAgIHNpZ24gPSBvZmZzZXQgPj0gMCA/IFwiK1wiIDogXCItXCI7XG5cbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBgJHtzaWdufSR7cGFkU3RhcnQoaG91cnMsIDIpfToke3BhZFN0YXJ0KG1pbnV0ZXMsIDIpfWA7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIGAke3NpZ259JHtob3Vyc30ke21pbnV0ZXMgPiAwID8gYDoke21pbnV0ZXN9YCA6IFwiXCJ9YDtcbiAgICBjYXNlIFwidGVjaGllXCI6XG4gICAgICByZXR1cm4gYCR7c2lnbn0ke3BhZFN0YXJ0KGhvdXJzLCAyKX0ke3BhZFN0YXJ0KG1pbnV0ZXMsIDIpfWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBWYWx1ZSBmb3JtYXQgJHtmb3JtYXR9IGlzIG91dCBvZiByYW5nZSBmb3IgcHJvcGVydHkgZm9ybWF0YCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVPYmplY3Qob2JqKSB7XG4gIHJldHVybiBwaWNrKG9iaiwgW1wiaG91clwiLCBcIm1pbnV0ZVwiLCBcInNlY29uZFwiLCBcIm1pbGxpc2Vjb25kXCJdKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBGb3JtYXRzIGZyb20gXCIuL2Zvcm1hdHMuanNcIjtcbmltcG9ydCB7IHBpY2sgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShvYmopIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgT2JqZWN0LmtleXMob2JqKS5zb3J0KCkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGNvbnN0IG1vbnRoc0xvbmcgPSBbXG4gIFwiSmFudWFyeVwiLFxuICBcIkZlYnJ1YXJ5XCIsXG4gIFwiTWFyY2hcIixcbiAgXCJBcHJpbFwiLFxuICBcIk1heVwiLFxuICBcIkp1bmVcIixcbiAgXCJKdWx5XCIsXG4gIFwiQXVndXN0XCIsXG4gIFwiU2VwdGVtYmVyXCIsXG4gIFwiT2N0b2JlclwiLFxuICBcIk5vdmVtYmVyXCIsXG4gIFwiRGVjZW1iZXJcIixcbl07XG5cbmV4cG9ydCBjb25zdCBtb250aHNTaG9ydCA9IFtcbiAgXCJKYW5cIixcbiAgXCJGZWJcIixcbiAgXCJNYXJcIixcbiAgXCJBcHJcIixcbiAgXCJNYXlcIixcbiAgXCJKdW5cIixcbiAgXCJKdWxcIixcbiAgXCJBdWdcIixcbiAgXCJTZXBcIixcbiAgXCJPY3RcIixcbiAgXCJOb3ZcIixcbiAgXCJEZWNcIixcbl07XG5cbmV4cG9ydCBjb25zdCBtb250aHNOYXJyb3cgPSBbXCJKXCIsIFwiRlwiLCBcIk1cIiwgXCJBXCIsIFwiTVwiLCBcIkpcIiwgXCJKXCIsIFwiQVwiLCBcIlNcIiwgXCJPXCIsIFwiTlwiLCBcIkRcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBtb250aHMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNOYXJyb3ddO1xuICAgIGNhc2UgXCJzaG9ydFwiOlxuICAgICAgcmV0dXJuIFsuLi5tb250aHNTaG9ydF07XG4gICAgY2FzZSBcImxvbmdcIjpcbiAgICAgIHJldHVybiBbLi4ubW9udGhzTG9uZ107XG4gICAgY2FzZSBcIm51bWVyaWNcIjpcbiAgICAgIHJldHVybiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgY2FzZSBcIjItZGlnaXRcIjpcbiAgICAgIHJldHVybiBbXCIwMVwiLCBcIjAyXCIsIFwiMDNcIiwgXCIwNFwiLCBcIjA1XCIsIFwiMDZcIiwgXCIwN1wiLCBcIjA4XCIsIFwiMDlcIiwgXCIxMFwiLCBcIjExXCIsIFwiMTJcIl07XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c0xvbmcgPSBbXG4gIFwiTW9uZGF5XCIsXG4gIFwiVHVlc2RheVwiLFxuICBcIldlZG5lc2RheVwiLFxuICBcIlRodXJzZGF5XCIsXG4gIFwiRnJpZGF5XCIsXG4gIFwiU2F0dXJkYXlcIixcbiAgXCJTdW5kYXlcIixcbl07XG5cbmV4cG9ydCBjb25zdCB3ZWVrZGF5c1Nob3J0ID0gW1wiTW9uXCIsIFwiVHVlXCIsIFwiV2VkXCIsIFwiVGh1XCIsIFwiRnJpXCIsIFwiU2F0XCIsIFwiU3VuXCJdO1xuXG5leHBvcnQgY29uc3Qgd2Vla2RheXNOYXJyb3cgPSBbXCJNXCIsIFwiVFwiLCBcIldcIiwgXCJUXCIsIFwiRlwiLCBcIlNcIiwgXCJTXCJdO1xuXG5leHBvcnQgZnVuY3Rpb24gd2Vla2RheXMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi53ZWVrZGF5c05hcnJvd107XG4gICAgY2FzZSBcInNob3J0XCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzU2hvcnRdO1xuICAgIGNhc2UgXCJsb25nXCI6XG4gICAgICByZXR1cm4gWy4uLndlZWtkYXlzTG9uZ107XG4gICAgY2FzZSBcIm51bWVyaWNcIjpcbiAgICAgIHJldHVybiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCJdO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbWVyaWRpZW1zID0gW1wiQU1cIiwgXCJQTVwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNMb25nID0gW1wiQmVmb3JlIENocmlzdFwiLCBcIkFubm8gRG9taW5pXCJdO1xuXG5leHBvcnQgY29uc3QgZXJhc1Nob3J0ID0gW1wiQkNcIiwgXCJBRFwiXTtcblxuZXhwb3J0IGNvbnN0IGVyYXNOYXJyb3cgPSBbXCJCXCIsIFwiQVwiXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVyYXMobGVuZ3RoKSB7XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSBcIm5hcnJvd1wiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzTmFycm93XTtcbiAgICBjYXNlIFwic2hvcnRcIjpcbiAgICAgIHJldHVybiBbLi4uZXJhc1Nob3J0XTtcbiAgICBjYXNlIFwibG9uZ1wiOlxuICAgICAgcmV0dXJuIFsuLi5lcmFzTG9uZ107XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJpZGllbUZvckRhdGVUaW1lKGR0KSB7XG4gIHJldHVybiBtZXJpZGllbXNbZHQuaG91ciA8IDEyID8gMCA6IDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIHdlZWtkYXlzKGxlbmd0aClbZHQud2Vla2RheSAtIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9udGhGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSB7XG4gIHJldHVybiBtb250aHMobGVuZ3RoKVtkdC5tb250aCAtIDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXJhRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aCkge1xuICByZXR1cm4gZXJhcyhsZW5ndGgpW2R0LnllYXIgPCAwID8gMCA6IDFdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0UmVsYXRpdmVUaW1lKHVuaXQsIGNvdW50LCBudW1lcmljID0gXCJhbHdheXNcIiwgbmFycm93ID0gZmFsc2UpIHtcbiAgY29uc3QgdW5pdHMgPSB7XG4gICAgeWVhcnM6IFtcInllYXJcIiwgXCJ5ci5cIl0sXG4gICAgcXVhcnRlcnM6IFtcInF1YXJ0ZXJcIiwgXCJxdHIuXCJdLFxuICAgIG1vbnRoczogW1wibW9udGhcIiwgXCJtby5cIl0sXG4gICAgd2Vla3M6IFtcIndlZWtcIiwgXCJ3ay5cIl0sXG4gICAgZGF5czogW1wiZGF5XCIsIFwiZGF5XCIsIFwiZGF5c1wiXSxcbiAgICBob3VyczogW1wiaG91clwiLCBcImhyLlwiXSxcbiAgICBtaW51dGVzOiBbXCJtaW51dGVcIiwgXCJtaW4uXCJdLFxuICAgIHNlY29uZHM6IFtcInNlY29uZFwiLCBcInNlYy5cIl0sXG4gIH07XG5cbiAgY29uc3QgbGFzdGFibGUgPSBbXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCJdLmluZGV4T2YodW5pdCkgPT09IC0xO1xuXG4gIGlmIChudW1lcmljID09PSBcImF1dG9cIiAmJiBsYXN0YWJsZSkge1xuICAgIGNvbnN0IGlzRGF5ID0gdW5pdCA9PT0gXCJkYXlzXCI7XG4gICAgc3dpdGNoIChjb3VudCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvbW9ycm93XCIgOiBgbmV4dCAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBjYXNlIC0xOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInllc3RlcmRheVwiIDogYGxhc3QgJHt1bml0c1t1bml0XVswXX1gO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gaXNEYXkgPyBcInRvZGF5XCIgOiBgdGhpcyAke3VuaXRzW3VuaXRdWzBdfWA7XG4gICAgICBkZWZhdWx0OiAvLyBmYWxsIHRocm91Z2hcbiAgICB9XG4gIH1cblxuICBjb25zdCBpc0luUGFzdCA9IE9iamVjdC5pcyhjb3VudCwgLTApIHx8IGNvdW50IDwgMCxcbiAgICBmbXRWYWx1ZSA9IE1hdGguYWJzKGNvdW50KSxcbiAgICBzaW5ndWxhciA9IGZtdFZhbHVlID09PSAxLFxuICAgIGxpbFVuaXRzID0gdW5pdHNbdW5pdF0sXG4gICAgZm10VW5pdCA9IG5hcnJvd1xuICAgICAgPyBzaW5ndWxhclxuICAgICAgICA/IGxpbFVuaXRzWzFdXG4gICAgICAgIDogbGlsVW5pdHNbMl0gfHwgbGlsVW5pdHNbMV1cbiAgICAgIDogc2luZ3VsYXJcbiAgICAgID8gdW5pdHNbdW5pdF1bMF1cbiAgICAgIDogdW5pdDtcbiAgcmV0dXJuIGlzSW5QYXN0ID8gYCR7Zm10VmFsdWV9ICR7Zm10VW5pdH0gYWdvYCA6IGBpbiAke2ZtdFZhbHVlfSAke2ZtdFVuaXR9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFN0cmluZyhrbm93bkZvcm1hdCkge1xuICAvLyB0aGVzZSBhbGwgaGF2ZSB0aGUgb2Zmc2V0cyByZW1vdmVkIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlbVxuICAvLyB3aXRob3V0IGFsbCB0aGUgaW50bCBzdHVmZiB0aGlzIGlzIGJhY2tmaWxsaW5nXG4gIGNvbnN0IGZpbHRlcmVkID0gcGljayhrbm93bkZvcm1hdCwgW1xuICAgICAgXCJ3ZWVrZGF5XCIsXG4gICAgICBcImVyYVwiLFxuICAgICAgXCJ5ZWFyXCIsXG4gICAgICBcIm1vbnRoXCIsXG4gICAgICBcImRheVwiLFxuICAgICAgXCJob3VyXCIsXG4gICAgICBcIm1pbnV0ZVwiLFxuICAgICAgXCJzZWNvbmRcIixcbiAgICAgIFwidGltZVpvbmVOYW1lXCIsXG4gICAgICBcImhvdXJDeWNsZVwiLFxuICAgIF0pLFxuICAgIGtleSA9IHN0cmluZ2lmeShmaWx0ZXJlZCksXG4gICAgZGF0ZVRpbWVIdWdlID0gXCJFRUVFLCBMTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9TSE9SVCk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURV9NRUQpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXlcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVfTUVEX1dJVEhfV0VFS0RBWSk6XG4gICAgICByZXR1cm4gXCJFRUUsIExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX0ZVTEwpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFX0hVR0UpOlxuICAgICAgcmV0dXJuIFwiRUVFRSwgTExMTCBkLCB5eXl5XCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FX1NJTVBMRSk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcImg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV9XSVRIX1NIT1JUX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJoOm1tIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLlRJTUVfMjRfU0lNUExFKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyk6XG4gICAgICByZXR1cm4gXCJISDptbTpzc1wiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVCk6XG4gICAgICByZXR1cm4gXCJISDptbVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUKTpcbiAgICAgIHJldHVybiBcIkhIOm1tXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9TSE9SVCk6XG4gICAgICByZXR1cm4gXCJNL2QveXl5eSwgaDptbSBhXCI7XG4gICAgY2FzZSBzdHJpbmdpZnkoRm9ybWF0cy5EQVRFVElNRV9NRUQpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfRlVMTCk6XG4gICAgICByZXR1cm4gXCJMTExMIGQsIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfSFVHRSk6XG4gICAgICByZXR1cm4gZGF0ZVRpbWVIdWdlO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIk0vZC95eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX01FRF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTExMIGQsIHl5eXksIGg6bW06c3MgYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSk6XG4gICAgICByZXR1cm4gXCJFRUUsIGQgTExMIHl5eXksIGg6bW0gYVwiO1xuICAgIGNhc2Ugc3RyaW5naWZ5KEZvcm1hdHMuREFURVRJTUVfRlVMTF9XSVRIX1NFQ09ORFMpOlxuICAgICAgcmV0dXJuIFwiTExMTCBkLCB5eXl5LCBoOm1tOnNzIGFcIjtcbiAgICBjYXNlIHN0cmluZ2lmeShGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTKTpcbiAgICAgIHJldHVybiBcIkVFRUUsIExMTEwgZCwgeXl5eSwgaDptbTpzcyBhXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRlVGltZUh1Z2U7XG4gIH1cbn1cbiIsICJpbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vZm9ybWF0cy5qc1wiO1xuaW1wb3J0IHsgcGFkU3RhcnQgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VucyhzcGxpdHMsIHRva2VuVG9TdHJpbmcpIHtcbiAgbGV0IHMgPSBcIlwiO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHNwbGl0cykge1xuICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICBzICs9IHRva2VuLnZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcyArPSB0b2tlblRvU3RyaW5nKHRva2VuLnZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufVxuXG5jb25zdCBtYWNyb1Rva2VuVG9Gb3JtYXRPcHRzID0ge1xuICBEOiBGb3JtYXRzLkRBVEVfU0hPUlQsXG4gIEREOiBGb3JtYXRzLkRBVEVfTUVELFxuICBEREQ6IEZvcm1hdHMuREFURV9GVUxMLFxuICBEREREOiBGb3JtYXRzLkRBVEVfSFVHRSxcbiAgdDogRm9ybWF0cy5USU1FX1NJTVBMRSxcbiAgdHQ6IEZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMsXG4gIHR0dDogRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VULFxuICB0dHR0OiBGb3JtYXRzLlRJTUVfV0lUSF9MT05HX09GRlNFVCxcbiAgVDogRm9ybWF0cy5USU1FXzI0X1NJTVBMRSxcbiAgVFQ6IEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFMsXG4gIFRUVDogRm9ybWF0cy5USU1FXzI0X1dJVEhfU0hPUlRfT0ZGU0VULFxuICBUVFRUOiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVCxcbiAgZjogRm9ybWF0cy5EQVRFVElNRV9TSE9SVCxcbiAgZmY6IEZvcm1hdHMuREFURVRJTUVfTUVELFxuICBmZmY6IEZvcm1hdHMuREFURVRJTUVfRlVMTCxcbiAgZmZmZjogRm9ybWF0cy5EQVRFVElNRV9IVUdFLFxuICBGOiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUyxcbiAgRkY6IEZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyxcbiAgRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTLFxuICBGRkZGOiBGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTLFxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZvcm1hdHRlciB7XG4gIHN0YXRpYyBjcmVhdGUobG9jYWxlLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IEZvcm1hdHRlcihsb2NhbGUsIG9wdHMpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlRm9ybWF0KGZtdCkge1xuICAgIC8vIHdoaXRlLXNwYWNlIGlzIGFsd2F5cyBjb25zaWRlcmVkIGEgbGl0ZXJhbCBpbiB1c2VyLXByb3ZpZGVkIGZvcm1hdHNcbiAgICAvLyB0aGUgXCIgXCIgdG9rZW4gaGFzIGEgc3BlY2lhbCBtZWFuaW5nIChzZWUgdW5pdEZvclRva2VuKVxuXG4gICAgbGV0IGN1cnJlbnQgPSBudWxsLFxuICAgICAgY3VycmVudEZ1bGwgPSBcIlwiLFxuICAgICAgYnJhY2tldGVkID0gZmFsc2U7XG4gICAgY29uc3Qgc3BsaXRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSBmbXQuY2hhckF0KGkpO1xuICAgICAgaWYgKGMgPT09IFwiJ1wiKSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiBicmFja2V0ZWQgfHwgL15cXHMrJC8udGVzdChjdXJyZW50RnVsbCksIHZhbDogY3VycmVudEZ1bGwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRGdWxsID0gXCJcIjtcbiAgICAgICAgYnJhY2tldGVkID0gIWJyYWNrZXRlZDtcbiAgICAgIH0gZWxzZSBpZiAoYnJhY2tldGVkKSB7XG4gICAgICAgIGN1cnJlbnRGdWxsICs9IGM7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgY3VycmVudEZ1bGwgKz0gYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc3BsaXRzLnB1c2goeyBsaXRlcmFsOiAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RnVsbCA9IGM7XG4gICAgICAgIGN1cnJlbnQgPSBjO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdXJyZW50RnVsbC5sZW5ndGggPiAwKSB7XG4gICAgICBzcGxpdHMucHVzaCh7IGxpdGVyYWw6IGJyYWNrZXRlZCB8fCAvXlxccyskLy50ZXN0KGN1cnJlbnRGdWxsKSwgdmFsOiBjdXJyZW50RnVsbCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3BsaXRzO1xuICB9XG5cbiAgc3RhdGljIG1hY3JvVG9rZW5Ub0Zvcm1hdE9wdHModG9rZW4pIHtcbiAgICByZXR1cm4gbWFjcm9Ub2tlblRvRm9ybWF0T3B0c1t0b2tlbl07XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihsb2NhbGUsIGZvcm1hdE9wdHMpIHtcbiAgICB0aGlzLm9wdHMgPSBmb3JtYXRPcHRzO1xuICAgIHRoaXMubG9jID0gbG9jYWxlO1xuICAgIHRoaXMuc3lzdGVtTG9jID0gbnVsbDtcbiAgfVxuXG4gIGZvcm1hdFdpdGhTeXN0ZW1EZWZhdWx0KGR0LCBvcHRzKSB7XG4gICAgaWYgKHRoaXMuc3lzdGVtTG9jID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN5c3RlbUxvYyA9IHRoaXMubG9jLnJlZGVmYXVsdFRvU3lzdGVtKCk7XG4gICAgfVxuICAgIGNvbnN0IGRmID0gdGhpcy5zeXN0ZW1Mb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICAgIHJldHVybiBkZi5mb3JtYXQoKTtcbiAgfVxuXG4gIGR0Rm9ybWF0dGVyKGR0LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5sb2MuZHRGb3JtYXR0ZXIoZHQsIHsgLi4udGhpcy5vcHRzLCAuLi5vcHRzIH0pO1xuICB9XG5cbiAgZm9ybWF0RGF0ZVRpbWUoZHQsIG9wdHMpIHtcbiAgICByZXR1cm4gdGhpcy5kdEZvcm1hdHRlcihkdCwgb3B0cykuZm9ybWF0KCk7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZVBhcnRzKGR0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuZHRGb3JtYXR0ZXIoZHQsIG9wdHMpLmZvcm1hdFRvUGFydHMoKTtcbiAgfVxuXG4gIGZvcm1hdEludGVydmFsKGludGVydmFsLCBvcHRzKSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmR0Rm9ybWF0dGVyKGludGVydmFsLnN0YXJ0LCBvcHRzKTtcbiAgICByZXR1cm4gZGYuZHRmLmZvcm1hdFJhbmdlKGludGVydmFsLnN0YXJ0LnRvSlNEYXRlKCksIGludGVydmFsLmVuZC50b0pTRGF0ZSgpKTtcbiAgfVxuXG4gIHJlc29sdmVkT3B0aW9ucyhkdCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLmR0Rm9ybWF0dGVyKGR0LCBvcHRzKS5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgfVxuXG4gIG51bShuLCBwID0gMCkge1xuICAgIC8vIHdlIGdldCBzb21lIHBlcmYgb3V0IG9mIGRvaW5nIHRoaXMgaGVyZSwgYW5ub3lpbmdseVxuICAgIGlmICh0aGlzLm9wdHMuZm9yY2VTaW1wbGUpIHtcbiAgICAgIHJldHVybiBwYWRTdGFydChuLCBwKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0geyAuLi50aGlzLm9wdHMgfTtcblxuICAgIGlmIChwID4gMCkge1xuICAgICAgb3B0cy5wYWRUbyA9IHA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubG9jLm51bWJlckZvcm1hdHRlcihvcHRzKS5mb3JtYXQobik7XG4gIH1cblxuICBmb3JtYXREYXRlVGltZUZyb21TdHJpbmcoZHQsIGZtdCkge1xuICAgIGNvbnN0IGtub3duRW5nbGlzaCA9IHRoaXMubG9jLmxpc3RpbmdNb2RlKCkgPT09IFwiZW5cIixcbiAgICAgIHVzZURhdGVUaW1lRm9ybWF0dGVyID0gdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgJiYgdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgIT09IFwiZ3JlZ29yeVwiLFxuICAgICAgc3RyaW5nID0gKG9wdHMsIGV4dHJhY3QpID0+IHRoaXMubG9jLmV4dHJhY3QoZHQsIG9wdHMsIGV4dHJhY3QpLFxuICAgICAgZm9ybWF0T2Zmc2V0ID0gKG9wdHMpID0+IHtcbiAgICAgICAgaWYgKGR0LmlzT2Zmc2V0Rml4ZWQgJiYgZHQub2Zmc2V0ID09PSAwICYmIG9wdHMuYWxsb3daKSB7XG4gICAgICAgICAgcmV0dXJuIFwiWlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQgPyBkdC56b25lLmZvcm1hdE9mZnNldChkdC50cywgb3B0cy5mb3JtYXQpIDogXCJcIjtcbiAgICAgIH0sXG4gICAgICBtZXJpZGllbSA9ICgpID0+XG4gICAgICAgIGtub3duRW5nbGlzaFxuICAgICAgICAgID8gRW5nbGlzaC5tZXJpZGllbUZvckRhdGVUaW1lKGR0KVxuICAgICAgICAgIDogc3RyaW5nKHsgaG91cjogXCJudW1lcmljXCIsIGhvdXJDeWNsZTogXCJoMTJcIiB9LCBcImRheXBlcmlvZFwiKSxcbiAgICAgIG1vbnRoID0gKGxlbmd0aCwgc3RhbmRhbG9uZSkgPT5cbiAgICAgICAga25vd25FbmdsaXNoXG4gICAgICAgICAgPyBFbmdsaXNoLm1vbnRoRm9yRGF0ZVRpbWUoZHQsIGxlbmd0aClcbiAgICAgICAgICA6IHN0cmluZyhzdGFuZGFsb25lID8geyBtb250aDogbGVuZ3RoIH0gOiB7IG1vbnRoOiBsZW5ndGgsIGRheTogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKSxcbiAgICAgIHdlZWtkYXkgPSAobGVuZ3RoLCBzdGFuZGFsb25lKSA9PlxuICAgICAgICBrbm93bkVuZ2xpc2hcbiAgICAgICAgICA/IEVuZ2xpc2gud2Vla2RheUZvckRhdGVUaW1lKGR0LCBsZW5ndGgpXG4gICAgICAgICAgOiBzdHJpbmcoXG4gICAgICAgICAgICAgIHN0YW5kYWxvbmUgPyB7IHdlZWtkYXk6IGxlbmd0aCB9IDogeyB3ZWVrZGF5OiBsZW5ndGgsIG1vbnRoOiBcImxvbmdcIiwgZGF5OiBcIm51bWVyaWNcIiB9LFxuICAgICAgICAgICAgICBcIndlZWtkYXlcIlxuICAgICAgICAgICAgKSxcbiAgICAgIG1heWJlTWFjcm8gPSAodG9rZW4pID0+IHtcbiAgICAgICAgY29uc3QgZm9ybWF0T3B0cyA9IEZvcm1hdHRlci5tYWNyb1Rva2VuVG9Gb3JtYXRPcHRzKHRva2VuKTtcbiAgICAgICAgaWYgKGZvcm1hdE9wdHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRXaXRoU3lzdGVtRGVmYXVsdChkdCwgZm9ybWF0T3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJhID0gKGxlbmd0aCkgPT5cbiAgICAgICAga25vd25FbmdsaXNoID8gRW5nbGlzaC5lcmFGb3JEYXRlVGltZShkdCwgbGVuZ3RoKSA6IHN0cmluZyh7IGVyYTogbGVuZ3RoIH0sIFwiZXJhXCIpLFxuICAgICAgdG9rZW5Ub1N0cmluZyA9ICh0b2tlbikgPT4ge1xuICAgICAgICAvLyBXaGVyZSBwb3NzaWJsZTogaHR0cHM6Ly9jbGRyLnVuaWNvZGUub3JnL3RyYW5zbGF0aW9uL2RhdGUtdGltZS9kYXRlLXRpbWUtc3ltYm9sc1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgLy8gbXNcbiAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWlsbGlzZWNvbmQsIDMpO1xuICAgICAgICAgIC8vIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LnNlY29uZCk7XG4gICAgICAgICAgY2FzZSBcInNzXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuc2Vjb25kLCAyKTtcbiAgICAgICAgICAvLyBmcmFjdGlvbmFsIHNlY29uZHNcbiAgICAgICAgICBjYXNlIFwidXVcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0Lm1pbGxpc2Vjb25kIC8gMTApLCAyKTtcbiAgICAgICAgICBjYXNlIFwidXV1XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oTWF0aC5mbG9vcihkdC5taWxsaXNlY29uZCAvIDEwMCkpO1xuICAgICAgICAgIC8vIG1pbnV0ZXNcbiAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm1pbnV0ZSk7XG4gICAgICAgICAgY2FzZSBcIm1tXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQubWludXRlLCAyKTtcbiAgICAgICAgICAvLyBob3Vyc1xuICAgICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQuaG91ciAlIDEyID09PSAwID8gMTIgOiBkdC5ob3VyICUgMTIpO1xuICAgICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIgJSAxMiA9PT0gMCA/IDEyIDogZHQuaG91ciAlIDEyLCAyKTtcbiAgICAgICAgICBjYXNlIFwiSFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIpO1xuICAgICAgICAgIGNhc2UgXCJISFwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0LmhvdXIsIDIpO1xuICAgICAgICAgIC8vIG9mZnNldFxuICAgICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICs2XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0T2Zmc2V0KHsgZm9ybWF0OiBcIm5hcnJvd1wiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlICswNjowMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJzaG9ydFwiLCBhbGxvd1o6IHRoaXMub3B0cy5hbGxvd1ogfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlwiOlxuICAgICAgICAgICAgLy8gbGlrZSArMDYwMFxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE9mZnNldCh7IGZvcm1hdDogXCJ0ZWNoaWVcIiwgYWxsb3daOiB0aGlzLm9wdHMuYWxsb3daIH0pO1xuICAgICAgICAgIGNhc2UgXCJaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVTVFxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwic2hvcnRcIiwgbG9jYWxlOiB0aGlzLmxvYy5sb2NhbGUgfSk7XG4gICAgICAgICAgY2FzZSBcIlpaWlpaXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEVhc3Rlcm4gU3RhbmRhcmQgVGltZVxuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmUub2Zmc2V0TmFtZShkdC50cywgeyBmb3JtYXQ6IFwibG9uZ1wiLCBsb2NhbGU6IHRoaXMubG9jLmxvY2FsZSB9KTtcbiAgICAgICAgICAvLyB6b25lXG4gICAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW1lcmljYS9OZXdfWW9ya1xuICAgICAgICAgICAgcmV0dXJuIGR0LnpvbmVOYW1lO1xuICAgICAgICAgIC8vIG1lcmlkaWVtc1xuICAgICAgICAgIGNhc2UgXCJhXCI6XG4gICAgICAgICAgICByZXR1cm4gbWVyaWRpZW0oKTtcbiAgICAgICAgICAvLyBkYXRlc1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyBkYXk6IFwibnVtZXJpY1wiIH0sIFwiZGF5XCIpIDogdGhpcy5udW0oZHQuZGF5KTtcbiAgICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlciA/IHN0cmluZyh7IGRheTogXCIyLWRpZ2l0XCIgfSwgXCJkYXlcIikgOiB0aGlzLm51bShkdC5kYXksIDIpO1xuICAgICAgICAgIC8vIHdlZWtkYXlzIC0gc3RhbmRhbG9uZVxuICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY1wiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVHVlc2RheSdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibG9uZ1wiLCB0cnVlKTtcbiAgICAgICAgICBjYXNlIFwiY2NjY2NcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1QnXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyB3ZWVrZGF5cyAtIGZvcm1hdFxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDFcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrZGF5KTtcbiAgICAgICAgICBjYXNlIFwiRUVFXCI6XG4gICAgICAgICAgICAvLyBsaWtlICdUdWVzJ1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtkYXkoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgJ1R1ZXNkYXknXG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheShcImxvbmdcIiwgZmFsc2UpO1xuICAgICAgICAgIGNhc2UgXCJFRUVFRVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAnVCdcbiAgICAgICAgICAgIHJldHVybiB3ZWVrZGF5KFwibmFycm93XCIsIGZhbHNlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBzdGFuZGFsb25lXG4gICAgICAgICAgY2FzZSBcIkxcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMVxuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwibnVtZXJpY1wiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCk7XG4gICAgICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxLCBkb2Vzbid0IHNlZW0gdG8gd29ya1xuICAgICAgICAgICAgcmV0dXJuIHVzZURhdGVUaW1lRm9ybWF0dGVyXG4gICAgICAgICAgICAgID8gc3RyaW5nKHsgbW9udGg6IFwiMi1kaWdpdFwiLCBkYXk6IFwibnVtZXJpY1wiIH0sIFwibW9udGhcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC5tb250aCwgMik7XG4gICAgICAgICAgY2FzZSBcIkxMTFwiOlxuICAgICAgICAgICAgLy8gbGlrZSBKYW5cbiAgICAgICAgICAgIHJldHVybiBtb250aChcInNob3J0XCIsIHRydWUpO1xuICAgICAgICAgIGNhc2UgXCJMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEphbnVhcnlcbiAgICAgICAgICAgIHJldHVybiBtb250aChcImxvbmdcIiwgdHJ1ZSk7XG4gICAgICAgICAgY2FzZSBcIkxMTExMXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCB0cnVlKTtcbiAgICAgICAgICAvLyBtb250aHMgLSBmb3JtYXRcbiAgICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyBtb250aDogXCJudW1lcmljXCIgfSwgXCJtb250aFwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0Lm1vbnRoKTtcbiAgICAgICAgICBjYXNlIFwiTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDFcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IG1vbnRoOiBcIjItZGlnaXRcIiB9LCBcIm1vbnRoXCIpXG4gICAgICAgICAgICAgIDogdGhpcy5udW0oZHQubW9udGgsIDIpO1xuICAgICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFuXG4gICAgICAgICAgICByZXR1cm4gbW9udGgoXCJzaG9ydFwiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICAgIC8vIGxpa2UgSmFudWFyeVxuICAgICAgICAgICAgcmV0dXJuIG1vbnRoKFwibG9uZ1wiLCBmYWxzZSk7XG4gICAgICAgICAgY2FzZSBcIk1NTU1NXCI6XG4gICAgICAgICAgICAvLyBsaWtlIEpcbiAgICAgICAgICAgIHJldHVybiBtb250aChcIm5hcnJvd1wiLCBmYWxzZSk7XG4gICAgICAgICAgLy8geWVhcnNcbiAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAyMDE0XG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXIgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIikgOiB0aGlzLm51bShkdC55ZWFyKTtcbiAgICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMTRcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwiMi1kaWdpdFwiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIudG9TdHJpbmcoKS5zbGljZSgtMiksIDIpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAwMTJcbiAgICAgICAgICAgIHJldHVybiB1c2VEYXRlVGltZUZvcm1hdHRlclxuICAgICAgICAgICAgICA/IHN0cmluZyh7IHllYXI6IFwibnVtZXJpY1wiIH0sIFwieWVhclwiKVxuICAgICAgICAgICAgICA6IHRoaXMubnVtKGR0LnllYXIsIDQpO1xuICAgICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgMDAwMDEyXG4gICAgICAgICAgICByZXR1cm4gdXNlRGF0ZVRpbWVGb3JtYXR0ZXJcbiAgICAgICAgICAgICAgPyBzdHJpbmcoeyB5ZWFyOiBcIm51bWVyaWNcIiB9LCBcInllYXJcIilcbiAgICAgICAgICAgICAgOiB0aGlzLm51bShkdC55ZWFyLCA2KTtcbiAgICAgICAgICAvLyBlcmFzXG4gICAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQURcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJzaG9ydFwiKTtcbiAgICAgICAgICBjYXNlIFwiR0dcIjpcbiAgICAgICAgICAgIC8vIGxpa2UgQW5ubyBEb21pbmlcbiAgICAgICAgICAgIHJldHVybiBlcmEoXCJsb25nXCIpO1xuICAgICAgICAgIGNhc2UgXCJHR0dHR1wiOlxuICAgICAgICAgICAgcmV0dXJuIGVyYShcIm5hcnJvd1wiKTtcbiAgICAgICAgICBjYXNlIFwia2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhci50b1N0cmluZygpLnNsaWNlKC0yKSwgMik7XG4gICAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrWWVhciwgNCk7XG4gICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyKTtcbiAgICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC53ZWVrTnVtYmVyLCAyKTtcbiAgICAgICAgICBjYXNlIFwib1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGR0Lm9yZGluYWwpO1xuICAgICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShkdC5vcmRpbmFsLCAzKTtcbiAgICAgICAgICBjYXNlIFwicVwiOlxuICAgICAgICAgICAgLy8gbGlrZSAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlcik7XG4gICAgICAgICAgY2FzZSBcInFxXCI6XG4gICAgICAgICAgICAvLyBsaWtlIDAxXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQucXVhcnRlciwgMik7XG4gICAgICAgICAgY2FzZSBcIlhcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bShNYXRoLmZsb29yKGR0LnRzIC8gMTAwMCkpO1xuICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5udW0oZHQudHMpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbWF5YmVNYWNybyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKEZvcm1hdHRlci5wYXJzZUZvcm1hdChmbXQpLCB0b2tlblRvU3RyaW5nKTtcbiAgfVxuXG4gIGZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyhkdXIsIGZtdCkge1xuICAgIGNvbnN0IHRva2VuVG9GaWVsZCA9ICh0b2tlbikgPT4ge1xuICAgICAgICBzd2l0Y2ggKHRva2VuWzBdKSB7XG4gICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCI7XG4gICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIHJldHVybiBcInNlY29uZFwiO1xuICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtaW51dGVcIjtcbiAgICAgICAgICBjYXNlIFwiaFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaG91clwiO1xuICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJkYXlcIjtcbiAgICAgICAgICBjYXNlIFwid1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwid2Vla1wiO1xuICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJtb250aFwiO1xuICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ5ZWFyXCI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9rZW5Ub1N0cmluZyA9IChsaWxkdXIpID0+ICh0b2tlbikgPT4ge1xuICAgICAgICBjb25zdCBtYXBwZWQgPSB0b2tlblRvRmllbGQodG9rZW4pO1xuICAgICAgICBpZiAobWFwcGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubnVtKGxpbGR1ci5nZXQobWFwcGVkKSwgdG9rZW4ubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2tlbnMgPSBGb3JtYXR0ZXIucGFyc2VGb3JtYXQoZm10KSxcbiAgICAgIHJlYWxUb2tlbnMgPSB0b2tlbnMucmVkdWNlKFxuICAgICAgICAoZm91bmQsIHsgbGl0ZXJhbCwgdmFsIH0pID0+IChsaXRlcmFsID8gZm91bmQgOiBmb3VuZC5jb25jYXQodmFsKSksXG4gICAgICAgIFtdXG4gICAgICApLFxuICAgICAgY29sbGFwc2VkID0gZHVyLnNoaWZ0VG8oLi4ucmVhbFRva2Vucy5tYXAodG9rZW5Ub0ZpZWxkKS5maWx0ZXIoKHQpID0+IHQpKTtcbiAgICByZXR1cm4gc3RyaW5naWZ5VG9rZW5zKHRva2VucywgdG9rZW5Ub1N0cmluZyhjb2xsYXBzZWQpKTtcbiAgfVxufVxuIiwgImV4cG9ydCBkZWZhdWx0IGNsYXNzIEludmFsaWQge1xuICBjb25zdHJ1Y3RvcihyZWFzb24sIGV4cGxhbmF0aW9uKSB7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5leHBsYW5hdGlvbiA9IGV4cGxhbmF0aW9uO1xuICB9XG5cbiAgdG9NZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLmV4cGxhbmF0aW9uKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5yZWFzb259OiAke3RoaXMuZXhwbGFuYXRpb259YDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucmVhc29uO1xuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIHVudHJ1bmNhdGVZZWFyLFxuICBzaWduZWRPZmZzZXQsXG4gIHBhcnNlSW50ZWdlcixcbiAgcGFyc2VNaWxsaXMsXG4gIGlzVW5kZWZpbmVkLFxuICBwYXJzZUZsb2F0aW5nLFxufSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgKiBhcyBFbmdsaXNoIGZyb20gXCIuL2VuZ2xpc2guanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4uL3pvbmVzL2ZpeGVkT2Zmc2V0Wm9uZS5qc1wiO1xuaW1wb3J0IElBTkFab25lIGZyb20gXCIuLi96b25lcy9JQU5BWm9uZS5qc1wiO1xuXG4vKlxuICogVGhpcyBmaWxlIGhhbmRsZXMgcGFyc2luZyBmb3Igd2VsbC1zcGVjaWZpZWQgZm9ybWF0cy4gSGVyZSdzIGhvdyBpdCB3b3JrczpcbiAqIFR3byB0aGluZ3MgZ28gaW50byBwYXJzaW5nOiBhIHJlZ2V4IHRvIG1hdGNoIHdpdGggYW5kIGFuIGV4dHJhY3RvciB0byB0YWtlIGFwYXJ0IHRoZSBncm91cHMgaW4gdGhlIG1hdGNoLlxuICogQW4gZXh0cmFjdG9yIGlzIGp1c3QgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgcmVnZXggbWF0Y2ggYXJyYXkgYW5kIHJldHVybnMgYSB7IHllYXI6IC4uLiwgbW9udGg6IC4uLiB9IG9iamVjdFxuICogcGFyc2UoKSBkb2VzIHRoZSB3b3JrIG9mIGV4ZWN1dGluZyB0aGUgcmVnZXggYW5kIGFwcGx5aW5nIHRoZSBleHRyYWN0b3IuIEl0IHRha2VzIG11bHRpcGxlIHJlZ2V4L2V4dHJhY3RvciBwYWlycyB0byB0cnkgaW4gc2VxdWVuY2UuXG4gKiBFeHRyYWN0b3JzIGNhbiB0YWtlIGEgXCJjdXJzb3JcIiByZXByZXNlbnRpbmcgdGhlIG9mZnNldCBpbiB0aGUgbWF0Y2ggdG8gbG9vayBhdC4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIGNvbWJpbmUgZXh0cmFjdG9ycy5cbiAqIGNvbWJpbmVFeHRyYWN0b3JzKCkgZG9lcyB0aGUgd29yayBvZiBjb21iaW5pbmcgdGhlbSwga2VlcGluZyB0cmFjayBvZiB0aGUgY3Vyc29yIHRocm91Z2ggbXVsdGlwbGUgZXh0cmFjdGlvbnMuXG4gKiBTb21lIGV4dHJhY3Rpb25zIGFyZSBzdXBlciBkdW1iIGFuZCBzaW1wbGVQYXJzZSBhbmQgZnJvbVN0cmluZ3MgaGVscCBEUlkgdGhlbS5cbiAqL1xuXG5jb25zdCBpYW5hUmVnZXggPSAvW0EtWmEtel8rLV17MSwyNTZ9KD86Oj9cXC9bQS1aYS16MC05XystXXsxLDI1Nn0oPzpcXC9bQS1aYS16MC05XystXXsxLDI1Nn0pPyk/LztcblxuZnVuY3Rpb24gY29tYmluZVJlZ2V4ZXMoLi4ucmVnZXhlcykge1xuICBjb25zdCBmdWxsID0gcmVnZXhlcy5yZWR1Y2UoKGYsIHIpID0+IGYgKyByLnNvdXJjZSwgXCJcIik7XG4gIHJldHVybiBSZWdFeHAoYF4ke2Z1bGx9JGApO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lRXh0cmFjdG9ycyguLi5leHRyYWN0b3JzKSB7XG4gIHJldHVybiAobSkgPT5cbiAgICBleHRyYWN0b3JzXG4gICAgICAucmVkdWNlKFxuICAgICAgICAoW21lcmdlZFZhbHMsIG1lcmdlZFpvbmUsIGN1cnNvcl0sIGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgW3ZhbCwgem9uZSwgbmV4dF0gPSBleChtLCBjdXJzb3IpO1xuICAgICAgICAgIHJldHVybiBbeyAuLi5tZXJnZWRWYWxzLCAuLi52YWwgfSwgem9uZSB8fCBtZXJnZWRab25lLCBuZXh0XTtcbiAgICAgICAgfSxcbiAgICAgICAgW3t9LCBudWxsLCAxXVxuICAgICAgKVxuICAgICAgLnNsaWNlKDAsIDIpO1xufVxuXG5mdW5jdGlvbiBwYXJzZShzLCAuLi5wYXR0ZXJucykge1xuICBpZiAocyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtudWxsLCBudWxsXTtcbiAgfVxuXG4gIGZvciAoY29uc3QgW3JlZ2V4LCBleHRyYWN0b3JdIG9mIHBhdHRlcm5zKSB7XG4gICAgY29uc3QgbSA9IHJlZ2V4LmV4ZWMocyk7XG4gICAgaWYgKG0pIHtcbiAgICAgIHJldHVybiBleHRyYWN0b3IobSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbbnVsbCwgbnVsbF07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZVBhcnNlKC4uLmtleXMpIHtcbiAgcmV0dXJuIChtYXRjaCwgY3Vyc29yKSA9PiB7XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgbGV0IGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV0W2tleXNbaV1dID0gcGFyc2VJbnRlZ2VyKG1hdGNoW2N1cnNvciArIGldKTtcbiAgICB9XG4gICAgcmV0dXJuIFtyZXQsIG51bGwsIGN1cnNvciArIGldO1xuICB9O1xufVxuXG4vLyBJU08gYW5kIFNRTCBwYXJzaW5nXG5jb25zdCBvZmZzZXRSZWdleCA9IC8oPzooWil8KFsrLV1cXGRcXGQpKD86Oj8oXFxkXFxkKSk/KS87XG5jb25zdCBpc29FeHRlbmRlZFpvbmUgPSBgKD86JHtvZmZzZXRSZWdleC5zb3VyY2V9Pyg/OlxcXFxbKCR7aWFuYVJlZ2V4LnNvdXJjZX0pXFxcXF0pPyk/YDtcbmNvbnN0IGlzb1RpbWVCYXNlUmVnZXggPSAvKFxcZFxcZCkoPzo6PyhcXGRcXGQpKD86Oj8oXFxkXFxkKSg/OlsuLF0oXFxkezEsMzB9KSk/KT8pPy87XG5jb25zdCBpc29UaW1lUmVnZXggPSBSZWdFeHAoYCR7aXNvVGltZUJhc2VSZWdleC5zb3VyY2V9JHtpc29FeHRlbmRlZFpvbmV9YCk7XG5jb25zdCBpc29UaW1lRXh0ZW5zaW9uUmVnZXggPSBSZWdFeHAoYCg/OlQke2lzb1RpbWVSZWdleC5zb3VyY2V9KT9gKTtcbmNvbnN0IGlzb1ltZFJlZ2V4ID0gLyhbKy1dXFxkezZ9fFxcZHs0fSkoPzotPyhcXGRcXGQpKD86LT8oXFxkXFxkKSk/KT8vO1xuY29uc3QgaXNvV2Vla1JlZ2V4ID0gLyhcXGR7NH0pLT9XKFxcZFxcZCkoPzotPyhcXGQpKT8vO1xuY29uc3QgaXNvT3JkaW5hbFJlZ2V4ID0gLyhcXGR7NH0pLT8oXFxkezN9KS87XG5jb25zdCBleHRyYWN0SVNPV2Vla0RhdGEgPSBzaW1wbGVQYXJzZShcIndlZWtZZWFyXCIsIFwid2Vla051bWJlclwiLCBcIndlZWtEYXlcIik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGEgPSBzaW1wbGVQYXJzZShcInllYXJcIiwgXCJvcmRpbmFsXCIpO1xuY29uc3Qgc3FsWW1kUmVnZXggPSAvKFxcZHs0fSktKFxcZFxcZCktKFxcZFxcZCkvOyAvLyBkdW1iZWQtZG93biB2ZXJzaW9uIG9mIHRoZSBJU08gb25lXG5jb25zdCBzcWxUaW1lUmVnZXggPSBSZWdFeHAoXG4gIGAke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSA/KD86JHtvZmZzZXRSZWdleC5zb3VyY2V9fCgke2lhbmFSZWdleC5zb3VyY2V9KSk/YFxuKTtcbmNvbnN0IHNxbFRpbWVFeHRlbnNpb25SZWdleCA9IFJlZ0V4cChgKD86ICR7c3FsVGltZVJlZ2V4LnNvdXJjZX0pP2ApO1xuXG5mdW5jdGlvbiBpbnQobWF0Y2gsIHBvcywgZmFsbGJhY2spIHtcbiAgY29uc3QgbSA9IG1hdGNoW3Bvc107XG4gIHJldHVybiBpc1VuZGVmaW5lZChtKSA/IGZhbGxiYWNrIDogcGFyc2VJbnRlZ2VyKG0pO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPWW1kKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICB5ZWFyOiBpbnQobWF0Y2gsIGN1cnNvciksXG4gICAgbW9udGg6IGludChtYXRjaCwgY3Vyc29yICsgMSwgMSksXG4gICAgZGF5OiBpbnQobWF0Y2gsIGN1cnNvciArIDIsIDEpLFxuICB9O1xuXG4gIHJldHVybiBbaXRlbSwgbnVsbCwgY3Vyc29yICsgM107XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RJU09UaW1lKG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICBob3VyczogaW50KG1hdGNoLCBjdXJzb3IsIDApLFxuICAgIG1pbnV0ZXM6IGludChtYXRjaCwgY3Vyc29yICsgMSwgMCksXG4gICAgc2Vjb25kczogaW50KG1hdGNoLCBjdXJzb3IgKyAyLCAwKSxcbiAgICBtaWxsaXNlY29uZHM6IHBhcnNlTWlsbGlzKG1hdGNoW2N1cnNvciArIDNdKSxcbiAgfTtcblxuICByZXR1cm4gW2l0ZW0sIG51bGwsIGN1cnNvciArIDRdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SVNPT2Zmc2V0KG1hdGNoLCBjdXJzb3IpIHtcbiAgY29uc3QgbG9jYWwgPSAhbWF0Y2hbY3Vyc29yXSAmJiAhbWF0Y2hbY3Vyc29yICsgMV0sXG4gICAgZnVsbE9mZnNldCA9IHNpZ25lZE9mZnNldChtYXRjaFtjdXJzb3IgKyAxXSwgbWF0Y2hbY3Vyc29yICsgMl0pLFxuICAgIHpvbmUgPSBsb2NhbCA/IG51bGwgOiBGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2UoZnVsbE9mZnNldCk7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDNdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SUFOQVpvbmUobWF0Y2gsIGN1cnNvcikge1xuICBjb25zdCB6b25lID0gbWF0Y2hbY3Vyc29yXSA/IElBTkFab25lLmNyZWF0ZShtYXRjaFtjdXJzb3JdKSA6IG51bGw7XG4gIHJldHVybiBbe30sIHpvbmUsIGN1cnNvciArIDFdO1xufVxuXG4vLyBJU08gdGltZSBwYXJzaW5nXG5cbmNvbnN0IGlzb1RpbWVPbmx5ID0gUmVnRXhwKGBeVD8ke2lzb1RpbWVCYXNlUmVnZXguc291cmNlfSRgKTtcblxuLy8gSVNPIGR1cmF0aW9uIHBhcnNpbmdcblxuY29uc3QgaXNvRHVyYXRpb24gPVxuICAvXi0/UCg/Oig/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KVkpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KU0pPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KVcpPyg/OigtP1xcZHsxLDIwfSg/OlxcLlxcZHsxLDIwfSk/KUQpPyg/OlQoPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylIKT8oPzooLT9cXGR7MSwyMH0oPzpcXC5cXGR7MSwyMH0pPylNKT8oPzooLT9cXGR7MSwyMH0pKD86Wy4sXSgtP1xcZHsxLDIwfSkpP1MpPyk/KSQvO1xuXG5mdW5jdGlvbiBleHRyYWN0SVNPRHVyYXRpb24obWF0Y2gpIHtcbiAgY29uc3QgW3MsIHllYXJTdHIsIG1vbnRoU3RyLCB3ZWVrU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyLCBtaWxsaXNlY29uZHNTdHJdID1cbiAgICBtYXRjaDtcblxuICBjb25zdCBoYXNOZWdhdGl2ZVByZWZpeCA9IHNbMF0gPT09IFwiLVwiO1xuICBjb25zdCBuZWdhdGl2ZVNlY29uZHMgPSBzZWNvbmRTdHIgJiYgc2Vjb25kU3RyWzBdID09PSBcIi1cIjtcblxuICBjb25zdCBtYXliZU5lZ2F0ZSA9IChudW0sIGZvcmNlID0gZmFsc2UpID0+XG4gICAgbnVtICE9PSB1bmRlZmluZWQgJiYgKGZvcmNlIHx8IChudW0gJiYgaGFzTmVnYXRpdmVQcmVmaXgpKSA/IC1udW0gOiBudW07XG5cbiAgcmV0dXJuIFtcbiAgICB7XG4gICAgICB5ZWFyczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyh5ZWFyU3RyKSksXG4gICAgICBtb250aHM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcobW9udGhTdHIpKSxcbiAgICAgIHdlZWtzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKHdlZWtTdHIpKSxcbiAgICAgIGRheXM6IG1heWJlTmVnYXRlKHBhcnNlRmxvYXRpbmcoZGF5U3RyKSksXG4gICAgICBob3VyczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhob3VyU3RyKSksXG4gICAgICBtaW51dGVzOiBtYXliZU5lZ2F0ZShwYXJzZUZsb2F0aW5nKG1pbnV0ZVN0cikpLFxuICAgICAgc2Vjb25kczogbWF5YmVOZWdhdGUocGFyc2VGbG9hdGluZyhzZWNvbmRTdHIpLCBzZWNvbmRTdHIgPT09IFwiLTBcIiksXG4gICAgICBtaWxsaXNlY29uZHM6IG1heWJlTmVnYXRlKHBhcnNlTWlsbGlzKG1pbGxpc2Vjb25kc1N0ciksIG5lZ2F0aXZlU2Vjb25kcyksXG4gICAgfSxcbiAgXTtcbn1cblxuLy8gVGhlc2UgYXJlIGEgbGl0dGxlIGJyYWluZGVhZC4gRURUICpzaG91bGQqIHRlbGwgdXMgdGhhdCB3ZSdyZSBpbiwgc2F5LCBBbWVyaWNhL05ld19Zb3JrXG4vLyBhbmQgbm90IGp1c3QgdGhhdCB3ZSdyZSBpbiAtMjQwICpyaWdodCBub3cqLiBCdXQgc2luY2UgSSBkb24ndCB0aGluayB0aGVzZSBhcmUgdXNlZCB0aGF0IG9mdGVuXG4vLyBJJ20ganVzdCBnb2luZyB0byBpZ25vcmUgdGhhdFxuY29uc3Qgb2JzT2Zmc2V0cyA9IHtcbiAgR01UOiAwLFxuICBFRFQ6IC00ICogNjAsXG4gIEVTVDogLTUgKiA2MCxcbiAgQ0RUOiAtNSAqIDYwLFxuICBDU1Q6IC02ICogNjAsXG4gIE1EVDogLTYgKiA2MCxcbiAgTVNUOiAtNyAqIDYwLFxuICBQRFQ6IC03ICogNjAsXG4gIFBTVDogLTggKiA2MCxcbn07XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmdzKHdlZWtkYXlTdHIsIHllYXJTdHIsIG1vbnRoU3RyLCBkYXlTdHIsIGhvdXJTdHIsIG1pbnV0ZVN0ciwgc2Vjb25kU3RyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICB5ZWFyOiB5ZWFyU3RyLmxlbmd0aCA9PT0gMiA/IHVudHJ1bmNhdGVZZWFyKHBhcnNlSW50ZWdlcih5ZWFyU3RyKSkgOiBwYXJzZUludGVnZXIoeWVhclN0ciksXG4gICAgbW9udGg6IEVuZ2xpc2gubW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0cikgKyAxLFxuICAgIGRheTogcGFyc2VJbnRlZ2VyKGRheVN0ciksXG4gICAgaG91cjogcGFyc2VJbnRlZ2VyKGhvdXJTdHIpLFxuICAgIG1pbnV0ZTogcGFyc2VJbnRlZ2VyKG1pbnV0ZVN0ciksXG4gIH07XG5cbiAgaWYgKHNlY29uZFN0cikgcmVzdWx0LnNlY29uZCA9IHBhcnNlSW50ZWdlcihzZWNvbmRTdHIpO1xuICBpZiAod2Vla2RheVN0cikge1xuICAgIHJlc3VsdC53ZWVrZGF5ID1cbiAgICAgIHdlZWtkYXlTdHIubGVuZ3RoID4gM1xuICAgICAgICA/IEVuZ2xpc2gud2Vla2RheXNMb25nLmluZGV4T2Yod2Vla2RheVN0cikgKyAxXG4gICAgICAgIDogRW5nbGlzaC53ZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0cikgKyAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gUkZDIDI4MjIvNTMyMlxuY29uc3QgcmZjMjgyMiA9XG4gIC9eKD86KE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksXFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfCg/OihbKy1dXFxkXFxkKShcXGRcXGQpKSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzI4MjIobWF0Y2gpIHtcbiAgY29uc3QgW1xuICAgICAgLFxuICAgICAgd2Vla2RheVN0cixcbiAgICAgIGRheVN0cixcbiAgICAgIG1vbnRoU3RyLFxuICAgICAgeWVhclN0cixcbiAgICAgIGhvdXJTdHIsXG4gICAgICBtaW51dGVTdHIsXG4gICAgICBzZWNvbmRTdHIsXG4gICAgICBvYnNPZmZzZXQsXG4gICAgICBtaWxPZmZzZXQsXG4gICAgICBvZmZIb3VyU3RyLFxuICAgICAgb2ZmTWludXRlU3RyLFxuICAgIF0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG5cbiAgbGV0IG9mZnNldDtcbiAgaWYgKG9ic09mZnNldCkge1xuICAgIG9mZnNldCA9IG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgfSBlbHNlIGlmIChtaWxPZmZzZXQpIHtcbiAgICBvZmZzZXQgPSAwO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldCA9IHNpZ25lZE9mZnNldChvZmZIb3VyU3RyLCBvZmZNaW51dGVTdHIpO1xuICB9XG5cbiAgcmV0dXJuIFtyZXN1bHQsIG5ldyBGaXhlZE9mZnNldFpvbmUob2Zmc2V0KV07XG59XG5cbmZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwoW14oKV0qXFwpfFtcXG5cXHRdL2csIFwiIFwiKVxuICAgIC5yZXBsYWNlKC8oXFxzXFxzKykvZywgXCIgXCIpXG4gICAgLnRyaW0oKTtcbn1cblxuLy8gaHR0cCBkYXRlXG5cbmNvbnN0IHJmYzExMjMgPVxuICAgIC9eKE1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksIChcXGRcXGQpIChKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYykgKFxcZHs0fSkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgR01UJC8sXG4gIHJmYzg1MCA9XG4gICAgL14oTW9uZGF5fFR1ZXNkYXl8V2VkbmVzZGF5fFRodXJzZGF5fEZyaWRheXxTYXR1cmRheXxTdW5kYXkpLCAoXFxkXFxkKS0oSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpLShcXGRcXGQpIChcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQpIEdNVCQvLFxuICBhc2NpaSA9XG4gICAgL14oTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSAoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpICggXFxkfFxcZFxcZCkgKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCkgKFxcZHs0fSkkLztcblxuZnVuY3Rpb24gZXh0cmFjdFJGQzExMjNPcjg1MChtYXRjaCkge1xuICBjb25zdCBbLCB3ZWVrZGF5U3RyLCBkYXlTdHIsIG1vbnRoU3RyLCB5ZWFyU3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cl0gPSBtYXRjaCxcbiAgICByZXN1bHQgPSBmcm9tU3RyaW5ncyh3ZWVrZGF5U3RyLCB5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cik7XG4gIHJldHVybiBbcmVzdWx0LCBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2VdO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0QVNDSUkobWF0Y2gpIHtcbiAgY29uc3QgWywgd2Vla2RheVN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIsIHllYXJTdHJdID0gbWF0Y2gsXG4gICAgcmVzdWx0ID0gZnJvbVN0cmluZ3Mod2Vla2RheVN0ciwgeWVhclN0ciwgbW9udGhTdHIsIGRheVN0ciwgaG91clN0ciwgbWludXRlU3RyLCBzZWNvbmRTdHIpO1xuICByZXR1cm4gW3Jlc3VsdCwgRml4ZWRPZmZzZXRab25lLnV0Y0luc3RhbmNlXTtcbn1cblxuY29uc3QgaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb1ltZFJlZ2V4LCBpc29UaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3QgaXNvV2Vla1dpdGhUaW1lRXh0ZW5zaW9uUmVnZXggPSBjb21iaW5lUmVnZXhlcyhpc29XZWVrUmVnZXgsIGlzb1RpbWVFeHRlbnNpb25SZWdleCk7XG5jb25zdCBpc29PcmRpbmFsV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKGlzb09yZGluYWxSZWdleCwgaXNvVGltZUV4dGVuc2lvblJlZ2V4KTtcbmNvbnN0IGlzb1RpbWVDb21iaW5lZFJlZ2V4ID0gY29tYmluZVJlZ2V4ZXMoaXNvVGltZVJlZ2V4KTtcblxuY29uc3QgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXQgPSBjb21iaW5lRXh0cmFjdG9ycyhcbiAgZXh0cmFjdElTT1ltZCxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09XZWVrVGltZUFuZE9mZnNldCA9IGNvbWJpbmVFeHRyYWN0b3JzKFxuICBleHRyYWN0SVNPV2Vla0RhdGEsXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5jb25zdCBleHRyYWN0SVNPT3JkaW5hbERhdGVBbmRUaW1lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09PcmRpbmFsRGF0YSxcbiAgZXh0cmFjdElTT1RpbWUsXG4gIGV4dHJhY3RJU09PZmZzZXQsXG4gIGV4dHJhY3RJQU5BWm9uZVxuKTtcbmNvbnN0IGV4dHJhY3RJU09UaW1lQW5kT2Zmc2V0ID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbi8qXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0RhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbaXNvWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1ltZFRpbWVBbmRPZmZzZXRdLFxuICAgIFtpc29XZWVrV2l0aFRpbWVFeHRlbnNpb25SZWdleCwgZXh0cmFjdElTT1dlZWtUaW1lQW5kT2Zmc2V0XSxcbiAgICBbaXNvT3JkaW5hbFdpdGhUaW1lRXh0ZW5zaW9uUmVnZXgsIGV4dHJhY3RJU09PcmRpbmFsRGF0ZUFuZFRpbWVdLFxuICAgIFtpc29UaW1lQ29tYmluZWRSZWdleCwgZXh0cmFjdElTT1RpbWVBbmRPZmZzZXRdXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJGQzI4MjJEYXRlKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHByZXByb2Nlc3NSRkMyODIyKHMpLCBbcmZjMjgyMiwgZXh0cmFjdFJGQzI4MjJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSFRUUERhdGUocykge1xuICByZXR1cm4gcGFyc2UoXG4gICAgcyxcbiAgICBbcmZjMTEyMywgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW3JmYzg1MCwgZXh0cmFjdFJGQzExMjNPcjg1MF0sXG4gICAgW2FzY2lpLCBleHRyYWN0QVNDSUldXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlTT0R1cmF0aW9uKHMpIHtcbiAgcmV0dXJuIHBhcnNlKHMsIFtpc29EdXJhdGlvbiwgZXh0cmFjdElTT0R1cmF0aW9uXSk7XG59XG5cbmNvbnN0IGV4dHJhY3RJU09UaW1lT25seSA9IGNvbWJpbmVFeHRyYWN0b3JzKGV4dHJhY3RJU09UaW1lKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSVNPVGltZU9ubHkocykge1xuICByZXR1cm4gcGFyc2UocywgW2lzb1RpbWVPbmx5LCBleHRyYWN0SVNPVGltZU9ubHldKTtcbn1cblxuY29uc3Qgc3FsWW1kV2l0aFRpbWVFeHRlbnNpb25SZWdleCA9IGNvbWJpbmVSZWdleGVzKHNxbFltZFJlZ2V4LCBzcWxUaW1lRXh0ZW5zaW9uUmVnZXgpO1xuY29uc3Qgc3FsVGltZUNvbWJpbmVkUmVnZXggPSBjb21iaW5lUmVnZXhlcyhzcWxUaW1lUmVnZXgpO1xuXG5jb25zdCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lID0gY29tYmluZUV4dHJhY3RvcnMoXG4gIGV4dHJhY3RJU09UaW1lLFxuICBleHRyYWN0SVNPT2Zmc2V0LFxuICBleHRyYWN0SUFOQVpvbmVcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVNRTChzKSB7XG4gIHJldHVybiBwYXJzZShcbiAgICBzLFxuICAgIFtzcWxZbWRXaXRoVGltZUV4dGVuc2lvblJlZ2V4LCBleHRyYWN0SVNPWW1kVGltZUFuZE9mZnNldF0sXG4gICAgW3NxbFRpbWVDb21iaW5lZFJlZ2V4LCBleHRyYWN0SVNPVGltZU9mZnNldEFuZElBTkFab25lXVxuICApO1xufVxuIiwgImltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBJbnZhbGlkRHVyYXRpb25FcnJvciwgSW52YWxpZFVuaXRFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW1wbC9pbnZhbGlkLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgeyBwYXJzZUlTT0R1cmF0aW9uLCBwYXJzZUlTT1RpbWVPbmx5IH0gZnJvbSBcIi4vaW1wbC9yZWdleFBhcnNlci5qc1wiO1xuaW1wb3J0IHtcbiAgYXNOdW1iZXIsXG4gIGhhc093blByb3BlcnR5LFxuICBpc051bWJlcixcbiAgaXNVbmRlZmluZWQsXG4gIG5vcm1hbGl6ZU9iamVjdCxcbiAgcm91bmRUbyxcbn0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIER1cmF0aW9uXCI7XG5cbi8vIHVuaXQgY29udmVyc2lvbiBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBsb3dPcmRlck1hdHJpeCA9IHtcbiAgICB3ZWVrczoge1xuICAgICAgZGF5czogNyxcbiAgICAgIGhvdXJzOiA3ICogMjQsXG4gICAgICBtaW51dGVzOiA3ICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgZGF5czoge1xuICAgICAgaG91cnM6IDI0LFxuICAgICAgbWludXRlczogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIGhvdXJzOiB7IG1pbnV0ZXM6IDYwLCBzZWNvbmRzOiA2MCAqIDYwLCBtaWxsaXNlY29uZHM6IDYwICogNjAgKiAxMDAwIH0sXG4gICAgbWludXRlczogeyBzZWNvbmRzOiA2MCwgbWlsbGlzZWNvbmRzOiA2MCAqIDEwMDAgfSxcbiAgICBzZWNvbmRzOiB7IG1pbGxpc2Vjb25kczogMTAwMCB9LFxuICB9LFxuICBjYXN1YWxNYXRyaXggPSB7XG4gICAgeWVhcnM6IHtcbiAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgbW9udGhzOiAxMixcbiAgICAgIHdlZWtzOiA1MixcbiAgICAgIGRheXM6IDM2NSxcbiAgICAgIGhvdXJzOiAzNjUgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDM2NSAqIDI0ICogNjAsXG4gICAgICBzZWNvbmRzOiAzNjUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IDM2NSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBxdWFydGVyczoge1xuICAgICAgbW9udGhzOiAzLFxuICAgICAgd2Vla3M6IDEzLFxuICAgICAgZGF5czogOTEsXG4gICAgICBob3VyczogOTEgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDkxICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDkxICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiA5MSAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcbiAgICBtb250aHM6IHtcbiAgICAgIHdlZWtzOiA0LFxuICAgICAgZGF5czogMzAsXG4gICAgICBob3VyczogMzAgKiAyNCxcbiAgICAgIG1pbnV0ZXM6IDMwICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwLFxuICAgICAgbWlsbGlzZWNvbmRzOiAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDAsXG4gICAgfSxcblxuICAgIC4uLmxvd09yZGVyTWF0cml4LFxuICB9LFxuICBkYXlzSW5ZZWFyQWNjdXJhdGUgPSAxNDYwOTcuMCAvIDQwMCxcbiAgZGF5c0luTW9udGhBY2N1cmF0ZSA9IDE0NjA5Ny4wIC8gNDgwMCxcbiAgYWNjdXJhdGVNYXRyaXggPSB7XG4gICAgeWVhcnM6IHtcbiAgICAgIHF1YXJ0ZXJzOiA0LFxuICAgICAgbW9udGhzOiAxMixcbiAgICAgIHdlZWtzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyA3LFxuICAgICAgZGF5czogZGF5c0luWWVhckFjY3VyYXRlLFxuICAgICAgaG91cnM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0LFxuICAgICAgbWludXRlczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCxcbiAgICAgIG1pbGxpc2Vjb25kczogZGF5c0luWWVhckFjY3VyYXRlICogMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICB9LFxuICAgIHF1YXJ0ZXJzOiB7XG4gICAgICBtb250aHM6IDMsXG4gICAgICB3ZWVrczogZGF5c0luWWVhckFjY3VyYXRlIC8gMjgsXG4gICAgICBkYXlzOiBkYXlzSW5ZZWFyQWNjdXJhdGUgLyA0LFxuICAgICAgaG91cnM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCkgLyA0LFxuICAgICAgbWludXRlczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjApIC8gNCxcbiAgICAgIHNlY29uZHM6IChkYXlzSW5ZZWFyQWNjdXJhdGUgKiAyNCAqIDYwICogNjApIC8gNCxcbiAgICAgIG1pbGxpc2Vjb25kczogKGRheXNJblllYXJBY2N1cmF0ZSAqIDI0ICogNjAgKiA2MCAqIDEwMDApIC8gNCxcbiAgICB9LFxuICAgIG1vbnRoczoge1xuICAgICAgd2Vla3M6IGRheXNJbk1vbnRoQWNjdXJhdGUgLyA3LFxuICAgICAgZGF5czogZGF5c0luTW9udGhBY2N1cmF0ZSxcbiAgICAgIGhvdXJzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQsXG4gICAgICBtaW51dGVzOiBkYXlzSW5Nb250aEFjY3VyYXRlICogMjQgKiA2MCxcbiAgICAgIHNlY29uZHM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwICogNjAsXG4gICAgICBtaWxsaXNlY29uZHM6IGRheXNJbk1vbnRoQWNjdXJhdGUgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuICAgIH0sXG4gICAgLi4ubG93T3JkZXJNYXRyaXgsXG4gIH07XG5cbi8vIHVuaXRzIG9yZGVyZWQgYnkgc2l6ZVxuY29uc3Qgb3JkZXJlZFVuaXRzID0gW1xuICBcInllYXJzXCIsXG4gIFwicXVhcnRlcnNcIixcbiAgXCJtb250aHNcIixcbiAgXCJ3ZWVrc1wiLFxuICBcImRheXNcIixcbiAgXCJob3Vyc1wiLFxuICBcIm1pbnV0ZXNcIixcbiAgXCJzZWNvbmRzXCIsXG4gIFwibWlsbGlzZWNvbmRzXCIsXG5dO1xuXG5jb25zdCByZXZlcnNlVW5pdHMgPSBvcmRlcmVkVW5pdHMuc2xpY2UoMCkucmV2ZXJzZSgpO1xuXG4vLyBjbG9uZSByZWFsbHkgbWVhbnMgXCJjcmVhdGUgYW5vdGhlciBpbnN0YW5jZSBqdXN0IGxpa2UgdGhpcyBvbmUsIGJ1dCB3aXRoIHRoZXNlIGNoYW5nZXNcIlxuZnVuY3Rpb24gY2xvbmUoZHVyLCBhbHRzLCBjbGVhciA9IGZhbHNlKSB7XG4gIC8vIGRlZXAgbWVyZ2UgZm9yIHZhbHNcbiAgY29uc3QgY29uZiA9IHtcbiAgICB2YWx1ZXM6IGNsZWFyID8gYWx0cy52YWx1ZXMgOiB7IC4uLmR1ci52YWx1ZXMsIC4uLihhbHRzLnZhbHVlcyB8fCB7fSkgfSxcbiAgICBsb2M6IGR1ci5sb2MuY2xvbmUoYWx0cy5sb2MpLFxuICAgIGNvbnZlcnNpb25BY2N1cmFjeTogYWx0cy5jb252ZXJzaW9uQWNjdXJhY3kgfHwgZHVyLmNvbnZlcnNpb25BY2N1cmFjeSxcbiAgICBtYXRyaXg6IGFsdHMubWF0cml4IHx8IGR1ci5tYXRyaXgsXG4gIH07XG4gIHJldHVybiBuZXcgRHVyYXRpb24oY29uZik7XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uVG9NaWxsaXMobWF0cml4LCB2YWxzKSB7XG4gIGxldCBzdW0gPSB2YWxzLm1pbGxpc2Vjb25kcyA/PyAwO1xuICBmb3IgKGNvbnN0IHVuaXQgb2YgcmV2ZXJzZVVuaXRzLnNsaWNlKDEpKSB7XG4gICAgaWYgKHZhbHNbdW5pdF0pIHtcbiAgICAgIHN1bSArPSB2YWxzW3VuaXRdICogbWF0cml4W3VuaXRdW1wibWlsbGlzZWNvbmRzXCJdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufVxuXG4vLyBOQjogbXV0YXRlcyBwYXJhbWV0ZXJzXG5mdW5jdGlvbiBub3JtYWxpemVWYWx1ZXMobWF0cml4LCB2YWxzKSB7XG4gIC8vIHRoZSBsb2dpYyBiZWxvdyBhc3N1bWVzIHRoZSBvdmVyYWxsIHZhbHVlIG9mIHRoZSBkdXJhdGlvbiBpcyBwb3NpdGl2ZVxuICAvLyBpZiB0aGlzIGlzIG5vdCB0aGUgY2FzZSwgZmFjdG9yIGlzIHVzZWQgdG8gbWFrZSBpdCBzb1xuICBjb25zdCBmYWN0b3IgPSBkdXJhdGlvblRvTWlsbGlzKG1hdHJpeCwgdmFscykgPCAwID8gLTEgOiAxO1xuXG4gIG9yZGVyZWRVbml0cy5yZWR1Y2VSaWdodCgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbHNbY3VycmVudF0pKSB7XG4gICAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWwgPSB2YWxzW3ByZXZpb3VzXSAqIGZhY3RvcjtcbiAgICAgICAgY29uc3QgY29udiA9IG1hdHJpeFtjdXJyZW50XVtwcmV2aW91c107XG5cbiAgICAgICAgLy8gaWYgKHByZXZpb3VzVmFsIDwgMCk6XG4gICAgICAgIC8vIGxvd2VyIG9yZGVyIHVuaXQgaXMgbmVnYXRpdmUgKGUuZy4geyB5ZWFyczogMiwgZGF5czogLTIgfSlcbiAgICAgICAgLy8gbm9ybWFsaXplIHRoaXMgYnkgcmVkdWNpbmcgdGhlIGhpZ2hlciBvcmRlciB1bml0IGJ5IHRoZSBhcHByb3ByaWF0ZSBhbW91bnRcbiAgICAgICAgLy8gYW5kIGluY3JlYXNpbmcgdGhlIGxvd2VyIG9yZGVyIHVuaXRcbiAgICAgICAgLy8gdGhpcyBjYW4gbmV2ZXIgbWFrZSB0aGUgaGlnaGVyIG9yZGVyIHVuaXQgbmVnYXRpdmUsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBvbmx5IG9wZXJhdGVzXG4gICAgICAgIC8vIG9uIHBvc2l0aXZlIGR1cmF0aW9ucywgc28gdGhlIGFtb3VudCBvZiB0aW1lIHJlcHJlc2VudGVkIGJ5IHRoZSBsb3dlciBvcmRlciB1bml0IGNhbm5vdFxuICAgICAgICAvLyBiZSBsYXJnZXIgdGhhbiB0aGUgaGlnaGVyIG9yZGVyIHVuaXRcbiAgICAgICAgLy8gZWxzZTpcbiAgICAgICAgLy8gbG93ZXIgb3JkZXIgdW5pdCBpcyBwb3NpdGl2ZSAoZS5nLiB7IHllYXJzOiAyLCBkYXlzOiA0NTAgfSBvciB7IHllYXJzOiAtMiwgZGF5czogNDUwIH0pXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBhdHRlbXB0IHRvIGNvbnZlcnQgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBsb3dlciBvcmRlciB1bml0IGludG9cbiAgICAgICAgLy8gdGhlIGhpZ2hlciBvcmRlciBvbmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gTWF0aC5mbG9vciB0YWtlcyBjYXJlIG9mIGJvdGggb2YgdGhlc2UgY2FzZXMsIHJvdW5kaW5nIGF3YXkgZnJvbSAwXG4gICAgICAgIC8vIGlmIHByZXZpb3VzVmFsIDwgMCBpdCBtYWtlcyB0aGUgYWJzb2x1dGUgdmFsdWUgbGFyZ2VyXG4gICAgICAgIC8vIGlmIHByZXZpb3VzVmFsID49IGl0IG1ha2VzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBzbWFsbGVyXG4gICAgICAgIGNvbnN0IHJvbGxVcCA9IE1hdGguZmxvb3IocHJldmlvdXNWYWwgLyBjb252KTtcbiAgICAgICAgdmFsc1tjdXJyZW50XSArPSByb2xsVXAgKiBmYWN0b3I7XG4gICAgICAgIHZhbHNbcHJldmlvdXNdIC09IHJvbGxVcCAqIGNvbnYgKiBmYWN0b3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cbiAgfSwgbnVsbCk7XG5cbiAgLy8gdHJ5IHRvIGNvbnZlcnQgYW55IGRlY2ltYWxzIGludG8gc21hbGxlciB1bml0cyBpZiBwb3NzaWJsZVxuICAvLyBmb3IgZXhhbXBsZSBmb3IgeyB5ZWFyczogMi41LCBkYXlzOiAwLCBzZWNvbmRzOiAwIH0gd2Ugd2FudCB0byBnZXQgeyB5ZWFyczogMiwgZGF5czogMTgyLCBob3VyczogMTIgfVxuICBvcmRlcmVkVW5pdHMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgIGlmICghaXNVbmRlZmluZWQodmFsc1tjdXJyZW50XSkpIHtcbiAgICAgIGlmIChwcmV2aW91cykge1xuICAgICAgICBjb25zdCBmcmFjdGlvbiA9IHZhbHNbcHJldmlvdXNdICUgMTtcbiAgICAgICAgdmFsc1twcmV2aW91c10gLT0gZnJhY3Rpb247XG4gICAgICAgIHZhbHNbY3VycmVudF0gKz0gZnJhY3Rpb24gKiBtYXRyaXhbcHJldmlvdXNdW2N1cnJlbnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gIH0sIG51bGwpO1xufVxuXG4vLyBSZW1vdmUgYWxsIHByb3BlcnRpZXMgd2l0aCBhIHZhbHVlIG9mIDAgZnJvbSBhbiBvYmplY3RcbmZ1bmN0aW9uIHJlbW92ZVplcm9lcyh2YWxzKSB7XG4gIGNvbnN0IG5ld1ZhbHMgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFscykpIHtcbiAgICBpZiAodmFsdWUgIT09IDApIHtcbiAgICAgIG5ld1ZhbHNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3VmFscztcbn1cblxuLyoqXG4gKiBBIER1cmF0aW9uIG9iamVjdCByZXByZXNlbnRzIGEgcGVyaW9kIG9mIHRpbWUsIGxpa2UgXCIyIG1vbnRoc1wiIG9yIFwiMSBkYXksIDEgaG91clwiLiBDb25jZXB0dWFsbHksIGl0J3MganVzdCBhIG1hcCBvZiB1bml0cyB0byB0aGVpciBxdWFudGl0aWVzLCBhY2NvbXBhbmllZCBieSBzb21lIGFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBhbmQgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS4gVGhleSBjYW4gYmUgdXNlZCBvbiB0aGVpciBvd24gb3IgaW4gY29uanVuY3Rpb24gd2l0aCBvdGhlciBMdXhvbiB0eXBlczsgZm9yIGV4YW1wbGUsIHlvdSBjYW4gdXNlIHtAbGluayBEYXRlVGltZSNwbHVzfSB0byBhZGQgYSBEdXJhdGlvbiBvYmplY3QgdG8gYSBEYXRlVGltZSwgcHJvZHVjaW5nIGFub3RoZXIgRGF0ZVRpbWUuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIGNvbW1vbmx5IHVzZWQgbWV0aG9kcyBhbmQgZ2V0dGVycyBpbiBEdXJhdGlvbjpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKiBUbyBjcmVhdGUgYSBEdXJhdGlvbiwgdXNlIHtAbGluayBEdXJhdGlvbi5mcm9tTWlsbGlzfSwge0BsaW5rIER1cmF0aW9uLmZyb21PYmplY3R9LCBvciB7QGxpbmsgRHVyYXRpb24uZnJvbUlTT30uXG4gKiAqICoqVW5pdCB2YWx1ZXMqKiBTZWUgdGhlIHtAbGluayBEdXJhdGlvbiN5ZWFyc30sIHtAbGluayBEdXJhdGlvbiNtb250aHN9LCB7QGxpbmsgRHVyYXRpb24jd2Vla3N9LCB7QGxpbmsgRHVyYXRpb24jZGF5c30sIHtAbGluayBEdXJhdGlvbiNob3Vyc30sIHtAbGluayBEdXJhdGlvbiNtaW51dGVzfSwge0BsaW5rIER1cmF0aW9uI3NlY29uZHN9LCB7QGxpbmsgRHVyYXRpb24jbWlsbGlzZWNvbmRzfSBhY2Nlc3NvcnMuXG4gKiAqICoqQ29uZmlndXJhdGlvbioqIFNlZSAge0BsaW5rIER1cmF0aW9uI2xvY2FsZX0gYW5kIHtAbGluayBEdXJhdGlvbiNudW1iZXJpbmdTeXN0ZW19IGFjY2Vzc29ycy5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBuZXcgRHVyYXRpb25zIG91dCBvZiBvbGQgb25lcyB1c2Uge0BsaW5rIER1cmF0aW9uI3BsdXN9LCB7QGxpbmsgRHVyYXRpb24jbWludXN9LCB7QGxpbmsgRHVyYXRpb24jbm9ybWFsaXplfSwge0BsaW5rIER1cmF0aW9uI3NldH0sIHtAbGluayBEdXJhdGlvbiNyZWNvbmZpZ3VyZX0sIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSwgYW5kIHtAbGluayBEdXJhdGlvbiNuZWdhdGV9LlxuICogKiAqKk91dHB1dCoqIFRvIGNvbnZlcnQgdGhlIER1cmF0aW9uIGludG8gb3RoZXIgcmVwcmVzZW50YXRpb25zLCBzZWUge0BsaW5rIER1cmF0aW9uI2FzfSwge0BsaW5rIER1cmF0aW9uI3RvSVNPfSwge0BsaW5rIER1cmF0aW9uI3RvRm9ybWF0fSwgYW5kIHtAbGluayBEdXJhdGlvbiN0b0pTT059XG4gKlxuICogVGhlcmUncyBhcmUgbW9yZSBtZXRob2RzIGRvY3VtZW50ZWQgYmVsb3cuIEluIGFkZGl0aW9uLCBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBzdWJ0bGVyIHRvcGljcyBsaWtlIGludGVybmF0aW9uYWxpemF0aW9uIGFuZCB2YWxpZGl0eSwgc2VlIHRoZSBleHRlcm5hbCBkb2N1bWVudGF0aW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEdXJhdGlvbiB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3QgYWNjdXJhdGUgPSBjb25maWcuY29udmVyc2lvbkFjY3VyYWN5ID09PSBcImxvbmd0ZXJtXCIgfHwgZmFsc2U7XG4gICAgbGV0IG1hdHJpeCA9IGFjY3VyYXRlID8gYWNjdXJhdGVNYXRyaXggOiBjYXN1YWxNYXRyaXg7XG5cbiAgICBpZiAoY29uZmlnLm1hdHJpeCkge1xuICAgICAgbWF0cml4ID0gY29uZmlnLm1hdHJpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlcyA9IGNvbmZpZy52YWx1ZXM7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5sb2MgPSBjb25maWcubG9jIHx8IExvY2FsZS5jcmVhdGUoKTtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNvbnZlcnNpb25BY2N1cmFjeSA9IGFjY3VyYXRlID8gXCJsb25ndGVybVwiIDogXCJjYXN1YWxcIjtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmludmFsaWQgPSBjb25maWcuaW52YWxpZCB8fCBudWxsO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaXNMdXhvbkR1cmF0aW9uID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgRHVyYXRpb24gZnJvbSBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBvZiBtaWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMoY291bnQsIG9wdHMpIHtcbiAgICByZXR1cm4gRHVyYXRpb24uZnJvbU9iamVjdCh7IG1pbGxpc2Vjb25kczogY291bnQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRHVyYXRpb24gZnJvbSBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGgga2V5cyBsaWtlICd5ZWFycycgYW5kICdob3VycycuXG4gICAqIElmIHRoaXMgb2JqZWN0IGlzIGVtcHR5IHRoZW4gYSB6ZXJvIG1pbGxpc2Vjb25kcyBkdXJhdGlvbiBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHRoZSBvYmplY3QgdG8gY3JlYXRlIHRoZSBEYXRlVGltZSBmcm9tXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoueWVhcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5xdWFydGVyc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouZGF5c1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmhvdXJzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlc1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnNlY29uZHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRzPVtdXSAtIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoaXMgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZT0nZW4tVVMnXSAtIHRoZSBsb2NhbGUgdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBwcmVzZXQgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tYXRyaXg9T2JqZWN0XSAtIHRoZSBjdXN0b20gY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21PYmplY3Qob2JqLCBvcHRzID0ge30pIHtcbiAgICBpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgICBgRHVyYXRpb24uZnJvbU9iamVjdDogYXJndW1lbnQgZXhwZWN0ZWQgdG8gYmUgYW4gb2JqZWN0LCBnb3QgJHtcbiAgICAgICAgICBvYmogPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBvYmpcbiAgICAgICAgfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEdXJhdGlvbih7XG4gICAgICB2YWx1ZXM6IG5vcm1hbGl6ZU9iamVjdChvYmosIER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQpLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRzKSxcbiAgICAgIGNvbnZlcnNpb25BY2N1cmFjeTogb3B0cy5jb252ZXJzaW9uQWNjdXJhY3ksXG4gICAgICBtYXRyaXg6IG9wdHMubWF0cml4LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gRHVyYXRpb25MaWtlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdCB8IG51bWJlciB8IER1cmF0aW9ufSBkdXJhdGlvbkxpa2VcbiAgICogT25lIG9mOlxuICAgKiAtIG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcnMnIGFuZCAnaG91cnMnLlxuICAgKiAtIG51bWJlciByZXByZXNlbnRpbmcgbWlsbGlzZWNvbmRzXG4gICAqIC0gRHVyYXRpb24gaW5zdGFuY2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbkxpa2UpIHtcbiAgICBpZiAoaXNOdW1iZXIoZHVyYXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21NaWxsaXMoZHVyYXRpb25MaWtlKTtcbiAgICB9IGVsc2UgaWYgKER1cmF0aW9uLmlzRHVyYXRpb24oZHVyYXRpb25MaWtlKSkge1xuICAgICAgcmV0dXJuIGR1cmF0aW9uTGlrZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbkxpa2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KGR1cmF0aW9uTGlrZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYFVua25vd24gZHVyYXRpb24gYXJndW1lbnQgJHtkdXJhdGlvbkxpa2V9IG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25MaWtlfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIER1cmF0aW9uIGZyb20gYW4gSVNPIDg2MDEgZHVyYXRpb24gc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPKCdQM1k2TTFXNERUMTJIMzBNNVMnKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMywgbW9udGhzOiA2LCB3ZWVrczogMSwgZGF5czogNCwgaG91cnM6IDEyLCBtaW51dGVzOiAzMCwgc2Vjb25kczogNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU08oJ1BUMjNIJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDIzIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTTygnUDVZM00nKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogNSwgbW9udGhzOiAzIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgZnJvbUlTTyh0ZXh0LCBvcHRzKSB7XG4gICAgY29uc3QgW3BhcnNlZF0gPSBwYXJzZUlTT0R1cmF0aW9uKHRleHQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5mcm9tT2JqZWN0KHBhcnNlZCwgb3B0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBEdXJhdGlvbi5pbnZhbGlkKFwidW5wYXJzYWJsZVwiLCBgdGhlIGlucHV0IFwiJHt0ZXh0fVwiIGNhbid0IGJlIHBhcnNlZCBhcyBJU08gODYwMWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEdXJhdGlvbiBmcm9tIGFuIElTTyA4NjAxIHRpbWUgc3RyaW5nLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRleHQgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIGZvciBwYXJzaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSB0aGUgbG9jYWxlIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgcHJlc2V0IGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWF0cml4PU9iamVjdF0gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDEjVGltZXNcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbUlTT1RpbWUoJzExOjIyOjMzLjQ0NCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMjIsIHNlY29uZHM6IDMzLCBtaWxsaXNlY29uZHM6IDQ0NCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCcxMTowMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTE6MDAnKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMTEsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tSVNPVGltZSgnMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21JU09UaW1lKCdUMTEwMCcpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAxMSwgbWludXRlczogMCwgc2Vjb25kczogMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc3RhdGljIGZyb21JU09UaW1lKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcGFyc2VkXSA9IHBhcnNlSVNPVGltZU9ubHkodGV4dCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmZyb21PYmplY3QocGFyc2VkLCBvcHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQoXCJ1bnBhcnNhYmxlXCIsIGB0aGUgaW5wdXQgXCIke3RleHR9XCIgY2FuJ3QgYmUgcGFyc2VkIGFzIElTTyA4NjAxYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIER1cmF0aW9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBkYXRldGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIER1cmF0aW9uIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWREdXJhdGlvbkVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IER1cmF0aW9uKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXRpYyBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgICBjb25zdCBub3JtYWxpemVkID0ge1xuICAgICAgeWVhcjogXCJ5ZWFyc1wiLFxuICAgICAgeWVhcnM6IFwieWVhcnNcIixcbiAgICAgIHF1YXJ0ZXI6IFwicXVhcnRlcnNcIixcbiAgICAgIHF1YXJ0ZXJzOiBcInF1YXJ0ZXJzXCIsXG4gICAgICBtb250aDogXCJtb250aHNcIixcbiAgICAgIG1vbnRoczogXCJtb250aHNcIixcbiAgICAgIHdlZWs6IFwid2Vla3NcIixcbiAgICAgIHdlZWtzOiBcIndlZWtzXCIsXG4gICAgICBkYXk6IFwiZGF5c1wiLFxuICAgICAgZGF5czogXCJkYXlzXCIsXG4gICAgICBob3VyOiBcImhvdXJzXCIsXG4gICAgICBob3VyczogXCJob3Vyc1wiLFxuICAgICAgbWludXRlOiBcIm1pbnV0ZXNcIixcbiAgICAgIG1pbnV0ZXM6IFwibWludXRlc1wiLFxuICAgICAgc2Vjb25kOiBcInNlY29uZHNcIixcbiAgICAgIHNlY29uZHM6IFwic2Vjb25kc1wiLFxuICAgICAgbWlsbGlzZWNvbmQ6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgICBtaWxsaXNlY29uZHM6IFwibWlsbGlzZWNvbmRzXCIsXG4gICAgfVt1bml0ID8gdW5pdC50b0xvd2VyQ2FzZSgpIDogdW5pdF07XG5cbiAgICBpZiAoIW5vcm1hbGl6ZWQpIHRocm93IG5ldyBJbnZhbGlkVW5pdEVycm9yKHVuaXQpO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYW4gb2JqZWN0IGlzIGEgRHVyYXRpb24uIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0R1cmF0aW9uKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uRHVyYXRpb24pIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCAgdGhlIGxvY2FsZSBvZiBhIER1cmF0aW9uLCBzdWNoICdlbi1HQidcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBsb2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLmxvY2FsZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXJpbmcgc3lzdGVtIG9mIGEgRHVyYXRpb24sIHN1Y2ggJ2JlbmcnLiBUaGUgbnVtYmVyaW5nIHN5c3RlbSBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRHVyYXRpb25cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBudW1iZXJpbmdTeXN0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMubG9jLm51bWJlcmluZ1N5c3RlbSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBmb3JtYXQgc3RyaW5nLiBZb3UgbWF5IHVzZSB0aGVzZSB0b2tlbnM6XG4gICAqICogYFNgIGZvciBtaWxsaXNlY29uZHNcbiAgICogKiBgc2AgZm9yIHNlY29uZHNcbiAgICogKiBgbWAgZm9yIG1pbnV0ZXNcbiAgICogKiBgaGAgZm9yIGhvdXJzXG4gICAqICogYGRgIGZvciBkYXlzXG4gICAqICogYHdgIGZvciB3ZWVrc1xuICAgKiAqIGBNYCBmb3IgbW9udGhzXG4gICAqICogYHlgIGZvciB5ZWFyc1xuICAgKiBOb3RlczpcbiAgICogKiBBZGQgcGFkZGluZyBieSByZXBlYXRpbmcgdGhlIHRva2VuLCBlLmcuIFwieXlcIiBwYWRzIHRoZSB5ZWFycyB0byB0d28gZGlnaXRzLCBcImhoaGhcIiBwYWRzIHRoZSBob3VycyBvdXQgdG8gZm91ciBkaWdpdHNcbiAgICogKiBUb2tlbnMgY2FuIGJlIGVzY2FwZWQgYnkgd3JhcHBpbmcgd2l0aCBzaW5nbGUgcXVvdGVzLlxuICAgKiAqIFRoZSBkdXJhdGlvbiB3aWxsIGJlIGNvbnZlcnRlZCB0byB0aGUgc2V0IG9mIHVuaXRzIGluIHRoZSBmb3JtYXQgc3RyaW5nIHVzaW5nIHtAbGluayBEdXJhdGlvbiNzaGlmdFRvfSBhbmQgdGhlIER1cmF0aW9ucydzIGNvbnZlcnNpb24gYWNjdXJhY3kgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmZsb29yPXRydWVdIC0gZmxvb3IgbnVtZXJpY2FsIHZhbHVlc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5IGQgc1wiKSAvLz0+IFwiMSA2IDJcIlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEsIGRheXM6IDYsIHNlY29uZHM6IDIgfSkudG9Gb3JtYXQoXCJ5eSBkZCBzc3NcIikgLy89PiBcIjAxIDA2IDAwMlwiXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSwgZGF5czogNiwgc2Vjb25kczogMiB9KS50b0Zvcm1hdChcIk0gU1wiKSAvLz0+IFwiMTIgNTE4NDAyMDAwXCJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICAvLyByZXZlcnNlLWNvbXBhdCBzaW5jZSAxLjI7IHdlIGFsd2F5cyByb3VuZCBkb3duIG5vdywgbmV2ZXIgdXAsIGFuZCB3ZSBkbyBpdCBieSBkZWZhdWx0XG4gICAgY29uc3QgZm10T3B0cyA9IHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBmbG9vcjogb3B0cy5yb3VuZCAhPT0gZmFsc2UgJiYgb3B0cy5mbG9vciAhPT0gZmFsc2UsXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MsIGZtdE9wdHMpLmZvcm1hdER1cmF0aW9uRnJvbVN0cmluZyh0aGlzLCBmbXQpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIER1cmF0aW9uIHdpdGggYWxsIHVuaXRzIGluY2x1ZGVkLlxuICAgKiBUbyBtb2RpZnkgaXRzIGJlaGF2aW9yIHVzZSB0aGUgYGxpc3RTdHlsZWAgYW5kIGFueSBJbnRsLk51bWJlckZvcm1hdCBvcHRpb24sIHRob3VnaCBgdW5pdERpc3BsYXlgIGlzIGVzcGVjaWFsbHkgcmVsZXZhbnQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50bC9OdW1iZXJGb3JtYXRcbiAgICogQHBhcmFtIG9wdHMgLSBPbiBvcHRpb24gb2JqZWN0IHRvIG92ZXJyaWRlIHRoZSBmb3JtYXR0aW5nLiBBY2NlcHRzIHRoZSBzYW1lIGtleXMgYXMgdGhlIG9wdGlvbnMgcGFyYW1ldGVyIG9mIHRoZSBuYXRpdmUgYEludC5OdW1iZXJGb3JtYXRgIGNvbnN0cnVjdG9yLCBhcyB3ZWxsIGFzIGBsaXN0U3R5bGVgLlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiB2YXIgZHVyID0gRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDEsIGhvdXJzOiA1LCBtaW51dGVzOiA2IH0pXG4gICAqIGR1ci50b0h1bWFuKCkgLy89PiAnMSBkYXksIDUgaG91cnMsIDYgbWludXRlcydcbiAgICogZHVyLnRvSHVtYW4oeyBsaXN0U3R5bGU6IFwibG9uZ1wiIH0pIC8vPT4gJzEgZGF5LCA1IGhvdXJzLCBhbmQgNiBtaW51dGVzJ1xuICAgKiBkdXIudG9IdW1hbih7IHVuaXREaXNwbGF5OiBcInNob3J0XCIgfSkgLy89PiAnMSBkYXksIDUgaHIsIDYgbWluJ1xuICAgKiBgYGBcbiAgICovXG4gIHRvSHVtYW4ob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuXG4gICAgY29uc3QgbCA9IG9yZGVyZWRVbml0c1xuICAgICAgLm1hcCgodW5pdCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnZhbHVlc1t1bml0XTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2NcbiAgICAgICAgICAubnVtYmVyRm9ybWF0dGVyKHsgc3R5bGU6IFwidW5pdFwiLCB1bml0RGlzcGxheTogXCJsb25nXCIsIC4uLm9wdHMsIHVuaXQ6IHVuaXQuc2xpY2UoMCwgLTEpIH0pXG4gICAgICAgICAgLmZvcm1hdCh2YWwpO1xuICAgICAgfSlcbiAgICAgIC5maWx0ZXIoKG4pID0+IG4pO1xuXG4gICAgcmV0dXJuIHRoaXMubG9jXG4gICAgICAubGlzdEZvcm1hdHRlcih7IHR5cGU6IFwiY29uanVuY3Rpb25cIiwgc3R5bGU6IG9wdHMubGlzdFN0eWxlIHx8IFwibmFycm93XCIsIC4uLm9wdHMgfSlcbiAgICAgIC5mb3JtYXQobCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgb2JqZWN0IHdpdGggdGhpcyBEdXJhdGlvbidzIHZhbHVlcy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH0pLnRvT2JqZWN0KCkgLy89PiB7IHllYXJzOiAxLCBkYXlzOiA2LCBzZWNvbmRzOiAyIH1cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgdG9PYmplY3QoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB7fTtcbiAgICByZXR1cm4geyAuLi50aGlzLnZhbHVlcyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI0R1cmF0aW9uc1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDMsIHNlY29uZHM6IDQ1IH0pLnRvSVNPKCkgLy89PiAnUDNZVDQ1UydcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogNCwgc2Vjb25kczogNDUgfSkudG9JU08oKSAvLz0+ICdQNE1UNDVTJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiA1IH0pLnRvSVNPKCkgLy89PiAnUDVNJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogNSB9KS50b0lTTygpIC8vPT4gJ1BUNU0nXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDYgfSkudG9JU08oKSAvLz0+ICdQVDAuMDA2UydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU08oKSB7XG4gICAgLy8gd2UgY291bGQgdXNlIHRoZSBmb3JtYXR0ZXIsIGJ1dCB0aGlzIGlzIGFuIGVhc2llciB3YXkgdG8gZ2V0IHRoZSBtaW5pbXVtIHN0cmluZ1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gbnVsbDtcblxuICAgIGxldCBzID0gXCJQXCI7XG4gICAgaWYgKHRoaXMueWVhcnMgIT09IDApIHMgKz0gdGhpcy55ZWFycyArIFwiWVwiO1xuICAgIGlmICh0aGlzLm1vbnRocyAhPT0gMCB8fCB0aGlzLnF1YXJ0ZXJzICE9PSAwKSBzICs9IHRoaXMubW9udGhzICsgdGhpcy5xdWFydGVycyAqIDMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy53ZWVrcyAhPT0gMCkgcyArPSB0aGlzLndlZWtzICsgXCJXXCI7XG4gICAgaWYgKHRoaXMuZGF5cyAhPT0gMCkgcyArPSB0aGlzLmRheXMgKyBcIkRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCB8fCB0aGlzLm1pbnV0ZXMgIT09IDAgfHwgdGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgcyArPSBcIlRcIjtcbiAgICBpZiAodGhpcy5ob3VycyAhPT0gMCkgcyArPSB0aGlzLmhvdXJzICsgXCJIXCI7XG4gICAgaWYgKHRoaXMubWludXRlcyAhPT0gMCkgcyArPSB0aGlzLm1pbnV0ZXMgKyBcIk1cIjtcbiAgICBpZiAodGhpcy5zZWNvbmRzICE9PSAwIHx8IHRoaXMubWlsbGlzZWNvbmRzICE9PSAwKVxuICAgICAgLy8gdGhpcyB3aWxsIGhhbmRsZSBcImZsb2F0aW5nIHBvaW50IG1hZG5lc3NcIiBieSByZW1vdmluZyBleHRyYSBkZWNpbWFsIHBsYWNlc1xuICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg4MDA0L2lzLWZsb2F0aW5nLXBvaW50LW1hdGgtYnJva2VuXG4gICAgICBzICs9IHJvdW5kVG8odGhpcy5zZWNvbmRzICsgdGhpcy5taWxsaXNlY29uZHMgLyAxMDAwLCAzKSArIFwiU1wiO1xuICAgIGlmIChzID09PSBcIlBcIikgcyArPSBcIlQwU1wiO1xuICAgIHJldHVybiBzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIER1cmF0aW9uLCBmb3JtYXR0ZWQgYXMgYSB0aW1lIG9mIGRheS5cbiAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgZHVyYXRpb24gaXMgaW52YWxpZCwgbmVnYXRpdmUsIG9yIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAyNCBob3Vycy5cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVByZWZpeD1mYWxzZV0gLSBpbmNsdWRlIHRoZSBgVGAgcHJlZml4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5mb3JtYXQ9J2V4dGVuZGVkJ10gLSBjaG9vc2UgYmV0d2VlbiB0aGUgYmFzaWMgYW5kIGV4dGVuZGVkIGZvcm1hdFxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSgpIC8vPT4gJzExOjAwOjAwLjAwMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc01pbGxpc2Vjb25kczogdHJ1ZSB9KSAvLz0+ICcxMTowMDowMCdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxMSB9KS50b0lTT1RpbWUoeyBzdXBwcmVzc1NlY29uZHM6IHRydWUgfSkgLy89PiAnMTE6MDAnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMTEgfSkudG9JU09UaW1lKHsgaW5jbHVkZVByZWZpeDogdHJ1ZSB9KSAvLz0+ICdUMTE6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDExIH0pLnRvSVNPVGltZSh7IGZvcm1hdDogJ2Jhc2ljJyB9KSAvLz0+ICcxMTAwMDAuMDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTT1RpbWUob3B0cyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgY29uc3QgbWlsbGlzID0gdGhpcy50b01pbGxpcygpO1xuICAgIGlmIChtaWxsaXMgPCAwIHx8IG1pbGxpcyA+PSA4NjQwMDAwMCkgcmV0dXJuIG51bGw7XG5cbiAgICBvcHRzID0ge1xuICAgICAgc3VwcHJlc3NNaWxsaXNlY29uZHM6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NTZWNvbmRzOiBmYWxzZSxcbiAgICAgIGluY2x1ZGVQcmVmaXg6IGZhbHNlLFxuICAgICAgZm9ybWF0OiBcImV4dGVuZGVkXCIsXG4gICAgICAuLi5vcHRzLFxuICAgICAgaW5jbHVkZU9mZnNldDogZmFsc2UsXG4gICAgfTtcblxuICAgIGNvbnN0IGRhdGVUaW1lID0gRGF0ZVRpbWUuZnJvbU1pbGxpcyhtaWxsaXMsIHsgem9uZTogXCJVVENcIiB9KTtcbiAgICByZXR1cm4gZGF0ZVRpbWUudG9JU09UaW1lKG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIEpTT04uXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0lTTygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEdXJhdGlvbiBhcHByb3ByaWF0ZSBmb3IgdXNlIGluIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9JU08oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG1pbGxpc2Vjb25kcyB2YWx1ZSBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB0b01pbGxpcygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIE5hTjtcblxuICAgIHJldHVybiBkdXJhdGlvblRvTWlsbGlzKHRoaXMubWF0cml4LCB0aGlzLnZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBtaWxsaXNlY29uZHMgdmFsdWUgb2YgdGhpcyBEdXJhdGlvbi4gQWxpYXMgb2Yge0BsaW5rIHRvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIER1cmF0aW9uIGxvbmdlciBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIGFkZC4gRWl0aGVyIGEgTHV4b24gRHVyYXRpb24sIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgdGhlIG9iamVjdCBhcmd1bWVudCB0byBEdXJhdGlvbi5mcm9tT2JqZWN0KClcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBwbHVzKGR1cmF0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShkdXIudmFsdWVzLCBrKSB8fCBoYXNPd25Qcm9wZXJ0eSh0aGlzLnZhbHVlcywgaykpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gZHVyLmdldChrKSArIHRoaXMuZ2V0KGspO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogcmVzdWx0IH0sIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgdGhpcyBEdXJhdGlvbiBzaG9ydGVyIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIFRoZSBhbW91bnQgdG8gc3VidHJhY3QuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgbWludXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG5cbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcy5wbHVzKGR1ci5uZWdhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhpcyBEdXJhdGlvbiBieSB0aGUgc3BlY2lmaWVkIGFtb3VudC4gUmV0dXJuIGEgbmV3bHktY29uc3RydWN0ZWQgRHVyYXRpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuIC0gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdW5pdC4gQXJpdHkgaXMgMSBvciAyOiB0aGUgdmFsdWUgb2YgdGhlIHVuaXQgYW5kLCBvcHRpb25hbGx5LCB0aGUgdW5pdCBuYW1lLiBNdXN0IHJldHVybiBhIG51bWJlci5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cyh4ID0+IHggKiAyKSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDYwIH1cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBtaW51dGVzOiAzMCB9KS5tYXBVbml0cygoeCwgdSkgPT4gdSA9PT0gXCJob3Vyc1wiID8geCAqIDIgOiB4KSAvLz0+IHsgaG91cnM6IDIsIG1pbnV0ZXM6IDMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBtYXBVbml0cyhmbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy52YWx1ZXMpKSB7XG4gICAgICByZXN1bHRba10gPSBhc051bWJlcihmbih0aGlzLnZhbHVlc1trXSwgaykpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHJlc3VsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZhbHVlIG9mIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gYSB1bml0IHN1Y2ggYXMgJ21pbnV0ZScgb3IgJ2RheSdcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ3llYXJzJykgLy89PiAyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAyLCBkYXlzOiAzfSkuZ2V0KCdtb250aHMnKSAvLz0+IDBcbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7eWVhcnM6IDIsIGRheXM6IDN9KS5nZXQoJ2RheXMnKSAvLz0+IDNcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0KHVuaXQpIHtcbiAgICByZXR1cm4gdGhpc1tEdXJhdGlvbi5ub3JtYWxpemVVbml0KHVuaXQpXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHVuaXRzLiBSZXR1cm4gYSBuZXdseS1jb25zdHJ1Y3RlZCBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlcyAtIGEgbWFwcGluZyBvZiB1bml0cyB0byBudW1iZXJzXG4gICAqIEBleGFtcGxlIGR1ci5zZXQoeyB5ZWFyczogMjAxNyB9KVxuICAgKiBAZXhhbXBsZSBkdXIuc2V0KHsgaG91cnM6IDgsIG1pbnV0ZXM6IDMwIH0pXG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgc2V0KHZhbHVlcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcblxuICAgIGNvbnN0IG1peGVkID0geyAuLi50aGlzLnZhbHVlcywgLi4ubm9ybWFsaXplT2JqZWN0KHZhbHVlcywgRHVyYXRpb24ubm9ybWFsaXplVW5pdCkgfTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IG1peGVkIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZSBhbmQvb3IgbnVtYmVyaW5nU3lzdGVtLiAgUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIER1cmF0aW9uLlxuICAgKiBAZXhhbXBsZSBkdXIucmVjb25maWd1cmUoeyBsb2NhbGU6ICdlbi1HQicgfSlcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICByZWNvbmZpZ3VyZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBjb252ZXJzaW9uQWNjdXJhY3ksIG1hdHJpeCB9ID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtIH0pO1xuICAgIGNvbnN0IG9wdHMgPSB7IGxvYywgbWF0cml4LCBjb252ZXJzaW9uQWNjdXJhY3kgfTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGR1cmF0aW9uIGluIHRoZSBzcGVjaWZpZWQgdW5pdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBhIHVuaXQgc3VjaCBhcyAnbWludXRlcycgb3IgJ2RheXMnXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe3llYXJzOiAxfSkuYXMoJ2RheXMnKSAvLz0+IDM2NVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHt5ZWFyczogMX0pLmFzKCdtb250aHMnKSAvLz0+IDEyXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3Qoe2hvdXJzOiA2MH0pLmFzKCdkYXlzJykgLy89PiAyLjVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgYXModW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnNoaWZ0VG8odW5pdCkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZSB0aGlzIER1cmF0aW9uIHRvIGl0cyBjYW5vbmljYWwgcmVwcmVzZW50YXRpb24gaW4gaXRzIGN1cnJlbnQgdW5pdHMuXG4gICAqIEFzc3VtaW5nIHRoZSBvdmVyYWxsIHZhbHVlIG9mIHRoZSBEdXJhdGlvbiBpcyBwb3NpdGl2ZSwgdGhpcyBtZWFuczpcbiAgICogLSBleGNlc3NpdmUgdmFsdWVzIGZvciBsb3dlci1vcmRlciB1bml0cyBhcmUgY29udmVydGVkIHRvIGhpZ2hlci1vcmRlciB1bml0cyAoaWYgcG9zc2libGUsIHNlZSBmaXJzdCBhbmQgc2Vjb25kIGV4YW1wbGUpXG4gICAqIC0gbmVnYXRpdmUgbG93ZXItb3JkZXIgdW5pdHMgYXJlIGNvbnZlcnRlZCB0byBoaWdoZXIgb3JkZXIgdW5pdHMgKHRoZXJlIG11c3QgYmUgc3VjaCBhIGhpZ2hlciBvcmRlciB1bml0LCBvdGhlcndpc2VcbiAgICogICB0aGUgb3ZlcmFsbCB2YWx1ZSB3b3VsZCBiZSBuZWdhdGl2ZSwgc2VlIHNlY29uZCBleGFtcGxlKVxuICAgKiAtIGZyYWN0aW9uYWwgdmFsdWVzIGZvciBoaWdoZXItb3JkZXIgdW5pdHMgYXJlIGNvbnZlcnRlZCB0byBsb3dlci1vcmRlciB1bml0cyAoaWYgcG9zc2libGUsIHNlZSBmb3VydGggZXhhbXBsZSlcbiAgICpcbiAgICogSWYgdGhlIG92ZXJhbGwgdmFsdWUgaXMgbmVnYXRpdmUsIHRoZSByZXN1bHQgb2YgdGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgdGhpcy5uZWdhdGUoKS5ub3JtYWxpemUoKS5uZWdhdGUoKWAuXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMiwgZGF5czogNTAwMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMTUsIGRheXM6IDI1NSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBkYXlzOiA1MDAwIH0pLm5vcm1hbGl6ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGRheXM6IDUwMDAgfVxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEyLCBtaW51dGVzOiAtNDUgfSkubm9ybWFsaXplKCkudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDExLCBtaW51dGVzOiAxNSB9XG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMi41LCBkYXlzOiAwLCBob3VyczogMCB9KS5ub3JtYWxpemUoKS50b09iamVjdCgpIC8vPT4geyB5ZWFyczogMiwgZGF5czogMTgyLCBob3VyczogMTIgfVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIG5vcm1hbGl6ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHRoaXMudG9PYmplY3QoKTtcbiAgICBub3JtYWxpemVWYWx1ZXModGhpcy5tYXRyaXgsIHZhbHMpO1xuICAgIHJldHVybiBjbG9uZSh0aGlzLCB7IHZhbHVlczogdmFscyB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNjYWxlIHVuaXRzIHRvIGl0cyBsYXJnZXN0IHJlcHJlc2VudGF0aW9uXG4gICAqIEBleGFtcGxlIER1cmF0aW9uLmZyb21PYmplY3QoeyBtaWxsaXNlY29uZHM6IDkwMDAwIH0pLnJlc2NhbGUoKS50b09iamVjdCgpIC8vPT4geyBtaW51dGVzOiAxLCBzZWNvbmRzOiAzMCB9XG4gICAqIEByZXR1cm4ge0R1cmF0aW9ufVxuICAgKi9cbiAgcmVzY2FsZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdmFscyA9IHJlbW92ZVplcm9lcyh0aGlzLm5vcm1hbGl6ZSgpLnNoaWZ0VG9BbGwoKS50b09iamVjdCgpKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IHZhbHMgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIER1cmF0aW9uIGludG8gaXRzIHJlcHJlc2VudGF0aW9uIGluIGEgZGlmZmVyZW50IHNldCBvZiB1bml0cy5cbiAgICogQGV4YW1wbGUgRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxLCBzZWNvbmRzOiAzMCB9KS5zaGlmdFRvKCdtaW51dGVzJywgJ21pbGxpc2Vjb25kcycpLnRvT2JqZWN0KCkgLy89PiB7IG1pbnV0ZXM6IDYwLCBtaWxsaXNlY29uZHM6IDMwMDAwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBzaGlmdFRvKC4uLnVuaXRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKHVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdW5pdHMgPSB1bml0cy5tYXAoKHUpID0+IER1cmF0aW9uLm5vcm1hbGl6ZVVuaXQodSkpO1xuXG4gICAgY29uc3QgYnVpbHQgPSB7fSxcbiAgICAgIGFjY3VtdWxhdGVkID0ge30sXG4gICAgICB2YWxzID0gdGhpcy50b09iamVjdCgpO1xuICAgIGxldCBsYXN0VW5pdDtcblxuICAgIGZvciAoY29uc3QgayBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICh1bml0cy5pbmRleE9mKGspID49IDApIHtcbiAgICAgICAgbGFzdFVuaXQgPSBrO1xuXG4gICAgICAgIGxldCBvd24gPSAwO1xuXG4gICAgICAgIC8vIGFueXRoaW5nIHdlIGhhdmVuJ3QgYm9pbGVkIGRvd24geWV0IHNob3VsZCBnZXQgYm9pbGVkIHRvIHRoaXMgdW5pdFxuICAgICAgICBmb3IgKGNvbnN0IGFrIGluIGFjY3VtdWxhdGVkKSB7XG4gICAgICAgICAgb3duICs9IHRoaXMubWF0cml4W2FrXVtrXSAqIGFjY3VtdWxhdGVkW2FrXTtcbiAgICAgICAgICBhY2N1bXVsYXRlZFtha10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGx1cyBhbnl0aGluZyB0aGF0J3MgYWxyZWFkeSBpbiB0aGlzIHVuaXRcbiAgICAgICAgaWYgKGlzTnVtYmVyKHZhbHNba10pKSB7XG4gICAgICAgICAgb3duICs9IHZhbHNba107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvbmx5IGtlZXAgdGhlIGludGVnZXIgcGFydCBmb3Igbm93IGluIHRoZSBob3BlcyBvZiBwdXR0aW5nIGFueSBkZWNpbWFsIHBhcnRcbiAgICAgICAgLy8gaW50byBhIHNtYWxsZXIgdW5pdCBsYXRlclxuICAgICAgICBjb25zdCBpID0gTWF0aC50cnVuYyhvd24pO1xuICAgICAgICBidWlsdFtrXSA9IGk7XG4gICAgICAgIGFjY3VtdWxhdGVkW2tdID0gKG93biAqIDEwMDAgLSBpICogMTAwMCkgLyAxMDAwO1xuXG4gICAgICAgIC8vIG90aGVyd2lzZSwga2VlcCBpdCBpbiB0aGUgd2luZ3MgdG8gYm9pbCBpdCBsYXRlclxuICAgICAgfSBlbHNlIGlmIChpc051bWJlcih2YWxzW2tdKSkge1xuICAgICAgICBhY2N1bXVsYXRlZFtrXSA9IHZhbHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYW55dGhpbmcgbGVmdG92ZXIgYmVjb21lcyB0aGUgZGVjaW1hbCBmb3IgdGhlIGxhc3QgdW5pdFxuICAgIC8vIGxhc3RVbml0IG11c3QgYmUgZGVmaW5lZCBzaW5jZSB1bml0cyBpcyBub3QgZW1wdHlcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhY2N1bXVsYXRlZCkge1xuICAgICAgaWYgKGFjY3VtdWxhdGVkW2tleV0gIT09IDApIHtcbiAgICAgICAgYnVpbHRbbGFzdFVuaXRdICs9XG4gICAgICAgICAga2V5ID09PSBsYXN0VW5pdCA/IGFjY3VtdWxhdGVkW2tleV0gOiBhY2N1bXVsYXRlZFtrZXldIC8gdGhpcy5tYXRyaXhbbGFzdFVuaXRdW2tleV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9ybWFsaXplVmFsdWVzKHRoaXMubWF0cml4LCBidWlsdCk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdmFsdWVzOiBidWlsdCB9LCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaGlmdCB0aGlzIER1cmF0aW9uIHRvIGFsbCBhdmFpbGFibGUgdW5pdHMuXG4gICAqIFNhbWUgYXMgc2hpZnRUbyhcInllYXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiKVxuICAgKiBAcmV0dXJuIHtEdXJhdGlvbn1cbiAgICovXG4gIHNoaWZ0VG9BbGwoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiB0aGlzLnNoaWZ0VG8oXG4gICAgICBcInllYXJzXCIsXG4gICAgICBcIm1vbnRoc1wiLFxuICAgICAgXCJ3ZWVrc1wiLFxuICAgICAgXCJkYXlzXCIsXG4gICAgICBcImhvdXJzXCIsXG4gICAgICBcIm1pbnV0ZXNcIixcbiAgICAgIFwic2Vjb25kc1wiLFxuICAgICAgXCJtaWxsaXNlY29uZHNcIlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZWdhdGl2ZSBvZiB0aGlzIER1cmF0aW9uLlxuICAgKiBAZXhhbXBsZSBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEsIHNlY29uZHM6IDMwIH0pLm5lZ2F0ZSgpLnRvT2JqZWN0KCkgLy89PiB7IGhvdXJzOiAtMSwgc2Vjb25kczogLTMwIH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBuZWdhdGUoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IG5lZ2F0ZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXModGhpcy52YWx1ZXMpKSB7XG4gICAgICBuZWdhdGVkW2tdID0gdGhpcy52YWx1ZXNba10gPT09IDAgPyAwIDogLXRoaXMudmFsdWVzW2tdO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyB2YWx1ZXM6IG5lZ2F0ZWQgfSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB5ZWFycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMueWVhcnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1YXJ0ZXJzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHF1YXJ0ZXJzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5xdWFydGVycyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9udGhzLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1vbnRocygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubW9udGhzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB3ZWVrc1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy53ZWVrcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5cy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnZhbHVlcy5kYXlzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBob3Vycy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBob3VycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMuaG91cnMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbnV0ZXMuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbWludXRlcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWludXRlcyB8fCAwIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vjb25kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMudmFsdWVzLnNlY29uZHMgfHwgMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG1pbGxpc2Vjb25kcy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbGxpc2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy52YWx1ZXMubWlsbGlzZWNvbmRzIHx8IDAgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBEdXJhdGlvbiBpcyBpbnZhbGlkLiBJbnZhbGlkIGR1cmF0aW9ucyBhcmUgcmV0dXJuZWQgYnkgZGlmZiBvcGVyYXRpb25zXG4gICAqIG9uIGludmFsaWQgRGF0ZVRpbWVzIG9yIEludGVydmFscy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPT09IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBlcnJvciBjb2RlIGlmIHRoaXMgRHVyYXRpb24gYmVjYW1lIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIER1cmF0aW9uIGlzIHZhbGlkXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmludmFsaWQgPyB0aGlzLmludmFsaWQucmVhc29uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGV4cGxhbmF0aW9uIG9mIHdoeSB0aGlzIER1cmF0aW9uIGJlY2FtZSBpbnZhbGlkLCBvciBudWxsIGlmIHRoZSBEdXJhdGlvbiBpcyB2YWxpZFxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGludmFsaWRFeHBsYW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLmV4cGxhbmF0aW9uIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFcXVhbGl0eSBjaGVja1xuICAgKiBUd28gRHVyYXRpb25zIGFyZSBlcXVhbCBpZmYgdGhleSBoYXZlIHRoZSBzYW1lIHVuaXRzIGFuZCB0aGUgc2FtZSB2YWx1ZXMgZm9yIGVhY2ggdW5pdC5cbiAgICogQHBhcmFtIHtEdXJhdGlvbn0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxKHYxLCB2Mikge1xuICAgICAgLy8gQ29uc2lkZXIgMCBhbmQgdW5kZWZpbmVkIGFzIGVxdWFsXG4gICAgICBpZiAodjEgPT09IHVuZGVmaW5lZCB8fCB2MSA9PT0gMCkgcmV0dXJuIHYyID09PSB1bmRlZmluZWQgfHwgdjIgPT09IDA7XG4gICAgICByZXR1cm4gdjEgPT09IHYyO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdSBvZiBvcmRlcmVkVW5pdHMpIHtcbiAgICAgIGlmICghZXEodGhpcy52YWx1ZXNbdV0sIG90aGVyLnZhbHVlc1t1XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRlVGltZSwgeyBmcmllbmRseURhdGVUaW1lIH0gZnJvbSBcIi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW52YWxpZEludGVydmFsRXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuaW1wb3J0IEZvcm1hdHRlciBmcm9tIFwiLi9pbXBsL2Zvcm1hdHRlci5qc1wiO1xuaW1wb3J0ICogYXMgRm9ybWF0cyBmcm9tIFwiLi9pbXBsL2Zvcm1hdHMuanNcIjtcblxuY29uc3QgSU5WQUxJRCA9IFwiSW52YWxpZCBJbnRlcnZhbFwiO1xuXG4vLyBjaGVja3MgaWYgdGhlIHN0YXJ0IGlzIGVxdWFsIHRvIG9yIGJlZm9yZSB0aGUgZW5kXG5mdW5jdGlvbiB2YWxpZGF0ZVN0YXJ0RW5kKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCB8fCAhc3RhcnQuaXNWYWxpZCkge1xuICAgIHJldHVybiBJbnRlcnZhbC5pbnZhbGlkKFwibWlzc2luZyBvciBpbnZhbGlkIHN0YXJ0XCIpO1xuICB9IGVsc2UgaWYgKCFlbmQgfHwgIWVuZC5pc1ZhbGlkKSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXCJtaXNzaW5nIG9yIGludmFsaWQgZW5kXCIpO1xuICB9IGVsc2UgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgcmV0dXJuIEludGVydmFsLmludmFsaWQoXG4gICAgICBcImVuZCBiZWZvcmUgc3RhcnRcIixcbiAgICAgIGBUaGUgZW5kIG9mIGFuIGludGVydmFsIG11c3QgYmUgYWZ0ZXIgaXRzIHN0YXJ0LCBidXQgeW91IGhhZCBzdGFydD0ke3N0YXJ0LnRvSVNPKCl9IGFuZCBlbmQ9JHtlbmQudG9JU08oKX1gXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEFuIEludGVydmFsIG9iamVjdCByZXByZXNlbnRzIGEgaGFsZi1vcGVuIGludGVydmFsIG9mIHRpbWUsIHdoZXJlIGVhY2ggZW5kcG9pbnQgaXMgYSB7QGxpbmsgRGF0ZVRpbWV9LiBDb25jZXB0dWFsbHksIGl0J3MgYSBjb250YWluZXIgZm9yIHRob3NlIHR3byBlbmRwb2ludHMsIGFjY29tcGFuaWVkIGJ5IG1ldGhvZHMgZm9yIGNyZWF0aW5nLCBwYXJzaW5nLCBpbnRlcnJvZ2F0aW5nLCBjb21wYXJpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBIZXJlIGlzIGEgYnJpZWYgb3ZlcnZpZXcgb2YgdGhlIG1vc3QgY29tbW9ubHkgdXNlZCBtZXRob2RzIGFuZCBnZXR0ZXJzIGluIEludGVydmFsOlxuICpcbiAqICogKipDcmVhdGlvbioqIFRvIGNyZWF0ZSBhbiBJbnRlcnZhbCwgdXNlIHtAbGluayBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzfSwge0BsaW5rIEludGVydmFsLmFmdGVyfSwge0BsaW5rIEludGVydmFsLmJlZm9yZX0sIG9yIHtAbGluayBJbnRlcnZhbC5mcm9tSVNPfS5cbiAqICogKipBY2Nlc3NvcnMqKiBVc2Uge0BsaW5rIEludGVydmFsI3N0YXJ0fSBhbmQge0BsaW5rIEludGVydmFsI2VuZH0gdG8gZ2V0IHRoZSBzdGFydCBhbmQgZW5kLlxuICogKiAqKkludGVycm9nYXRpb24qKiBUbyBhbmFseXplIHRoZSBJbnRlcnZhbCwgdXNlIHtAbGluayBJbnRlcnZhbCNjb3VudH0sIHtAbGluayBJbnRlcnZhbCNsZW5ndGh9LCB7QGxpbmsgSW50ZXJ2YWwjaGFzU2FtZX0sIHtAbGluayBJbnRlcnZhbCNjb250YWluc30sIHtAbGluayBJbnRlcnZhbCNpc0FmdGVyfSwgb3Ige0BsaW5rIEludGVydmFsI2lzQmVmb3JlfS5cbiAqICogKipUcmFuc2Zvcm1hdGlvbioqIFRvIGNyZWF0ZSBvdGhlciBJbnRlcnZhbHMgb3V0IG9mIHRoaXMgb25lLCB1c2Uge0BsaW5rIEludGVydmFsI3NldH0sIHtAbGluayBJbnRlcnZhbCNzcGxpdEF0fSwge0BsaW5rIEludGVydmFsI3NwbGl0Qnl9LCB7QGxpbmsgSW50ZXJ2YWwjZGl2aWRlRXF1YWxseX0sIHtAbGluayBJbnRlcnZhbC5tZXJnZX0sIHtAbGluayBJbnRlcnZhbC54b3J9LCB7QGxpbmsgSW50ZXJ2YWwjdW5pb259LCB7QGxpbmsgSW50ZXJ2YWwjaW50ZXJzZWN0aW9ufSwgb3Ige0BsaW5rIEludGVydmFsI2RpZmZlcmVuY2V9LlxuICogKiAqKkNvbXBhcmlzb24qKiBUbyBjb21wYXJlIHRoaXMgSW50ZXJ2YWwgdG8gYW5vdGhlciBvbmUsIHVzZSB7QGxpbmsgSW50ZXJ2YWwjZXF1YWxzfSwge0BsaW5rIEludGVydmFsI292ZXJsYXBzfSwge0BsaW5rIEludGVydmFsI2FidXRzU3RhcnR9LCB7QGxpbmsgSW50ZXJ2YWwjYWJ1dHNFbmR9LCB7QGxpbmsgSW50ZXJ2YWwjZW5ndWxmc31cbiAqICogKipPdXRwdXQqKiBUbyBjb252ZXJ0IHRoZSBJbnRlcnZhbCBpbnRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgc2VlIHtAbGluayBJbnRlcnZhbCN0b1N0cmluZ30sIHtAbGluayBJbnRlcnZhbCN0b0xvY2FsZVN0cmluZ30sIHtAbGluayBJbnRlcnZhbCN0b0lTT30sIHtAbGluayBJbnRlcnZhbCN0b0lTT0RhdGV9LCB7QGxpbmsgSW50ZXJ2YWwjdG9JU09UaW1lfSwge0BsaW5rIEludGVydmFsI3RvRm9ybWF0fSwgYW5kIHtAbGluayBJbnRlcnZhbCN0b0R1cmF0aW9ufS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50ZXJ2YWwge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucyA9IGNvbmZpZy5zdGFydDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmUgPSBjb25maWcuZW5kO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuaW52YWxpZCA9IGNvbmZpZy5pbnZhbGlkIHx8IG51bGw7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uSW50ZXJ2YWwgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBJbnRlcnZhbCBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbZXhwbGFuYXRpb249bnVsbF0gLSBsb25nZXIgZXhwbGFuYXRpb24sIG1heSBpbmNsdWRlIHBhcmFtZXRlcnMgYW5kIG90aGVyIHVzZWZ1bCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7SW50ZXJ2YWx9XG4gICAqL1xuICBzdGF0aWMgaW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uID0gbnVsbCkge1xuICAgIGlmICghcmVhc29uKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXCJuZWVkIHRvIHNwZWNpZnkgYSByZWFzb24gdGhlIEludGVydmFsIGlzIGludmFsaWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW52YWxpZCA9IHJlYXNvbiBpbnN0YW5jZW9mIEludmFsaWQgPyByZWFzb24gOiBuZXcgSW52YWxpZChyZWFzb24sIGV4cGxhbmF0aW9uKTtcblxuICAgIGlmIChTZXR0aW5ncy50aHJvd09uSW52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRJbnRlcnZhbEVycm9yKGludmFsaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IEludGVydmFsKHsgaW52YWxpZCB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYSBzdGFydCBEYXRlVGltZSBhbmQgYW4gZW5kIERhdGVUaW1lLiBJbmNsdXNpdmUgb2YgdGhlIHN0YXJ0IGJ1dCBub3QgdGhlIGVuZC5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gc3RhcnRcbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gZW5kXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGZyb21EYXRlVGltZXMoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGJ1aWx0U3RhcnQgPSBmcmllbmRseURhdGVUaW1lKHN0YXJ0KSxcbiAgICAgIGJ1aWx0RW5kID0gZnJpZW5kbHlEYXRlVGltZShlbmQpO1xuXG4gICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IHZhbGlkYXRlU3RhcnRFbmQoYnVpbHRTdGFydCwgYnVpbHRFbmQpO1xuXG4gICAgaWYgKHZhbGlkYXRlRXJyb3IgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnZhbCh7XG4gICAgICAgIHN0YXJ0OiBidWlsdFN0YXJ0LFxuICAgICAgICBlbmQ6IGJ1aWx0RW5kLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZUVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gSW50ZXJ2YWwgZnJvbSBhIHN0YXJ0IERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCB0by5cbiAgICogQHBhcmFtIHtEYXRlVGltZXxEYXRlfE9iamVjdH0gc3RhcnRcbiAgICogQHBhcmFtIHtEdXJhdGlvbnxPYmplY3R8bnVtYmVyfSBkdXJhdGlvbiAtIHRoZSBsZW5ndGggb2YgdGhlIEludGVydmFsLlxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBhZnRlcihzdGFydCwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKSxcbiAgICAgIGR0ID0gZnJpZW5kbHlEYXRlVGltZShzdGFydCk7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQsIGR0LnBsdXMoZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYW4gZW5kIERhdGVUaW1lIGFuZCBhIER1cmF0aW9uIHRvIGV4dGVuZCBiYWNrd2FyZHMgdG8uXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV8RGF0ZXxPYmplY3R9IGVuZFxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gdGhlIGxlbmd0aCBvZiB0aGUgSW50ZXJ2YWwuXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc3RhdGljIGJlZm9yZShlbmQsIGR1cmF0aW9uKSB7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbiksXG4gICAgICBkdCA9IGZyaWVuZGx5RGF0ZVRpbWUoZW5kKTtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdC5taW51cyhkdXIpLCBkdCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEludGVydmFsIGZyb20gYW4gSVNPIDg2MDEgc3RyaW5nLlxuICAgKiBBY2NlcHRzIGA8c3RhcnQ+LzxlbmQ+YCwgYDxzdGFydD4vPGR1cmF0aW9uPmAsIGFuZCBgPGR1cmF0aW9uPi88ZW5kPmAgZm9ybWF0cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSVNPIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHNdIC0gb3B0aW9ucyB0byBwYXNzIHtAbGluayBEYXRlVGltZSNmcm9tSVNPfSBhbmQgb3B0aW9uYWxseSB7QGxpbmsgRHVyYXRpb24jZnJvbUlTT31cbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSNUaW1lX2ludGVydmFsc1xuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHN0YXRpYyBmcm9tSVNPKHRleHQsIG9wdHMpIHtcbiAgICBjb25zdCBbcywgZV0gPSAodGV4dCB8fCBcIlwiKS5zcGxpdChcIi9cIiwgMik7XG4gICAgaWYgKHMgJiYgZSkge1xuICAgICAgbGV0IHN0YXJ0LCBzdGFydElzVmFsaWQ7XG4gICAgICB0cnkge1xuICAgICAgICBzdGFydCA9IERhdGVUaW1lLmZyb21JU08ocywgb3B0cyk7XG4gICAgICAgIHN0YXJ0SXNWYWxpZCA9IHN0YXJ0LmlzVmFsaWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHN0YXJ0SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBsZXQgZW5kLCBlbmRJc1ZhbGlkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhlLCBvcHRzKTtcbiAgICAgICAgZW5kSXNWYWxpZCA9IGVuZC5pc1ZhbGlkO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlbmRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydElzVmFsaWQgJiYgZW5kSXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhzdGFydCwgZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0SXNWYWxpZCkge1xuICAgICAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tSVNPKGUsIG9wdHMpO1xuICAgICAgICBpZiAoZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYWZ0ZXIoc3RhcnQsIGR1cik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kSXNWYWxpZCkge1xuICAgICAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tSVNPKHMsIG9wdHMpO1xuICAgICAgICBpZiAoZHVyLmlzVmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gSW50ZXJ2YWwuYmVmb3JlKGVuZCwgZHVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSW50ZXJ2YWwuaW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgSVNPIDg2MDFgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBvYmplY3QgaXMgYW4gSW50ZXJ2YWwuIFdvcmtzIGFjcm9zcyBjb250ZXh0IGJvdW5kYXJpZXNcbiAgICogQHBhcmFtIHtvYmplY3R9IG9cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0ludGVydmFsKG8pIHtcbiAgICByZXR1cm4gKG8gJiYgby5pc0x1eG9uSW50ZXJ2YWwpIHx8IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0YXJ0IG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMucyA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZW5kIG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAdHlwZSB7RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgZW5kKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmUgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGlzIEludGVydmFsJ3MgZW5kIGlzIGF0IGxlYXN0IGl0cyBzdGFydCwgbWVhbmluZyB0aGF0IHRoZSBJbnRlcnZhbCBpc24ndCAnYmFja3dhcmRzJy5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkUmVhc29uID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIEludGVydmFsIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIEludGVydmFsIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBJbnRlcnZhbCBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgSW50ZXJ2YWwgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBJbnRlcnZhbCBpbiB0aGUgc3BlY2lmaWVkIHVuaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IC0gdGhlIHVuaXQgKHN1Y2ggYXMgJ2hvdXJzJyBvciAnZGF5cycpIHRvIHJldHVybiB0aGUgbGVuZ3RoIGluLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBsZW5ndGgodW5pdCA9IFwibWlsbGlzZWNvbmRzXCIpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50b0R1cmF0aW9uKC4uLlt1bml0XSkuZ2V0KHVuaXQpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvdW50IG9mIG1pbnV0ZXMsIGhvdXJzLCBkYXlzLCBtb250aHMsIG9yIHllYXJzIGluY2x1ZGVkIGluIHRoZSBJbnRlcnZhbCwgZXZlbiBpbiBwYXJ0LlxuICAgKiBVbmxpa2Uge0BsaW5rIEludGVydmFsI2xlbmd0aH0gdGhpcyBjb3VudHMgc2VjdGlvbnMgb2YgdGhlIGNhbGVuZGFyLCBub3QgcGVyaW9kcyBvZiB0aW1lLCBlLmcuIHNwZWNpZnlpbmcgJ2RheSdcbiAgICogYXNrcyAnd2hhdCBkYXRlcyBhcmUgaW5jbHVkZWQgaW4gdGhpcyBpbnRlcnZhbD8nLCBub3QgJ2hvdyBtYW55IGRheXMgbG9uZyBpcyB0aGlzIGludGVydmFsPydcbiAgICogQHBhcmFtIHtzdHJpbmd9IFt1bml0PSdtaWxsaXNlY29uZHMnXSAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvdW50KHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBOYU47XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXJ0LnN0YXJ0T2YodW5pdCksXG4gICAgICBlbmQgPSB0aGlzLmVuZC5zdGFydE9mKHVuaXQpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGVuZC5kaWZmKHN0YXJ0LCB1bml0KS5nZXQodW5pdCkpICsgKGVuZC52YWx1ZU9mKCkgIT09IHRoaXMuZW5kLnZhbHVlT2YoKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBhbmQgZW5kIGFyZSBib3RoIGluIHRoZSBzYW1lIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIHRoZSB1bml0IG9mIHRpbWUgdG8gY2hlY2sgc2FtZW5lc3Mgb25cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc1NhbWUodW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLmlzRW1wdHkoKSB8fCB0aGlzLmUubWludXMoMSkuaGFzU2FtZSh0aGlzLnMsIHVuaXQpIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCBoYXMgdGhlIHNhbWUgc3RhcnQgYW5kIGVuZCBEYXRlVGltZXMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLnMudmFsdWVPZigpID09PSB0aGlzLmUudmFsdWVPZigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBzdGFydCBpcyBhZnRlciB0aGUgc3BlY2lmaWVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge0RhdGVUaW1lfSBkYXRlVGltZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBZnRlcihkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA+IGRhdGVUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwncyBlbmQgaXMgYmVmb3JlIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0JlZm9yZShkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuZSA8PSBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGlzIEludGVydmFsIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgRGF0ZVRpbWUuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IGRhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBjb250YWlucyhkYXRlVGltZSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBkYXRlVGltZSAmJiB0aGlzLmUgPiBkYXRlVGltZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldHNcIiB0aGUgc3RhcnQgYW5kL29yIGVuZCBkYXRlcy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVzIC0gdGhlIHZhbHVlcyB0byBzZXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gdmFsdWVzLnN0YXJ0IC0gdGhlIHN0YXJ0aW5nIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IHZhbHVlcy5lbmQgLSB0aGUgZW5kaW5nIERhdGVUaW1lXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgc2V0KHsgc3RhcnQsIGVuZCB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMoc3RhcnQgfHwgdGhpcy5zLCBlbmQgfHwgdGhpcy5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGlzIEludGVydmFsIGF0IGVhY2ggb2YgdGhlIHNwZWNpZmllZCBEYXRlVGltZXNcbiAgICogQHBhcmFtIHsuLi5EYXRlVGltZX0gZGF0ZVRpbWVzIC0gdGhlIHVuaXQgb2YgdGltZSB0byBjb3VudC5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzcGxpdEF0KC4uLmRhdGVUaW1lcykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gW107XG4gICAgY29uc3Qgc29ydGVkID0gZGF0ZVRpbWVzXG4gICAgICAgIC5tYXAoZnJpZW5kbHlEYXRlVGltZSlcbiAgICAgICAgLmZpbHRlcigoZCkgPT4gdGhpcy5jb250YWlucyhkKSlcbiAgICAgICAgLnNvcnQoKSxcbiAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaSA9IDA7XG5cbiAgICB3aGlsZSAocyA8IHRoaXMuZSkge1xuICAgICAgY29uc3QgYWRkZWQgPSBzb3J0ZWRbaV0gfHwgdGhpcy5lLFxuICAgICAgICBuZXh0ID0gK2FkZGVkID4gK3RoaXMuZSA/IHRoaXMuZSA6IGFkZGVkO1xuICAgICAgcmVzdWx0cy5wdXNoKEludGVydmFsLmZyb21EYXRlVGltZXMocywgbmV4dCkpO1xuICAgICAgcyA9IG5leHQ7XG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHNtYWxsZXIgSW50ZXJ2YWxzLCBlYWNoIG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgKiBMZWZ0IG92ZXIgdGltZSBpcyBncm91cGVkIGludG8gYSBzbWFsbGVyIGludGVydmFsXG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgbGVuZ3RoIG9mIGVhY2ggcmVzdWx0aW5nIGludGVydmFsLlxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHNwbGl0QnkoZHVyYXRpb24pIHtcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKTtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFkdXIuaXNWYWxpZCB8fCBkdXIuYXMoXCJtaWxsaXNlY29uZHNcIikgPT09IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBsZXQgeyBzIH0gPSB0aGlzLFxuICAgICAgaWR4ID0gMSxcbiAgICAgIG5leHQ7XG5cbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgd2hpbGUgKHMgPCB0aGlzLmUpIHtcbiAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5zdGFydC5wbHVzKGR1ci5tYXBVbml0cygoeCkgPT4geCAqIGlkeCkpO1xuICAgICAgbmV4dCA9ICthZGRlZCA+ICt0aGlzLmUgPyB0aGlzLmUgOiBhZGRlZDtcbiAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIG5leHQpKTtcbiAgICAgIHMgPSBuZXh0O1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXQgdGhpcyBJbnRlcnZhbCBpbnRvIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNtYWxsZXIgaW50ZXJ2YWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyT2ZQYXJ0cyAtIFRoZSBudW1iZXIgb2YgSW50ZXJ2YWxzIHRvIGRpdmlkZSB0aGUgSW50ZXJ2YWwgaW50by5cbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBkaXZpZGVFcXVhbGx5KG51bWJlck9mUGFydHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiB0aGlzLnNwbGl0QnkodGhpcy5sZW5ndGgoKSAvIG51bWJlck9mUGFydHMpLnNsaWNlKDAsIG51bWJlck9mUGFydHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIEludGVydmFsXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBvdmVybGFwcyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmUgPiBvdGhlci5zICYmIHRoaXMucyA8IG90aGVyLmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIGVuZCBpcyBhZGphY2VudCB0byB0aGUgc3BlY2lmaWVkIEludGVydmFsJ3Mgc3RhcnQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c1N0YXJ0KG90aGVyKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gK3RoaXMuZSA9PT0gK290aGVyLnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBJbnRlcnZhbCdzIHN0YXJ0IGlzIGFkamFjZW50IHRvIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwncyBlbmQuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhYnV0c0VuZChvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuICtvdGhlci5lID09PSArdGhpcy5zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgZW5ndWxmcyB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFsLlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZW5ndWxmcyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMucyA8PSBvdGhlci5zICYmIHRoaXMuZSA+PSBvdGhlci5lO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB3aGV0aGVyIHRoaXMgSW50ZXJ2YWwgaGFzIHRoZSBzYW1lIHN0YXJ0IGFuZCBlbmQgYXMgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogQHBhcmFtIHtJbnRlcnZhbH0gb3RoZXJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkIHx8ICFvdGhlci5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucy5lcXVhbHMob3RoZXIucykgJiYgdGhpcy5lLmVxdWFscyhvdGhlci5lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgcmVwcmVzZW50aW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhpcyBJbnRlcnZhbCBhbmQgdGhlIHNwZWNpZmllZCBJbnRlcnZhbC5cbiAgICogU3BlY2lmaWNhbGx5LCB0aGUgcmVzdWx0aW5nIEludGVydmFsIGhhcyB0aGUgbWF4aW11bSBzdGFydCB0aW1lIGFuZCB0aGUgbWluaW11bSBlbmQgdGltZSBvZiB0aGUgdHdvIEludGVydmFscy5cbiAgICogUmV0dXJucyBudWxsIGlmIHRoZSBpbnRlcnNlY3Rpb24gaXMgZW1wdHksIG1lYW5pbmcsIHRoZSBpbnRlcnZhbHMgZG9uJ3QgaW50ZXJzZWN0LlxuICAgKiBAcGFyYW0ge0ludGVydmFsfSBvdGhlclxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBzID0gdGhpcy5zID4gb3RoZXIucyA/IHRoaXMucyA6IG90aGVyLnMsXG4gICAgICBlID0gdGhpcy5lIDwgb3RoZXIuZSA/IHRoaXMuZSA6IG90aGVyLmU7XG5cbiAgICBpZiAocyA+PSBlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEludGVydmFsLmZyb21EYXRlVGltZXMocywgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBJbnRlcnZhbCByZXByZXNlbnRpbmcgdGhlIHVuaW9uIG9mIHRoaXMgSW50ZXJ2YWwgYW5kIHRoZSBzcGVjaWZpZWQgSW50ZXJ2YWwuXG4gICAqIFNwZWNpZmljYWxseSwgdGhlIHJlc3VsdGluZyBJbnRlcnZhbCBoYXMgdGhlIG1pbmltdW0gc3RhcnQgdGltZSBhbmQgdGhlIG1heGltdW0gZW5kIHRpbWUgb2YgdGhlIHR3byBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7SW50ZXJ2YWx9IG90aGVyXG4gICAqIEByZXR1cm4ge0ludGVydmFsfVxuICAgKi9cbiAgdW5pb24ob3RoZXIpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgcyA9IHRoaXMucyA8IG90aGVyLnMgPyB0aGlzLnMgOiBvdGhlci5zLFxuICAgICAgZSA9IHRoaXMuZSA+IG90aGVyLmUgPyB0aGlzLmUgOiBvdGhlci5lO1xuICAgIHJldHVybiBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHMsIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIGFycmF5IG9mIEludGVydmFscyBpbnRvIGEgZXF1aXZhbGVudCBtaW5pbWFsIHNldCBvZiBJbnRlcnZhbHMuXG4gICAqIENvbWJpbmVzIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJnZShpbnRlcnZhbHMpIHtcbiAgICBjb25zdCBbZm91bmQsIGZpbmFsXSA9IGludGVydmFsc1xuICAgICAgLnNvcnQoKGEsIGIpID0+IGEucyAtIGIucylcbiAgICAgIC5yZWR1Y2UoXG4gICAgICAgIChbc29mYXIsIGN1cnJlbnRdLCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBpdGVtXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQub3ZlcmxhcHMoaXRlbSkgfHwgY3VycmVudC5hYnV0c1N0YXJ0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvZmFyLCBjdXJyZW50LnVuaW9uKGl0ZW0pXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtzb2Zhci5jb25jYXQoW2N1cnJlbnRdKSwgaXRlbV07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBbW10sIG51bGxdXG4gICAgICApO1xuICAgIGlmIChmaW5hbCkge1xuICAgICAgZm91bmQucHVzaChmaW5hbCk7XG4gICAgfVxuICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgSW50ZXJ2YWxzIHJlcHJlc2VudGluZyB0aGUgc3BhbnMgb2YgdGltZSB0aGF0IG9ubHkgYXBwZWFyIGluIG9uZSBvZiB0aGUgc3BlY2lmaWVkIEludGVydmFscy5cbiAgICogQHBhcmFtIHtBcnJheX0gaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHhvcihpbnRlcnZhbHMpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsLFxuICAgICAgY3VycmVudENvdW50ID0gMDtcbiAgICBjb25zdCByZXN1bHRzID0gW10sXG4gICAgICBlbmRzID0gaW50ZXJ2YWxzLm1hcCgoaSkgPT4gW1xuICAgICAgICB7IHRpbWU6IGkucywgdHlwZTogXCJzXCIgfSxcbiAgICAgICAgeyB0aW1lOiBpLmUsIHR5cGU6IFwiZVwiIH0sXG4gICAgICBdKSxcbiAgICAgIGZsYXR0ZW5lZCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4uZW5kcyksXG4gICAgICBhcnIgPSBmbGF0dGVuZWQuc29ydCgoYSwgYikgPT4gYS50aW1lIC0gYi50aW1lKTtcblxuICAgIGZvciAoY29uc3QgaSBvZiBhcnIpIHtcbiAgICAgIGN1cnJlbnRDb3VudCArPSBpLnR5cGUgPT09IFwic1wiID8gMSA6IC0xO1xuXG4gICAgICBpZiAoY3VycmVudENvdW50ID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gaS50aW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXJ0ICYmICtzdGFydCAhPT0gK2kudGltZSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKHN0YXJ0LCBpLnRpbWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gSW50ZXJ2YWwubWVyZ2UocmVzdWx0cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIEludGVydmFsIHJlcHJlc2VudGluZyB0aGUgc3BhbiBvZiB0aW1lIGluIHRoaXMgSW50ZXJ2YWwgdGhhdCBkb2Vzbid0IG92ZXJsYXAgd2l0aCBhbnkgb2YgdGhlIHNwZWNpZmllZCBJbnRlcnZhbHMuXG4gICAqIEBwYXJhbSB7Li4uSW50ZXJ2YWx9IGludGVydmFsc1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIGRpZmZlcmVuY2UoLi4uaW50ZXJ2YWxzKSB7XG4gICAgcmV0dXJuIEludGVydmFsLnhvcihbdGhpc10uY29uY2F0KGludGVydmFscykpXG4gICAgICAubWFwKChpKSA9PiB0aGlzLmludGVyc2VjdGlvbihpKSlcbiAgICAgIC5maWx0ZXIoKGkpID0+IGkgJiYgIWkuaXNFbXB0eSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgWyR7dGhpcy5zLnRvSVNPKCl9IOKAkyAke3RoaXMuZS50b0lTTygpfSlgO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2NhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIEludGVydmFsLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlXG4gICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IgYW5kIGFueSBwcmVzZXRzIGRlZmluZWQgYnkgTHV4b24sIHN1Y2ggYXNcbiAgICoge0BsaW5rIERhdGVUaW1lLkRBVEVfRlVMTH0gb3Ige0BsaW5rIERhdGVUaW1lLlRJTUVfU0lNUExFfS4gVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kXG4gICAqIGlzIGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBpbiBnZW5lcmFsIGl0IHdpbGwgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgKiBJbnRlcnZhbCBpbiB0aGUgYXNzaWduZWQgbG9jYWxlLiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlblxuICAgKiBzcGVjaWZpZWQuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtmb3JtYXRPcHRzPURhdGVUaW1lLkRBVEVfU0hPUlRdIC0gRWl0aGVyIGEgRGF0ZVRpbWUgcHJlc2V0IG9yXG4gICAqIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBPcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBzdGFydCBEYXRlVGltZS5cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QwOTowMFovMjAyMi0xMS0wOFQwOTowMFonKS50b0xvY2FsZVN0cmluZygpOyAvLz0+IDExLzcvMjAyMiDigJMgMTEvOC8yMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMKTsgLy89PiBOb3ZlbWJlciA3IOKAkyA4LCAyMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMDk6MDBaLzIwMjItMTEtMDhUMDk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuREFURV9GVUxMLCB7IGxvY2FsZTogJ2ZyLUZSJyB9KTsgLy89PiA34oCTOCBub3ZlbWJyZSAyMDIyXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21JU08oJzIwMjItMTEtMDdUMTc6MDBaLzIwMjItMTEtMDdUMTk6MDBaJykudG9Mb2NhbGVTdHJpbmcoRGF0ZVRpbWUuVElNRV9TSU1QTEUpOyAvLz0+IDY6MDAg4oCTIDg6MDAgUE1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbUlTTygnMjAyMi0xMS0wN1QxNzowMFovMjAyMi0xMS0wN1QxOTowMFonKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICcyLWRpZ2l0JywgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JyB9KTsgLy89PiBNb24sIE5vdiAwNywgNjowMCDigJMgODowMCBwXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvTG9jYWxlU3RyaW5nKGZvcm1hdE9wdHMgPSBGb3JtYXRzLkRBVEVfU0hPUlQsIG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLnMubG9jLmNsb25lKG9wdHMpLCBmb3JtYXRPcHRzKS5mb3JtYXRJbnRlcnZhbCh0aGlzKVxuICAgICAgOiBJTlZBTElEO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEludGVydmFsLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTTyhvcHRzKX0vJHt0aGlzLmUudG9JU08ob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZGF0ZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgdGltZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPRGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIElOVkFMSUQ7XG4gICAgcmV0dXJuIGAke3RoaXMucy50b0lTT0RhdGUoKX0vJHt0aGlzLmUudG9JU09EYXRlKCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGltZSBvZiB0aGlzIEludGVydmFsLlxuICAgKiBUaGUgZGF0ZSBjb21wb25lbnRzIGFyZSBpZ25vcmVkLlxuICAgKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT184NjAxI1RpbWVfaW50ZXJ2YWxzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gVGhlIHNhbWUgb3B0aW9ucyBhcyB7QGxpbmsgRGF0ZVRpbWUjdG9JU099XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPVGltZShvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9JU09UaW1lKG9wdHMpfS8ke3RoaXMuZS50b0lTT1RpbWUob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgSW50ZXJ2YWwgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdFxuICAgKiBzdHJpbmcuICoqWW91IG1heSBub3Qgd2FudCB0aGlzLioqIFNlZSB7QGxpbmsgSW50ZXJ2YWwjdG9Mb2NhbGVTdHJpbmd9IGZvciBhIG1vcmUgZmxleGlibGVcbiAgICogZm9ybWF0dGluZyB0b29sLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0ZUZvcm1hdCAtIFRoZSBmb3JtYXQgc3RyaW5nLiBUaGlzIHN0cmluZyBmb3JtYXRzIHRoZSBzdGFydCBhbmQgZW5kIHRpbWUuXG4gICAqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjdG9Gb3JtYXR9IGZvciBkZXRhaWxzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbnMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5zZXBhcmF0b3IgPSAgJyDigJMgJ10gLSBBIHNlcGFyYXRvciB0byBwbGFjZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kXG4gICAqIHJlcHJlc2VudGF0aW9ucy5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZGF0ZUZvcm1hdCwgeyBzZXBhcmF0b3IgPSBcIiDigJMgXCIgfSA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBJTlZBTElEO1xuICAgIHJldHVybiBgJHt0aGlzLnMudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9JHtzZXBhcmF0b3J9JHt0aGlzLmUudG9Gb3JtYXQoZGF0ZUZvcm1hdCl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBEdXJhdGlvbiByZXByZXNlbnRpbmcgdGhlIHRpbWUgc3Bhbm5lZCBieSB0aGlzIGludGVydmFsLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW3VuaXQ9WydtaWxsaXNlY29uZHMnXV0gLSB0aGUgdW5pdCBvciB1bml0cyAoc3VjaCBhcyAnaG91cnMnIG9yICdkYXlzJykgdG8gaW5jbHVkZSBpbiB0aGUgZHVyYXRpb24uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgY3JlYXRpb24gb2YgdGhlIER1cmF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5jb252ZXJzaW9uQWNjdXJhY3k9J2Nhc3VhbCddIC0gdGhlIGNvbnZlcnNpb24gc3lzdGVtIHRvIHVzZVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCkudG9PYmplY3QoKSAvLz0+IHsgbWlsbGlzZWNvbmRzOiA4ODQ4OTI1NyB9XG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLnRvRHVyYXRpb24oJ2RheXMnKS50b09iamVjdCgpIC8vPT4geyBkYXlzOiAxLjAyNDE4MTIxNTI3Nzc3NzggfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKFsnaG91cnMnLCAnbWludXRlcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LjgyMDk1IH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikudG9EdXJhdGlvbihbJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddKS50b09iamVjdCgpIC8vPT4geyBob3VyczogMjQsIG1pbnV0ZXM6IDM0LCBzZWNvbmRzOiA0OS4yNTcgfVxuICAgKiBAZXhhbXBsZSBJbnRlcnZhbC5mcm9tRGF0ZVRpbWVzKGR0MSwgZHQyKS50b0R1cmF0aW9uKCdzZWNvbmRzJykudG9PYmplY3QoKSAvLz0+IHsgc2Vjb25kczogODg0ODkuMjU3IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICB0b0R1cmF0aW9uKHVuaXQsIG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIER1cmF0aW9uLmludmFsaWQodGhpcy5pbnZhbGlkUmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZS5kaWZmKHRoaXMucywgdW5pdCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIG1hcEZuIG9uIHRoZSBpbnRlcnZhbCBzdGFydCBhbmQgZW5kLCByZXR1cm5pbmcgYSBuZXcgSW50ZXJ2YWwgZnJvbSB0aGUgcmVzdWx0aW5nIERhdGVUaW1lc1xuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtYXBGblxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICogQGV4YW1wbGUgSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhkdDEsIGR0MikubWFwRW5kcG9pbnRzKGVuZHBvaW50ID0+IGVuZHBvaW50LnRvVVRDKCkpXG4gICAqIEBleGFtcGxlIEludGVydmFsLmZyb21EYXRlVGltZXMoZHQxLCBkdDIpLm1hcEVuZHBvaW50cyhlbmRwb2ludCA9PiBlbmRwb2ludC5wbHVzKHsgaG91cnM6IDIgfSkpXG4gICAqL1xuICBtYXBFbmRwb2ludHMobWFwRm4pIHtcbiAgICByZXR1cm4gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyhtYXBGbih0aGlzLnMpLCBtYXBGbih0aGlzLmUpKTtcbiAgfVxufVxuIiwgImltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi9kYXRldGltZS5qc1wiO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gXCIuL3NldHRpbmdzLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQgSUFOQVpvbmUgZnJvbSBcIi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCB7IG5vcm1hbGl6ZVpvbmUgfSBmcm9tIFwiLi9pbXBsL3pvbmVVdGlsLmpzXCI7XG5cbmltcG9ydCB7IGhhc1JlbGF0aXZlIH0gZnJvbSBcIi4vaW1wbC91dGlsLmpzXCI7XG5cbi8qKlxuICogVGhlIEluZm8gY2xhc3MgY29udGFpbnMgc3RhdGljIG1ldGhvZHMgZm9yIHJldHJpZXZpbmcgZ2VuZXJhbCB0aW1lIGFuZCBkYXRlIHJlbGF0ZWQgZGF0YS4gRm9yIGV4YW1wbGUsIGl0IGhhcyBtZXRob2RzIGZvciBmaW5kaW5nIG91dCBpZiBhIHRpbWUgem9uZSBoYXMgYSBEU1QsIGZvciBsaXN0aW5nIHRoZSBtb250aHMgaW4gYW55IHN1cHBvcnRlZCBsb2NhbGUsIGFuZCBmb3IgZGlzY292ZXJpbmcgd2hpY2ggb2YgTHV4b24gZmVhdHVyZXMgYXJlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW5mbyB7XG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgY29udGFpbnMgYSBEU1QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFt6b25lPSdsb2NhbCddIC0gWm9uZSB0byBjaGVjay4gRGVmYXVsdHMgdG8gdGhlIGVudmlyb25tZW50J3MgbG9jYWwgem9uZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBoYXNEU1Qoem9uZSA9IFNldHRpbmdzLmRlZmF1bHRab25lKSB7XG4gICAgY29uc3QgcHJvdG8gPSBEYXRlVGltZS5ub3coKS5zZXRab25lKHpvbmUpLnNldCh7IG1vbnRoOiAxMiB9KTtcblxuICAgIHJldHVybiAhem9uZS5pc1VuaXZlcnNhbCAmJiBwcm90by5vZmZzZXQgIT09IHByb3RvLnNldCh7IG1vbnRoOiA2IH0pLm9mZnNldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciB0aGUgc3BlY2lmaWVkIHpvbmUgaXMgYSB2YWxpZCBJQU5BIHNwZWNpZmllci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHpvbmUgLSBab25lIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBzdGF0aWMgaXNWYWxpZElBTkFab25lKHpvbmUpIHtcbiAgICByZXR1cm4gSUFOQVpvbmUuaXNWYWxpZFpvbmUoem9uZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhlIGlucHV0IGludG8gYSB7QGxpbmsgWm9uZX0gaW5zdGFuY2UuXG4gICAqXG4gICAqICogSWYgYGlucHV0YCBpcyBhbHJlYWR5IGEgWm9uZSBpbnN0YW5jZSwgaXQgaXMgcmV0dXJuZWQgdW5jaGFuZ2VkLlxuICAgKiAqIElmIGBpbnB1dGAgaXMgYSBzdHJpbmcgY29udGFpbmluZyBhIHZhbGlkIHRpbWUgem9uZSBuYW1lLCBhIFpvbmUgaW5zdGFuY2VcbiAgICogICB3aXRoIHRoYXQgbmFtZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCByZWZlciB0byBhIGtub3duIHRpbWUgem9uZSwgYSBab25lXG4gICAqICAgaW5zdGFuY2Ugd2l0aCB7QGxpbmsgWm9uZSNpc1ZhbGlkfSA9PSBmYWxzZSBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXQgaXMgYSBudW1iZXIsIGEgWm9uZSBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgZml4ZWQgb2Zmc2V0XG4gICAqICAgaW4gbWludXRlcyBpcyByZXR1cm5lZC5cbiAgICogKiBJZiBgaW5wdXRgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIGRlZmF1bHQgem9uZSBpcyByZXR1cm5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZXxudW1iZXJ9IFtpbnB1dF0gLSB0aGUgdmFsdWUgdG8gYmUgY29udmVydGVkXG4gICAqIEByZXR1cm4ge1pvbmV9XG4gICAqL1xuICBzdGF0aWMgbm9ybWFsaXplWm9uZShpbnB1dCkge1xuICAgIHJldHVybiBub3JtYWxpemVab25lKGlucHV0LCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIHN0YW5kYWxvbmUgbW9udGggbmFtZXMuXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZVRpbWVGb3JtYXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibnVtZXJpY1wiLCBcIjItZGlnaXRcIiwgXCJuYXJyb3dcIiwgXCJzaG9ydFwiLCBcImxvbmdcIlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbT1udWxsXSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NPYmo9bnVsbF0gLSBhbiBleGlzdGluZyBsb2NhbGUgb2JqZWN0IHRvIHVzZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMub3V0cHV0Q2FsZW5kYXI9J2dyZWdvcnknXSAtIHRoZSBjYWxlbmRhclxuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygpWzBdIC8vPT4gJ0phbnVhcnknXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdzaG9ydCcpWzBdIC8vPT4gJ0phbidcbiAgICogQGV4YW1wbGUgSW5mby5tb250aHMoJ251bWVyaWMnKVswXSAvLz0+ICcxJ1xuICAgKiBAZXhhbXBsZSBJbmZvLm1vbnRocygnc2hvcnQnLCB7IGxvY2FsZTogJ2ZyLUNBJyB9IClbMF0gLy89PiAnamFudi4nXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdudW1lcmljJywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAn2aEnXG4gICAqIEBleGFtcGxlIEluZm8ubW9udGhzKCdsb25nJywgeyBvdXRwdXRDYWxlbmRhcjogJ2lzbGFtaWMnIH0pWzBdIC8vPT4gJ1JhYmnKuyBJJ1xuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtb250aHMoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsLCBvdXRwdXRDYWxlbmRhciA9IFwiZ3JlZ29yeVwiIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhcikpLm1vbnRocyhsZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBmb3JtYXQgbW9udGggbmFtZXMuXG4gICAqIEZvcm1hdCBtb250aHMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSBtb250aHMgaW4gdGhhdCB0aGV5J3JlIG1lYW50IHRvIGFwcGVhciBuZXh0IHRvIHRoZSBkYXkgb2YgdGhlIG1vbnRoLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyNtb250aHN9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSBtb250aCByZXByZXNlbnRhdGlvbiwgc3VjaCBhcyBcIm51bWVyaWNcIiwgXCIyLWRpZ2l0XCIsIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyPSdncmVnb3J5J10gLSB0aGUgY2FsZW5kYXJcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgbW9udGhzRm9ybWF0KFxuICAgIGxlbmd0aCA9IFwibG9uZ1wiLFxuICAgIHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCwgbG9jT2JqID0gbnVsbCwgb3V0cHV0Q2FsZW5kYXIgPSBcImdyZWdvcnlcIiB9ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXIpKS5tb250aHMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Ygc3RhbmRhbG9uZSB3ZWVrIG5hbWVzLlxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdsb25nJ10gLSB0aGUgbGVuZ3RoIG9mIHRoZSB3ZWVrZGF5IHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlXSAtIHRoZSBsb2NhbGUgY29kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubnVtYmVyaW5nU3lzdGVtPW51bGxdIC0gdGhlIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY09iaj1udWxsXSAtIGFuIGV4aXN0aW5nIGxvY2FsZSBvYmplY3QgdG8gdXNlXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoKVswXSAvLz0+ICdNb25kYXknXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JylbMF0gLy89PiAnTW9uJ1xuICAgKiBAZXhhbXBsZSBJbmZvLndlZWtkYXlzKCdzaG9ydCcsIHsgbG9jYWxlOiAnZnItQ0EnIH0pWzBdIC8vPT4gJ2x1bi4nXG4gICAqIEBleGFtcGxlIEluZm8ud2Vla2RheXMoJ3Nob3J0JywgeyBsb2NhbGU6ICdhcicgfSlbMF0gLy89PiAn2KfZhNin2KvZhtmK2YYnXG4gICAqIEByZXR1cm4ge0FycmF5fVxuICAgKi9cbiAgc3RhdGljIHdlZWtkYXlzKGxlbmd0aCA9IFwibG9uZ1wiLCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwsIGxvY09iaiA9IG51bGwgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChsb2NPYmogfHwgTG9jYWxlLmNyZWF0ZShsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgbnVsbCkpLndlZWtkYXlzKGxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGZvcm1hdCB3ZWVrIG5hbWVzLlxuICAgKiBGb3JtYXQgd2Vla2RheXMgZGlmZmVyIGZyb20gc3RhbmRhbG9uZSB3ZWVrZGF5cyBpbiB0aGF0IHRoZXkncmUgbWVhbnQgdG8gYXBwZWFyIG5leHQgdG8gbW9yZSBkYXRlIGluZm9ybWF0aW9uLiBJbiBzb21lIGxhbmd1YWdlcywgdGhhdFxuICAgKiBjaGFuZ2VzIHRoZSBzdHJpbmcuXG4gICAqIFNlZSB7QGxpbmsgSW5mbyN3ZWVrZGF5c31cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtsZW5ndGg9J2xvbmcnXSAtIHRoZSBsZW5ndGggb2YgdGhlIG1vbnRoIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwibmFycm93XCIsIFwic2hvcnRcIiwgXCJsb25nXCIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPW51bGxdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5udW1iZXJpbmdTeXN0ZW09bnVsbF0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jT2JqPW51bGxdIC0gYW4gZXhpc3RpbmcgbG9jYWxlIG9iamVjdCB0byB1c2VcbiAgICogQHJldHVybiB7QXJyYXl9XG4gICAqL1xuICBzdGF0aWMgd2Vla2RheXNGb3JtYXQoXG4gICAgbGVuZ3RoID0gXCJsb25nXCIsXG4gICAgeyBsb2NhbGUgPSBudWxsLCBudW1iZXJpbmdTeXN0ZW0gPSBudWxsLCBsb2NPYmogPSBudWxsIH0gPSB7fVxuICApIHtcbiAgICByZXR1cm4gKGxvY09iaiB8fCBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBudWxsKSkud2Vla2RheXMobGVuZ3RoLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgbWVyaWRpZW1zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmxvY2FsZV0gLSB0aGUgbG9jYWxlIGNvZGVcbiAgICogQGV4YW1wbGUgSW5mby5tZXJpZGllbXMoKSAvLz0+IFsgJ0FNJywgJ1BNJyBdXG4gICAqIEBleGFtcGxlIEluZm8ubWVyaWRpZW1zKHsgbG9jYWxlOiAnbXknIH0pIC8vPT4gWyAn4YCU4YC24YCU4YCA4YC6JywgJ+GAiuGAlOGAsScgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBtZXJpZGllbXMoeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSkubWVyaWRpZW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIGFycmF5IG9mIGVyYXMsIHN1Y2ggYXMgWydCQycsICdBRCddLiBUaGUgbG9jYWxlIGNhbiBiZSBzcGVjaWZpZWQsIGJ1dCB0aGUgY2FsZW5kYXIgc3lzdGVtIGlzIGFsd2F5cyBHcmVnb3JpYW4uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbGVuZ3RoPSdzaG9ydCddIC0gdGhlIGxlbmd0aCBvZiB0aGUgZXJhIHJlcHJlc2VudGF0aW9uLCBzdWNoIGFzIFwic2hvcnRcIiBvciBcImxvbmdcIi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGVdIC0gdGhlIGxvY2FsZSBjb2RlXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygpIC8vPT4gWyAnQkMnLCAnQUQnIF1cbiAgICogQGV4YW1wbGUgSW5mby5lcmFzKCdsb25nJykgLy89PiBbICdCZWZvcmUgQ2hyaXN0JywgJ0Fubm8gRG9taW5pJyBdXG4gICAqIEBleGFtcGxlIEluZm8uZXJhcygnbG9uZycsIHsgbG9jYWxlOiAnZnInIH0pIC8vPT4gWyAnYXZhbnQgSsOpc3VzLUNocmlzdCcsICdhcHLDqHMgSsOpc3VzLUNocmlzdCcgXVxuICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICovXG4gIHN0YXRpYyBlcmFzKGxlbmd0aCA9IFwic2hvcnRcIiwgeyBsb2NhbGUgPSBudWxsIH0gPSB7fSkge1xuICAgIHJldHVybiBMb2NhbGUuY3JlYXRlKGxvY2FsZSwgbnVsbCwgXCJncmVnb3J5XCIpLmVyYXMobGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHNldCBvZiBhdmFpbGFibGUgZmVhdHVyZXMgaW4gdGhpcyBlbnZpcm9ubWVudC5cbiAgICogU29tZSBmZWF0dXJlcyBvZiBMdXhvbiBhcmUgbm90IGF2YWlsYWJsZSBpbiBhbGwgZW52aXJvbm1lbnRzLiBGb3IgZXhhbXBsZSwgb24gb2xkZXIgYnJvd3NlcnMsIHJlbGF0aXZlIHRpbWUgZm9ybWF0dGluZyBzdXBwb3J0IGlzIG5vdCBhdmFpbGFibGUuIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgdGhhdCdzIHRoZSBjYXNlLlxuICAgKiBLZXlzOlxuICAgKiAqIGByZWxhdGl2ZWA6IHdoZXRoZXIgdGhpcyBlbnZpcm9ubWVudCBzdXBwb3J0cyByZWxhdGl2ZSB0aW1lIGZvcm1hdHRpbmdcbiAgICogQGV4YW1wbGUgSW5mby5mZWF0dXJlcygpIC8vPT4geyByZWxhdGl2ZTogZmFsc2UgfVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZmVhdHVyZXMoKSB7XG4gICAgcmV0dXJuIHsgcmVsYXRpdmU6IGhhc1JlbGF0aXZlKCkgfTtcbiAgfVxufVxuIiwgImltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi4vZHVyYXRpb24uanNcIjtcblxuZnVuY3Rpb24gZGF5RGlmZihlYXJsaWVyLCBsYXRlcikge1xuICBjb25zdCB1dGNEYXlTdGFydCA9IChkdCkgPT4gZHQudG9VVEMoMCwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pLnN0YXJ0T2YoXCJkYXlcIikudmFsdWVPZigpLFxuICAgIG1zID0gdXRjRGF5U3RhcnQobGF0ZXIpIC0gdXRjRGF5U3RhcnQoZWFybGllcik7XG4gIHJldHVybiBNYXRoLmZsb29yKER1cmF0aW9uLmZyb21NaWxsaXMobXMpLmFzKFwiZGF5c1wiKSk7XG59XG5cbmZ1bmN0aW9uIGhpZ2hPcmRlckRpZmZzKGN1cnNvciwgbGF0ZXIsIHVuaXRzKSB7XG4gIGNvbnN0IGRpZmZlcnMgPSBbXG4gICAgW1wieWVhcnNcIiwgKGEsIGIpID0+IGIueWVhciAtIGEueWVhcl0sXG4gICAgW1wicXVhcnRlcnNcIiwgKGEsIGIpID0+IGIucXVhcnRlciAtIGEucXVhcnRlciArIChiLnllYXIgLSBhLnllYXIpICogNF0sXG4gICAgW1wibW9udGhzXCIsIChhLCBiKSA9PiBiLm1vbnRoIC0gYS5tb250aCArIChiLnllYXIgLSBhLnllYXIpICogMTJdLFxuICAgIFtcbiAgICAgIFwid2Vla3NcIixcbiAgICAgIChhLCBiKSA9PiB7XG4gICAgICAgIGNvbnN0IGRheXMgPSBkYXlEaWZmKGEsIGIpO1xuICAgICAgICByZXR1cm4gKGRheXMgLSAoZGF5cyAlIDcpKSAvIDc7XG4gICAgICB9LFxuICAgIF0sXG4gICAgW1wiZGF5c1wiLCBkYXlEaWZmXSxcbiAgXTtcblxuICBjb25zdCByZXN1bHRzID0ge307XG4gIGNvbnN0IGVhcmxpZXIgPSBjdXJzb3I7XG4gIGxldCBsb3dlc3RPcmRlciwgaGlnaFdhdGVyO1xuXG4gIC8qIFRoaXMgbG9vcCB0cmllcyB0byBkaWZmIHVzaW5nIGxhcmdlciB1bml0cyBmaXJzdC5cbiAgICAgSWYgd2Ugb3ZlcnNob290LCB3ZSBiYWNrdHJhY2sgYW5kIHRyeSB0aGUgbmV4dCBzbWFsbGVyIHVuaXQuXG4gICAgIFwiY3Vyc29yXCIgc3RhcnRzIG91dCBhdCB0aGUgZWFybGllciB0aW1lc3RhbXAgYW5kIG1vdmVzIGNsb3NlciBhbmQgY2xvc2VyIHRvIFwibGF0ZXJcIlxuICAgICBhcyB3ZSB1c2Ugc21hbGxlciBhbmQgc21hbGxlciB1bml0cy5cbiAgICAgaGlnaFdhdGVyIGtlZXBzIHRyYWNrIG9mIHdoZXJlIHdlIHdvdWxkIGJlIGlmIHdlIGFkZGVkIG9uZSBtb3JlIG9mIHRoZSBzbWFsbGVzdCB1bml0LFxuICAgICB0aGlzIGlzIHVzZWQgbGF0ZXIgdG8gcG90ZW50aWFsbHkgY29udmVydCBhbnkgZGlmZmVyZW5jZSBzbWFsbGVyIHRoYW4gdGhlIHNtYWxsZXN0IGhpZ2hlciBvcmRlciB1bml0XG4gICAgIGludG8gYSBmcmFjdGlvbiBvZiB0aGF0IHNtYWxsZXN0IGhpZ2hlciBvcmRlciB1bml0XG4gICovXG4gIGZvciAoY29uc3QgW3VuaXQsIGRpZmZlcl0gb2YgZGlmZmVycykge1xuICAgIGlmICh1bml0cy5pbmRleE9mKHVuaXQpID49IDApIHtcbiAgICAgIGxvd2VzdE9yZGVyID0gdW5pdDtcblxuICAgICAgcmVzdWx0c1t1bml0XSA9IGRpZmZlcihjdXJzb3IsIGxhdGVyKTtcbiAgICAgIGhpZ2hXYXRlciA9IGVhcmxpZXIucGx1cyhyZXN1bHRzKTtcblxuICAgICAgaWYgKGhpZ2hXYXRlciA+IGxhdGVyKSB7XG4gICAgICAgIC8vIHdlIG92ZXJzaG90IHRoZSBlbmQgcG9pbnQsIGJhY2t0cmFjayBjdXJzb3IgYnkgMVxuICAgICAgICByZXN1bHRzW3VuaXRdLS07XG4gICAgICAgIGN1cnNvciA9IGVhcmxpZXIucGx1cyhyZXN1bHRzKTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmUgc3RpbGwgb3ZlcnNob290aW5nIG5vdywgd2UgbmVlZCB0byBiYWNrdHJhY2sgYWdhaW5cbiAgICAgICAgLy8gdGhpcyBoYXBwZW5zIGluIGNlcnRhaW4gc2l0dWF0aW9ucyB3aGVuIGRpZmZpbmcgdGltZXMgaW4gZGlmZmVyZW50IHpvbmVzLFxuICAgICAgICAvLyBiZWNhdXNlIHRoaXMgY2FsY3VsYXRpb24gaWdub3JlcyB0aW1lIHpvbmVzXG4gICAgICAgIGlmIChjdXJzb3IgPiBsYXRlcikge1xuICAgICAgICAgIC8vIGtlZXAgdGhlIFwib3ZlcnNob3QgYnkgMVwiIGFyb3VuZCBhcyBoaWdoV2F0ZXJcbiAgICAgICAgICBoaWdoV2F0ZXIgPSBjdXJzb3I7XG4gICAgICAgICAgLy8gYmFja3RyYWNrIGN1cnNvciBieSAxXG4gICAgICAgICAgcmVzdWx0c1t1bml0XS0tO1xuICAgICAgICAgIGN1cnNvciA9IGVhcmxpZXIucGx1cyhyZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yID0gaGlnaFdhdGVyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbY3Vyc29yLCByZXN1bHRzLCBoaWdoV2F0ZXIsIGxvd2VzdE9yZGVyXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGVhcmxpZXIsIGxhdGVyLCB1bml0cywgb3B0cykge1xuICBsZXQgW2N1cnNvciwgcmVzdWx0cywgaGlnaFdhdGVyLCBsb3dlc3RPcmRlcl0gPSBoaWdoT3JkZXJEaWZmcyhlYXJsaWVyLCBsYXRlciwgdW5pdHMpO1xuXG4gIGNvbnN0IHJlbWFpbmluZ01pbGxpcyA9IGxhdGVyIC0gY3Vyc29yO1xuXG4gIGNvbnN0IGxvd2VyT3JkZXJVbml0cyA9IHVuaXRzLmZpbHRlcihcbiAgICAodSkgPT4gW1wiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiXS5pbmRleE9mKHUpID49IDBcbiAgKTtcblxuICBpZiAobG93ZXJPcmRlclVuaXRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChoaWdoV2F0ZXIgPCBsYXRlcikge1xuICAgICAgaGlnaFdhdGVyID0gY3Vyc29yLnBsdXMoeyBbbG93ZXN0T3JkZXJdOiAxIH0pO1xuICAgIH1cblxuICAgIGlmIChoaWdoV2F0ZXIgIT09IGN1cnNvcikge1xuICAgICAgcmVzdWx0c1tsb3dlc3RPcmRlcl0gPSAocmVzdWx0c1tsb3dlc3RPcmRlcl0gfHwgMCkgKyByZW1haW5pbmdNaWxsaXMgLyAoaGlnaFdhdGVyIC0gY3Vyc29yKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkdXJhdGlvbiA9IER1cmF0aW9uLmZyb21PYmplY3QocmVzdWx0cywgb3B0cyk7XG5cbiAgaWYgKGxvd2VyT3JkZXJVbml0cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIER1cmF0aW9uLmZyb21NaWxsaXMocmVtYWluaW5nTWlsbGlzLCBvcHRzKVxuICAgICAgLnNoaWZ0VG8oLi4ubG93ZXJPcmRlclVuaXRzKVxuICAgICAgLnBsdXMoZHVyYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkdXJhdGlvbjtcbiAgfVxufVxuIiwgImNvbnN0IG51bWJlcmluZ1N5c3RlbXMgPSB7XG4gIGFyYWI6IFwiW1xcdTA2NjAtXFx1MDY2OV1cIixcbiAgYXJhYmV4dDogXCJbXFx1MDZGMC1cXHUwNkY5XVwiLFxuICBiYWxpOiBcIltcXHUxQjUwLVxcdTFCNTldXCIsXG4gIGJlbmc6IFwiW1xcdTA5RTYtXFx1MDlFRl1cIixcbiAgZGV2YTogXCJbXFx1MDk2Ni1cXHUwOTZGXVwiLFxuICBmdWxsd2lkZTogXCJbXFx1RkYxMC1cXHVGRjE5XVwiLFxuICBndWpyOiBcIltcXHUwQUU2LVxcdTBBRUZdXCIsXG4gIGhhbmlkZWM6IFwiW+OAh3zkuIB85LqMfOS4iXzlm5t85LqUfOWFrXzkuIN85YWrfOS5nV1cIixcbiAga2htcjogXCJbXFx1MTdFMC1cXHUxN0U5XVwiLFxuICBrbmRhOiBcIltcXHUwQ0U2LVxcdTBDRUZdXCIsXG4gIGxhb286IFwiW1xcdTBFRDAtXFx1MEVEOV1cIixcbiAgbGltYjogXCJbXFx1MTk0Ni1cXHUxOTRGXVwiLFxuICBtbHltOiBcIltcXHUwRDY2LVxcdTBENkZdXCIsXG4gIG1vbmc6IFwiW1xcdTE4MTAtXFx1MTgxOV1cIixcbiAgbXltcjogXCJbXFx1MTA0MC1cXHUxMDQ5XVwiLFxuICBvcnlhOiBcIltcXHUwQjY2LVxcdTBCNkZdXCIsXG4gIHRhbWxkZWM6IFwiW1xcdTBCRTYtXFx1MEJFRl1cIixcbiAgdGVsdTogXCJbXFx1MEM2Ni1cXHUwQzZGXVwiLFxuICB0aGFpOiBcIltcXHUwRTUwLVxcdTBFNTldXCIsXG4gIHRpYnQ6IFwiW1xcdTBGMjAtXFx1MEYyOV1cIixcbiAgbGF0bjogXCJcXFxcZFwiLFxufTtcblxuY29uc3QgbnVtYmVyaW5nU3lzdGVtc1VURjE2ID0ge1xuICBhcmFiOiBbMTYzMiwgMTY0MV0sXG4gIGFyYWJleHQ6IFsxNzc2LCAxNzg1XSxcbiAgYmFsaTogWzY5OTIsIDcwMDFdLFxuICBiZW5nOiBbMjUzNCwgMjU0M10sXG4gIGRldmE6IFsyNDA2LCAyNDE1XSxcbiAgZnVsbHdpZGU6IFs2NTI5NiwgNjUzMDNdLFxuICBndWpyOiBbMjc5MCwgMjc5OV0sXG4gIGtobXI6IFs2MTEyLCA2MTIxXSxcbiAga25kYTogWzMzMDIsIDMzMTFdLFxuICBsYW9vOiBbMzc5MiwgMzgwMV0sXG4gIGxpbWI6IFs2NDcwLCA2NDc5XSxcbiAgbWx5bTogWzM0MzAsIDM0MzldLFxuICBtb25nOiBbNjE2MCwgNjE2OV0sXG4gIG15bXI6IFs0MTYwLCA0MTY5XSxcbiAgb3J5YTogWzI5MTgsIDI5MjddLFxuICB0YW1sZGVjOiBbMzA0NiwgMzA1NV0sXG4gIHRlbHU6IFszMTc0LCAzMTgzXSxcbiAgdGhhaTogWzM2NjQsIDM2NzNdLFxuICB0aWJ0OiBbMzg3MiwgMzg4MV0sXG59O1xuXG5jb25zdCBoYW5pZGVjQ2hhcnMgPSBudW1iZXJpbmdTeXN0ZW1zLmhhbmlkZWMucmVwbGFjZSgvW1xcW3xcXF1dL2csIFwiXCIpLnNwbGl0KFwiXCIpO1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VEaWdpdHMoc3RyKSB7XG4gIGxldCB2YWx1ZSA9IHBhcnNlSW50KHN0ciwgMTApO1xuICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgdmFsdWUgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgIGlmIChzdHJbaV0uc2VhcmNoKG51bWJlcmluZ1N5c3RlbXMuaGFuaWRlYykgIT09IC0xKSB7XG4gICAgICAgIHZhbHVlICs9IGhhbmlkZWNDaGFycy5pbmRleE9mKHN0cltpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBudW1iZXJpbmdTeXN0ZW1zVVRGMTYpIHtcbiAgICAgICAgICBjb25zdCBbbWluLCBtYXhdID0gbnVtYmVyaW5nU3lzdGVtc1VURjE2W2tleV07XG4gICAgICAgICAgaWYgKGNvZGUgPj0gbWluICYmIGNvZGUgPD0gbWF4KSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBjb2RlIC0gbWluO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpZ2l0UmVnZXgoeyBudW1iZXJpbmdTeXN0ZW0gfSwgYXBwZW5kID0gXCJcIikge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgJHtudW1iZXJpbmdTeXN0ZW1zW251bWJlcmluZ1N5c3RlbSB8fCBcImxhdG5cIl19JHthcHBlbmR9YCk7XG59XG4iLCAiaW1wb3J0IHsgcGFyc2VNaWxsaXMsIGlzVW5kZWZpbmVkLCB1bnRydW5jYXRlWWVhciwgc2lnbmVkT2Zmc2V0LCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vZm9ybWF0dGVyLmpzXCI7XG5pbXBvcnQgRml4ZWRPZmZzZXRab25lIGZyb20gXCIuLi96b25lcy9maXhlZE9mZnNldFpvbmUuanNcIjtcbmltcG9ydCBJQU5BWm9uZSBmcm9tIFwiLi4vem9uZXMvSUFOQVpvbmUuanNcIjtcbmltcG9ydCBEYXRlVGltZSBmcm9tIFwiLi4vZGF0ZXRpbWUuanNcIjtcbmltcG9ydCB7IGRpZ2l0UmVnZXgsIHBhcnNlRGlnaXRzIH0gZnJvbSBcIi4vZGlnaXRzLmpzXCI7XG5pbXBvcnQgeyBDb25mbGljdGluZ1NwZWNpZmljYXRpb25FcnJvciB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcblxuY29uc3QgTUlTU0lOR19GVFAgPSBcIm1pc3NpbmcgSW50bC5EYXRlVGltZUZvcm1hdC5mb3JtYXRUb1BhcnRzIHN1cHBvcnRcIjtcblxuZnVuY3Rpb24gaW50VW5pdChyZWdleCwgcG9zdCA9IChpKSA9PiBpKSB7XG4gIHJldHVybiB7IHJlZ2V4LCBkZXNlcjogKFtzXSkgPT4gcG9zdChwYXJzZURpZ2l0cyhzKSkgfTtcbn1cblxuY29uc3QgTkJTUCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTYwKTtcbmNvbnN0IHNwYWNlT3JOQlNQID0gYFsgJHtOQlNQfV1gO1xuY29uc3Qgc3BhY2VPck5CU1BSZWdFeHAgPSBuZXcgUmVnRXhwKHNwYWNlT3JOQlNQLCBcImdcIik7XG5cbmZ1bmN0aW9uIGZpeExpc3RSZWdleChzKSB7XG4gIC8vIG1ha2UgZG90cyBvcHRpb25hbCBhbmQgYWxzbyBtYWtlIHRoZW0gbGl0ZXJhbFxuICAvLyBtYWtlIHNwYWNlIGFuZCBub24gYnJlYWthYmxlIHNwYWNlIGNoYXJhY3RlcnMgaW50ZXJjaGFuZ2VhYmxlXG4gIHJldHVybiBzLnJlcGxhY2UoL1xcLi9nLCBcIlxcXFwuP1wiKS5yZXBsYWNlKHNwYWNlT3JOQlNQUmVnRXhwLCBzcGFjZU9yTkJTUCk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpIHtcbiAgcmV0dXJuIHNcbiAgICAucmVwbGFjZSgvXFwuL2csIFwiXCIpIC8vIGlnbm9yZSBkb3RzIHRoYXQgd2VyZSBtYWRlIG9wdGlvbmFsXG4gICAgLnJlcGxhY2Uoc3BhY2VPck5CU1BSZWdFeHAsIFwiIFwiKSAvLyBpbnRlcmNoYW5nZSBzcGFjZSBhbmQgbmJzcFxuICAgIC50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBvbmVPZihzdHJpbmdzLCBzdGFydEluZGV4KSB7XG4gIGlmIChzdHJpbmdzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2V4OiBSZWdFeHAoc3RyaW5ncy5tYXAoZml4TGlzdFJlZ2V4KS5qb2luKFwifFwiKSksXG4gICAgICBkZXNlcjogKFtzXSkgPT5cbiAgICAgICAgc3RyaW5ncy5maW5kSW5kZXgoKGkpID0+IHN0cmlwSW5zZW5zaXRpdml0aWVzKHMpID09PSBzdHJpcEluc2Vuc2l0aXZpdGllcyhpKSkgKyBzdGFydEluZGV4LFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gb2Zmc2V0KHJlZ2V4LCBncm91cHMpIHtcbiAgcmV0dXJuIHsgcmVnZXgsIGRlc2VyOiAoWywgaCwgbV0pID0+IHNpZ25lZE9mZnNldChoLCBtKSwgZ3JvdXBzIH07XG59XG5cbmZ1bmN0aW9uIHNpbXBsZShyZWdleCkge1xuICByZXR1cm4geyByZWdleCwgZGVzZXI6IChbc10pID0+IHMgfTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlVG9rZW4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXC1cXFtcXF17fSgpKis/LixcXFxcXFxeJHwjXFxzXS9nLCBcIlxcXFwkJlwiKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gdG9rZW5cbiAqIEBwYXJhbSB7TG9jYWxlfSBsb2NcbiAqL1xuZnVuY3Rpb24gdW5pdEZvclRva2VuKHRva2VuLCBsb2MpIHtcbiAgY29uc3Qgb25lID0gZGlnaXRSZWdleChsb2MpLFxuICAgIHR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsyfVwiKSxcbiAgICB0aHJlZSA9IGRpZ2l0UmVnZXgobG9jLCBcInszfVwiKSxcbiAgICBmb3VyID0gZGlnaXRSZWdleChsb2MsIFwiezR9XCIpLFxuICAgIHNpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns2fVwiKSxcbiAgICBvbmVPclR3byA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDJ9XCIpLFxuICAgIG9uZVRvVGhyZWUgPSBkaWdpdFJlZ2V4KGxvYywgXCJ7MSwzfVwiKSxcbiAgICBvbmVUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDZ9XCIpLFxuICAgIG9uZVRvTmluZSA9IGRpZ2l0UmVnZXgobG9jLCBcInsxLDl9XCIpLFxuICAgIHR3b1RvRm91ciA9IGRpZ2l0UmVnZXgobG9jLCBcInsyLDR9XCIpLFxuICAgIGZvdXJUb1NpeCA9IGRpZ2l0UmVnZXgobG9jLCBcIns0LDZ9XCIpLFxuICAgIGxpdGVyYWwgPSAodCkgPT4gKHsgcmVnZXg6IFJlZ0V4cChlc2NhcGVUb2tlbih0LnZhbCkpLCBkZXNlcjogKFtzXSkgPT4gcywgbGl0ZXJhbDogdHJ1ZSB9KSxcbiAgICB1bml0YXRlID0gKHQpID0+IHtcbiAgICAgIGlmICh0b2tlbi5saXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBsaXRlcmFsKHQpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0LnZhbCkge1xuICAgICAgICAvLyBlcmFcbiAgICAgICAgY2FzZSBcIkdcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLmVyYXMoXCJzaG9ydFwiKSwgMCk7XG4gICAgICAgIGNhc2UgXCJHR1wiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MuZXJhcyhcImxvbmdcIiksIDApO1xuICAgICAgICAvLyB5ZWFyc1xuICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvU2l4KTtcbiAgICAgICAgY2FzZSBcInl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvVG9Gb3VyLCB1bnRydW5jYXRlWWVhcik7XG4gICAgICAgIGNhc2UgXCJ5eXl5XCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQoZm91cik7XG4gICAgICAgIGNhc2UgXCJ5eXl5eVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KGZvdXJUb1NpeCk7XG4gICAgICAgIGNhc2UgXCJ5eXl5eXlcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChzaXgpO1xuICAgICAgICAvLyBtb250aHNcbiAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJNTVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJNTU1cIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcInNob3J0XCIsIHRydWUpLCAxKTtcbiAgICAgICAgY2FzZSBcIk1NTU1cIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcImxvbmdcIiwgdHJ1ZSksIDEpO1xuICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcIkxMXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIkxMTFwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubW9udGhzKFwic2hvcnRcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkxMTExcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLm1vbnRocyhcImxvbmdcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgLy8gZGF0ZXNcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJkZFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIC8vIG9yZGluYWxzXG4gICAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lVG9UaHJlZSk7XG4gICAgICAgIGNhc2UgXCJvb29cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0aHJlZSk7XG4gICAgICAgIC8vIHRpbWVcbiAgICAgICAgY2FzZSBcIkhIXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvKTtcbiAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJoaFwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJoXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwibW1cIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZU9yVHdvKTtcbiAgICAgICAgY2FzZSBcInFcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJxcVwiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KHR3byk7XG4gICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwic3NcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZVRvVGhyZWUpO1xuICAgICAgICBjYXNlIFwiU1NTXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodGhyZWUpO1xuICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgIHJldHVybiBzaW1wbGUob25lVG9OaW5lKTtcbiAgICAgICAgY2FzZSBcInV1XCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZShvbmVPclR3byk7XG4gICAgICAgIGNhc2UgXCJ1dXVcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChvbmUpO1xuICAgICAgICAvLyBtZXJpZGllbVxuICAgICAgICBjYXNlIFwiYVwiOlxuICAgICAgICAgIHJldHVybiBvbmVPZihsb2MubWVyaWRpZW1zKCksIDApO1xuICAgICAgICAvLyB3ZWVrWWVhciAoaylcbiAgICAgICAgY2FzZSBcImtra2tcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdChmb3VyKTtcbiAgICAgICAgY2FzZSBcImtrXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQodHdvVG9Gb3VyLCB1bnRydW5jYXRlWWVhcik7XG4gICAgICAgIC8vIHdlZWtOdW1iZXIgKFcpXG4gICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgcmV0dXJuIGludFVuaXQob25lT3JUd28pO1xuICAgICAgICBjYXNlIFwiV1dcIjpcbiAgICAgICAgICByZXR1cm4gaW50VW5pdCh0d28pO1xuICAgICAgICAvLyB3ZWVrZGF5c1xuICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgIHJldHVybiBpbnRVbml0KG9uZSk7XG4gICAgICAgIGNhc2UgXCJFRUVcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwic2hvcnRcIiwgZmFsc2UpLCAxKTtcbiAgICAgICAgY2FzZSBcIkVFRUVcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwibG9uZ1wiLCBmYWxzZSksIDEpO1xuICAgICAgICBjYXNlIFwiY2NjXCI6XG4gICAgICAgICAgcmV0dXJuIG9uZU9mKGxvYy53ZWVrZGF5cyhcInNob3J0XCIsIHRydWUpLCAxKTtcbiAgICAgICAgY2FzZSBcImNjY2NcIjpcbiAgICAgICAgICByZXR1cm4gb25lT2YobG9jLndlZWtkYXlzKFwibG9uZ1wiLCB0cnVlKSwgMSk7XG4gICAgICAgIC8vIG9mZnNldC96b25lXG4gICAgICAgIGNhc2UgXCJaXCI6XG4gICAgICAgIGNhc2UgXCJaWlwiOlxuICAgICAgICAgIHJldHVybiBvZmZzZXQobmV3IFJlZ0V4cChgKFsrLV0ke29uZU9yVHdvLnNvdXJjZX0pKD86Oigke3R3by5zb3VyY2V9KSk/YCksIDIpO1xuICAgICAgICBjYXNlIFwiWlpaXCI6XG4gICAgICAgICAgcmV0dXJuIG9mZnNldChuZXcgUmVnRXhwKGAoWystXSR7b25lT3JUd28uc291cmNlfSkoJHt0d28uc291cmNlfSk/YCksIDIpO1xuICAgICAgICAvLyB3ZSBkb24ndCBzdXBwb3J0IFpaWlogKFBTVCkgb3IgWlpaWlogKFBhY2lmaWMgU3RhbmRhcmQgVGltZSkgaW4gcGFyc2luZ1xuICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IGhhdmUgYW55IHdheSB0byBmaWd1cmUgb3V0IHdoYXQgdGhleSBhcmVcbiAgICAgICAgY2FzZSBcInpcIjpcbiAgICAgICAgICByZXR1cm4gc2ltcGxlKC9bYS16XystL117MSwyNTZ9Py9pKTtcbiAgICAgICAgLy8gdGhpcyBzcGVjaWFsLWNhc2UgXCJ0b2tlblwiIHJlcHJlc2VudHMgYSBwbGFjZSB3aGVyZSBhIG1hY3JvLXRva2VuIGV4cGFuZGVkIGludG8gYSB3aGl0ZS1zcGFjZSBsaXRlcmFsXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB3ZSBhY2NlcHQgYW55IG5vbi1uZXdsaW5lIHdoaXRlLXNwYWNlXG4gICAgICAgIGNhc2UgXCIgXCI6XG4gICAgICAgICAgcmV0dXJuIHNpbXBsZSgvW15cXFNcXG5cXHJdLyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGxpdGVyYWwodCk7XG4gICAgICB9XG4gICAgfTtcblxuICBjb25zdCB1bml0ID0gdW5pdGF0ZSh0b2tlbikgfHwge1xuICAgIGludmFsaWRSZWFzb246IE1JU1NJTkdfRlRQLFxuICB9O1xuXG4gIHVuaXQudG9rZW4gPSB0b2tlbjtcblxuICByZXR1cm4gdW5pdDtcbn1cblxuY29uc3QgcGFydFR5cGVTdHlsZVRvVG9rZW5WYWwgPSB7XG4gIHllYXI6IHtcbiAgICBcIjItZGlnaXRcIjogXCJ5eVwiLFxuICAgIG51bWVyaWM6IFwieXl5eXlcIixcbiAgfSxcbiAgbW9udGg6IHtcbiAgICBudW1lcmljOiBcIk1cIixcbiAgICBcIjItZGlnaXRcIjogXCJNTVwiLFxuICAgIHNob3J0OiBcIk1NTVwiLFxuICAgIGxvbmc6IFwiTU1NTVwiLFxuICB9LFxuICBkYXk6IHtcbiAgICBudW1lcmljOiBcImRcIixcbiAgICBcIjItZGlnaXRcIjogXCJkZFwiLFxuICB9LFxuICB3ZWVrZGF5OiB7XG4gICAgc2hvcnQ6IFwiRUVFXCIsXG4gICAgbG9uZzogXCJFRUVFXCIsXG4gIH0sXG4gIGRheXBlcmlvZDogXCJhXCIsXG4gIGRheVBlcmlvZDogXCJhXCIsXG4gIGhvdXIxMjoge1xuICAgIG51bWVyaWM6IFwiaFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcImhoXCIsXG4gIH0sXG4gIGhvdXIyNDoge1xuICAgIG51bWVyaWM6IFwiSFwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIkhIXCIsXG4gIH0sXG4gIG1pbnV0ZToge1xuICAgIG51bWVyaWM6IFwibVwiLFxuICAgIFwiMi1kaWdpdFwiOiBcIm1tXCIsXG4gIH0sXG4gIHNlY29uZDoge1xuICAgIG51bWVyaWM6IFwic1wiLFxuICAgIFwiMi1kaWdpdFwiOiBcInNzXCIsXG4gIH0sXG4gIHRpbWVab25lTmFtZToge1xuICAgIGxvbmc6IFwiWlpaWlpcIixcbiAgICBzaG9ydDogXCJaWlpcIixcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRva2VuRm9yUGFydChwYXJ0LCBmb3JtYXRPcHRzLCByZXNvbHZlZE9wdHMpIHtcbiAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gcGFydDtcblxuICBpZiAodHlwZSA9PT0gXCJsaXRlcmFsXCIpIHtcbiAgICBjb25zdCBpc1NwYWNlID0gL15cXHMrJC8udGVzdCh2YWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpdGVyYWw6ICFpc1NwYWNlLFxuICAgICAgdmFsOiBpc1NwYWNlID8gXCIgXCIgOiB2YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qgc3R5bGUgPSBmb3JtYXRPcHRzW3R5cGVdO1xuXG4gIC8vIFRoZSB1c2VyIG1pZ2h0IGhhdmUgZXhwbGljaXRseSBzcGVjaWZpZWQgaG91cjEyIG9yIGhvdXJDeWNsZVxuICAvLyBpZiBzbywgcmVzcGVjdCB0aGVpciBkZWNpc2lvblxuICAvLyBpZiBub3QsIHJlZmVyIGJhY2sgdG8gdGhlIHJlc29sdmVkT3B0cywgd2hpY2ggYXJlIGJhc2VkIG9uIHRoZSBsb2NhbGVcbiAgbGV0IGFjdHVhbFR5cGUgPSB0eXBlO1xuICBpZiAodHlwZSA9PT0gXCJob3VyXCIpIHtcbiAgICBpZiAoZm9ybWF0T3B0cy5ob3VyMTIgIT0gbnVsbCkge1xuICAgICAgYWN0dWFsVHlwZSA9IGZvcm1hdE9wdHMuaG91cjEyID8gXCJob3VyMTJcIiA6IFwiaG91cjI0XCI7XG4gICAgfSBlbHNlIGlmIChmb3JtYXRPcHRzLmhvdXJDeWNsZSAhPSBudWxsKSB7XG4gICAgICBpZiAoZm9ybWF0T3B0cy5ob3VyQ3ljbGUgPT09IFwiaDExXCIgfHwgZm9ybWF0T3B0cy5ob3VyQ3ljbGUgPT09IFwiaDEyXCIpIHtcbiAgICAgICAgYWN0dWFsVHlwZSA9IFwiaG91cjEyXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3R1YWxUeXBlID0gXCJob3VyMjRcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdG9rZW5zIG9ubHkgZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIDI0IGhvdXJzIG9yIG5vdCxcbiAgICAgIC8vIHNvIHdlIGRvIG5vdCBuZWVkIHRvIGNoZWNrIGhvdXJDeWNsZSBoZXJlLCB3aGljaCBpcyBsZXNzIHN1cHBvcnRlZCBhbnl3YXlzXG4gICAgICBhY3R1YWxUeXBlID0gcmVzb2x2ZWRPcHRzLmhvdXIxMiA/IFwiaG91cjEyXCIgOiBcImhvdXIyNFwiO1xuICAgIH1cbiAgfVxuICBsZXQgdmFsID0gcGFydFR5cGVTdHlsZVRvVG9rZW5WYWxbYWN0dWFsVHlwZV07XG4gIGlmICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgdmFsID0gdmFsW3N0eWxlXTtcbiAgfVxuXG4gIGlmICh2YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICB2YWwsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUmVnZXgodW5pdHMpIHtcbiAgY29uc3QgcmUgPSB1bml0cy5tYXAoKHUpID0+IHUucmVnZXgpLnJlZHVjZSgoZiwgcikgPT4gYCR7Zn0oJHtyLnNvdXJjZX0pYCwgXCJcIik7XG4gIHJldHVybiBbYF4ke3JlfSRgLCB1bml0c107XG59XG5cbmZ1bmN0aW9uIG1hdGNoKGlucHV0LCByZWdleCwgaGFuZGxlcnMpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGlucHV0Lm1hdGNoKHJlZ2V4KTtcblxuICBpZiAobWF0Y2hlcykge1xuICAgIGNvbnN0IGFsbCA9IHt9O1xuICAgIGxldCBtYXRjaEluZGV4ID0gMTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gaGFuZGxlcnMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShoYW5kbGVycywgaSkpIHtcbiAgICAgICAgY29uc3QgaCA9IGhhbmRsZXJzW2ldLFxuICAgICAgICAgIGdyb3VwcyA9IGguZ3JvdXBzID8gaC5ncm91cHMgKyAxIDogMTtcbiAgICAgICAgaWYgKCFoLmxpdGVyYWwgJiYgaC50b2tlbikge1xuICAgICAgICAgIGFsbFtoLnRva2VuLnZhbFswXV0gPSBoLmRlc2VyKG1hdGNoZXMuc2xpY2UobWF0Y2hJbmRleCwgbWF0Y2hJbmRleCArIGdyb3VwcykpO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoSW5kZXggKz0gZ3JvdXBzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW21hdGNoZXMsIGFsbF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFttYXRjaGVzLCB7fV07XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0ZVRpbWVGcm9tTWF0Y2hlcyhtYXRjaGVzKSB7XG4gIGNvbnN0IHRvRmllbGQgPSAodG9rZW4pID0+IHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICBjYXNlIFwiU1wiOlxuICAgICAgICByZXR1cm4gXCJtaWxsaXNlY29uZFwiO1xuICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgcmV0dXJuIFwic2Vjb25kXCI7XG4gICAgICBjYXNlIFwibVwiOlxuICAgICAgICByZXR1cm4gXCJtaW51dGVcIjtcbiAgICAgIGNhc2UgXCJoXCI6XG4gICAgICBjYXNlIFwiSFwiOlxuICAgICAgICByZXR1cm4gXCJob3VyXCI7XG4gICAgICBjYXNlIFwiZFwiOlxuICAgICAgICByZXR1cm4gXCJkYXlcIjtcbiAgICAgIGNhc2UgXCJvXCI6XG4gICAgICAgIHJldHVybiBcIm9yZGluYWxcIjtcbiAgICAgIGNhc2UgXCJMXCI6XG4gICAgICBjYXNlIFwiTVwiOlxuICAgICAgICByZXR1cm4gXCJtb250aFwiO1xuICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgcmV0dXJuIFwieWVhclwiO1xuICAgICAgY2FzZSBcIkVcIjpcbiAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgIHJldHVybiBcIndlZWtkYXlcIjtcbiAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgIHJldHVybiBcIndlZWtOdW1iZXJcIjtcbiAgICAgIGNhc2UgXCJrXCI6XG4gICAgICAgIHJldHVybiBcIndlZWtZZWFyXCI7XG4gICAgICBjYXNlIFwicVwiOlxuICAgICAgICByZXR1cm4gXCJxdWFydGVyXCI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgbGV0IHpvbmUgPSBudWxsO1xuICBsZXQgc3BlY2lmaWNPZmZzZXQ7XG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy56KSkge1xuICAgIHpvbmUgPSBJQU5BWm9uZS5jcmVhdGUobWF0Y2hlcy56KTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5aKSkge1xuICAgIGlmICghem9uZSkge1xuICAgICAgem9uZSA9IG5ldyBGaXhlZE9mZnNldFpvbmUobWF0Y2hlcy5aKTtcbiAgICB9XG4gICAgc3BlY2lmaWNPZmZzZXQgPSBtYXRjaGVzLlo7XG4gIH1cblxuICBpZiAoIWlzVW5kZWZpbmVkKG1hdGNoZXMucSkpIHtcbiAgICBtYXRjaGVzLk0gPSAobWF0Y2hlcy5xIC0gMSkgKiAzICsgMTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy5oKSkge1xuICAgIGlmIChtYXRjaGVzLmggPCAxMiAmJiBtYXRjaGVzLmEgPT09IDEpIHtcbiAgICAgIG1hdGNoZXMuaCArPSAxMjtcbiAgICB9IGVsc2UgaWYgKG1hdGNoZXMuaCA9PT0gMTIgJiYgbWF0Y2hlcy5hID09PSAwKSB7XG4gICAgICBtYXRjaGVzLmggPSAwO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtYXRjaGVzLkcgPT09IDAgJiYgbWF0Y2hlcy55KSB7XG4gICAgbWF0Y2hlcy55ID0gLW1hdGNoZXMueTtcbiAgfVxuXG4gIGlmICghaXNVbmRlZmluZWQobWF0Y2hlcy51KSkge1xuICAgIG1hdGNoZXMuUyA9IHBhcnNlTWlsbGlzKG1hdGNoZXMudSk7XG4gIH1cblxuICBjb25zdCB2YWxzID0gT2JqZWN0LmtleXMobWF0Y2hlcykucmVkdWNlKChyLCBrKSA9PiB7XG4gICAgY29uc3QgZiA9IHRvRmllbGQoayk7XG4gICAgaWYgKGYpIHtcbiAgICAgIHJbZl0gPSBtYXRjaGVzW2tdO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIFt2YWxzLCB6b25lLCBzcGVjaWZpY09mZnNldF07XG59XG5cbmxldCBkdW1teURhdGVUaW1lQ2FjaGUgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXREdW1teURhdGVUaW1lKCkge1xuICBpZiAoIWR1bW15RGF0ZVRpbWVDYWNoZSkge1xuICAgIGR1bW15RGF0ZVRpbWVDYWNoZSA9IERhdGVUaW1lLmZyb21NaWxsaXMoMTU1NTU1NTU1NTU1NSk7XG4gIH1cblxuICByZXR1cm4gZHVtbXlEYXRlVGltZUNhY2hlO1xufVxuXG5mdW5jdGlvbiBtYXliZUV4cGFuZE1hY3JvVG9rZW4odG9rZW4sIGxvY2FsZSkge1xuICBpZiAodG9rZW4ubGl0ZXJhbCkge1xuICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdE9wdHMgPSBGb3JtYXR0ZXIubWFjcm9Ub2tlblRvRm9ybWF0T3B0cyh0b2tlbi52YWwpO1xuICBjb25zdCB0b2tlbnMgPSBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgbG9jYWxlKTtcblxuICBpZiAodG9rZW5zID09IG51bGwgfHwgdG9rZW5zLmluY2x1ZGVzKHVuZGVmaW5lZCkpIHtcbiAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICByZXR1cm4gdG9rZW5zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kTWFjcm9Ub2tlbnModG9rZW5zLCBsb2NhbGUpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQoLi4udG9rZW5zLm1hcCgodCkgPT4gbWF5YmVFeHBhbmRNYWNyb1Rva2VuKHQsIGxvY2FsZSkpKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgdG9rZW5zID0gZXhwYW5kTWFjcm9Ub2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZvcm1hdCksIGxvY2FsZSksXG4gICAgdW5pdHMgPSB0b2tlbnMubWFwKCh0KSA9PiB1bml0Rm9yVG9rZW4odCwgbG9jYWxlKSksXG4gICAgZGlzcXVhbGlmeWluZ1VuaXQgPSB1bml0cy5maW5kKCh0KSA9PiB0LmludmFsaWRSZWFzb24pO1xuXG4gIGlmIChkaXNxdWFsaWZ5aW5nVW5pdCkge1xuICAgIHJldHVybiB7IGlucHV0LCB0b2tlbnMsIGludmFsaWRSZWFzb246IGRpc3F1YWxpZnlpbmdVbml0LmludmFsaWRSZWFzb24gfTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBbcmVnZXhTdHJpbmcsIGhhbmRsZXJzXSA9IGJ1aWxkUmVnZXgodW5pdHMpLFxuICAgICAgcmVnZXggPSBSZWdFeHAocmVnZXhTdHJpbmcsIFwiaVwiKSxcbiAgICAgIFtyYXdNYXRjaGVzLCBtYXRjaGVzXSA9IG1hdGNoKGlucHV0LCByZWdleCwgaGFuZGxlcnMpLFxuICAgICAgW3Jlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXRdID0gbWF0Y2hlc1xuICAgICAgICA/IGRhdGVUaW1lRnJvbU1hdGNoZXMobWF0Y2hlcylcbiAgICAgICAgOiBbbnVsbCwgbnVsbCwgdW5kZWZpbmVkXTtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkobWF0Y2hlcywgXCJhXCIpICYmIGhhc093blByb3BlcnR5KG1hdGNoZXMsIFwiSFwiKSkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFxuICAgICAgICBcIkNhbid0IGluY2x1ZGUgbWVyaWRpZW0gd2hlbiBzcGVjaWZ5aW5nIDI0LWhvdXIgZm9ybWF0XCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7IGlucHV0LCB0b2tlbnMsIHJlZ2V4LCByYXdNYXRjaGVzLCBtYXRjaGVzLCByZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0IH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpIHtcbiAgY29uc3QgeyByZXN1bHQsIHpvbmUsIHNwZWNpZmljT2Zmc2V0LCBpbnZhbGlkUmVhc29uIH0gPSBleHBsYWluRnJvbVRva2Vucyhsb2NhbGUsIGlucHV0LCBmb3JtYXQpO1xuICByZXR1cm4gW3Jlc3VsdCwgem9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRSZWFzb25dO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0T3B0c1RvVG9rZW5zKGZvcm1hdE9wdHMsIGxvY2FsZSkge1xuICBpZiAoIWZvcm1hdE9wdHMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGZvcm1hdHRlciA9IEZvcm1hdHRlci5jcmVhdGUobG9jYWxlLCBmb3JtYXRPcHRzKTtcbiAgY29uc3QgZGYgPSBmb3JtYXR0ZXIuZHRGb3JtYXR0ZXIoZ2V0RHVtbXlEYXRlVGltZSgpKTtcbiAgY29uc3QgcGFydHMgPSBkZi5mb3JtYXRUb1BhcnRzKCk7XG4gIGNvbnN0IHJlc29sdmVkT3B0cyA9IGRmLnJlc29sdmVkT3B0aW9ucygpO1xuICByZXR1cm4gcGFydHMubWFwKChwKSA9PiB0b2tlbkZvclBhcnQocCwgZm9ybWF0T3B0cywgcmVzb2x2ZWRPcHRzKSk7XG59XG4iLCAiaW1wb3J0IHtcbiAgaW50ZWdlckJldHdlZW4sXG4gIGlzTGVhcFllYXIsXG4gIHRpbWVPYmplY3QsXG4gIGRheXNJblllYXIsXG4gIGRheXNJbk1vbnRoLFxuICB3ZWVrc0luV2Vla1llYXIsXG4gIGlzSW50ZWdlcixcbn0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IEludmFsaWQgZnJvbSBcIi4vaW52YWxpZC5qc1wiO1xuXG5jb25zdCBub25MZWFwTGFkZGVyID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XSxcbiAgbGVhcExhZGRlciA9IFswLCAzMSwgNjAsIDkxLCAxMjEsIDE1MiwgMTgyLCAyMTMsIDI0NCwgMjc0LCAzMDUsIDMzNV07XG5cbmZ1bmN0aW9uIHVuaXRPdXRPZlJhbmdlKHVuaXQsIHZhbHVlKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcbiAgICBcInVuaXQgb3V0IG9mIHJhbmdlXCIsXG4gICAgYHlvdSBzcGVjaWZpZWQgJHt2YWx1ZX0gKG9mIHR5cGUgJHt0eXBlb2YgdmFsdWV9KSBhcyBhICR7dW5pdH0sIHdoaWNoIGlzIGludmFsaWRgXG4gICk7XG59XG5cbmZ1bmN0aW9uIGRheU9mV2Vlayh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIGNvbnN0IGQgPSBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSkpO1xuXG4gIGlmICh5ZWFyIDwgMTAwICYmIHllYXIgPj0gMCkge1xuICAgIGQuc2V0VVRDRnVsbFllYXIoZC5nZXRVVENGdWxsWWVhcigpIC0gMTkwMCk7XG4gIH1cblxuICBjb25zdCBqcyA9IGQuZ2V0VVRDRGF5KCk7XG5cbiAgcmV0dXJuIGpzID09PSAwID8gNyA6IGpzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlT3JkaW5hbCh5ZWFyLCBtb250aCwgZGF5KSB7XG4gIHJldHVybiBkYXkgKyAoaXNMZWFwWWVhcih5ZWFyKSA/IGxlYXBMYWRkZXIgOiBub25MZWFwTGFkZGVyKVttb250aCAtIDFdO1xufVxuXG5mdW5jdGlvbiB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpIHtcbiAgY29uc3QgdGFibGUgPSBpc0xlYXBZZWFyKHllYXIpID8gbGVhcExhZGRlciA6IG5vbkxlYXBMYWRkZXIsXG4gICAgbW9udGgwID0gdGFibGUuZmluZEluZGV4KChpKSA9PiBpIDwgb3JkaW5hbCksXG4gICAgZGF5ID0gb3JkaW5hbCAtIHRhYmxlW21vbnRoMF07XG4gIHJldHVybiB7IG1vbnRoOiBtb250aDAgKyAxLCBkYXkgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBncmVnb3JpYW5Ub1dlZWsoZ3JlZ09iaikge1xuICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGdyZWdPYmosXG4gICAgb3JkaW5hbCA9IGNvbXB1dGVPcmRpbmFsKHllYXIsIG1vbnRoLCBkYXkpLFxuICAgIHdlZWtkYXkgPSBkYXlPZldlZWsoeWVhciwgbW9udGgsIGRheSk7XG5cbiAgbGV0IHdlZWtOdW1iZXIgPSBNYXRoLmZsb29yKChvcmRpbmFsIC0gd2Vla2RheSArIDEwKSAvIDcpLFxuICAgIHdlZWtZZWFyO1xuXG4gIGlmICh3ZWVrTnVtYmVyIDwgMSkge1xuICAgIHdlZWtZZWFyID0geWVhciAtIDE7XG4gICAgd2Vla051bWJlciA9IHdlZWtzSW5XZWVrWWVhcih3ZWVrWWVhcik7XG4gIH0gZWxzZSBpZiAod2Vla051bWJlciA+IHdlZWtzSW5XZWVrWWVhcih5ZWFyKSkge1xuICAgIHdlZWtZZWFyID0geWVhciArIDE7XG4gICAgd2Vla051bWJlciA9IDE7XG4gIH0gZWxzZSB7XG4gICAgd2Vla1llYXIgPSB5ZWFyO1xuICB9XG5cbiAgcmV0dXJuIHsgd2Vla1llYXIsIHdlZWtOdW1iZXIsIHdlZWtkYXksIC4uLnRpbWVPYmplY3QoZ3JlZ09iaikgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdlZWtUb0dyZWdvcmlhbih3ZWVrRGF0YSkge1xuICBjb25zdCB7IHdlZWtZZWFyLCB3ZWVrTnVtYmVyLCB3ZWVrZGF5IH0gPSB3ZWVrRGF0YSxcbiAgICB3ZWVrZGF5T2ZKYW40ID0gZGF5T2ZXZWVrKHdlZWtZZWFyLCAxLCA0KSxcbiAgICB5ZWFySW5EYXlzID0gZGF5c0luWWVhcih3ZWVrWWVhcik7XG5cbiAgbGV0IG9yZGluYWwgPSB3ZWVrTnVtYmVyICogNyArIHdlZWtkYXkgLSB3ZWVrZGF5T2ZKYW40IC0gMyxcbiAgICB5ZWFyO1xuXG4gIGlmIChvcmRpbmFsIDwgMSkge1xuICAgIHllYXIgPSB3ZWVrWWVhciAtIDE7XG4gICAgb3JkaW5hbCArPSBkYXlzSW5ZZWFyKHllYXIpO1xuICB9IGVsc2UgaWYgKG9yZGluYWwgPiB5ZWFySW5EYXlzKSB7XG4gICAgeWVhciA9IHdlZWtZZWFyICsgMTtcbiAgICBvcmRpbmFsIC09IGRheXNJblllYXIod2Vla1llYXIpO1xuICB9IGVsc2Uge1xuICAgIHllYXIgPSB3ZWVrWWVhcjtcbiAgfVxuXG4gIGNvbnN0IHsgbW9udGgsIGRheSB9ID0gdW5jb21wdXRlT3JkaW5hbCh5ZWFyLCBvcmRpbmFsKTtcbiAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSwgLi4udGltZU9iamVjdCh3ZWVrRGF0YSkgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdyZWdvcmlhblRvT3JkaW5hbChncmVnRGF0YSkge1xuICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IGdyZWdEYXRhO1xuICBjb25zdCBvcmRpbmFsID0gY29tcHV0ZU9yZGluYWwoeWVhciwgbW9udGgsIGRheSk7XG4gIHJldHVybiB7IHllYXIsIG9yZGluYWwsIC4uLnRpbWVPYmplY3QoZ3JlZ0RhdGEpIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvcmRpbmFsVG9HcmVnb3JpYW4ob3JkaW5hbERhdGEpIHtcbiAgY29uc3QgeyB5ZWFyLCBvcmRpbmFsIH0gPSBvcmRpbmFsRGF0YTtcbiAgY29uc3QgeyBtb250aCwgZGF5IH0gPSB1bmNvbXB1dGVPcmRpbmFsKHllYXIsIG9yZGluYWwpO1xuICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5LCAuLi50aW1lT2JqZWN0KG9yZGluYWxEYXRhKSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZFdlZWtEYXRhKG9iaikge1xuICBjb25zdCB2YWxpZFllYXIgPSBpc0ludGVnZXIob2JqLndlZWtZZWFyKSxcbiAgICB2YWxpZFdlZWsgPSBpbnRlZ2VyQmV0d2VlbihvYmoud2Vla051bWJlciwgMSwgd2Vla3NJbldlZWtZZWFyKG9iai53ZWVrWWVhcikpLFxuICAgIHZhbGlkV2Vla2RheSA9IGludGVnZXJCZXR3ZWVuKG9iai53ZWVrZGF5LCAxLCA3KTtcblxuICBpZiAoIXZhbGlkWWVhcikge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtZZWFyXCIsIG9iai53ZWVrWWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkV2Vlaykge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIndlZWtcIiwgb2JqLndlZWspO1xuICB9IGVsc2UgaWYgKCF2YWxpZFdlZWtkYXkpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJ3ZWVrZGF5XCIsIG9iai53ZWVrZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRPcmRpbmFsRGF0YShvYmopIHtcbiAgY29uc3QgdmFsaWRZZWFyID0gaXNJbnRlZ2VyKG9iai55ZWFyKSxcbiAgICB2YWxpZE9yZGluYWwgPSBpbnRlZ2VyQmV0d2VlbihvYmoub3JkaW5hbCwgMSwgZGF5c0luWWVhcihvYmoueWVhcikpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkT3JkaW5hbCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm9yZGluYWxcIiwgb2JqLm9yZGluYWwpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB7XG4gIGNvbnN0IHZhbGlkWWVhciA9IGlzSW50ZWdlcihvYmoueWVhciksXG4gICAgdmFsaWRNb250aCA9IGludGVnZXJCZXR3ZWVuKG9iai5tb250aCwgMSwgMTIpLFxuICAgIHZhbGlkRGF5ID0gaW50ZWdlckJldHdlZW4ob2JqLmRheSwgMSwgZGF5c0luTW9udGgob2JqLnllYXIsIG9iai5tb250aCkpO1xuXG4gIGlmICghdmFsaWRZZWFyKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwieWVhclwiLCBvYmoueWVhcik7XG4gIH0gZWxzZSBpZiAoIXZhbGlkTW9udGgpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJtb250aFwiLCBvYmoubW9udGgpO1xuICB9IGVsc2UgaWYgKCF2YWxpZERheSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcImRheVwiLCBvYmouZGF5KTtcbiAgfSBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ludmFsaWRUaW1lRGF0YShvYmopIHtcbiAgY29uc3QgeyBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSA9IG9iajtcbiAgY29uc3QgdmFsaWRIb3VyID1cbiAgICAgIGludGVnZXJCZXR3ZWVuKGhvdXIsIDAsIDIzKSB8fFxuICAgICAgKGhvdXIgPT09IDI0ICYmIG1pbnV0ZSA9PT0gMCAmJiBzZWNvbmQgPT09IDAgJiYgbWlsbGlzZWNvbmQgPT09IDApLFxuICAgIHZhbGlkTWludXRlID0gaW50ZWdlckJldHdlZW4obWludXRlLCAwLCA1OSksXG4gICAgdmFsaWRTZWNvbmQgPSBpbnRlZ2VyQmV0d2VlbihzZWNvbmQsIDAsIDU5KSxcbiAgICB2YWxpZE1pbGxpc2Vjb25kID0gaW50ZWdlckJldHdlZW4obWlsbGlzZWNvbmQsIDAsIDk5OSk7XG5cbiAgaWYgKCF2YWxpZEhvdXIpIHtcbiAgICByZXR1cm4gdW5pdE91dE9mUmFuZ2UoXCJob3VyXCIsIGhvdXIpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbnV0ZSkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcIm1pbnV0ZVwiLCBtaW51dGUpO1xuICB9IGVsc2UgaWYgKCF2YWxpZFNlY29uZCkge1xuICAgIHJldHVybiB1bml0T3V0T2ZSYW5nZShcInNlY29uZFwiLCBzZWNvbmQpO1xuICB9IGVsc2UgaWYgKCF2YWxpZE1pbGxpc2Vjb25kKSB7XG4gICAgcmV0dXJuIHVuaXRPdXRPZlJhbmdlKFwibWlsbGlzZWNvbmRcIiwgbWlsbGlzZWNvbmQpO1xuICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuIiwgImltcG9ydCBEdXJhdGlvbiBmcm9tIFwiLi9kdXJhdGlvbi5qc1wiO1xuaW1wb3J0IEludGVydmFsIGZyb20gXCIuL2ludGVydmFsLmpzXCI7XG5pbXBvcnQgU2V0dGluZ3MgZnJvbSBcIi4vc2V0dGluZ3MuanNcIjtcbmltcG9ydCBJbmZvIGZyb20gXCIuL2luZm8uanNcIjtcbmltcG9ydCBGb3JtYXR0ZXIgZnJvbSBcIi4vaW1wbC9mb3JtYXR0ZXIuanNcIjtcbmltcG9ydCBGaXhlZE9mZnNldFpvbmUgZnJvbSBcIi4vem9uZXMvZml4ZWRPZmZzZXRab25lLmpzXCI7XG5pbXBvcnQgTG9jYWxlIGZyb20gXCIuL2ltcGwvbG9jYWxlLmpzXCI7XG5pbXBvcnQge1xuICBpc1VuZGVmaW5lZCxcbiAgbWF5YmVBcnJheSxcbiAgaXNEYXRlLFxuICBpc051bWJlcixcbiAgYmVzdEJ5LFxuICBkYXlzSW5Nb250aCxcbiAgZGF5c0luWWVhcixcbiAgaXNMZWFwWWVhcixcbiAgd2Vla3NJbldlZWtZZWFyLFxuICBub3JtYWxpemVPYmplY3QsXG4gIHJvdW5kVG8sXG4gIG9ialRvTG9jYWxUUyxcbiAgcGFkU3RhcnQsXG59IGZyb20gXCIuL2ltcGwvdXRpbC5qc1wiO1xuaW1wb3J0IHsgbm9ybWFsaXplWm9uZSB9IGZyb20gXCIuL2ltcGwvem9uZVV0aWwuanNcIjtcbmltcG9ydCBkaWZmIGZyb20gXCIuL2ltcGwvZGlmZi5qc1wiO1xuaW1wb3J0IHsgcGFyc2VSRkMyODIyRGF0ZSwgcGFyc2VJU09EYXRlLCBwYXJzZUhUVFBEYXRlLCBwYXJzZVNRTCB9IGZyb20gXCIuL2ltcGwvcmVnZXhQYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIHBhcnNlRnJvbVRva2VucyxcbiAgZXhwbGFpbkZyb21Ub2tlbnMsXG4gIGZvcm1hdE9wdHNUb1Rva2VucyxcbiAgZXhwYW5kTWFjcm9Ub2tlbnMsXG59IGZyb20gXCIuL2ltcGwvdG9rZW5QYXJzZXIuanNcIjtcbmltcG9ydCB7XG4gIGdyZWdvcmlhblRvV2VlayxcbiAgd2Vla1RvR3JlZ29yaWFuLFxuICBncmVnb3JpYW5Ub09yZGluYWwsXG4gIG9yZGluYWxUb0dyZWdvcmlhbixcbiAgaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEsXG4gIGhhc0ludmFsaWRXZWVrRGF0YSxcbiAgaGFzSW52YWxpZE9yZGluYWxEYXRhLFxuICBoYXNJbnZhbGlkVGltZURhdGEsXG59IGZyb20gXCIuL2ltcGwvY29udmVyc2lvbnMuanNcIjtcbmltcG9ydCAqIGFzIEZvcm1hdHMgZnJvbSBcIi4vaW1wbC9mb3JtYXRzLmpzXCI7XG5pbXBvcnQge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IsXG4gIEludmFsaWRVbml0RXJyb3IsXG4gIEludmFsaWREYXRlVGltZUVycm9yLFxufSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCBJbnZhbGlkIGZyb20gXCIuL2ltcGwvaW52YWxpZC5qc1wiO1xuXG5jb25zdCBJTlZBTElEID0gXCJJbnZhbGlkIERhdGVUaW1lXCI7XG5jb25zdCBNQVhfREFURSA9IDguNjRlMTU7XG5cbmZ1bmN0aW9uIHVuc3VwcG9ydGVkWm9uZSh6b25lKSB7XG4gIHJldHVybiBuZXcgSW52YWxpZChcInVuc3VwcG9ydGVkIHpvbmVcIiwgYHRoZSB6b25lIFwiJHt6b25lLm5hbWV9XCIgaXMgbm90IHN1cHBvcnRlZGApO1xufVxuXG4vLyB3ZSBjYWNoZSB3ZWVrIGRhdGEgb24gdGhlIERUIG9iamVjdCBhbmQgdGhpcyBpbnRlcm1lZGlhdGVzIHRoZSBjYWNoZVxuZnVuY3Rpb24gcG9zc2libHlDYWNoZWRXZWVrRGF0YShkdCkge1xuICBpZiAoZHQud2Vla0RhdGEgPT09IG51bGwpIHtcbiAgICBkdC53ZWVrRGF0YSA9IGdyZWdvcmlhblRvV2VlayhkdC5jKTtcbiAgfVxuICByZXR1cm4gZHQud2Vla0RhdGE7XG59XG5cbi8vIGNsb25lIHJlYWxseSBtZWFucywgXCJtYWtlIGEgbmV3IG9iamVjdCB3aXRoIHRoZXNlIG1vZGlmaWNhdGlvbnNcIi4gYWxsIFwic2V0dGVyc1wiIHJlYWxseSB1c2UgdGhpc1xuLy8gdG8gY3JlYXRlIGEgbmV3IG9iamVjdCB3aGlsZSBvbmx5IGNoYW5naW5nIHNvbWUgb2YgdGhlIHByb3BlcnRpZXNcbmZ1bmN0aW9uIGNsb25lKGluc3QsIGFsdHMpIHtcbiAgY29uc3QgY3VycmVudCA9IHtcbiAgICB0czogaW5zdC50cyxcbiAgICB6b25lOiBpbnN0LnpvbmUsXG4gICAgYzogaW5zdC5jLFxuICAgIG86IGluc3QubyxcbiAgICBsb2M6IGluc3QubG9jLFxuICAgIGludmFsaWQ6IGluc3QuaW52YWxpZCxcbiAgfTtcbiAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IC4uLmN1cnJlbnQsIC4uLmFsdHMsIG9sZDogY3VycmVudCB9KTtcbn1cblxuLy8gZmluZCB0aGUgcmlnaHQgb2Zmc2V0IGEgZ2l2ZW4gbG9jYWwgdGltZS4gVGhlIG8gaW5wdXQgaXMgb3VyIGd1ZXNzLCB3aGljaCBkZXRlcm1pbmVzIHdoaWNoXG4vLyBvZmZzZXQgd2UnbGwgcGljayBpbiBhbWJpZ3VvdXMgY2FzZXMgKGUuZy4gdGhlcmUgYXJlIHR3byAzIEFNcyBiL2MgRmFsbGJhY2sgRFNUKVxuZnVuY3Rpb24gZml4T2Zmc2V0KGxvY2FsVFMsIG8sIHR6KSB7XG4gIC8vIE91ciBVVEMgdGltZSBpcyBqdXN0IGEgZ3Vlc3MgYmVjYXVzZSBvdXIgb2Zmc2V0IGlzIGp1c3QgYSBndWVzc1xuICBsZXQgdXRjR3Vlc3MgPSBsb2NhbFRTIC0gbyAqIDYwICogMTAwMDtcblxuICAvLyBUZXN0IHdoZXRoZXIgdGhlIHpvbmUgbWF0Y2hlcyB0aGUgb2Zmc2V0IGZvciB0aGlzIHRzXG4gIGNvbnN0IG8yID0gdHoub2Zmc2V0KHV0Y0d1ZXNzKTtcblxuICAvLyBJZiBzbywgb2Zmc2V0IGRpZG4ndCBjaGFuZ2UgYW5kIHdlJ3JlIGRvbmVcbiAgaWYgKG8gPT09IG8yKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgb107XG4gIH1cblxuICAvLyBJZiBub3QsIGNoYW5nZSB0aGUgdHMgYnkgdGhlIGRpZmZlcmVuY2UgaW4gdGhlIG9mZnNldFxuICB1dGNHdWVzcyAtPSAobzIgLSBvKSAqIDYwICogMTAwMDtcblxuICAvLyBJZiB0aGF0IGdpdmVzIHVzIHRoZSBsb2NhbCB0aW1lIHdlIHdhbnQsIHdlJ3JlIGRvbmVcbiAgY29uc3QgbzMgPSB0ei5vZmZzZXQodXRjR3Vlc3MpO1xuICBpZiAobzIgPT09IG8zKSB7XG4gICAgcmV0dXJuIFt1dGNHdWVzcywgbzJdO1xuICB9XG5cbiAgLy8gSWYgaXQncyBkaWZmZXJlbnQsIHdlJ3JlIGluIGEgaG9sZSB0aW1lLiBUaGUgb2Zmc2V0IGhhcyBjaGFuZ2VkLCBidXQgdGhlIHdlIGRvbid0IGFkanVzdCB0aGUgdGltZVxuICByZXR1cm4gW2xvY2FsVFMgLSBNYXRoLm1pbihvMiwgbzMpICogNjAgKiAxMDAwLCBNYXRoLm1heChvMiwgbzMpXTtcbn1cblxuLy8gY29udmVydCBhbiBlcG9jaCB0aW1lc3RhbXAgaW50byBhIGNhbGVuZGFyIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBvZmZzZXRcbmZ1bmN0aW9uIHRzVG9PYmoodHMsIG9mZnNldCkge1xuICB0cyArPSBvZmZzZXQgKiA2MCAqIDEwMDA7XG5cbiAgY29uc3QgZCA9IG5ldyBEYXRlKHRzKTtcblxuICByZXR1cm4ge1xuICAgIHllYXI6IGQuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICBtb250aDogZC5nZXRVVENNb250aCgpICsgMSxcbiAgICBkYXk6IGQuZ2V0VVRDRGF0ZSgpLFxuICAgIGhvdXI6IGQuZ2V0VVRDSG91cnMoKSxcbiAgICBtaW51dGU6IGQuZ2V0VVRDTWludXRlcygpLFxuICAgIHNlY29uZDogZC5nZXRVVENTZWNvbmRzKCksXG4gICAgbWlsbGlzZWNvbmQ6IGQuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gIH07XG59XG5cbi8vIGNvbnZlcnQgYSBjYWxlbmRhciBvYmplY3QgdG8gYSBlcG9jaCB0aW1lc3RhbXBcbmZ1bmN0aW9uIG9ialRvVFMob2JqLCBvZmZzZXQsIHpvbmUpIHtcbiAgcmV0dXJuIGZpeE9mZnNldChvYmpUb0xvY2FsVFMob2JqKSwgb2Zmc2V0LCB6b25lKTtcbn1cblxuLy8gY3JlYXRlIGEgbmV3IERUIGluc3RhbmNlIGJ5IGFkZGluZyBhIGR1cmF0aW9uLCBhZGp1c3RpbmcgZm9yIERTVHNcbmZ1bmN0aW9uIGFkanVzdFRpbWUoaW5zdCwgZHVyKSB7XG4gIGNvbnN0IG9QcmUgPSBpbnN0Lm8sXG4gICAgeWVhciA9IGluc3QuYy55ZWFyICsgTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgIG1vbnRoID0gaW5zdC5jLm1vbnRoICsgTWF0aC50cnVuYyhkdXIubW9udGhzKSArIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSAqIDMsXG4gICAgYyA9IHtcbiAgICAgIC4uLmluc3QuYyxcbiAgICAgIHllYXIsXG4gICAgICBtb250aCxcbiAgICAgIGRheTpcbiAgICAgICAgTWF0aC5taW4oaW5zdC5jLmRheSwgZGF5c0luTW9udGgoeWVhciwgbW9udGgpKSArXG4gICAgICAgIE1hdGgudHJ1bmMoZHVyLmRheXMpICtcbiAgICAgICAgTWF0aC50cnVuYyhkdXIud2Vla3MpICogNyxcbiAgICB9LFxuICAgIG1pbGxpc1RvQWRkID0gRHVyYXRpb24uZnJvbU9iamVjdCh7XG4gICAgICB5ZWFyczogZHVyLnllYXJzIC0gTWF0aC50cnVuYyhkdXIueWVhcnMpLFxuICAgICAgcXVhcnRlcnM6IGR1ci5xdWFydGVycyAtIE1hdGgudHJ1bmMoZHVyLnF1YXJ0ZXJzKSxcbiAgICAgIG1vbnRoczogZHVyLm1vbnRocyAtIE1hdGgudHJ1bmMoZHVyLm1vbnRocyksXG4gICAgICB3ZWVrczogZHVyLndlZWtzIC0gTWF0aC50cnVuYyhkdXIud2Vla3MpLFxuICAgICAgZGF5czogZHVyLmRheXMgLSBNYXRoLnRydW5jKGR1ci5kYXlzKSxcbiAgICAgIGhvdXJzOiBkdXIuaG91cnMsXG4gICAgICBtaW51dGVzOiBkdXIubWludXRlcyxcbiAgICAgIHNlY29uZHM6IGR1ci5zZWNvbmRzLFxuICAgICAgbWlsbGlzZWNvbmRzOiBkdXIubWlsbGlzZWNvbmRzLFxuICAgIH0pLmFzKFwibWlsbGlzZWNvbmRzXCIpLFxuICAgIGxvY2FsVFMgPSBvYmpUb0xvY2FsVFMoYyk7XG5cbiAgbGV0IFt0cywgb10gPSBmaXhPZmZzZXQobG9jYWxUUywgb1ByZSwgaW5zdC56b25lKTtcblxuICBpZiAobWlsbGlzVG9BZGQgIT09IDApIHtcbiAgICB0cyArPSBtaWxsaXNUb0FkZDtcbiAgICAvLyB0aGF0IGNvdWxkIGhhdmUgY2hhbmdlZCB0aGUgb2Zmc2V0IGJ5IGdvaW5nIG92ZXIgYSBEU1QsIGJ1dCB3ZSB3YW50IHRvIGtlZXAgdGhlIHRzIHRoZSBzYW1lXG4gICAgbyA9IGluc3Quem9uZS5vZmZzZXQodHMpO1xuICB9XG5cbiAgcmV0dXJuIHsgdHMsIG8gfTtcbn1cblxuLy8gaGVscGVyIHVzZWZ1bCBpbiB0dXJuaW5nIHRoZSByZXN1bHRzIG9mIHBhcnNpbmcgaW50byByZWFsIGRhdGVzXG4vLyBieSBoYW5kbGluZyB0aGUgem9uZSBvcHRpb25zXG5mdW5jdGlvbiBwYXJzZURhdGFUb0RhdGVUaW1lKHBhcnNlZCwgcGFyc2VkWm9uZSwgb3B0cywgZm9ybWF0LCB0ZXh0LCBzcGVjaWZpY09mZnNldCkge1xuICBjb25zdCB7IHNldFpvbmUsIHpvbmUgfSA9IG9wdHM7XG4gIGlmICgocGFyc2VkICYmIE9iamVjdC5rZXlzKHBhcnNlZCkubGVuZ3RoICE9PSAwKSB8fCBwYXJzZWRab25lKSB7XG4gICAgY29uc3QgaW50ZXJwcmV0YXRpb25ab25lID0gcGFyc2VkWm9uZSB8fCB6b25lLFxuICAgICAgaW5zdCA9IERhdGVUaW1lLmZyb21PYmplY3QocGFyc2VkLCB7XG4gICAgICAgIC4uLm9wdHMsXG4gICAgICAgIHpvbmU6IGludGVycHJldGF0aW9uWm9uZSxcbiAgICAgICAgc3BlY2lmaWNPZmZzZXQsXG4gICAgICB9KTtcbiAgICByZXR1cm4gc2V0Wm9uZSA/IGluc3QgOiBpbnN0LnNldFpvbmUoem9uZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXG4gICAgICBuZXcgSW52YWxpZChcInVucGFyc2FibGVcIiwgYHRoZSBpbnB1dCBcIiR7dGV4dH1cIiBjYW4ndCBiZSBwYXJzZWQgYXMgJHtmb3JtYXR9YClcbiAgICApO1xuICB9XG59XG5cbi8vIGlmIHlvdSB3YW50IHRvIG91dHB1dCBhIHRlY2huaWNhbCBmb3JtYXQgKGUuZy4gUkZDIDI4MjIpLCB0aGlzIGhlbHBlclxuLy8gaGVscHMgaGFuZGxlIHRoZSBkZXRhaWxzXG5mdW5jdGlvbiB0b1RlY2hGb3JtYXQoZHQsIGZvcm1hdCwgYWxsb3daID0gdHJ1ZSkge1xuICByZXR1cm4gZHQuaXNWYWxpZFxuICAgID8gRm9ybWF0dGVyLmNyZWF0ZShMb2NhbGUuY3JlYXRlKFwiZW4tVVNcIiksIHtcbiAgICAgICAgYWxsb3daLFxuICAgICAgICBmb3JjZVNpbXBsZTogdHJ1ZSxcbiAgICAgIH0pLmZvcm1hdERhdGVUaW1lRnJvbVN0cmluZyhkdCwgZm9ybWF0KVxuICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9JU09EYXRlKG8sIGV4dGVuZGVkKSB7XG4gIGNvbnN0IGxvbmdGb3JtYXQgPSBvLmMueWVhciA+IDk5OTkgfHwgby5jLnllYXIgPCAwO1xuICBsZXQgYyA9IFwiXCI7XG4gIGlmIChsb25nRm9ybWF0ICYmIG8uYy55ZWFyID49IDApIGMgKz0gXCIrXCI7XG4gIGMgKz0gcGFkU3RhcnQoby5jLnllYXIsIGxvbmdGb3JtYXQgPyA2IDogNCk7XG5cbiAgaWYgKGV4dGVuZGVkKSB7XG4gICAgYyArPSBcIi1cIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5tb250aCk7XG4gICAgYyArPSBcIi1cIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5kYXkpO1xuICB9IGVsc2Uge1xuICAgIGMgKz0gcGFkU3RhcnQoby5jLm1vbnRoKTtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5kYXkpO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiB0b0lTT1RpbWUoXG4gIG8sXG4gIGV4dGVuZGVkLFxuICBzdXBwcmVzc1NlY29uZHMsXG4gIHN1cHByZXNzTWlsbGlzZWNvbmRzLFxuICBpbmNsdWRlT2Zmc2V0LFxuICBleHRlbmRlZFpvbmVcbikge1xuICBsZXQgYyA9IHBhZFN0YXJ0KG8uYy5ob3VyKTtcbiAgaWYgKGV4dGVuZGVkKSB7XG4gICAgYyArPSBcIjpcIjtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5taW51dGUpO1xuICAgIGlmIChvLmMubWlsbGlzZWNvbmQgIT09IDAgfHwgby5jLnNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NTZWNvbmRzKSB7XG4gICAgICBjICs9IFwiOlwiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5taW51dGUpO1xuICB9XG5cbiAgaWYgKG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCBvLmMuc2Vjb25kICE9PSAwIHx8ICFzdXBwcmVzc1NlY29uZHMpIHtcbiAgICBjICs9IHBhZFN0YXJ0KG8uYy5zZWNvbmQpO1xuXG4gICAgaWYgKG8uYy5taWxsaXNlY29uZCAhPT0gMCB8fCAhc3VwcHJlc3NNaWxsaXNlY29uZHMpIHtcbiAgICAgIGMgKz0gXCIuXCI7XG4gICAgICBjICs9IHBhZFN0YXJ0KG8uYy5taWxsaXNlY29uZCwgMyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICBpZiAoby5pc09mZnNldEZpeGVkICYmIG8ub2Zmc2V0ID09PSAwICYmICFleHRlbmRlZFpvbmUpIHtcbiAgICAgIGMgKz0gXCJaXCI7XG4gICAgfSBlbHNlIGlmIChvLm8gPCAwKSB7XG4gICAgICBjICs9IFwiLVwiO1xuICAgICAgYyArPSBwYWRTdGFydChNYXRoLnRydW5jKC1vLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYygtby5vICUgNjApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyArPSBcIitcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gLyA2MCkpO1xuICAgICAgYyArPSBcIjpcIjtcbiAgICAgIGMgKz0gcGFkU3RhcnQoTWF0aC50cnVuYyhvLm8gJSA2MCkpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChleHRlbmRlZFpvbmUpIHtcbiAgICBjICs9IFwiW1wiICsgby56b25lLmlhbmFOYW1lICsgXCJdXCI7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbi8vIGRlZmF1bHRzIGZvciB1bnNwZWNpZmllZCB1bml0cyBpbiB0aGUgc3VwcG9ydGVkIGNhbGVuZGFyc1xuY29uc3QgZGVmYXVsdFVuaXRWYWx1ZXMgPSB7XG4gICAgbW9udGg6IDEsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfSxcbiAgZGVmYXVsdFdlZWtVbml0VmFsdWVzID0ge1xuICAgIHdlZWtOdW1iZXI6IDEsXG4gICAgd2Vla2RheTogMSxcbiAgICBob3VyOiAwLFxuICAgIG1pbnV0ZTogMCxcbiAgICBzZWNvbmQ6IDAsXG4gICAgbWlsbGlzZWNvbmQ6IDAsXG4gIH0sXG4gIGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcyA9IHtcbiAgICBvcmRpbmFsOiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBtaWxsaXNlY29uZDogMCxcbiAgfTtcblxuLy8gVW5pdHMgaW4gdGhlIHN1cHBvcnRlZCBjYWxlbmRhcnMsIHNvcnRlZCBieSBiaWduZXNzXG5jb25zdCBvcmRlcmVkVW5pdHMgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3VyXCIsIFwibWludXRlXCIsIFwic2Vjb25kXCIsIFwibWlsbGlzZWNvbmRcIl0sXG4gIG9yZGVyZWRXZWVrVW5pdHMgPSBbXG4gICAgXCJ3ZWVrWWVhclwiLFxuICAgIFwid2Vla051bWJlclwiLFxuICAgIFwid2Vla2RheVwiLFxuICAgIFwiaG91clwiLFxuICAgIFwibWludXRlXCIsXG4gICAgXCJzZWNvbmRcIixcbiAgICBcIm1pbGxpc2Vjb25kXCIsXG4gIF0sXG4gIG9yZGVyZWRPcmRpbmFsVW5pdHMgPSBbXCJ5ZWFyXCIsIFwib3JkaW5hbFwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZFwiXTtcblxuLy8gc3RhbmRhcmRpemUgY2FzZSBhbmQgcGx1cmFsaXR5IGluIHVuaXRzXG5mdW5jdGlvbiBub3JtYWxpemVVbml0KHVuaXQpIHtcbiAgY29uc3Qgbm9ybWFsaXplZCA9IHtcbiAgICB5ZWFyOiBcInllYXJcIixcbiAgICB5ZWFyczogXCJ5ZWFyXCIsXG4gICAgbW9udGg6IFwibW9udGhcIixcbiAgICBtb250aHM6IFwibW9udGhcIixcbiAgICBkYXk6IFwiZGF5XCIsXG4gICAgZGF5czogXCJkYXlcIixcbiAgICBob3VyOiBcImhvdXJcIixcbiAgICBob3VyczogXCJob3VyXCIsXG4gICAgbWludXRlOiBcIm1pbnV0ZVwiLFxuICAgIG1pbnV0ZXM6IFwibWludXRlXCIsXG4gICAgcXVhcnRlcjogXCJxdWFydGVyXCIsXG4gICAgcXVhcnRlcnM6IFwicXVhcnRlclwiLFxuICAgIHNlY29uZDogXCJzZWNvbmRcIixcbiAgICBzZWNvbmRzOiBcInNlY29uZFwiLFxuICAgIG1pbGxpc2Vjb25kOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgbWlsbGlzZWNvbmRzOiBcIm1pbGxpc2Vjb25kXCIsXG4gICAgd2Vla2RheTogXCJ3ZWVrZGF5XCIsXG4gICAgd2Vla2RheXM6IFwid2Vla2RheVwiLFxuICAgIHdlZWtudW1iZXI6IFwid2Vla051bWJlclwiLFxuICAgIHdlZWtzbnVtYmVyOiBcIndlZWtOdW1iZXJcIixcbiAgICB3ZWVrbnVtYmVyczogXCJ3ZWVrTnVtYmVyXCIsXG4gICAgd2Vla3llYXI6IFwid2Vla1llYXJcIixcbiAgICB3ZWVreWVhcnM6IFwid2Vla1llYXJcIixcbiAgICBvcmRpbmFsOiBcIm9yZGluYWxcIixcbiAgfVt1bml0LnRvTG93ZXJDYXNlKCldO1xuXG4gIGlmICghbm9ybWFsaXplZCkgdGhyb3cgbmV3IEludmFsaWRVbml0RXJyb3IodW5pdCk7XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG59XG5cbi8vIHRoaXMgaXMgYSBkdW1iZWQgZG93biB2ZXJzaW9uIG9mIGZyb21PYmplY3QoKSB0aGF0IHJ1bnMgYWJvdXQgNjAlIGZhc3RlclxuLy8gYnV0IGRvZXNuJ3QgZG8gYW55IHZhbGlkYXRpb24sIG1ha2VzIGEgYnVuY2ggb2YgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCB1bml0c1xuLy8gYXJlIHByZXNlbnQsIGFuZCBzbyBvbi5cbmZ1bmN0aW9uIHF1aWNrRFQob2JqLCBvcHRzKSB7XG4gIGNvbnN0IHpvbmUgPSBub3JtYWxpemVab25lKG9wdHMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgIGxvYyA9IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpLFxuICAgIHRzTm93ID0gU2V0dGluZ3Mubm93KCk7XG5cbiAgbGV0IHRzLCBvO1xuXG4gIC8vIGFzc3VtZSB3ZSBoYXZlIHRoZSBoaWdoZXItb3JkZXIgdW5pdHNcbiAgaWYgKCFpc1VuZGVmaW5lZChvYmoueWVhcikpIHtcbiAgICBmb3IgKGNvbnN0IHUgb2Ygb3JkZXJlZFVuaXRzKSB7XG4gICAgICBpZiAoaXNVbmRlZmluZWQob2JqW3VdKSkge1xuICAgICAgICBvYmpbdV0gPSBkZWZhdWx0VW5pdFZhbHVlc1t1XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnZhbGlkID0gaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEob2JqKSB8fCBoYXNJbnZhbGlkVGltZURhdGEob2JqKTtcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoaW52YWxpZCk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0UHJvdmlzID0gem9uZS5vZmZzZXQodHNOb3cpO1xuICAgIFt0cywgb10gPSBvYmpUb1RTKG9iaiwgb2Zmc2V0UHJvdmlzLCB6b25lKTtcbiAgfSBlbHNlIHtcbiAgICB0cyA9IHRzTm93O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IHRzLCB6b25lLCBsb2MsIG8gfSk7XG59XG5cbmZ1bmN0aW9uIGRpZmZSZWxhdGl2ZShzdGFydCwgZW5kLCBvcHRzKSB7XG4gIGNvbnN0IHJvdW5kID0gaXNVbmRlZmluZWQob3B0cy5yb3VuZCkgPyB0cnVlIDogb3B0cy5yb3VuZCxcbiAgICBmb3JtYXQgPSAoYywgdW5pdCkgPT4ge1xuICAgICAgYyA9IHJvdW5kVG8oYywgcm91bmQgfHwgb3B0cy5jYWxlbmRhcnkgPyAwIDogMiwgdHJ1ZSk7XG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBlbmQubG9jLmNsb25lKG9wdHMpLnJlbEZvcm1hdHRlcihvcHRzKTtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0KGMsIHVuaXQpO1xuICAgIH0sXG4gICAgZGlmZmVyID0gKHVuaXQpID0+IHtcbiAgICAgIGlmIChvcHRzLmNhbGVuZGFyeSkge1xuICAgICAgICBpZiAoIWVuZC5oYXNTYW1lKHN0YXJ0LCB1bml0KSkge1xuICAgICAgICAgIHJldHVybiBlbmQuc3RhcnRPZih1bml0KS5kaWZmKHN0YXJ0LnN0YXJ0T2YodW5pdCksIHVuaXQpLmdldCh1bml0KTtcbiAgICAgICAgfSBlbHNlIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCB1bml0KS5nZXQodW5pdCk7XG4gICAgICB9XG4gICAgfTtcblxuICBpZiAob3B0cy51bml0KSB7XG4gICAgcmV0dXJuIGZvcm1hdChkaWZmZXIob3B0cy51bml0KSwgb3B0cy51bml0KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdW5pdCBvZiBvcHRzLnVuaXRzKSB7XG4gICAgY29uc3QgY291bnQgPSBkaWZmZXIodW5pdCk7XG4gICAgaWYgKE1hdGguYWJzKGNvdW50KSA+PSAxKSB7XG4gICAgICByZXR1cm4gZm9ybWF0KGNvdW50LCB1bml0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdChzdGFydCA+IGVuZCA/IC0wIDogMCwgb3B0cy51bml0c1tvcHRzLnVuaXRzLmxlbmd0aCAtIDFdKTtcbn1cblxuZnVuY3Rpb24gbGFzdE9wdHMoYXJnTGlzdCkge1xuICBsZXQgb3B0cyA9IHt9LFxuICAgIGFyZ3M7XG4gIGlmIChhcmdMaXN0Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIGFyZ0xpc3RbYXJnTGlzdC5sZW5ndGggLSAxXSA9PT0gXCJvYmplY3RcIikge1xuICAgIG9wdHMgPSBhcmdMaXN0W2FyZ0xpc3QubGVuZ3RoIC0gMV07XG4gICAgYXJncyA9IEFycmF5LmZyb20oYXJnTGlzdCkuc2xpY2UoMCwgYXJnTGlzdC5sZW5ndGggLSAxKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdMaXN0KTtcbiAgfVxuICByZXR1cm4gW29wdHMsIGFyZ3NdO1xufVxuXG4vKipcbiAqIEEgRGF0ZVRpbWUgaXMgYW4gaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlIHJlcHJlc2VudGluZyBhIHNwZWNpZmljIGRhdGUgYW5kIHRpbWUgYW5kIGFjY29tcGFueWluZyBtZXRob2RzLiBJdCBjb250YWlucyBjbGFzcyBhbmQgaW5zdGFuY2UgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHBhcnNpbmcsIGludGVycm9nYXRpbmcsIHRyYW5zZm9ybWluZywgYW5kIGZvcm1hdHRpbmcgdGhlbS5cbiAqXG4gKiBBIERhdGVUaW1lIGNvbXByaXNlcyBvZjpcbiAqICogQSB0aW1lc3RhbXAuIEVhY2ggRGF0ZVRpbWUgaW5zdGFuY2UgcmVmZXJzIHRvIGEgc3BlY2lmaWMgbWlsbGlzZWNvbmQgb2YgdGhlIFVuaXggZXBvY2guXG4gKiAqIEEgdGltZSB6b25lLiBFYWNoIGluc3RhbmNlIGlzIGNvbnNpZGVyZWQgaW4gdGhlIGNvbnRleHQgb2YgYSBzcGVjaWZpYyB6b25lIChieSBkZWZhdWx0IHRoZSBsb2NhbCBzeXN0ZW0ncyB6b25lKS5cbiAqICogQ29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRoYXQgZWZmZWN0IGhvdyBvdXRwdXQgc3RyaW5ncyBhcmUgZm9ybWF0dGVkLCBzdWNoIGFzIGBsb2NhbGVgLCBgbnVtYmVyaW5nU3lzdGVtYCwgYW5kIGBvdXRwdXRDYWxlbmRhcmAuXG4gKlxuICogSGVyZSBpcyBhIGJyaWVmIG92ZXJ2aWV3IG9mIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgZnVuY3Rpb25hbGl0eSBpdCBwcm92aWRlczpcbiAqXG4gKiAqICoqQ3JlYXRpb24qKjogVG8gY3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBpdHMgY29tcG9uZW50cywgdXNlIG9uZSBvZiBpdHMgZmFjdG9yeSBjbGFzcyBtZXRob2RzOiB7QGxpbmsgRGF0ZVRpbWUubG9jYWx9LCB7QGxpbmsgRGF0ZVRpbWUudXRjfSwgYW5kIChtb3N0IGZsZXhpYmx5KSB7QGxpbmsgRGF0ZVRpbWUuZnJvbU9iamVjdH0uIFRvIGNyZWF0ZSBvbmUgZnJvbSBhIHN0YW5kYXJkIHN0cmluZyBmb3JtYXQsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUlTT30sIHtAbGluayBEYXRlVGltZS5mcm9tSFRUUH0sIGFuZCB7QGxpbmsgRGF0ZVRpbWUuZnJvbVJGQzI4MjJ9LiBUbyBjcmVhdGUgb25lIGZyb20gYSBjdXN0b20gc3RyaW5nIGZvcm1hdCwgdXNlIHtAbGluayBEYXRlVGltZS5mcm9tRm9ybWF0fS4gVG8gY3JlYXRlIG9uZSBmcm9tIGEgbmF0aXZlIEpTIGRhdGUsIHVzZSB7QGxpbmsgRGF0ZVRpbWUuZnJvbUpTRGF0ZX0uXG4gKiAqICoqR3JlZ29yaWFuIGNhbGVuZGFyIGFuZCB0aW1lKio6IFRvIGV4YW1pbmUgdGhlIEdyZWdvcmlhbiBwcm9wZXJ0aWVzIG9mIGEgRGF0ZVRpbWUgaW5kaXZpZHVhbGx5IChpLmUgYXMgb3Bwb3NlZCB0byBjb2xsZWN0aXZlbHkgdGhyb3VnaCB7QGxpbmsgRGF0ZVRpbWUjdG9PYmplY3R9KSwgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjeWVhcn0sIHtAbGluayBEYXRlVGltZSNtb250aH0sXG4gKiB7QGxpbmsgRGF0ZVRpbWUjZGF5fSwge0BsaW5rIERhdGVUaW1lI2hvdXJ9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXRlfSwge0BsaW5rIERhdGVUaW1lI3NlY29uZH0sIHtAbGluayBEYXRlVGltZSNtaWxsaXNlY29uZH0gYWNjZXNzb3JzLlxuICogKiAqKldlZWsgY2FsZW5kYXIqKjogRm9yIElTTyB3ZWVrIGNhbGVuZGFyIGF0dHJpYnV0ZXMsIHNlZSB0aGUge0BsaW5rIERhdGVUaW1lI3dlZWtZZWFyfSwge0BsaW5rIERhdGVUaW1lI3dlZWtOdW1iZXJ9LCBhbmQge0BsaW5rIERhdGVUaW1lI3dlZWtkYXl9IGFjY2Vzc29ycy5cbiAqICogKipDb25maWd1cmF0aW9uKiogU2VlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjbG9jYWxlfSBhbmQge0BsaW5rIERhdGVUaW1lI251bWJlcmluZ1N5c3RlbX0gYWNjZXNzb3JzLlxuICogKiAqKlRyYW5zZm9ybWF0aW9uKio6IFRvIHRyYW5zZm9ybSB0aGUgRGF0ZVRpbWUgaW50byBvdGhlciBEYXRlVGltZXMsIHVzZSB7QGxpbmsgRGF0ZVRpbWUjc2V0fSwge0BsaW5rIERhdGVUaW1lI3JlY29uZmlndXJlfSwge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9LCB7QGxpbmsgRGF0ZVRpbWUjc2V0TG9jYWxlfSwge0BsaW5rIERhdGVUaW1lLnBsdXN9LCB7QGxpbmsgRGF0ZVRpbWUjbWludXN9LCB7QGxpbmsgRGF0ZVRpbWUjZW5kT2Z9LCB7QGxpbmsgRGF0ZVRpbWUjc3RhcnRPZn0sIHtAbGluayBEYXRlVGltZSN0b1VUQ30sIGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbH0uXG4gKiAqICoqT3V0cHV0Kio6IFRvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIG90aGVyIHJlcHJlc2VudGF0aW9ucywgdXNlIHRoZSB7QGxpbmsgRGF0ZVRpbWUjdG9SZWxhdGl2ZX0sIHtAbGluayBEYXRlVGltZSN0b1JlbGF0aXZlQ2FsZW5kYXJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9KU09OfSwge0BsaW5rIERhdGVUaW1lI3RvSVNPfSwge0BsaW5rIERhdGVUaW1lI3RvSFRUUH0sIHtAbGluayBEYXRlVGltZSN0b09iamVjdH0sIHtAbGluayBEYXRlVGltZSN0b1JGQzI4MjJ9LCB7QGxpbmsgRGF0ZVRpbWUjdG9TdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9LCB7QGxpbmsgRGF0ZVRpbWUjdG9Gb3JtYXR9LCB7QGxpbmsgRGF0ZVRpbWUjdG9NaWxsaXN9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjdG9KU0RhdGV9LlxuICpcbiAqIFRoZXJlJ3MgcGxlbnR5IG90aGVycyBkb2N1bWVudGVkIGJlbG93LiBJbiBhZGRpdGlvbiwgZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gc3VidGxlciB0b3BpY3MgbGlrZSBpbnRlcm5hdGlvbmFsaXphdGlvbiwgdGltZSB6b25lcywgYWx0ZXJuYXRpdmUgY2FsZW5kYXJzLCB2YWxpZGl0eSwgYW5kIHNvIG9uLCBzZWUgdGhlIGV4dGVybmFsIGRvY3VtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGVUaW1lIHtcbiAgLyoqXG4gICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgY29uc3Qgem9uZSA9IGNvbmZpZy56b25lIHx8IFNldHRpbmdzLmRlZmF1bHRab25lO1xuXG4gICAgbGV0IGludmFsaWQgPVxuICAgICAgY29uZmlnLmludmFsaWQgfHxcbiAgICAgIChOdW1iZXIuaXNOYU4oY29uZmlnLnRzKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGwpIHx8XG4gICAgICAoIXpvbmUuaXNWYWxpZCA/IHVuc3VwcG9ydGVkWm9uZSh6b25lKSA6IG51bGwpO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudHMgPSBpc1VuZGVmaW5lZChjb25maWcudHMpID8gU2V0dGluZ3Mubm93KCkgOiBjb25maWcudHM7XG5cbiAgICBsZXQgYyA9IG51bGwsXG4gICAgICBvID0gbnVsbDtcbiAgICBpZiAoIWludmFsaWQpIHtcbiAgICAgIGNvbnN0IHVuY2hhbmdlZCA9IGNvbmZpZy5vbGQgJiYgY29uZmlnLm9sZC50cyA9PT0gdGhpcy50cyAmJiBjb25maWcub2xkLnpvbmUuZXF1YWxzKHpvbmUpO1xuXG4gICAgICBpZiAodW5jaGFuZ2VkKSB7XG4gICAgICAgIFtjLCBvXSA9IFtjb25maWcub2xkLmMsIGNvbmZpZy5vbGQub107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvdCA9IHpvbmUub2Zmc2V0KHRoaXMudHMpO1xuICAgICAgICBjID0gdHNUb09iaih0aGlzLnRzLCBvdCk7XG4gICAgICAgIGludmFsaWQgPSBOdW1iZXIuaXNOYU4oYy55ZWFyKSA/IG5ldyBJbnZhbGlkKFwiaW52YWxpZCBpbnB1dFwiKSA6IG51bGw7XG4gICAgICAgIGMgPSBpbnZhbGlkID8gbnVsbCA6IGM7XG4gICAgICAgIG8gPSBpbnZhbGlkID8gbnVsbCA6IG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3pvbmUgPSB6b25lO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubG9jID0gY29uZmlnLmxvYyB8fCBMb2NhbGUuY3JlYXRlKCk7XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLndlZWtEYXRhID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmMgPSBjO1xuICAgIC8qKlxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMubyA9IG87XG4gICAgLyoqXG4gICAgICogQGFjY2VzcyBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5pc0x1eG9uRGF0ZVRpbWUgPSB0cnVlO1xuICB9XG5cbiAgLy8gQ09OU1RSVUNUXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZvciB0aGUgY3VycmVudCBpbnN0YW50LCBpbiB0aGUgc3lzdGVtJ3MgdGltZSB6b25lLlxuICAgKlxuICAgKiBVc2UgU2V0dGluZ3MgdG8gb3ZlcnJpZGUgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaWYgbmVlZGVkLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0lTTygpIC8vfj4gbm93IGluIHRoZSBJU08gZm9ybWF0XG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIG5vdygpIHtcbiAgICByZXR1cm4gbmV3IERhdGVUaW1lKHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBsb2NhbCBEYXRlVGltZVxuICAgKiBAcGFyYW0ge251bWJlcn0gW3llYXJdIC0gVGhlIGNhbGVuZGFyIHllYXIuIElmIG9taXR0ZWQgKGFzIGluLCBjYWxsIGBsb2NhbCgpYCB3aXRoIG5vIGFyZ3VtZW50cyksIHRoZSBjdXJyZW50IHRpbWUgd2lsbCBiZSB1c2VkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbW9udGg9MV0gLSBUaGUgbW9udGgsIDEtaW5kZXhlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RheT0xXSAtIFRoZSBkYXkgb2YgdGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtob3VyPTBdIC0gVGhlIGhvdXIgb2YgdGhlIGRheSwgaW4gMjQtaG91ciB0aW1lXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWludXRlPTBdIC0gVGhlIG1pbnV0ZSBvZiB0aGUgaG91ciwgbWVhbmluZyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kPTBdIC0gVGhlIHNlY29uZCBvZiB0aGUgbWludXRlLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaWxsaXNlY29uZD0wXSAtIFRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgOTk5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoeyB6b25lOiBcIkFtZXJpY2EvTmV3X1lvcmtcIiB9KSAgICAgIC8vfj4gbm93LCBpbiBVUyBlYXN0IGNvYXN0IHRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDEtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIHsgbG9jYWxlOiBcImZyXCIgfSkgICAgIC8vfj4gMjAxNy0wMy0xMlQwMDowMDowMCwgd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUpICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6MDA6MDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgMywgMTIsIDUsIHsgem9uZTogXCJ1dGNcIiB9KSAgIC8vfj4gMjAxNy0wMy0xMlQwNTowMDowMCwgaW4gVVRDXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSkgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTApICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDMsIDEyLCA1LCA0NSwgMTAsIDc2NSkgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwLjc2NVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBsb2NhbCgpIHtcbiAgICBjb25zdCBbb3B0cywgYXJnc10gPSBsYXN0T3B0cyhhcmd1bWVudHMpLFxuICAgICAgW3llYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF0gPSBhcmdzO1xuICAgIHJldHVybiBxdWlja0RUKHsgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kIH0sIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGluIFVUQ1xuICAgKiBAcGFyYW0ge251bWJlcn0gW3llYXJdIC0gVGhlIGNhbGVuZGFyIHllYXIuIElmIG9taXR0ZWQgKGFzIGluLCBjYWxsIGB1dGMoKWAgd2l0aCBubyBhcmd1bWVudHMpLCB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gW21vbnRoPTFdIC0gVGhlIG1vbnRoLCAxLWluZGV4ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkYXk9MV0gLSBUaGUgZGF5IG9mIHRoZSBtb250aFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2hvdXI9MF0gLSBUaGUgaG91ciBvZiB0aGUgZGF5LCBpbiAyNC1ob3VyIHRpbWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW51dGU9MF0gLSBUaGUgbWludXRlIG9mIHRoZSBob3VyLCBtZWFuaW5nIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmQ9MF0gLSBUaGUgc2Vjb25kIG9mIHRoZSBtaW51dGUsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA1OVxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbGxpc2Vjb25kPTBdIC0gVGhlIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIG1lYW5pbmcgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCA5OTlcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubG9jYWxlXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5vdXRwdXRDYWxlbmRhcl0gLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW1dIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiBub3dcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAxLTAxVDAwOjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMykgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMDFUMDA6MDA6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMikgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vfj4gMjAxNy0wMy0xMlQwMDowMDowMFpcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTcsIDMsIDEyLCA1KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjAwOjAwWlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1KSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MDBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIHsgbG9jYWxlOiBcImZyXCIgfSkgICAgICAgICAgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjAwWiB3aXRoIGEgRnJlbmNoIGxvY2FsZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNywgMywgMTIsIDUsIDQ1LCAxMCkgICAgICAgICAgICAgICAgICAgICAgICAvL34+IDIwMTctMDMtMTJUMDU6NDU6MTBaXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE3LCAzLCAxMiwgNSwgNDUsIDEwLCA3NjUsIHsgbG9jYWxlOiBcImZyXCIgfSkgLy9+PiAyMDE3LTAzLTEyVDA1OjQ1OjEwLjc2NVogd2l0aCBhIEZyZW5jaCBsb2NhbGVcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgdXRjKCkge1xuICAgIGNvbnN0IFtvcHRzLCBhcmdzXSA9IGxhc3RPcHRzKGFyZ3VtZW50cyksXG4gICAgICBbeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXSA9IGFyZ3M7XG5cbiAgICBvcHRzLnpvbmUgPSBGaXhlZE9mZnNldFpvbmUudXRjSW5zdGFuY2U7XG4gICAgcmV0dXJuIHF1aWNrRFQoeyB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmQgfSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhIEphdmFTY3JpcHQgRGF0ZSBvYmplY3QuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlIC0gYSBKYXZhU2NyaXB0IERhdGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21KU0RhdGUoZGF0ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHMgPSBpc0RhdGUoZGF0ZSkgPyBkYXRlLnZhbHVlT2YoKSA6IE5hTjtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHRzKSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJpbnZhbGlkIGlucHV0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHpvbmVUb1VzZSA9IG5vcm1hbGl6ZVpvbmUob3B0aW9ucy56b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKCF6b25lVG9Vc2UuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmVUb1VzZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRGF0ZVRpbWUoe1xuICAgICAgdHM6IHRzLFxuICAgICAgem9uZTogem9uZVRvVXNlLFxuICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgZXBvY2ggKG1lYW5pbmcgc2luY2UgMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS4gVXNlcyB0aGUgZGVmYXVsdCB6b25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21NaWxsaXMobWlsbGlzZWNvbmRzLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAoIWlzTnVtYmVyKG1pbGxpc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcbiAgICAgICAgYGZyb21NaWxsaXMgcmVxdWlyZXMgYSBudW1lcmljYWwgaW5wdXQsIGJ1dCByZWNlaXZlZCBhICR7dHlwZW9mIG1pbGxpc2Vjb25kc30gd2l0aCB2YWx1ZSAke21pbGxpc2Vjb25kc31gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmRzIDwgLU1BWF9EQVRFIHx8IG1pbGxpc2Vjb25kcyA+IE1BWF9EQVRFKSB7XG4gICAgICAvLyB0aGlzIGlzbid0IHBlcmZlY3QgYmVjYXVzZSBiZWNhdXNlIHdlIGNhbiBzdGlsbCBlbmQgdXAgb3V0IG9mIHJhbmdlIGJlY2F1c2Ugb2YgYWRkaXRpb25hbCBzaGlmdGluZywgYnV0IGl0J3MgYSBzdGFydFxuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXCJUaW1lc3RhbXAgb3V0IG9mIHJhbmdlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IG1pbGxpc2Vjb25kcyxcbiAgICAgICAgem9uZTogbm9ybWFsaXplWm9uZShvcHRpb25zLnpvbmUsIFNldHRpbmdzLmRlZmF1bHRab25lKSxcbiAgICAgICAgbG9jOiBMb2NhbGUuZnJvbU9iamVjdChvcHRpb25zKSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIGVwb2NoIChtZWFuaW5nIHNpbmNlIDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuIFVzZXMgdGhlIGRlZmF1bHQgem9uZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNlY29uZHMgLSBhIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIDE5NzAgVVRDXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdGlvbnMuem9uZT0nbG9jYWwnXSAtIHRoZSB6b25lIHRvIHBsYWNlIHRoZSBEYXRlVGltZSBpbnRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5sb2NhbGVdIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21TZWNvbmRzKHNlY29uZHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICghaXNOdW1iZXIoc2Vjb25kcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihcImZyb21TZWNvbmRzIHJlcXVpcmVzIGEgbnVtZXJpY2FsIGlucHV0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IERhdGVUaW1lKHtcbiAgICAgICAgdHM6IHNlY29uZHMgKiAxMDAwLFxuICAgICAgICB6b25lOiBub3JtYWxpemVab25lKG9wdGlvbnMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpLFxuICAgICAgICBsb2M6IExvY2FsZS5mcm9tT2JqZWN0KG9wdGlvbnMpLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIGtleXMgbGlrZSAneWVhcicgYW5kICdob3VyJyB3aXRoIHJlYXNvbmFibGUgZGVmYXVsdHMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgb2JqZWN0IHRvIGNyZWF0ZSB0aGUgRGF0ZVRpbWUgZnJvbVxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLnllYXIgLSBhIHllYXIsIHN1Y2ggYXMgMTk4N1xuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm1vbnRoIC0gYSBtb250aCwgMS0xMlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLmRheSAtIGEgZGF5IG9mIHRoZSBtb250aCwgMS0zMSwgZGVwZW5kaW5nIG9uIHRoZSBtb250aFxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLm9yZGluYWwgLSBkYXkgb2YgdGhlIHllYXIsIDEtMzY1IG9yIDM2NlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtZZWFyIC0gYW4gSVNPIHdlZWsgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtOdW1iZXIgLSBhbiBJU08gd2VlayBudW1iZXIsIGJldHdlZW4gMSBhbmQgNTIgb3IgNTMsIGRlcGVuZGluZyBvbiB0aGUgeWVhclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2JqLndlZWtkYXkgLSBhbiBJU08gd2Vla2RheSwgMS03LCB3aGVyZSAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5ob3VyIC0gaG91ciBvZiB0aGUgZGF5LCAwLTIzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmoubWludXRlIC0gbWludXRlIG9mIHRoZSBob3VyLCAwLTU5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvYmouc2Vjb25kIC0gc2Vjb25kIG9mIHRoZSBtaW51dGUsIDAtNTlcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9iai5taWxsaXNlY29uZCAtIG1pbGxpc2Vjb25kIG9mIHRoZSBzZWNvbmQsIDAtOTk5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gaW50ZXJwcmV0IHRoZSBudW1iZXJzIGluIHRoZSBjb250ZXh0IG9mIGEgcGFydGljdWxhciB6b25lLiBDYW4gdGFrZSBhbnkgdmFsdWUgdGFrZW4gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHNldFpvbmUoKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogMTk4MiwgbW9udGg6IDUsIGRheTogMjV9KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTA1LTI1J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgeWVhcjogMTk4MiB9KS50b0lTT0RhdGUoKSAvLz0+ICcxOTgyLTAxLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9KSAvL34+IHRvZGF5IGF0IDEwOjI2OjA2XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ3V0YycgfSksXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21PYmplY3QoeyBob3VyOiAxMCwgbWludXRlOiAyNiwgc2Vjb25kOiA2IH0sIHsgem9uZTogJ2xvY2FsJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgaG91cjogMTAsIG1pbnV0ZTogMjYsIHNlY29uZDogNiB9LCB7IHpvbmU6ICdBbWVyaWNhL05ld19Zb3JrJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tT2JqZWN0KHsgd2Vla1llYXI6IDIwMTYsIHdlZWtOdW1iZXI6IDIsIHdlZWtkYXk6IDMgfSkudG9JU09EYXRlKCkgLy89PiAnMjAxNi0wMS0xMydcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzdGF0aWMgZnJvbU9iamVjdChvYmosIG9wdHMgPSB7fSkge1xuICAgIG9iaiA9IG9iaiB8fCB7fTtcbiAgICBjb25zdCB6b25lVG9Vc2UgPSBub3JtYWxpemVab25lKG9wdHMuem9uZSwgU2V0dGluZ3MuZGVmYXVsdFpvbmUpO1xuICAgIGlmICghem9uZVRvVXNlLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiBEYXRlVGltZS5pbnZhbGlkKHVuc3VwcG9ydGVkWm9uZSh6b25lVG9Vc2UpKTtcbiAgICB9XG5cbiAgICBjb25zdCB0c05vdyA9IFNldHRpbmdzLm5vdygpLFxuICAgICAgb2Zmc2V0UHJvdmlzID0gIWlzVW5kZWZpbmVkKG9wdHMuc3BlY2lmaWNPZmZzZXQpXG4gICAgICAgID8gb3B0cy5zcGVjaWZpY09mZnNldFxuICAgICAgICA6IHpvbmVUb1VzZS5vZmZzZXQodHNOb3cpLFxuICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU9iamVjdChvYmosIG5vcm1hbGl6ZVVuaXQpLFxuICAgICAgY29udGFpbnNPcmRpbmFsID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCksXG4gICAgICBjb250YWluc0dyZWdvclllYXIgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC55ZWFyKSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yTUQgPSAhaXNVbmRlZmluZWQobm9ybWFsaXplZC5tb250aCkgfHwgIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQuZGF5KSxcbiAgICAgIGNvbnRhaW5zR3JlZ29yID0gY29udGFpbnNHcmVnb3JZZWFyIHx8IGNvbnRhaW5zR3JlZ29yTUQsXG4gICAgICBkZWZpbml0ZVdlZWtEZWYgPSBub3JtYWxpemVkLndlZWtZZWFyIHx8IG5vcm1hbGl6ZWQud2Vla051bWJlcixcbiAgICAgIGxvYyA9IExvY2FsZS5mcm9tT2JqZWN0KG9wdHMpO1xuXG4gICAgLy8gY2FzZXM6XG4gICAgLy8ganVzdCBhIHdlZWtkYXkgLT4gdGhpcyB3ZWVrJ3MgaW5zdGFuY2Ugb2YgdGhhdCB3ZWVrZGF5LCBubyB3b3JyaWVzXG4gICAgLy8gKGdyZWdvcmlhbiBkYXRhIG9yIG9yZGluYWwpICsgKHdlZWtZZWFyIG9yIHdlZWtOdW1iZXIpIC0+IGVycm9yXG4gICAgLy8gKGdyZWdvcmlhbiBtb250aCBvciBkYXkpICsgb3JkaW5hbCAtPiBlcnJvclxuICAgIC8vIG90aGVyd2lzZSBqdXN0IHVzZSB3ZWVrcyBvciBvcmRpbmFscyBvciBncmVnb3JpYW4sIGRlcGVuZGluZyBvbiB3aGF0J3Mgc3BlY2lmaWVkXG5cbiAgICBpZiAoKGNvbnRhaW5zR3JlZ29yIHx8IGNvbnRhaW5zT3JkaW5hbCkgJiYgZGVmaW5pdGVXZWVrRGVmKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgbWl4IHdlZWtZZWFyL3dlZWtOdW1iZXIgdW5pdHMgd2l0aCB5ZWFyL21vbnRoL2RheSBvciBvcmRpbmFsc1wiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0dyZWdvck1EICYmIGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgbWl4IG9yZGluYWwgZGF0ZXMgd2l0aCBtb250aC9kYXlcIik7XG4gICAgfVxuXG4gICAgY29uc3QgdXNlV2Vla0RhdGEgPSBkZWZpbml0ZVdlZWtEZWYgfHwgKG5vcm1hbGl6ZWQud2Vla2RheSAmJiAhY29udGFpbnNHcmVnb3IpO1xuXG4gICAgLy8gY29uZmlndXJlIG91cnNlbHZlcyB0byBkZWFsIHdpdGggZ3JlZ29yaWFuIGRhdGVzIG9yIHdlZWsgc3R1ZmZcbiAgICBsZXQgdW5pdHMsXG4gICAgICBkZWZhdWx0VmFsdWVzLFxuICAgICAgb2JqTm93ID0gdHNUb09iaih0c05vdywgb2Zmc2V0UHJvdmlzKTtcbiAgICBpZiAodXNlV2Vla0RhdGEpIHtcbiAgICAgIHVuaXRzID0gb3JkZXJlZFdlZWtVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0V2Vla1VuaXRWYWx1ZXM7XG4gICAgICBvYmpOb3cgPSBncmVnb3JpYW5Ub1dlZWsob2JqTm93KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdW5pdHMgPSBvcmRlcmVkT3JkaW5hbFVuaXRzO1xuICAgICAgZGVmYXVsdFZhbHVlcyA9IGRlZmF1bHRPcmRpbmFsVW5pdFZhbHVlcztcbiAgICAgIG9iak5vdyA9IGdyZWdvcmlhblRvT3JkaW5hbChvYmpOb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1bml0cyA9IG9yZGVyZWRVbml0cztcbiAgICAgIGRlZmF1bHRWYWx1ZXMgPSBkZWZhdWx0VW5pdFZhbHVlcztcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdCB2YWx1ZXMgZm9yIG1pc3Npbmcgc3R1ZmZcbiAgICBsZXQgZm91bmRGaXJzdCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgdSBvZiB1bml0cykge1xuICAgICAgY29uc3QgdiA9IG5vcm1hbGl6ZWRbdV07XG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKHYpKSB7XG4gICAgICAgIGZvdW5kRmlyc3QgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChmb3VuZEZpcnN0KSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbdV0gPSBkZWZhdWx0VmFsdWVzW3VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZFt1XSA9IG9iak5vd1t1XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYWtlIHN1cmUgdGhlIHZhbHVlcyB3ZSBoYXZlIGFyZSBpbiByYW5nZVxuICAgIGNvbnN0IGhpZ2hlck9yZGVySW52YWxpZCA9IHVzZVdlZWtEYXRhXG4gICAgICAgID8gaGFzSW52YWxpZFdlZWtEYXRhKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogY29udGFpbnNPcmRpbmFsXG4gICAgICAgID8gaGFzSW52YWxpZE9yZGluYWxEYXRhKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogaGFzSW52YWxpZEdyZWdvcmlhbkRhdGEobm9ybWFsaXplZCksXG4gICAgICBpbnZhbGlkID0gaGlnaGVyT3JkZXJJbnZhbGlkIHx8IGhhc0ludmFsaWRUaW1lRGF0YShub3JtYWxpemVkKTtcblxuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9XG5cbiAgICAvLyBjb21wdXRlIHRoZSBhY3R1YWwgdGltZVxuICAgIGNvbnN0IGdyZWdvcmlhbiA9IHVzZVdlZWtEYXRhXG4gICAgICAgID8gd2Vla1RvR3JlZ29yaWFuKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogY29udGFpbnNPcmRpbmFsXG4gICAgICAgID8gb3JkaW5hbFRvR3JlZ29yaWFuKG5vcm1hbGl6ZWQpXG4gICAgICAgIDogbm9ybWFsaXplZCxcbiAgICAgIFt0c0ZpbmFsLCBvZmZzZXRGaW5hbF0gPSBvYmpUb1RTKGdyZWdvcmlhbiwgb2Zmc2V0UHJvdmlzLCB6b25lVG9Vc2UpLFxuICAgICAgaW5zdCA9IG5ldyBEYXRlVGltZSh7XG4gICAgICAgIHRzOiB0c0ZpbmFsLFxuICAgICAgICB6b25lOiB6b25lVG9Vc2UsXG4gICAgICAgIG86IG9mZnNldEZpbmFsLFxuICAgICAgICBsb2MsXG4gICAgICB9KTtcblxuICAgIC8vIGdyZWdvcmlhbiBkYXRhICsgd2Vla2RheSBzZXJ2ZXMgb25seSB0byB2YWxpZGF0ZVxuICAgIGlmIChub3JtYWxpemVkLndlZWtkYXkgJiYgY29udGFpbnNHcmVnb3IgJiYgb2JqLndlZWtkYXkgIT09IGluc3Qud2Vla2RheSkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQoXG4gICAgICAgIFwibWlzbWF0Y2hlZCB3ZWVrZGF5XCIsXG4gICAgICAgIGB5b3UgY2FuJ3Qgc3BlY2lmeSBib3RoIGEgd2Vla2RheSBvZiAke25vcm1hbGl6ZWQud2Vla2RheX0gYW5kIGEgZGF0ZSBvZiAke2luc3QudG9JU08oKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gSVNPIDg2MDEgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIElTTyBzdHJpbmdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIHRpbWUgdG8gdGhpcyB6b25lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIGEgZml4ZWQtb2Zmc2V0IHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J3N5c3RlbSdzIGxvY2FsZSddIC0gYSBsb2NhbGUgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm91dHB1dENhbGVuZGFyXSAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm51bWJlcmluZ1N5c3RlbV0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSVNPKCcyMDE2LTA1LTI1VDA5OjA4OjM0LjEyMycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi0wNS0yNVQwOTowODozNC4xMjMrMDY6MDAnLCB7c2V0Wm9uZTogdHJ1ZX0pXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21JU08oJzIwMTYtMDUtMjVUMDk6MDg6MzQuMTIzJywge3pvbmU6ICd1dGMnfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUlTTygnMjAxNi1XMDUtNCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21JU08odGV4dCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgW3ZhbHMsIHBhcnNlZFpvbmVdID0gcGFyc2VJU09EYXRlKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiSVNPIDg2MDFcIiwgdGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgRGF0ZVRpbWUgZnJvbSBhbiBSRkMgMjgyMiBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgUkZDIDI4MjIgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSBjb252ZXJ0IHRoZSB0aW1lIHRvIHRoaXMgem9uZS4gU2luY2UgdGhlIG9mZnNldCBpcyBhbHdheXMgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCB0aGlzIGhhcyBubyBlZmZlY3Qgb24gdGhlIGludGVycHJldGF0aW9uIG9mIHN0cmluZywgbWVyZWx5IHRoZSB6b25lIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaXMgZXhwcmVzc2VkIGluLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIGZpeGVkLW9mZnNldCB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignMjUgTm92IDIwMTYgMTM6MjM6MTIgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVJGQzI4MjIoJ0ZyaSwgMjUgTm92IDIwMTYgMTM6MjM6MTIgKzA2MDAnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tUkZDMjgyMignMjUgTm92IDIwMTYgMTM6MjMgWicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21SRkMyODIyKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlUkZDMjgyMkRhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJSRkMgMjgyMlwiLCB0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGFuIEhUVFAgaGVhZGVyIGRhdGVcbiAgICogQHNlZSBodHRwczovL3d3dy53My5vcmcvUHJvdG9jb2xzL3JmYzI2MTYvcmZjMjYxNi1zZWMzLmh0bWwjc2VjMy4zLjFcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgSFRUUCBoZWFkZXIgZGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdG8gYWZmZWN0IHRoZSBjcmVhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ3xab25lfSBbb3B0cy56b25lPSdsb2NhbCddIC0gY29udmVydCB0aGUgdGltZSB0byB0aGlzIHpvbmUuIFNpbmNlIEhUVFAgZGF0ZXMgYXJlIGFsd2F5cyBpbiBVVEMsIHRoaXMgaGFzIG5vIGVmZmVjdCBvbiB0aGUgaW50ZXJwcmV0YXRpb24gb2Ygc3RyaW5nLCBtZXJlbHkgdGhlIHpvbmUgdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpcyBleHByZXNzZWQgaW4uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc2V0Wm9uZT1mYWxzZV0gLSBvdmVycmlkZSB0aGUgem9uZSB3aXRoIHRoZSBmaXhlZC1vZmZzZXQgem9uZSBzcGVjaWZpZWQgaW4gdGhlIHN0cmluZy4gRm9yIEhUVFAgZGF0ZXMsIHRoaXMgaXMgYWx3YXlzIFVUQywgc28gdGhpcyBvcHRpb24gaXMgZXF1aXZhbGVudCB0byBzZXR0aW5nIHRoZSBgem9uZWAgb3B0aW9uIHRvICd1dGMnLCBidXQgdGhpcyBvcHRpb24gaXMgaW5jbHVkZWQgZm9yIGNvbnNpc3RlbmN5IHdpdGggc2ltaWxhciBtZXRob2RzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdzeXN0ZW0ncyBsb2NhbGUnXSAtIGEgbG9jYWxlIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm91dHB1dENhbGVuZGFyIC0gdGhlIG91dHB1dCBjYWxlbmRhciB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5udW1iZXJpbmdTeXN0ZW0gLSB0aGUgbnVtYmVyaW5nIHN5c3RlbSB0byBzZXQgb24gdGhlIHJlc3VsdGluZyBEYXRlVGltZSBpbnN0YW5jZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuLCAwNiBOb3YgMTk5NCAwODo0OTozNyBHTVQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tSFRUUCgnU3VuZGF5LCAwNi1Ob3YtOTQgMDg6NDk6MzcgR01UJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbUhUVFAoJ1N1biBOb3YgIDYgMDg6NDk6MzcgMTk5NCcpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21IVFRQKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlSFRUUERhdGUodGV4dCk7XG4gICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgXCJIVFRQXCIsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIERhdGVUaW1lIGZyb20gYW4gaW5wdXQgc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nLlxuICAgKiBEZWZhdWx0cyB0byBlbi1VUyBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkLCByZWdhcmRsZXNzIG9mIHRoZSBzeXN0ZW0ncyBsb2NhbGUuIEZvciBhIHRhYmxlIG9mIHRva2VucyBhbmQgdGhlaXIgaW50ZXJwcmV0YXRpb25zLCBzZWUgW2hlcmVdKGh0dHBzOi8vbW9tZW50LmdpdGh1Yi5pby9sdXhvbi8jL3BhcnNpbmc/aWQ9dGFibGUtb2YtdG9rZW5zKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHRoZSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gKHNlZSB0aGUgbGluayBiZWxvdyBmb3IgdGhlIGZvcm1hdHMpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9ucyB0byBhZmZlY3QgdGhlIGNyZWF0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfFpvbmV9IFtvcHRzLnpvbmU9J2xvY2FsJ10gLSB1c2UgdGhpcyB6b25lIGlmIG5vIG9mZnNldCBpcyBzcGVjaWZpZWQgaW4gdGhlIGlucHV0IHN0cmluZyBpdHNlbGYuIFdpbGwgYWxzbyBjb252ZXJ0IHRoZSBEYXRlVGltZSB0byB0aGlzIHpvbmVcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zZXRab25lPWZhbHNlXSAtIG92ZXJyaWRlIHRoZSB6b25lIHdpdGggYSB6b25lIHNwZWNpZmllZCBpbiB0aGUgc3RyaW5nIGl0c2VsZiwgaWYgaXQgc3BlY2lmaWVzIG9uZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubG9jYWxlPSdlbi1VUyddIC0gYSBsb2NhbGUgc3RyaW5nIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIERhdGVUaW1lIHRvIHRoaXMgbG9jYWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLm51bWJlcmluZ1N5c3RlbSAtIHRoZSBudW1iZXJpbmcgc3lzdGVtIHRvIHVzZSB3aGVuIHBhcnNpbmcuIFdpbGwgYWxzbyBzZXQgdGhlIHJlc3VsdGluZyBEYXRlVGltZSB0byB0aGlzIG51bWJlcmluZyBzeXN0ZW1cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMub3V0cHV0Q2FsZW5kYXIgLSB0aGUgb3V0cHV0IGNhbGVuZGFyIHRvIHNldCBvbiB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIGluc3RhbmNlXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzID0ge30pIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGV4dCkgfHwgaXNVbmRlZmluZWQoZm10KSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwiZnJvbUZvcm1hdCByZXF1aXJlcyBhbiBpbnB1dCBzdHJpbmcgYW5kIGEgZm9ybWF0XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgbG9jYWxlID0gbnVsbCwgbnVtYmVyaW5nU3lzdGVtID0gbnVsbCB9ID0gb3B0cyxcbiAgICAgIGxvY2FsZVRvVXNlID0gTG9jYWxlLmZyb21PcHRzKHtcbiAgICAgICAgbG9jYWxlLFxuICAgICAgICBudW1iZXJpbmdTeXN0ZW0sXG4gICAgICAgIGRlZmF1bHRUb0VOOiB0cnVlLFxuICAgICAgfSksXG4gICAgICBbdmFscywgcGFyc2VkWm9uZSwgc3BlY2lmaWNPZmZzZXQsIGludmFsaWRdID0gcGFyc2VGcm9tVG9rZW5zKGxvY2FsZVRvVXNlLCB0ZXh0LCBmbXQpO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICByZXR1cm4gRGF0ZVRpbWUuaW52YWxpZChpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlRGF0YVRvRGF0ZVRpbWUodmFscywgcGFyc2VkWm9uZSwgb3B0cywgYGZvcm1hdCAke2ZtdH1gLCB0ZXh0LCBzcGVjaWZpY09mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBmcm9tRm9ybWF0IGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU3RyaW5nKHRleHQsIGZtdCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21Gb3JtYXQodGV4dCwgZm10LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBEYXRlVGltZSBmcm9tIGEgU1FMIGRhdGUsIHRpbWUsIG9yIGRhdGV0aW1lXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRvIGFmZmVjdCB0aGUgY3JlYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW29wdHMuem9uZT0nbG9jYWwnXSAtIHVzZSB0aGlzIHpvbmUgaWYgbm8gb2Zmc2V0IGlzIHNwZWNpZmllZCBpbiB0aGUgaW5wdXQgc3RyaW5nIGl0c2VsZi4gV2lsbCBhbHNvIGNvbnZlcnQgdGhlIERhdGVUaW1lIHRvIHRoaXMgem9uZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNldFpvbmU9ZmFsc2VdIC0gb3ZlcnJpZGUgdGhlIHpvbmUgd2l0aCBhIHpvbmUgc3BlY2lmaWVkIGluIHRoZSBzdHJpbmcgaXRzZWxmLCBpZiBpdCBzcGVjaWZpZXMgb25lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5sb2NhbGU9J2VuLVVTJ10gLSBhIGxvY2FsZSBzdHJpbmcgdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgRGF0ZVRpbWUgdG8gdGhpcyBsb2NhbGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubnVtYmVyaW5nU3lzdGVtIC0gdGhlIG51bWJlcmluZyBzeXN0ZW0gdG8gdXNlIHdoZW4gcGFyc2luZy4gV2lsbCBhbHNvIHNldCB0aGUgcmVzdWx0aW5nIERhdGVUaW1lIHRvIHRoaXMgbnVtYmVyaW5nIHN5c3RlbVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5vdXRwdXRDYWxlbmRhciAtIHRoZSBvdXRwdXQgY2FsZW5kYXIgdG8gc2V0IG9uIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWUgaW5zdGFuY2VcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNScpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQnKVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcyMDE3LTA1LTE1IDA5OjEyOjM0LjM0MicpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyKzA2OjAwJylcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDIgQW1lcmljYS9Mb3NfQW5nZWxlcycpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmZyb21TUUwoJzIwMTctMDUtMTUgMDk6MTI6MzQuMzQyIEFtZXJpY2EvTG9zX0FuZ2VsZXMnLCB7IHNldFpvbmU6IHRydWUgfSlcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUuZnJvbVNRTCgnMjAxNy0wNS0xNSAwOToxMjozNC4zNDInLCB7IHpvbmU6ICdBbWVyaWNhL0xvc19BbmdlbGVzJyB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5mcm9tU1FMKCcwOToxMjozNC4zNDInKVxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHN0YXRpYyBmcm9tU1FMKHRleHQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IFt2YWxzLCBwYXJzZWRab25lXSA9IHBhcnNlU1FMKHRleHQpO1xuICAgIHJldHVybiBwYXJzZURhdGFUb0RhdGVUaW1lKHZhbHMsIHBhcnNlZFpvbmUsIG9wdHMsIFwiU1FMXCIsIHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnZhbGlkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uIC0gc2ltcGxlIHN0cmluZyBvZiB3aHkgdGhpcyBEYXRlVGltZSBpcyBpbnZhbGlkLiBTaG91bGQgbm90IGNvbnRhaW4gcGFyYW1ldGVycyBvciBhbnl0aGluZyBlbHNlIGRhdGEtZGVwZW5kZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V4cGxhbmF0aW9uPW51bGxdIC0gbG9uZ2VyIGV4cGxhbmF0aW9uLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzIGFuZCBvdGhlciB1c2VmdWwgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhdGljIGludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibmVlZCB0byBzcGVjaWZ5IGEgcmVhc29uIHRoZSBEYXRlVGltZSBpcyBpbnZhbGlkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGludmFsaWQgPSByZWFzb24gaW5zdGFuY2VvZiBJbnZhbGlkID8gcmVhc29uIDogbmV3IEludmFsaWQocmVhc29uLCBleHBsYW5hdGlvbik7XG5cbiAgICBpZiAoU2V0dGluZ3MudGhyb3dPbkludmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkRGF0ZVRpbWVFcnJvcihpbnZhbGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlVGltZSh7IGludmFsaWQgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBEYXRlVGltZS4gV29ya3MgYWNyb3NzIGNvbnRleHQgYm91bmRhcmllc1xuICAgKiBAcGFyYW0ge29iamVjdH0gb1xuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzRGF0ZVRpbWUobykge1xuICAgIHJldHVybiAobyAmJiBvLmlzTHV4b25EYXRlVGltZSkgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUHJvZHVjZSB0aGUgZm9ybWF0IHN0cmluZyBmb3IgYSBzZXQgb2Ygb3B0aW9uc1xuICAgKiBAcGFyYW0gZm9ybWF0T3B0c1xuICAgKiBAcGFyYW0gbG9jYWxlT3B0c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIHBhcnNlRm9ybWF0Rm9yT3B0cyhmb3JtYXRPcHRzLCBsb2NhbGVPcHRzID0ge30pIHtcbiAgICBjb25zdCB0b2tlbkxpc3QgPSBmb3JtYXRPcHRzVG9Ub2tlbnMoZm9ybWF0T3B0cywgTG9jYWxlLmZyb21PYmplY3QobG9jYWxlT3B0cykpO1xuICAgIHJldHVybiAhdG9rZW5MaXN0ID8gbnVsbCA6IHRva2VuTGlzdC5tYXAoKHQpID0+ICh0ID8gdC52YWwgOiBudWxsKSkuam9pbihcIlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlIHRoZSB0aGUgZnVsbHkgZXhwYW5kZWQgZm9ybWF0IHRva2VuIGZvciB0aGUgbG9jYWxlXG4gICAqIERvZXMgTk9UIHF1b3RlIGNoYXJhY3RlcnMsIHNvIHF1b3RlZCB0b2tlbnMgd2lsbCBub3Qgcm91bmQgdHJpcCBjb3JyZWN0bHlcbiAgICogQHBhcmFtIGZtdFxuICAgKiBAcGFyYW0gbG9jYWxlT3B0c1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGV4cGFuZEZvcm1hdChmbXQsIGxvY2FsZU9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGV4cGFuZGVkID0gZXhwYW5kTWFjcm9Ub2tlbnMoRm9ybWF0dGVyLnBhcnNlRm9ybWF0KGZtdCksIExvY2FsZS5mcm9tT2JqZWN0KGxvY2FsZU9wdHMpKTtcbiAgICByZXR1cm4gZXhwYW5kZWQubWFwKCh0KSA9PiB0LnZhbCkuam9pbihcIlwiKTtcbiAgfVxuXG4gIC8vIElORk9cblxuICAvKipcbiAgICogR2V0IHRoZSB2YWx1ZSBvZiB1bml0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIGEgdW5pdCBzdWNoIGFzICdtaW51dGUnIG9yICdkYXknXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnbW9udGgnKTsgLy89PiA3XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDcsIDQpLmdldCgnZGF5Jyk7IC8vPT4gNFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQodW5pdCkge1xuICAgIHJldHVybiB0aGlzW3VuaXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgdmFsaWQuIEludmFsaWQgRGF0ZVRpbWVzIG9jY3VyIHdoZW46XG4gICAqICogVGhlIERhdGVUaW1lIHdhcyBjcmVhdGVkIGZyb20gaW52YWxpZCBjYWxlbmRhciBpbmZvcm1hdGlvbiwgc3VjaCBhcyB0aGUgMTN0aCBtb250aCBvciBGZWJydWFyeSAzMFxuICAgKiAqIFRoZSBEYXRlVGltZSB3YXMgY3JlYXRlZCBieSBhbiBvcGVyYXRpb24gb24gYW5vdGhlciBpbnZhbGlkIGRhdGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZXJyb3IgY29kZSBpZiB0aGlzIERhdGVUaW1lIGlzIGludmFsaWQsIG9yIG51bGwgaWYgdGhlIERhdGVUaW1lIGlzIHZhbGlkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgaW52YWxpZFJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnZhbGlkID8gdGhpcy5pbnZhbGlkLnJlYXNvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBEYXRlVGltZSBiZWNhbWUgaW52YWxpZCwgb3IgbnVsbCBpZiB0aGUgRGF0ZVRpbWUgaXMgdmFsaWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBpbnZhbGlkRXhwbGFuYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW52YWxpZCA/IHRoaXMuaW52YWxpZC5leHBsYW5hdGlvbiA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBsb2NhbGUgb2YgYSBEYXRlVGltZSwgc3VjaCAnZW4tR0InLiBUaGUgbG9jYWxlIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxvY2FsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubG9jYWxlIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG51bWJlcmluZyBzeXN0ZW0gb2YgYSBEYXRlVGltZSwgc3VjaCAnYmVuZycuIFRoZSBudW1iZXJpbmcgc3lzdGVtIGlzIHVzZWQgd2hlbiBmb3JtYXR0aW5nIHRoZSBEYXRlVGltZVxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG51bWJlcmluZ1N5c3RlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2MubnVtYmVyaW5nU3lzdGVtIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG91dHB1dCBjYWxlbmRhciBvZiBhIERhdGVUaW1lLCBzdWNoICdpc2xhbWljJy4gVGhlIG91dHB1dCBjYWxlbmRhciBpcyB1c2VkIHdoZW4gZm9ybWF0dGluZyB0aGUgRGF0ZVRpbWVcbiAgICpcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvdXRwdXRDYWxlbmRhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5sb2Mub3V0cHV0Q2FsZW5kYXIgOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGltZSB6b25lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIERhdGVUaW1lLlxuICAgKiBAdHlwZSB7Wm9uZX1cbiAgICovXG4gIGdldCB6b25lKCkge1xuICAgIHJldHVybiB0aGlzLl96b25lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgdGltZSB6b25lLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHpvbmVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnpvbmUubmFtZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB5ZWFyXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS55ZWFyIC8vPT4gMjAxN1xuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHllYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy55ZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVhcnRlclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkucXVhcnRlciAvLz0+IDJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBxdWFydGVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBNYXRoLmNlaWwodGhpcy5jLm1vbnRoIC8gMykgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtb250aCAoMS0xMikuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5tb250aCAvLz0+IDVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtb250aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1vbnRoIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSBtb250aCAoMS0zMGlzaCkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5kYXkgLy89PiAyNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGRheSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLmRheSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvdXIgb2YgdGhlIGRheSAoMC0yMykuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5KS5ob3VyIC8vPT4gOVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5ob3VyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbWludXRlIG9mIHRoZSBob3VyICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwKS5taW51dGUgLy89PiAzMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG1pbnV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbnV0ZSA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNlY29uZCBvZiB0aGUgbWludXRlICgwLTU5KS5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNywgNSwgMjUsIDksIDMwLCA1Mikuc2Vjb25kIC8vPT4gNTJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBzZWNvbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCA/IHRoaXMuYy5zZWNvbmQgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtaWxsaXNlY29uZCBvZiB0aGUgc2Vjb25kICgwLTk5OSkuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1LCA5LCAzMCwgNTIsIDY1NCkubWlsbGlzZWNvbmQgLy89PiA2NTRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBtaWxsaXNlY29uZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy5jLm1pbGxpc2Vjb25kIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAxMiwgMzEpLndlZWtZZWFyIC8vPT4gMjAxNVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtZZWFyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgd2VlayBudW1iZXIgb2YgdGhlIHdlZWsgeWVhciAoMS01MmlzaCkuXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkud2Vla051bWJlciAvLz0+IDIxXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2Vla051bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gcG9zc2libHlDYWNoZWRXZWVrRGF0YSh0aGlzKS53ZWVrTnVtYmVyIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGF5IG9mIHRoZSB3ZWVrLlxuICAgKiAxIGlzIE1vbmRheSBhbmQgNyBpcyBTdW5kYXlcbiAgICogQHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDExLCAzMSkud2Vla2RheSAvLz0+IDRcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCB3ZWVrZGF5KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBwb3NzaWJseUNhY2hlZFdlZWtEYXRhKHRoaXMpLndlZWtkYXkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBvcmRpbmFsIChtZWFuaW5nIHRoZSBkYXkgb2YgdGhlIHllYXIpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDUsIDI1KS5vcmRpbmFsIC8vPT4gMTQ1XG4gICAqIEB0eXBlIHtudW1iZXJ8RGF0ZVRpbWV9XG4gICAqL1xuICBnZXQgb3JkaW5hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gZ3JlZ29yaWFuVG9PcmRpbmFsKHRoaXMuYykub3JkaW5hbCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIHNob3J0IG1vbnRoIG5hbWUsIHN1Y2ggYXMgJ09jdCcuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCAxMCwgMzApLm1vbnRoU2hvcnQgLy89PiBPY3RcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBtb250aFNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLm1vbnRocyhcInNob3J0XCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgbG9uZyBtb250aCBuYW1lLCBzdWNoIGFzICdPY3RvYmVyJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkubW9udGhMb25nIC8vPT4gT2N0b2JlclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IG1vbnRoTG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby5tb250aHMoXCJsb25nXCIsIHsgbG9jT2JqOiB0aGlzLmxvYyB9KVt0aGlzLm1vbnRoIC0gMV0gOiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaHVtYW4gcmVhZGFibGUgc2hvcnQgd2Vla2RheSwgc3VjaCBhcyAnTW9uJy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheVNob3J0IC8vPT4gTW9uXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgd2Vla2RheVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBJbmZvLndlZWtkYXlzKFwic2hvcnRcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGh1bWFuIHJlYWRhYmxlIGxvbmcgd2Vla2RheSwgc3VjaCBhcyAnTW9uZGF5Jy5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTcsIDEwLCAzMCkud2Vla2RheUxvbmcgLy89PiBNb25kYXlcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCB3ZWVrZGF5TG9uZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW5mby53ZWVrZGF5cyhcImxvbmdcIiwgeyBsb2NPYmo6IHRoaXMubG9jIH0pW3RoaXMud2Vla2RheSAtIDFdIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIFVUQyBvZmZzZXQgb2YgdGhpcyBEYXRlVGltZSBpbiBtaW51dGVzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm9mZnNldCAvLz0+IC0yNDBcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkub2Zmc2V0IC8vPT4gMFxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gK3RoaXMubyA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHNob3J0IGh1bWFuIG5hbWUgZm9yIHRoZSB6b25lJ3MgY3VycmVudCBvZmZzZXQsIGZvciBleGFtcGxlIFwiRVNUXCIgb3IgXCJFRFRcIi5cbiAgICogRGVmYXVsdHMgdG8gdGhlIHN5c3RlbSdzIGxvY2FsZSBpZiBubyBsb2NhbGUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgb2Zmc2V0TmFtZVNob3J0KCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnpvbmUub2Zmc2V0TmFtZSh0aGlzLnRzLCB7XG4gICAgICAgIGZvcm1hdDogXCJzaG9ydFwiLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGxvbmcgaHVtYW4gbmFtZSBmb3IgdGhlIHpvbmUncyBjdXJyZW50IG9mZnNldCwgZm9yIGV4YW1wbGUgXCJFYXN0ZXJuIFN0YW5kYXJkIFRpbWVcIiBvciBcIkVhc3Rlcm4gRGF5bGlnaHQgVGltZVwiLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIGdldCBvZmZzZXROYW1lTG9uZygpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy56b25lLm9mZnNldE5hbWUodGhpcy50cywge1xuICAgICAgICBmb3JtYXQ6IFwibG9uZ1wiLFxuICAgICAgICBsb2NhbGU6IHRoaXMubG9jYWxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGlzIHpvbmUncyBvZmZzZXQgZXZlciBjaGFuZ2VzLCBhcyBpbiBhIERTVC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgaXNPZmZzZXRGaXhlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy56b25lLmlzVW5pdmVyc2FsIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGUgRGF0ZVRpbWUgaXMgaW4gYSBEU1QuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzSW5EU1QoKSB7XG4gICAgaWYgKHRoaXMuaXNPZmZzZXRGaXhlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLm9mZnNldCA+IHRoaXMuc2V0KHsgbW9udGg6IDEsIGRheTogMSB9KS5vZmZzZXQgfHxcbiAgICAgICAgdGhpcy5vZmZzZXQgPiB0aGlzLnNldCh7IG1vbnRoOiA1IH0pLm9mZnNldFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRob3NlIERhdGVUaW1lcyB3aGljaCBoYXZlIHRoZSBzYW1lIGxvY2FsIHRpbWUgYXMgdGhpcyBEYXRlVGltZSwgYnV0IGEgZGlmZmVyZW50IG9mZnNldCBmcm9tIFVUQ1xuICAgKiBpbiB0aGlzIERhdGVUaW1lJ3Mgem9uZS4gRHVyaW5nIERTVCBjaGFuZ2VzIGxvY2FsIHRpbWUgY2FuIGJlIGFtYmlndW91cywgZm9yIGV4YW1wbGVcbiAgICogYDIwMjMtMTAtMjlUMDI6MzA6MDBgIGluIGBFdXJvcGUvQmVybGluYCBjYW4gaGF2ZSBvZmZzZXQgYCswMTowMGAgb3IgYCswMjowMGAuXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGJvdGggcG9zc2libGUgRGF0ZVRpbWVzIGlmIHRoaXMgRGF0ZVRpbWUncyBsb2NhbCB0aW1lIGlzIGFtYmlndW91cy5cbiAgICogQHJldHVybnMge0RhdGVUaW1lW119XG4gICAqL1xuICBnZXRQb3NzaWJsZU9mZnNldHMoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQgfHwgdGhpcy5pc09mZnNldEZpeGVkKSB7XG4gICAgICByZXR1cm4gW3RoaXNdO1xuICAgIH1cbiAgICBjb25zdCBkYXlNcyA9IDg2NDAwMDAwO1xuICAgIGNvbnN0IG1pbnV0ZU1zID0gNjAwMDA7XG4gICAgY29uc3QgbG9jYWxUUyA9IG9ialRvTG9jYWxUUyh0aGlzLmMpO1xuICAgIGNvbnN0IG9FYXJsaWVyID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gZGF5TXMpO1xuICAgIGNvbnN0IG9MYXRlciA9IHRoaXMuem9uZS5vZmZzZXQobG9jYWxUUyArIGRheU1zKTtcblxuICAgIGNvbnN0IG8xID0gdGhpcy56b25lLm9mZnNldChsb2NhbFRTIC0gb0VhcmxpZXIgKiBtaW51dGVNcyk7XG4gICAgY29uc3QgbzIgPSB0aGlzLnpvbmUub2Zmc2V0KGxvY2FsVFMgLSBvTGF0ZXIgKiBtaW51dGVNcyk7XG4gICAgaWYgKG8xID09PSBvMikge1xuICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICB9XG4gICAgY29uc3QgdHMxID0gbG9jYWxUUyAtIG8xICogbWludXRlTXM7XG4gICAgY29uc3QgdHMyID0gbG9jYWxUUyAtIG8yICogbWludXRlTXM7XG4gICAgY29uc3QgYzEgPSB0c1RvT2JqKHRzMSwgbzEpO1xuICAgIGNvbnN0IGMyID0gdHNUb09iaih0czIsIG8yKTtcbiAgICBpZiAoXG4gICAgICBjMS5ob3VyID09PSBjMi5ob3VyICYmXG4gICAgICBjMS5taW51dGUgPT09IGMyLm1pbnV0ZSAmJlxuICAgICAgYzEuc2Vjb25kID09PSBjMi5zZWNvbmQgJiZcbiAgICAgIGMxLm1pbGxpc2Vjb25kID09PSBjMi5taWxsaXNlY29uZFxuICAgICkge1xuICAgICAgcmV0dXJuIFtjbG9uZSh0aGlzLCB7IHRzOiB0czEgfSksIGNsb25lKHRoaXMsIHsgdHM6IHRzMiB9KV07XG4gICAgfVxuICAgIHJldHVybiBbdGhpc107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgRGF0ZVRpbWUgaXMgaW4gYSBsZWFwIHllYXIsIGZhbHNlIG90aGVyd2lzZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5pc0luTGVhcFllYXIgLy89PiB0cnVlXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmlzSW5MZWFwWWVhciAvLz0+IGZhbHNlXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGlzSW5MZWFwWWVhcigpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBkYXlzIGluIHRoaXMgRGF0ZVRpbWUncyBtb250aFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2LCAyKS5kYXlzSW5Nb250aCAvLz0+IDI5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTYsIDMpLmRheXNJbk1vbnRoIC8vPT4gMzFcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5Nb250aCgpIHtcbiAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyLCB0aGlzLm1vbnRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGlzIERhdGVUaW1lJ3MgeWVhclxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE2KS5kYXlzSW5ZZWFyIC8vPT4gMzY2XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTMpLmRheXNJblllYXIgLy89PiAzNjVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGdldCBkYXlzSW5ZZWFyKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyBkYXlzSW5ZZWFyKHRoaXMueWVhcikgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHdlZWtzIGluIHRoaXMgRGF0ZVRpbWUncyB5ZWFyXG4gICAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDA0KS53ZWVrc0luV2Vla1llYXIgLy89PiA1M1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDEzKS53ZWVrc0luV2Vla1llYXIgLy89PiA1MlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gd2Vla3NJbldlZWtZZWFyKHRoaXMud2Vla1llYXIpIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlc29sdmVkIEludGwgb3B0aW9ucyBmb3IgdGhpcyBEYXRlVGltZS5cbiAgICogVGhpcyBpcyB1c2VmdWwgaW4gdW5kZXJzdGFuZGluZyB0aGUgYmVoYXZpb3Igb2YgZm9ybWF0dGluZyBtZXRob2RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gdGhlIHNhbWUgb3B0aW9ucyBhcyB0b0xvY2FsZVN0cmluZ1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICByZXNvbHZlZExvY2FsZU9wdGlvbnMob3B0cyA9IHt9KSB7XG4gICAgY29uc3QgeyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgY2FsZW5kYXIgfSA9IEZvcm1hdHRlci5jcmVhdGUoXG4gICAgICB0aGlzLmxvYy5jbG9uZShvcHRzKSxcbiAgICAgIG9wdHNcbiAgICApLnJlc29sdmVkT3B0aW9ucyh0aGlzKTtcbiAgICByZXR1cm4geyBsb2NhbGUsIG51bWJlcmluZ1N5c3RlbSwgb3V0cHV0Q2FsZW5kYXI6IGNhbGVuZGFyIH07XG4gIH1cblxuICAvLyBUUkFOU0ZPUk1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIFVUQy4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIHtAbGluayBEYXRlVGltZSNzZXRab25lfSgndXRjJylcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvZmZzZXQ9MF0gLSBvcHRpb25hbGx5LCBhbiBvZmZzZXQgZnJvbSBVVEMgaW4gbWludXRlc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdHM9e31dIC0gb3B0aW9ucyB0byBwYXNzIHRvIGBzZXRab25lKClgXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgdG9VVEMob2Zmc2V0ID0gMCwgb3B0cyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Wm9uZShGaXhlZE9mZnNldFpvbmUuaW5zdGFuY2Uob2Zmc2V0KSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIHRoZSBob3N0J3MgbG9jYWwgem9uZS4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIGBzZXRab25lKCdsb2NhbCcpYFxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHRvTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0Wm9uZShTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgRGF0ZVRpbWUncyB6b25lIHRvIHNwZWNpZmllZCB6b25lLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoZSBzZXR0ZXIga2VlcHMgdGhlIHVuZGVybHlpbmcgdGltZSB0aGUgc2FtZSAoYXMgaW4sIHRoZSBzYW1lIHRpbWVzdGFtcCksIGJ1dCB0aGUgbmV3IGluc3RhbmNlIHdpbGwgcmVwb3J0IGRpZmZlcmVudCBsb2NhbCB0aW1lcyBhbmQgY29uc2lkZXIgRFNUcyB3aGVuIG1ha2luZyBjb21wdXRhdGlvbnMsIGFzIHdpdGgge0BsaW5rIERhdGVUaW1lI3BsdXN9LiBZb3UgbWF5IHdpc2ggdG8gdXNlIHtAbGluayBEYXRlVGltZSN0b0xvY2FsfSBhbmQge0BsaW5rIERhdGVUaW1lI3RvVVRDfSB3aGljaCBwcm92aWRlIHNpbXBsZSBjb252ZW5pZW5jZSB3cmFwcGVycyBmb3IgY29tbW9ubHkgdXNlZCB6b25lcy5cbiAgICogQHBhcmFtIHtzdHJpbmd8Wm9uZX0gW3pvbmU9J2xvY2FsJ10gLSBhIHpvbmUgaWRlbnRpZmllci4gQXMgYSBzdHJpbmcsIHRoYXQgY2FuIGJlIGFueSBJQU5BIHpvbmUgc3VwcG9ydGVkIGJ5IHRoZSBob3N0IGVudmlyb25tZW50LCBvciBhIGZpeGVkLW9mZnNldCBuYW1lIG9mIHRoZSBmb3JtICdVVEMrMycsIG9yIHRoZSBzdHJpbmdzICdsb2NhbCcgb3IgJ3V0YycuIFlvdSBtYXkgYWxzbyBzdXBwbHkgYW4gaW5zdGFuY2Ugb2YgYSB7QGxpbmsgRGF0ZVRpbWUjWm9uZX0gY2xhc3MuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmtlZXBMb2NhbFRpbWU9ZmFsc2VdIC0gSWYgdHJ1ZSwgYWRqdXN0IHRoZSB1bmRlcmx5aW5nIHRpbWUgc28gdGhhdCB0aGUgbG9jYWwgdGltZSBzdGF5cyB0aGUgc2FtZSwgYnV0IGluIHRoZSB0YXJnZXQgem9uZS4gWW91IHNob3VsZCByYXJlbHkgbmVlZCB0aGlzLlxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHNldFpvbmUoem9uZSwgeyBrZWVwTG9jYWxUaW1lID0gZmFsc2UsIGtlZXBDYWxlbmRhclRpbWUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICB6b25lID0gbm9ybWFsaXplWm9uZSh6b25lLCBTZXR0aW5ncy5kZWZhdWx0Wm9uZSk7XG4gICAgaWYgKHpvbmUuZXF1YWxzKHRoaXMuem9uZSkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSBpZiAoIXpvbmUuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIERhdGVUaW1lLmludmFsaWQodW5zdXBwb3J0ZWRab25lKHpvbmUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG5ld1RTID0gdGhpcy50cztcbiAgICAgIGlmIChrZWVwTG9jYWxUaW1lIHx8IGtlZXBDYWxlbmRhclRpbWUpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0R3Vlc3MgPSB6b25lLm9mZnNldCh0aGlzLnRzKTtcbiAgICAgICAgY29uc3QgYXNPYmogPSB0aGlzLnRvT2JqZWN0KCk7XG4gICAgICAgIFtuZXdUU10gPSBvYmpUb1RTKGFzT2JqLCBvZmZzZXRHdWVzcywgem9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmUodGhpcywgeyB0czogbmV3VFMsIHpvbmUgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvciBvdXRwdXRDYWxlbmRhci4gUmV0dXJucyBhIG5ld2x5LWNvbnN0cnVjdGVkIERhdGVUaW1lLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIHRoZSBwcm9wZXJ0aWVzIHRvIHNldFxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkucmVjb25maWd1cmUoeyBsb2NhbGU6ICdlbi1HQicgfSlcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICByZWNvbmZpZ3VyZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9ID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLmxvYy5jbG9uZSh7IGxvY2FsZSwgbnVtYmVyaW5nU3lzdGVtLCBvdXRwdXRDYWxlbmRhciB9KTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgeyBsb2MgfSk7XG4gIH1cblxuICAvKipcbiAgICogXCJTZXRcIiB0aGUgbG9jYWxlLiBSZXR1cm5zIGEgbmV3bHktY29uc3RydWN0ZWQgRGF0ZVRpbWUuXG4gICAqIEp1c3QgYSBjb252ZW5pZW50IGFsaWFzIGZvciByZWNvbmZpZ3VyZSh7IGxvY2FsZSB9KVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE3LCA1LCAyNSkuc2V0TG9jYWxlKCdlbi1HQicpXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgIHJldHVybiB0aGlzLnJlY29uZmlndXJlKHsgbG9jYWxlIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdW5pdHMuIFJldHVybnMgYSBuZXdseS1jb25zdHJ1Y3RlZCBEYXRlVGltZS5cbiAgICogWW91IGNhbiBvbmx5IHNldCB1bml0cyB3aXRoIHRoaXMgbWV0aG9kOyBmb3IgXCJzZXR0aW5nXCIgbWV0YWRhdGEsIHNlZSB7QGxpbmsgRGF0ZVRpbWUjcmVjb25maWd1cmV9IGFuZCB7QGxpbmsgRGF0ZVRpbWUjc2V0Wm9uZX0uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZXMgLSBhIG1hcHBpbmcgb2YgdW5pdHMgdG8gbnVtYmVyc1xuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB5ZWFyOiAyMDE3IH0pXG4gICAqIEBleGFtcGxlIGR0LnNldCh7IGhvdXI6IDgsIG1pbnV0ZTogMzAgfSlcbiAgICogQGV4YW1wbGUgZHQuc2V0KHsgd2Vla2RheTogNSB9KVxuICAgKiBAZXhhbXBsZSBkdC5zZXQoeyB5ZWFyOiAyMDA1LCBvcmRpbmFsOiAyMzQgfSlcbiAgICogQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBzZXQodmFsdWVzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZU9iamVjdCh2YWx1ZXMsIG5vcm1hbGl6ZVVuaXQpLFxuICAgICAgc2V0dGluZ1dlZWtTdHVmZiA9XG4gICAgICAgICFpc1VuZGVmaW5lZChub3JtYWxpemVkLndlZWtZZWFyKSB8fFxuICAgICAgICAhaXNVbmRlZmluZWQobm9ybWFsaXplZC53ZWVrTnVtYmVyKSB8fFxuICAgICAgICAhaXNVbmRlZmluZWQobm9ybWFsaXplZC53ZWVrZGF5KSxcbiAgICAgIGNvbnRhaW5zT3JkaW5hbCA9ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLm9yZGluYWwpLFxuICAgICAgY29udGFpbnNHcmVnb3JZZWFyID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQueWVhciksXG4gICAgICBjb250YWluc0dyZWdvck1EID0gIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQubW9udGgpIHx8ICFpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSksXG4gICAgICBjb250YWluc0dyZWdvciA9IGNvbnRhaW5zR3JlZ29yWWVhciB8fCBjb250YWluc0dyZWdvck1ELFxuICAgICAgZGVmaW5pdGVXZWVrRGVmID0gbm9ybWFsaXplZC53ZWVrWWVhciB8fCBub3JtYWxpemVkLndlZWtOdW1iZXI7XG5cbiAgICBpZiAoKGNvbnRhaW5zR3JlZ29yIHx8IGNvbnRhaW5zT3JkaW5hbCkgJiYgZGVmaW5pdGVXZWVrRGVmKSB7XG4gICAgICB0aHJvdyBuZXcgQ29uZmxpY3RpbmdTcGVjaWZpY2F0aW9uRXJyb3IoXG4gICAgICAgIFwiQ2FuJ3QgbWl4IHdlZWtZZWFyL3dlZWtOdW1iZXIgdW5pdHMgd2l0aCB5ZWFyL21vbnRoL2RheSBvciBvcmRpbmFsc1wiXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChjb250YWluc0dyZWdvck1EICYmIGNvbnRhaW5zT3JkaW5hbCkge1xuICAgICAgdGhyb3cgbmV3IENvbmZsaWN0aW5nU3BlY2lmaWNhdGlvbkVycm9yKFwiQ2FuJ3QgbWl4IG9yZGluYWwgZGF0ZXMgd2l0aCBtb250aC9kYXlcIik7XG4gICAgfVxuXG4gICAgbGV0IG1peGVkO1xuICAgIGlmIChzZXR0aW5nV2Vla1N0dWZmKSB7XG4gICAgICBtaXhlZCA9IHdlZWtUb0dyZWdvcmlhbih7IC4uLmdyZWdvcmlhblRvV2Vlayh0aGlzLmMpLCAuLi5ub3JtYWxpemVkIH0pO1xuICAgIH0gZWxzZSBpZiAoIWlzVW5kZWZpbmVkKG5vcm1hbGl6ZWQub3JkaW5hbCkpIHtcbiAgICAgIG1peGVkID0gb3JkaW5hbFRvR3JlZ29yaWFuKHsgLi4uZ3JlZ29yaWFuVG9PcmRpbmFsKHRoaXMuYyksIC4uLm5vcm1hbGl6ZWQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1peGVkID0geyAuLi50aGlzLnRvT2JqZWN0KCksIC4uLm5vcm1hbGl6ZWQgfTtcblxuICAgICAgLy8gaWYgd2UgZGlkbid0IHNldCB0aGUgZGF5IGJ1dCB3ZSBlbmRlZCB1cCBvbiBhbiBvdmVyZmxvdyBkYXRlLFxuICAgICAgLy8gdXNlIHRoZSBsYXN0IGRheSBvZiB0aGUgcmlnaHQgbW9udGhcbiAgICAgIGlmIChpc1VuZGVmaW5lZChub3JtYWxpemVkLmRheSkpIHtcbiAgICAgICAgbWl4ZWQuZGF5ID0gTWF0aC5taW4oZGF5c0luTW9udGgobWl4ZWQueWVhciwgbWl4ZWQubW9udGgpLCBtaXhlZC5kYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFt0cywgb10gPSBvYmpUb1RTKG1peGVkLCB0aGlzLm8sIHRoaXMuem9uZSk7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIHsgdHMsIG8gfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgcGVyaW9kIG9mIHRpbWUgdG8gdGhpcyBEYXRlVGltZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgRGF0ZVRpbWVcbiAgICpcbiAgICogQWRkaW5nIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBvciBtaWxsaXNlY29uZHMgaW5jcmVhc2VzIHRoZSB0aW1lc3RhbXAgYnkgdGhlIHJpZ2h0IG51bWJlciBvZiBtaWxsaXNlY29uZHMuIEFkZGluZyBkYXlzLCBtb250aHMsIG9yIHllYXJzIHNoaWZ0cyB0aGUgY2FsZW5kYXIsIGFjY291bnRpbmcgZm9yIERTVHMgYW5kIGxlYXAgeWVhcnMgYWxvbmcgdGhlIHdheS4gVGh1cywgYGR0LnBsdXMoeyBob3VyczogMjQgfSlgIG1heSByZXN1bHQgaW4gYSBkaWZmZXJlbnQgdGltZSB0aGFuIGBkdC5wbHVzKHsgZGF5czogMSB9KWAgaWYgdGhlcmUncyBhIERTVCBzaGlmdCBpbiBiZXR3ZWVuLlxuICAgKiBAcGFyYW0ge0R1cmF0aW9ufE9iamVjdHxudW1iZXJ9IGR1cmF0aW9uIC0gVGhlIGFtb3VudCB0byBhZGQuIEVpdGhlciBhIEx1eG9uIER1cmF0aW9uLCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIHRoZSBvYmplY3QgYXJndW1lbnQgdG8gRHVyYXRpb24uZnJvbU9iamVjdCgpXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoMTIzKSAvL34+IGluIDEyMyBtaWxsaXNlY29uZHNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IG1pbnV0ZXM6IDE1IH0pIC8vfj4gaW4gMTUgbWludXRlc1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogMSB9KSAvL34+IHRoaXMgdGltZSB0b21vcnJvd1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5wbHVzKHsgZGF5czogLTEgfSkgLy9+PiB0aGlzIHRpbWUgeWVzdGVyZGF5XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBob3VyczogMywgbWludXRlczogMTMgfSkgLy9+PiBpbiAzIGhyLCAxMyBtaW5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyhEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDMsIG1pbnV0ZXM6IDEzIH0pKSAvL34+IGluIDMgaHIsIDEzIG1pblxuICAgKiBAcmV0dXJuIHtEYXRlVGltZX1cbiAgICovXG4gIHBsdXMoZHVyYXRpb24pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgZHVyID0gRHVyYXRpb24uZnJvbUR1cmF0aW9uTGlrZShkdXJhdGlvbik7XG4gICAgcmV0dXJuIGNsb25lKHRoaXMsIGFkanVzdFRpbWUodGhpcywgZHVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU3VidHJhY3QgYSBwZXJpb2Qgb2YgdGltZSB0byB0aGlzIERhdGVUaW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBEYXRlVGltZVxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI3BsdXN9XG4gICAqIEBwYXJhbSB7RHVyYXRpb258T2JqZWN0fG51bWJlcn0gZHVyYXRpb24gLSBUaGUgYW1vdW50IHRvIHN1YnRyYWN0LiBFaXRoZXIgYSBMdXhvbiBEdXJhdGlvbiwgYSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCB0aGUgb2JqZWN0IGFyZ3VtZW50IHRvIER1cmF0aW9uLmZyb21PYmplY3QoKVxuICAgQHJldHVybiB7RGF0ZVRpbWV9XG4gICAqL1xuICBtaW51cyhkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4gdGhpcztcbiAgICBjb25zdCBkdXIgPSBEdXJhdGlvbi5mcm9tRHVyYXRpb25MaWtlKGR1cmF0aW9uKS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY2xvbmUodGhpcywgYWRqdXN0VGltZSh0aGlzLCBkdXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcIlNldFwiIHRoaXMgRGF0ZVRpbWUgdG8gdGhlIGJlZ2lubmluZyBvZiBhIHVuaXQgb2YgdGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSBUaGUgdW5pdCB0byBnbyB0byB0aGUgYmVnaW5uaW5nIG9mLiBDYW4gYmUgJ3llYXInLCAncXVhcnRlcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCBvciAnbWlsbGlzZWNvbmQnLlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCdtb250aCcpLnRvSVNPRGF0ZSgpOyAvLz0+ICcyMDE0LTAzLTAxJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5zdGFydE9mKCd5ZWFyJykudG9JU09EYXRlKCk7IC8vPT4gJzIwMTQtMDEtMDEnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLnN0YXJ0T2YoJ3dlZWsnKS50b0lTT0RhdGUoKTsgLy89PiAnMjAxNC0wMy0wMycsIHdlZWtzIGFsd2F5cyBzdGFydCBvbiBNb25kYXlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMsIDUsIDMwKS5zdGFydE9mKCdkYXknKS50b0lTT1RpbWUoKTsgLy89PiAnMDA6MDAuMDAwLTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzLCA1LCAzMCkuc3RhcnRPZignaG91cicpLnRvSVNPVGltZSgpOyAvLz0+ICcwNTowMDowMC4wMDAtMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgc3RhcnRPZih1bml0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IG8gPSB7fSxcbiAgICAgIG5vcm1hbGl6ZWRVbml0ID0gRHVyYXRpb24ubm9ybWFsaXplVW5pdCh1bml0KTtcbiAgICBzd2l0Y2ggKG5vcm1hbGl6ZWRVbml0KSB7XG4gICAgICBjYXNlIFwieWVhcnNcIjpcbiAgICAgICAgby5tb250aCA9IDE7XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFwicXVhcnRlcnNcIjpcbiAgICAgIGNhc2UgXCJtb250aHNcIjpcbiAgICAgICAgby5kYXkgPSAxO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcIndlZWtzXCI6XG4gICAgICBjYXNlIFwiZGF5c1wiOlxuICAgICAgICBvLmhvdXIgPSAwO1xuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBcImhvdXJzXCI6XG4gICAgICAgIG8ubWludXRlID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJtaW51dGVzXCI6XG4gICAgICAgIG8uc2Vjb25kID0gMDtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgXCJzZWNvbmRzXCI6XG4gICAgICAgIG8ubWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWxsaXNlY29uZHNcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBubyBkZWZhdWx0LCBpbnZhbGlkIHVuaXRzIHRocm93IGluIG5vcm1hbGl6ZVVuaXQoKVxuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkVW5pdCA9PT0gXCJ3ZWVrc1wiKSB7XG4gICAgICBvLndlZWtkYXkgPSAxO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkVW5pdCA9PT0gXCJxdWFydGVyc1wiKSB7XG4gICAgICBjb25zdCBxID0gTWF0aC5jZWlsKHRoaXMubW9udGggLyAzKTtcbiAgICAgIG8ubW9udGggPSAocSAtIDEpICogMyArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc2V0KG8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFwiU2V0XCIgdGhpcyBEYXRlVGltZSB0byB0aGUgZW5kIChtZWFuaW5nIHRoZSBsYXN0IG1pbGxpc2Vjb25kKSBvZiBhIHVuaXQgb2YgdGltZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdW5pdCAtIFRoZSB1bml0IHRvIGdvIHRvIHRoZSBlbmQgb2YuIENhbiBiZSAneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsIG9yICdtaWxsaXNlY29uZCcuXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDMsIDMpLmVuZE9mKCdtb250aCcpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMDMtMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZigneWVhcicpLnRvSVNPKCk7IC8vPT4gJzIwMTQtMTItMzFUMjM6NTk6NTkuOTk5LTA1OjAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCAzLCAzKS5lbmRPZignd2VlaycpLnRvSVNPKCk7IC8vID0+ICcyMDE0LTAzLTA5VDIzOjU5OjU5Ljk5OS0wNTowMCcsIHdlZWtzIHN0YXJ0IG9uIE1vbmRheXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLmVuZE9mKCdkYXknKS50b0lTTygpOyAvLz0+ICcyMDE0LTAzLTAzVDIzOjU5OjU5Ljk5OS0wNTowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubG9jYWwoMjAxNCwgMywgMywgNSwgMzApLmVuZE9mKCdob3VyJykudG9JU08oKTsgLy89PiAnMjAxNC0wMy0wM1QwNTo1OTo1OS45OTktMDU6MDAnXG4gICAqIEByZXR1cm4ge0RhdGVUaW1lfVxuICAgKi9cbiAgZW5kT2YodW5pdCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gdGhpcy5wbHVzKHsgW3VuaXRdOiAxIH0pXG4gICAgICAgICAgLnN0YXJ0T2YodW5pdClcbiAgICAgICAgICAubWludXMoMSlcbiAgICAgIDogdGhpcztcbiAgfVxuXG4gIC8vIE9VVFBVVFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWVkIGZvcm1hdCBzdHJpbmcuXG4gICAqICoqWW91IG1heSBub3Qgd2FudCB0aGlzLioqIFNlZSB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvciBhIG1vcmUgZmxleGlibGUgZm9ybWF0dGluZyB0b29sLiBGb3IgYSB0YWJsZSBvZiB0b2tlbnMgYW5kIHRoZWlyIGludGVycHJldGF0aW9ucywgc2VlIFtoZXJlXShodHRwczovL21vbWVudC5naXRodWIuaW8vbHV4b24vIy9mb3JtYXR0aW5nP2lkPXRhYmxlLW9mLXRva2VucykuXG4gICAqIERlZmF1bHRzIHRvIGVuLVVTIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIHJlZ2FyZGxlc3Mgb2YgdGhlIHN5c3RlbSdzIGxvY2FsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZtdCAtIHRoZSBmb3JtYXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0cyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9uIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Gb3JtYXQoJ3l5eXkgTExMIGRkJykgLy89PiAnMjAxNyBBcHIgMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZSgnZnInKS50b0Zvcm1hdCgneXl5eSBMTEwgZGQnKSAvLz0+ICcyMDE3IGF2ci4gMjInXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvRm9ybWF0KCd5eXl5IExMTCBkZCcsIHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiAnMjAxNyBhdnIuIDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0Zvcm1hdChcIkhIICdob3VycyBhbmQnIG1tICdtaW51dGVzJ1wiKSAvLz0+ICcyMCBob3VycyBhbmQgNTUgbWludXRlcydcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9Gb3JtYXQoZm10LCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MucmVkZWZhdWx0VG9FTihvcHRzKSkuZm9ybWF0RGF0ZVRpbWVGcm9tU3RyaW5nKHRoaXMsIGZtdClcbiAgICAgIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbG9jYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhpcyBkYXRlLiBBY2NlcHRzIHRoZSBzYW1lIG9wdGlvbnMgYXMgdGhlIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3IgYW5kIGFueSBwcmVzZXRzIGRlZmluZWQgYnkgTHV4b24sIHN1Y2ggYXMgYERhdGVUaW1lLkRBVEVfRlVMTGAgb3IgYERhdGVUaW1lLlRJTUVfU0lNUExFYC5cbiAgICogVGhlIGV4YWN0IGJlaGF2aW9yIG9mIHRoaXMgbWV0aG9kIGlzIGJyb3dzZXItc3BlY2lmaWMsIGJ1dCBpbiBnZW5lcmFsIGl0IHdpbGwgcmV0dXJuIGFuIGFwcHJvcHJpYXRlIHJlcHJlc2VudGF0aW9uXG4gICAqIG9mIHRoZSBEYXRlVGltZSBpbiB0aGUgYXNzaWduZWQgbG9jYWxlLlxuICAgKiBEZWZhdWx0cyB0byB0aGUgc3lzdGVtJ3MgbG9jYWxlIGlmIG5vIGxvY2FsZSBoYXMgYmVlbiBzcGVjaWZpZWRcbiAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlVGltZUZvcm1hdFxuICAgKiBAcGFyYW0gZm9ybWF0T3B0cyB7T2JqZWN0fSAtIEludGwuRGF0ZVRpbWVGb3JtYXQgY29uc3RydWN0b3Igb3B0aW9ucyBhbmQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0cyB0byBvdmVycmlkZSB0aGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9uIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVTdHJpbmcoKTsgLy89PiA0LzIwLzIwMTdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkuc2V0TG9jYWxlKCdlbi1nYicpLnRvTG9jYWxlU3RyaW5nKCk7IC8vPT4gJzIwLzA0LzIwMTcnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKERhdGVUaW1lLkRBVEVfRlVMTCk7IC8vPT4gJ0FwcmlsIDIwLCAyMDE3J1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFX0ZVTEwsIHsgbG9jYWxlOiAnZnInIH0pOyAvLz0+ICcyOCBhb8O7dCAyMDIyJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5USU1FX1NJTVBMRSk7IC8vPT4gJzExOjMyIEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyhEYXRlVGltZS5EQVRFVElNRV9TSE9SVCk7IC8vPT4gJzQvMjAvMjAxNywgMTE6MzIgQU0nXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvTG9jYWxlU3RyaW5nKHsgd2Vla2RheTogJ2xvbmcnLCBtb250aDogJ2xvbmcnLCBkYXk6ICcyLWRpZ2l0JyB9KTsgLy89PiAnVGh1cnNkYXksIEFwcmlsIDIwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IHdlZWtkYXk6ICdzaG9ydCcsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICcyLWRpZ2l0JywgaG91cjogJzItZGlnaXQnLCBtaW51dGU6ICcyLWRpZ2l0JyB9KTsgLy89PiAnVGh1LCBBcHIgMjAsIDExOjI3IEFNJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS50b0xvY2FsZVN0cmluZyh7IGhvdXI6ICcyLWRpZ2l0JywgbWludXRlOiAnMi1kaWdpdCcsIGhvdXJDeWNsZTogJ2gyMycgfSk7IC8vPT4gJzExOjMyJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0xvY2FsZVN0cmluZyhmb3JtYXRPcHRzID0gRm9ybWF0cy5EQVRFX1NIT1JULCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkXG4gICAgICA/IEZvcm1hdHRlci5jcmVhdGUodGhpcy5sb2MuY2xvbmUob3B0cyksIGZvcm1hdE9wdHMpLmZvcm1hdERhdGVUaW1lKHRoaXMpXG4gICAgICA6IElOVkFMSUQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBmb3JtYXQgXCJwYXJ0c1wiLCBtZWFuaW5nIGluZGl2aWR1YWwgdG9rZW5zIGFsb25nIHdpdGggbWV0YWRhdGEuIFRoaXMgaXMgYWxsb3dzIGNhbGxlcnMgdG8gcG9zdC1wcm9jZXNzIGluZGl2aWR1YWwgc2VjdGlvbnMgb2YgdGhlIGZvcm1hdHRlZCBvdXRwdXQuXG4gICAqIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0ncyBsb2NhbGUgaWYgbm8gbG9jYWxlIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGVUaW1lRm9ybWF0L2Zvcm1hdFRvUGFydHNcbiAgICogQHBhcmFtIG9wdHMge09iamVjdH0gLSBJbnRsLkRhdGVUaW1lRm9ybWF0IGNvbnN0cnVjdG9yIG9wdGlvbnMsIHNhbWUgYXMgYHRvTG9jYWxlU3RyaW5nYC5cbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9Mb2NhbGVQYXJ0cygpOyAvLz0+IFtcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vPT4gICB7IHR5cGU6ICdkYXknLCB2YWx1ZTogJzI1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAnbW9udGgnLCB2YWx1ZTogJzA1JyB9LFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiAgIHsgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogJy8nIH0sXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLz0+ICAgeyB0eXBlOiAneWVhcicsIHZhbHVlOiAnMTk4MicgfVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy89PiBdXG4gICAqL1xuICB0b0xvY2FsZVBhcnRzKG9wdHMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWRcbiAgICAgID8gRm9ybWF0dGVyLmNyZWF0ZSh0aGlzLmxvYy5jbG9uZShvcHRzKSwgb3B0cykuZm9ybWF0RGF0ZVRpbWVQYXJ0cyh0aGlzKVxuICAgICAgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIElTTyA4NjAxLWNvbXBsaWFudCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRlVGltZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zdXBwcmVzc01pbGxpc2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIG1pbGxpc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NTZWNvbmRzPWZhbHNlXSAtIGV4Y2x1ZGUgc2Vjb25kcyBmcm9tIHRoZSBmb3JtYXQgaWYgdGhleSdyZSAwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldD10cnVlXSAtIGluY2x1ZGUgdGhlIG9mZnNldCwgc3VjaCBhcyAnWicgb3IgJy0wNDowMCdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5leHRlbmRlZFpvbmU9ZmFsc2VdIC0gYWRkIHRoZSB0aW1lIHpvbmUgZm9ybWF0IGV4dGVuc2lvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODMsIDUsIDI1KS50b0lTTygpIC8vPT4gJzE5ODItMDUtMjVUMDA6MDA6MDAuMDAwWidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oKSAvLz0+ICcyMDE3LTA0LTIyVDIwOjQ3OjA1LjMzNS0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcyMDE3LTA0LTIyVDIwOjQ3OjA1LjMzNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9JU08oeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMjAxNzA0MjJUMjA0NzA1LjMzNS0wNDAwJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0lTTyh7XG4gICAgZm9ybWF0ID0gXCJleHRlbmRlZFwiLFxuICAgIHN1cHByZXNzU2Vjb25kcyA9IGZhbHNlLFxuICAgIHN1cHByZXNzTWlsbGlzZWNvbmRzID0gZmFsc2UsXG4gICAgaW5jbHVkZU9mZnNldCA9IHRydWUsXG4gICAgZXh0ZW5kZWRab25lID0gZmFsc2UsXG4gIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBleHQgPSBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIjtcblxuICAgIGxldCBjID0gdG9JU09EYXRlKHRoaXMsIGV4dCk7XG4gICAgYyArPSBcIlRcIjtcbiAgICBjICs9IHRvSVNPVGltZSh0aGlzLCBleHQsIHN1cHByZXNzU2Vjb25kcywgc3VwcHJlc3NNaWxsaXNlY29uZHMsIGluY2x1ZGVPZmZzZXQsIGV4dGVuZGVkWm9uZSk7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyBkYXRlIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmZvcm1hdD0nZXh0ZW5kZWQnXSAtIGNob29zZSBiZXR3ZWVuIHRoZSBiYXNpYyBhbmQgZXh0ZW5kZWQgZm9ybWF0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygxOTgyLCA1LCAyNSkudG9JU09EYXRlKCkgLy89PiAnMTk4Mi0wNS0yNSdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT0RhdGUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMTk4MjA1MjUnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSVNPRGF0ZSh7IGZvcm1hdCA9IFwiZXh0ZW5kZWRcIiB9ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvSVNPRGF0ZSh0aGlzLCBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMS1jb21wbGlhbnQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUncyB3ZWVrIGRhdGVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDE5ODIsIDUsIDI1KS50b0lTT1dlZWtEYXRlKCkgLy89PiAnMTk4Mi1XMjEtMidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09XZWVrRGF0ZSgpIHtcbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIFwia2tray0nVydXVy1jXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gSVNPIDg2MDEtY29tcGxpYW50IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lJ3MgdGltZSBjb21wb25lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuc3VwcHJlc3NNaWxsaXNlY29uZHM9ZmFsc2VdIC0gZXhjbHVkZSBtaWxsaXNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnN1cHByZXNzU2Vjb25kcz1mYWxzZV0gLSBleGNsdWRlIHNlY29uZHMgZnJvbSB0aGUgZm9ybWF0IGlmIHRoZXkncmUgMFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuZXh0ZW5kZWRab25lPXRydWVdIC0gYWRkIHRoZSB0aW1lIHpvbmUgZm9ybWF0IGV4dGVuc2lvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVQcmVmaXg9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgYFRgIHByZWZpeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuZm9ybWF0PSdleHRlbmRlZCddIC0gY2hvb3NlIGJldHdlZW4gdGhlIGJhc2ljIGFuZCBleHRlbmRlZCBmb3JtYXRcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoKSAvLz0+ICcwNzozNDoxOS4zNjFaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoKS5zZXQoeyBob3VyOiA3LCBtaW51dGU6IDM0LCBzZWNvbmRzOiAwLCBtaWxsaXNlY29uZHM6IDAgfSkudG9JU09UaW1lKHsgc3VwcHJlc3NTZWNvbmRzOiB0cnVlIH0pIC8vPT4gJzA3OjM0WidcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkuc2V0KHsgaG91cjogNywgbWludXRlOiAzNCB9KS50b0lTT1RpbWUoeyBmb3JtYXQ6ICdiYXNpYycgfSkgLy89PiAnMDczNDE5LjM2MVonXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygpLnNldCh7IGhvdXI6IDcsIG1pbnV0ZTogMzQgfSkudG9JU09UaW1lKHsgaW5jbHVkZVByZWZpeDogdHJ1ZSB9KSAvLz0+ICdUMDc6MzQ6MTkuMzYxWidcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9JU09UaW1lKHtcbiAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyA9IGZhbHNlLFxuICAgIHN1cHByZXNzU2Vjb25kcyA9IGZhbHNlLFxuICAgIGluY2x1ZGVPZmZzZXQgPSB0cnVlLFxuICAgIGluY2x1ZGVQcmVmaXggPSBmYWxzZSxcbiAgICBleHRlbmRlZFpvbmUgPSBmYWxzZSxcbiAgICBmb3JtYXQgPSBcImV4dGVuZGVkXCIsXG4gIH0gPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgYyA9IGluY2x1ZGVQcmVmaXggPyBcIlRcIiA6IFwiXCI7XG4gICAgcmV0dXJuIChcbiAgICAgIGMgK1xuICAgICAgdG9JU09UaW1lKFxuICAgICAgICB0aGlzLFxuICAgICAgICBmb3JtYXQgPT09IFwiZXh0ZW5kZWRcIixcbiAgICAgICAgc3VwcHJlc3NTZWNvbmRzLFxuICAgICAgICBzdXBwcmVzc01pbGxpc2Vjb25kcyxcbiAgICAgICAgaW5jbHVkZU9mZnNldCxcbiAgICAgICAgZXh0ZW5kZWRab25lXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFJGQyAyODIyLWNvbXBhdGlibGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWVcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKDIwMTQsIDcsIDEzKS50b1JGQzI4MjIoKSAvLz0+ICdTdW4sIDEzIEp1bCAyMDE0IDAwOjAwOjAwICswMDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9SRkMyODIyKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCAtMDQwMCdcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9SRkMyODIyKCkge1xuICAgIHJldHVybiB0b1RlY2hGb3JtYXQodGhpcywgXCJFRUUsIGRkIExMTCB5eXl5IEhIOm1tOnNzIFpaWlwiLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSFRUUCBoZWFkZXJzLiBUaGUgb3V0cHV0IGlzIGFsd2F5cyBleHByZXNzZWQgaW4gR01ULlxuICAgKiBTcGVjaWZpY2FsbHksIHRoZSBzdHJpbmcgY29uZm9ybXMgdG8gUkZDIDExMjMuXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMy5odG1sI3NlYzMuMy4xXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9IVFRQKCkgLy89PiAnU3VuLCAxMyBKdWwgMjAxNCAwMDowMDowMCBHTVQnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMywgMTkpLnRvSFRUUCgpIC8vPT4gJ1N1biwgMTMgSnVsIDIwMTQgMTk6MDA6MDAgR01UJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0hUVFAoKSB7XG4gICAgcmV0dXJuIHRvVGVjaEZvcm1hdCh0aGlzLnRvVVRDKCksIFwiRUVFLCBkZCBMTEwgeXl5eSBISDptbTpzcyAnR01UJ1wiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIHVzZSBpbiBTUUwgRGF0ZVxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS51dGMoMjAxNCwgNywgMTMpLnRvU1FMRGF0ZSgpIC8vPT4gJzIwMTQtMDctMTMnXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvU1FMRGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0b0lTT0RhdGUodGhpcywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gU1FMIFRpbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZVpvbmU9ZmFsc2VdIC0gaW5jbHVkZSB0aGUgem9uZSwgc3VjaCBhcyAnQW1lcmljYS9OZXdfWW9yaycuIE92ZXJyaWRlcyBpbmNsdWRlT2Zmc2V0LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXQ9dHJ1ZV0gLSBpbmNsdWRlIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJ1onIG9yICctMDQ6MDAnXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZU9mZnNldFNwYWNlPXRydWVdIC0gaW5jbHVkZSB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgdGltZSBhbmQgdGhlIG9mZnNldCwgc3VjaCBhcyAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUudXRjKCkudG9TUUwoKSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKCkgLy89PiAnMDU6MTU6MTYuMzQ1IC0wNDowMCdcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkudG9TUUwoeyBpbmNsdWRlT2Zmc2V0OiBmYWxzZSB9KSAvLz0+ICcwNToxNToxNi4zNDUnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvU1FMKHsgaW5jbHVkZVpvbmU6IGZhbHNlIH0pIC8vPT4gJzA1OjE1OjE2LjM0NSBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTFRpbWUoeyBpbmNsdWRlT2Zmc2V0ID0gdHJ1ZSwgaW5jbHVkZVpvbmUgPSBmYWxzZSwgaW5jbHVkZU9mZnNldFNwYWNlID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBsZXQgZm10ID0gXCJISDptbTpzcy5TU1NcIjtcblxuICAgIGlmIChpbmNsdWRlWm9uZSB8fCBpbmNsdWRlT2Zmc2V0KSB7XG4gICAgICBpZiAoaW5jbHVkZU9mZnNldFNwYWNlKSB7XG4gICAgICAgIGZtdCArPSBcIiBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlWm9uZSkge1xuICAgICAgICBmbXQgKz0gXCJ6XCI7XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVPZmZzZXQpIHtcbiAgICAgICAgZm10ICs9IFwiWlpcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9UZWNoRm9ybWF0KHRoaXMsIGZtdCwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gU1FMIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVab25lPWZhbHNlXSAtIGluY2x1ZGUgdGhlIHpvbmUsIHN1Y2ggYXMgJ0FtZXJpY2EvTmV3X1lvcmsnLiBPdmVycmlkZXMgaW5jbHVkZU9mZnNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5pbmNsdWRlT2Zmc2V0PXRydWVdIC0gaW5jbHVkZSB0aGUgb2Zmc2V0LCBzdWNoIGFzICdaJyBvciAnLTA0OjAwJ1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmluY2x1ZGVPZmZzZXRTcGFjZT10cnVlXSAtIGluY2x1ZGUgdGhlIHNwYWNlIGJldHdlZW4gdGhlIHRpbWUgYW5kIHRoZSBvZmZzZXQsIHN1Y2ggYXMgJzA1OjE1OjE2LjM0NSAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLnV0YygyMDE0LCA3LCAxMykudG9TUUwoKSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCBaJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoKSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCAtMDQ6MDAnXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLmxvY2FsKDIwMTQsIDcsIDEzKS50b1NRTCh7IGluY2x1ZGVPZmZzZXQ6IGZhbHNlIH0pIC8vPT4gJzIwMTQtMDctMTMgMDA6MDA6MDAuMDAwJ1xuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5sb2NhbCgyMDE0LCA3LCAxMykudG9TUUwoeyBpbmNsdWRlWm9uZTogdHJ1ZSB9KSAvLz0+ICcyMDE0LTA3LTEzIDAwOjAwOjAwLjAwMCBBbWVyaWNhL05ld19Zb3JrJ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1NRTChvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke3RoaXMudG9TUUxEYXRlKCl9ICR7dGhpcy50b1NRTFRpbWUob3B0cyl9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgRGF0ZVRpbWUgYXBwcm9wcmlhdGUgZm9yIGRlYnVnZ2luZ1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gdGhpcy50b0lTTygpIDogSU5WQUxJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBtaWxsaXNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS4gQWxpYXMgb2Yge0BsaW5rIERhdGVUaW1lI3RvTWlsbGlzfVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICB2YWx1ZU9mKCkge1xuICAgIHJldHVybiB0aGlzLnRvTWlsbGlzKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXBvY2ggbWlsbGlzZWNvbmRzIG9mIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHRvTWlsbGlzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIDogTmFOO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVwb2NoIHNlY29uZHMgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQgPyB0aGlzLnRzIC8gMTAwMCA6IE5hTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlcG9jaCBzZWNvbmRzIChhcyBhIHdob2xlIG51bWJlcikgb2YgdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgdG9Vbml4SW50ZWdlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gTWF0aC5mbG9vcih0aGlzLnRzIC8gMTAwMCkgOiBOYU47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJU08gODYwMSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGVUaW1lIGFwcHJvcHJpYXRlIGZvciB1c2UgaW4gSlNPTi5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLnRvSVNPKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEJTT04gc2VyaWFsaXphYmxlIGVxdWl2YWxlbnQgdG8gdGhpcyBEYXRlVGltZS5cbiAgICogQHJldHVybiB7RGF0ZX1cbiAgICovXG4gIHRvQlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy50b0pTRGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKYXZhU2NyaXB0IG9iamVjdCB3aXRoIHRoaXMgRGF0ZVRpbWUncyB5ZWFyLCBtb250aCwgZGF5LCBhbmQgc28gb24uXG4gICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdHMuaW5jbHVkZUNvbmZpZz1mYWxzZV0gLSBpbmNsdWRlIGNvbmZpZ3VyYXRpb24gYXR0cmlidXRlcyBpbiB0aGUgb3V0cHV0XG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnRvT2JqZWN0KCkgLy89PiB7IHllYXI6IDIwMTcsIG1vbnRoOiA0LCBkYXk6IDIyLCBob3VyOiAyMCwgbWludXRlOiA0OSwgc2Vjb25kOiA0MiwgbWlsbGlzZWNvbmQ6IDI2OCB9XG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIHRvT2JqZWN0KG9wdHMgPSB7fSkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKSByZXR1cm4ge307XG5cbiAgICBjb25zdCBiYXNlID0geyAuLi50aGlzLmMgfTtcblxuICAgIGlmIChvcHRzLmluY2x1ZGVDb25maWcpIHtcbiAgICAgIGJhc2Uub3V0cHV0Q2FsZW5kYXIgPSB0aGlzLm91dHB1dENhbGVuZGFyO1xuICAgICAgYmFzZS5udW1iZXJpbmdTeXN0ZW0gPSB0aGlzLmxvYy5udW1iZXJpbmdTeXN0ZW07XG4gICAgICBiYXNlLmxvY2FsZSA9IHRoaXMubG9jLmxvY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEphdmFTY3JpcHQgRGF0ZSBlcXVpdmFsZW50IHRvIHRoaXMgRGF0ZVRpbWUuXG4gICAqIEByZXR1cm4ge0RhdGV9XG4gICAqL1xuICB0b0pTRGF0ZSgpIHtcbiAgICByZXR1cm4gbmV3IERhdGUodGhpcy5pc1ZhbGlkID8gdGhpcy50cyA6IE5hTik7XG4gIH1cblxuICAvLyBDT01QQVJFXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBEYXRlVGltZXMgYXMgYSBEdXJhdGlvbi5cbiAgICogQHBhcmFtIHtEYXRlVGltZX0gb3RoZXJEYXRlVGltZSAtIHRoZSBEYXRlVGltZSB0byBjb21wYXJlIHRoaXMgb25lIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIGFycmF5IG9mIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBjcmVhdGlvbiBvZiB0aGUgRHVyYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLmNvbnZlcnNpb25BY2N1cmFjeT0nY2FzdWFsJ10gLSB0aGUgY29udmVyc2lvbiBzeXN0ZW0gdG8gdXNlXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBpMSA9IERhdGVUaW1lLmZyb21JU08oJzE5ODItMDUtMjVUMDk6NDUnKSxcbiAgICogICAgIGkyID0gRGF0ZVRpbWUuZnJvbUlTTygnMTk4My0xMC0xNFQxMDozMCcpO1xuICAgKiBpMi5kaWZmKGkxKS50b09iamVjdCgpIC8vPT4geyBtaWxsaXNlY29uZHM6IDQzODA3NTAwMDAwIH1cbiAgICogaTIuZGlmZihpMSwgJ2hvdXJzJykudG9PYmplY3QoKSAvLz0+IHsgaG91cnM6IDEyMTY4Ljc1IH1cbiAgICogaTIuZGlmZihpMSwgWydtb250aHMnLCAnZGF5cyddKS50b09iamVjdCgpIC8vPT4geyBtb250aHM6IDE2LCBkYXlzOiAxOS4wMzEyNSB9XG4gICAqIGkyLmRpZmYoaTEsIFsnbW9udGhzJywgJ2RheXMnLCAnaG91cnMnXSkudG9PYmplY3QoKSAvLz0+IHsgbW9udGhzOiAxNiwgZGF5czogMTksIGhvdXJzOiAwLjc1IH1cbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBkaWZmKG90aGVyRGF0ZVRpbWUsIHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzID0ge30pIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCB8fCAhb3RoZXJEYXRlVGltZS5pc1ZhbGlkKSB7XG4gICAgICByZXR1cm4gRHVyYXRpb24uaW52YWxpZChcImNyZWF0ZWQgYnkgZGlmZmluZyBhbiBpbnZhbGlkIERhdGVUaW1lXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGR1ck9wdHMgPSB7IGxvY2FsZTogdGhpcy5sb2NhbGUsIG51bWJlcmluZ1N5c3RlbTogdGhpcy5udW1iZXJpbmdTeXN0ZW0sIC4uLm9wdHMgfTtcblxuICAgIGNvbnN0IHVuaXRzID0gbWF5YmVBcnJheSh1bml0KS5tYXAoRHVyYXRpb24ubm9ybWFsaXplVW5pdCksXG4gICAgICBvdGhlcklzTGF0ZXIgPSBvdGhlckRhdGVUaW1lLnZhbHVlT2YoKSA+IHRoaXMudmFsdWVPZigpLFxuICAgICAgZWFybGllciA9IG90aGVySXNMYXRlciA/IHRoaXMgOiBvdGhlckRhdGVUaW1lLFxuICAgICAgbGF0ZXIgPSBvdGhlcklzTGF0ZXIgPyBvdGhlckRhdGVUaW1lIDogdGhpcyxcbiAgICAgIGRpZmZlZCA9IGRpZmYoZWFybGllciwgbGF0ZXIsIHVuaXRzLCBkdXJPcHRzKTtcblxuICAgIHJldHVybiBvdGhlcklzTGF0ZXIgPyBkaWZmZWQubmVnYXRlKCkgOiBkaWZmZWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBEYXRlVGltZSBhbmQgcmlnaHQgbm93LlxuICAgKiBTZWUge0BsaW5rIERhdGVUaW1lI2RpZmZ9XG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBbdW5pdD1bJ21pbGxpc2Vjb25kcyddXSAtIHRoZSB1bml0IG9yIHVuaXRzIHVuaXRzIChzdWNoIGFzICdob3Vycycgb3IgJ2RheXMnKSB0byBpbmNsdWRlIGluIHRoZSBkdXJhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnMgdGhhdCBhZmZlY3QgdGhlIGNyZWF0aW9uIG9mIHRoZSBEdXJhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuY29udmVyc2lvbkFjY3VyYWN5PSdjYXN1YWwnXSAtIHRoZSBjb252ZXJzaW9uIHN5c3RlbSB0byB1c2VcbiAgICogQHJldHVybiB7RHVyYXRpb259XG4gICAqL1xuICBkaWZmTm93KHVuaXQgPSBcIm1pbGxpc2Vjb25kc1wiLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5kaWZmKERhdGVUaW1lLm5vdygpLCB1bml0LCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gSW50ZXJ2YWwgc3Bhbm5pbmcgYmV0d2VlbiB0aGlzIERhdGVUaW1lIGFuZCBhbm90aGVyIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgZW5kIHBvaW50IG9mIHRoZSBJbnRlcnZhbFxuICAgKiBAcmV0dXJuIHtJbnRlcnZhbH1cbiAgICovXG4gIHVudGlsKG90aGVyRGF0ZVRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkID8gSW50ZXJ2YWwuZnJvbURhdGVUaW1lcyh0aGlzLCBvdGhlckRhdGVUaW1lKSA6IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHdoZXRoZXIgdGhpcyBEYXRlVGltZSBpcyBpbiB0aGUgc2FtZSB1bml0IG9mIHRpbWUgYXMgYW5vdGhlciBEYXRlVGltZS5cbiAgICogSGlnaGVyLW9yZGVyIHVuaXRzIG11c3QgYWxzbyBiZSBpZGVudGljYWwgZm9yIHRoaXMgZnVuY3Rpb24gdG8gcmV0dXJuIGB0cnVlYC5cbiAgICogTm90ZSB0aGF0IHRpbWUgem9uZXMgYXJlICoqaWdub3JlZCoqIGluIHRoaXMgY29tcGFyaXNvbiwgd2hpY2ggY29tcGFyZXMgdGhlICoqbG9jYWwqKiBjYWxlbmRhciB0aW1lLiBVc2Uge0BsaW5rIERhdGVUaW1lI3NldFpvbmV9IHRvIGNvbnZlcnQgb25lIG9mIHRoZSBkYXRlcyBpZiBuZWVkZWQuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyRGF0ZVRpbWUgLSB0aGUgb3RoZXIgRGF0ZVRpbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgLSB0aGUgdW5pdCBvZiB0aW1lIHRvIGNoZWNrIHNhbWVuZXNzIG9uXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLmhhc1NhbWUob3RoZXJEVCwgJ2RheScpOyAvL34+IHRydWUgaWYgb3RoZXJEVCBpcyBpbiB0aGUgc2FtZSBjdXJyZW50IGNhbGVuZGFyIGRheVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzU2FtZShvdGhlckRhdGVUaW1lLCB1bml0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGlucHV0TXMgPSBvdGhlckRhdGVUaW1lLnZhbHVlT2YoKTtcbiAgICBjb25zdCBhZGp1c3RlZFRvWm9uZSA9IHRoaXMuc2V0Wm9uZShvdGhlckRhdGVUaW1lLnpvbmUsIHsga2VlcExvY2FsVGltZTogdHJ1ZSB9KTtcbiAgICByZXR1cm4gYWRqdXN0ZWRUb1pvbmUuc3RhcnRPZih1bml0KSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gYWRqdXN0ZWRUb1pvbmUuZW5kT2YodW5pdCk7XG4gIH1cblxuICAvKipcbiAgICogRXF1YWxpdHkgY2hlY2tcbiAgICogVHdvIERhdGVUaW1lcyBhcmUgZXF1YWwgaWYgYW5kIG9ubHkgaWYgdGhleSByZXByZXNlbnQgdGhlIHNhbWUgbWlsbGlzZWNvbmQsIGhhdmUgdGhlIHNhbWUgem9uZSBhbmQgbG9jYXRpb24sIGFuZCBhcmUgYm90aCB2YWxpZC5cbiAgICogVG8gY29tcGFyZSBqdXN0IHRoZSBtaWxsaXNlY29uZCB2YWx1ZXMsIHVzZSBgK2R0MSA9PT0gK2R0MmAuXG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IG90aGVyIC0gdGhlIG90aGVyIERhdGVUaW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5pc1ZhbGlkICYmXG4gICAgICBvdGhlci5pc1ZhbGlkICYmXG4gICAgICB0aGlzLnZhbHVlT2YoKSA9PT0gb3RoZXIudmFsdWVPZigpICYmXG4gICAgICB0aGlzLnpvbmUuZXF1YWxzKG90aGVyLnpvbmUpICYmXG4gICAgICB0aGlzLmxvYy5lcXVhbHMob3RoZXIubG9jKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHRoaXMgdGltZSByZWxhdGl2ZSB0byBub3csIHN1Y2ggYXMgXCJpbiB0d28gZGF5c1wiLiBDYW4gb25seSBpbnRlcm5hdGlvbmFsaXplIGlmIHlvdXJcbiAgICogcGxhdGZvcm0gc3VwcG9ydHMgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuIFJvdW5kcyBkb3duIGJ5IGRlZmF1bHQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9ucyB0aGF0IGFmZmVjdCB0aGUgb3V0cHV0XG4gICAqIEBwYXJhbSB7RGF0ZVRpbWV9IFtvcHRpb25zLmJhc2U9RGF0ZVRpbWUubm93KCldIC0gdGhlIERhdGVUaW1lIHRvIHVzZSBhcyB0aGUgYmFzaXMgdG8gd2hpY2ggdGhpcyB0aW1lIGlzIGNvbXBhcmVkLiBEZWZhdWx0cyB0byBub3cuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zdHlsZT1cImxvbmdcIl0gLSB0aGUgc3R5bGUgb2YgdW5pdHMsIG11c3QgYmUgXCJsb25nXCIsIFwic2hvcnRcIiwgb3IgXCJuYXJyb3dcIlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gb3B0aW9ucy51bml0IC0gdXNlIGEgc3BlY2lmaWMgdW5pdCBvciBhcnJheSBvZiB1bml0czsgaWYgb21pdHRlZCwgb3IgYW4gYXJyYXksIHRoZSBtZXRob2Qgd2lsbCBwaWNrIHRoZSBiZXN0IHVuaXQuIFVzZSBhbiBhcnJheSBvciBvbmUgb2YgXCJ5ZWFyc1wiLCBcInF1YXJ0ZXJzXCIsIFwibW9udGhzXCIsIFwid2Vla3NcIiwgXCJkYXlzXCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIG9yIFwic2Vjb25kc1wiXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucm91bmQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIHJvdW5kIHRoZSBudW1iZXJzIGluIHRoZSBvdXRwdXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5wYWRkaW5nPTBdIC0gcGFkZGluZyBpbiBtaWxsaXNlY29uZHMuIFRoaXMgYWxsb3dzIHlvdSB0byByb3VuZCB1cCB0aGUgcmVzdWx0IGlmIGl0IGZpdHMgaW5zaWRlIHRoZSB0aHJlc2hvbGQuIERvbid0IHVzZSBpbiBjb21iaW5hdGlvbiB3aXRoIHtyb3VuZDogZmFsc2V9IGJlY2F1c2UgdGhlIGRlY2ltYWwgb3V0cHV0IHdpbGwgaW5jbHVkZSB0aGUgcGFkZGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm51bWJlcmluZ1N5c3RlbSAtIG92ZXJyaWRlIHRoZSBudW1iZXJpbmdTeXN0ZW0gb2YgdGhpcyBEYXRlVGltZS4gVGhlIEludGwgc3lzdGVtIG1heSBjaG9vc2Ugbm90IHRvIGhvbm9yIHRoaXNcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSgpIC8vPT4gXCJpbiAxIGRheVwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnRvUmVsYXRpdmUoeyBkYXlzOiAxIH0pIC8vPT4gXCJkZW50cm8gZGUgMSBkw61hXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZSh7IGxvY2FsZTogXCJmclwiIH0pIC8vPT4gXCJkYW5zIDIzIGhldXJlc1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlKCkgLy89PiBcIjIgZGF5cyBhZ29cIlxuICAgKiBAZXhhbXBsZSBEYXRlVGltZS5ub3coKS5taW51cyh7IGRheXM6IDIgfSkudG9SZWxhdGl2ZSh7IHVuaXQ6IFwiaG91cnNcIiB9KSAvLz0+IFwiNDggaG91cnMgYWdvXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkubWludXMoeyBob3VyczogMzYgfSkudG9SZWxhdGl2ZSh7IHJvdW5kOiBmYWxzZSB9KSAvLz0+IFwiMS41IGRheXMgYWdvXCJcbiAgICovXG4gIHRvUmVsYXRpdmUob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGJhc2UgPSBvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7fSwgeyB6b25lOiB0aGlzLnpvbmUgfSksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nID8gKHRoaXMgPCBiYXNlID8gLW9wdGlvbnMucGFkZGluZyA6IG9wdGlvbnMucGFkZGluZykgOiAwO1xuICAgIGxldCB1bml0cyA9IFtcInllYXJzXCIsIFwibW9udGhzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIl07XG4gICAgbGV0IHVuaXQgPSBvcHRpb25zLnVuaXQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy51bml0KSkge1xuICAgICAgdW5pdHMgPSBvcHRpb25zLnVuaXQ7XG4gICAgICB1bml0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gZGlmZlJlbGF0aXZlKGJhc2UsIHRoaXMucGx1cyhwYWRkaW5nKSwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIG51bWVyaWM6IFwiYWx3YXlzXCIsXG4gICAgICB1bml0cyxcbiAgICAgIHVuaXQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGRhdGUgcmVsYXRpdmUgdG8gdG9kYXksIHN1Y2ggYXMgXCJ5ZXN0ZXJkYXlcIiBvciBcIm5leHQgbW9udGhcIi5cbiAgICogT25seSBpbnRlcm5hdGlvbmFsaXplcyBvbiBwbGF0Zm9ybXMgdGhhdCBzdXBwb3J0cyBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRoYXQgYWZmZWN0IHRoZSBvdXRwdXRcbiAgICogQHBhcmFtIHtEYXRlVGltZX0gW29wdGlvbnMuYmFzZT1EYXRlVGltZS5ub3coKV0gLSB0aGUgRGF0ZVRpbWUgdG8gdXNlIGFzIHRoZSBiYXNpcyB0byB3aGljaCB0aGlzIHRpbWUgaXMgY29tcGFyZWQuIERlZmF1bHRzIHRvIG5vdy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMubG9jYWxlIC0gb3ZlcnJpZGUgdGhlIGxvY2FsZSBvZiB0aGlzIERhdGVUaW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVuaXQgLSB1c2UgYSBzcGVjaWZpYyB1bml0OyBpZiBvbWl0dGVkLCB0aGUgbWV0aG9kIHdpbGwgcGljayB0aGUgdW5pdC4gVXNlIG9uZSBvZiBcInllYXJzXCIsIFwicXVhcnRlcnNcIiwgXCJtb250aHNcIiwgXCJ3ZWVrc1wiLCBvciBcImRheXNcIlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5udW1iZXJpbmdTeXN0ZW0gLSBvdmVycmlkZSB0aGUgbnVtYmVyaW5nU3lzdGVtIG9mIHRoaXMgRGF0ZVRpbWUuIFRoZSBJbnRsIHN5c3RlbSBtYXkgY2hvb3NlIG5vdCB0byBob25vciB0aGlzXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmVDYWxlbmRhcigpIC8vPT4gXCJ0b21vcnJvd1wiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLnNldExvY2FsZShcImVzXCIpLnBsdXMoeyBkYXlzOiAxIH0pLnRvUmVsYXRpdmUoKSAvLz0+IFwiXCJtYcOxYW5hXCJcbiAgICogQGV4YW1wbGUgRGF0ZVRpbWUubm93KCkucGx1cyh7IGRheXM6IDEgfSkudG9SZWxhdGl2ZUNhbGVuZGFyKHsgbG9jYWxlOiBcImZyXCIgfSkgLy89PiBcImRlbWFpblwiXG4gICAqIEBleGFtcGxlIERhdGVUaW1lLm5vdygpLm1pbnVzKHsgZGF5czogMiB9KS50b1JlbGF0aXZlQ2FsZW5kYXIoKSAvLz0+IFwiMiBkYXlzIGFnb1wiXG4gICAqL1xuICB0b1JlbGF0aXZlQ2FsZW5kYXIob3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQpIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIGRpZmZSZWxhdGl2ZShvcHRpb25zLmJhc2UgfHwgRGF0ZVRpbWUuZnJvbU9iamVjdCh7fSwgeyB6b25lOiB0aGlzLnpvbmUgfSksIHRoaXMsIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBudW1lcmljOiBcImF1dG9cIixcbiAgICAgIHVuaXRzOiBbXCJ5ZWFyc1wiLCBcIm1vbnRoc1wiLCBcImRheXNcIl0sXG4gICAgICBjYWxlbmRhcnk6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtaW4gb2Ygc2V2ZXJhbCBkYXRlIHRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSBEYXRlVGltZXMgZnJvbSB3aGljaCB0byBjaG9vc2UgdGhlIG1pbmltdW1cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9IHRoZSBtaW4gRGF0ZVRpbWUsIG9yIHVuZGVmaW5lZCBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudFxuICAgKi9cbiAgc3RhdGljIG1pbiguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIWRhdGVUaW1lcy5ldmVyeShEYXRlVGltZS5pc0RhdGVUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWluIHJlcXVpcmVzIGFsbCBhcmd1bWVudHMgYmUgRGF0ZVRpbWVzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdEJ5KGRhdGVUaW1lcywgKGkpID0+IGkudmFsdWVPZigpLCBNYXRoLm1pbik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBtYXggb2Ygc2V2ZXJhbCBkYXRlIHRpbWVzXG4gICAqIEBwYXJhbSB7Li4uRGF0ZVRpbWV9IGRhdGVUaW1lcyAtIHRoZSBEYXRlVGltZXMgZnJvbSB3aGljaCB0byBjaG9vc2UgdGhlIG1heGltdW1cbiAgICogQHJldHVybiB7RGF0ZVRpbWV9IHRoZSBtYXggRGF0ZVRpbWUsIG9yIHVuZGVmaW5lZCBpZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudFxuICAgKi9cbiAgc3RhdGljIG1heCguLi5kYXRlVGltZXMpIHtcbiAgICBpZiAoIWRhdGVUaW1lcy5ldmVyeShEYXRlVGltZS5pc0RhdGVUaW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFwibWF4IHJlcXVpcmVzIGFsbCBhcmd1bWVudHMgYmUgRGF0ZVRpbWVzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYmVzdEJ5KGRhdGVUaW1lcywgKGkpID0+IGkudmFsdWVPZigpLCBNYXRoLm1heCk7XG4gIH1cblxuICAvLyBNSVNDXG5cbiAgLyoqXG4gICAqIEV4cGxhaW4gaG93IGEgc3RyaW5nIHdvdWxkIGJlIHBhcnNlZCBieSBmcm9tRm9ybWF0KClcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmbXQgLSB0aGUgZm9ybWF0IHRoZSBzdHJpbmcgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gKHNlZSBkZXNjcmlwdGlvbilcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25zIHRha2VuIGJ5IGZyb21Gb3JtYXQoKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZnJvbUZvcm1hdEV4cGxhaW4odGV4dCwgZm10LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZSA9IG51bGwsIG51bWJlcmluZ1N5c3RlbSA9IG51bGwgfSA9IG9wdGlvbnMsXG4gICAgICBsb2NhbGVUb1VzZSA9IExvY2FsZS5mcm9tT3B0cyh7XG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgbnVtYmVyaW5nU3lzdGVtLFxuICAgICAgICBkZWZhdWx0VG9FTjogdHJ1ZSxcbiAgICAgIH0pO1xuICAgIHJldHVybiBleHBsYWluRnJvbVRva2Vucyhsb2NhbGVUb1VzZSwgdGV4dCwgZm10KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZnJvbUZvcm1hdEV4cGxhaW4gaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmdFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21Gb3JtYXRFeHBsYWluKHRleHQsIGZtdCwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBGT1JNQVQgUFJFU0VUU1xuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlIDEwLzE0LzE5ODNcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9TSE9SVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX1NIT1JUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdCAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9NRUQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9NRUQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnRnJpLCBPY3QgMTQsIDE5ODMnXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVfTUVEX1dJVEhfV0VFS0RBWSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFX01FRF9XSVRIX1dFRUtEQVk7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnT2N0b2JlciAxNCwgMTk4MydcbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURV9GVUxMKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVfRlVMTDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdUdWVzZGF5LCBPY3RvYmVyIDE0LCAxOTgzJ1xuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFX0hVR0UoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURV9IVUdFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfU0lNUExFKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfU0lNUExFO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzA5OjMwOjIzIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBUSU1FX1dJVEhfU0hPUlRfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfV0lUSF9TSE9SVF9PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfV0lUSF9MT05HX09GRlNFVCgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5USU1FX1dJVEhfTE9OR19PRkZTRVQ7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzAnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9TSU1QTEUoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9TSU1QTEU7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX1NFQ09ORFMoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX1NFQ09ORFM7XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rIERhdGVUaW1lI3RvTG9jYWxlU3RyaW5nfSBmb3JtYXQgbGlrZSAnMDk6MzA6MjMgRURUJywgYWx3YXlzIDI0LWhvdXIuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IFRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuVElNRV8yNF9XSVRIX1NIT1JUX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcwOTozMDoyMyBFYXN0ZXJuIERheWxpZ2h0IFRpbWUnLCBhbHdheXMgMjQtaG91ci5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgVElNRV8yNF9XSVRIX0xPTkdfT0ZGU0VUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLlRJTUVfMjRfV0lUSF9MT05HX09GRlNFVDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICcxMC8xNC8xOTgzLCA5OjMwIEFNJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX1NIT1JUKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJzEwLzE0LzE5ODMsIDk6MzA6MzMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX1NIT1JUX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX01FRDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3QgMTQsIDE5ODMsIDk6MzA6MzMgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9TRUNPTkRTO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ0ZyaSwgMTQgT2N0IDE5ODMsIDk6MzAgQU0nLiBPbmx5IDEyLWhvdXIgaWYgdGhlIGxvY2FsZSBpcy5cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHN0YXRpYyBnZXQgREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSgpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9NRURfV0lUSF9XRUVLREFZO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayBEYXRlVGltZSN0b0xvY2FsZVN0cmluZ30gZm9ybWF0IGxpa2UgJ09jdG9iZXIgMTQsIDE5ODMsIDk6MzAgQU0gRURUJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0ZVTEwoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfRlVMTDtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdPY3RvYmVyIDE0LCAxOTgzLCA5OjMwOjMzIEFNIEVEVCcuIE9ubHkgMTItaG91ciBpZiB0aGUgbG9jYWxlIGlzLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIGdldCBEQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUygpIHtcbiAgICByZXR1cm4gRm9ybWF0cy5EQVRFVElNRV9GVUxMX1dJVEhfU0VDT05EUztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmlkYXksIE9jdG9iZXIgMTQsIDE5ODMsIDk6MzAgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0hVR0UoKSB7XG4gICAgcmV0dXJuIEZvcm1hdHMuREFURVRJTUVfSFVHRTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QGxpbmsgRGF0ZVRpbWUjdG9Mb2NhbGVTdHJpbmd9IGZvcm1hdCBsaWtlICdGcmlkYXksIE9jdG9iZXIgMTQsIDE5ODMsIDk6MzA6MzMgQU0gRWFzdGVybiBEYXlsaWdodCBUaW1lJy4gT25seSAxMi1ob3VyIGlmIHRoZSBsb2NhbGUgaXMuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBzdGF0aWMgZ2V0IERBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTKCkge1xuICAgIHJldHVybiBGb3JtYXRzLkRBVEVUSU1FX0hVR0VfV0lUSF9TRUNPTkRTO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyaWVuZGx5RGF0ZVRpbWUoZGF0ZVRpbWVpc2gpIHtcbiAgaWYgKERhdGVUaW1lLmlzRGF0ZVRpbWUoZGF0ZVRpbWVpc2gpKSB7XG4gICAgcmV0dXJuIGRhdGVUaW1laXNoO1xuICB9IGVsc2UgaWYgKGRhdGVUaW1laXNoICYmIGRhdGVUaW1laXNoLnZhbHVlT2YgJiYgaXNOdW1iZXIoZGF0ZVRpbWVpc2gudmFsdWVPZigpKSkge1xuICAgIHJldHVybiBEYXRlVGltZS5mcm9tSlNEYXRlKGRhdGVUaW1laXNoKTtcbiAgfSBlbHNlIGlmIChkYXRlVGltZWlzaCAmJiB0eXBlb2YgZGF0ZVRpbWVpc2ggPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdChkYXRlVGltZWlzaCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKFxuICAgICAgYFVua25vd24gZGF0ZXRpbWUgYXJndW1lbnQ6ICR7ZGF0ZVRpbWVpc2h9LCBvZiB0eXBlICR7dHlwZW9mIGRhdGVUaW1laXNofWBcbiAgICApO1xuICB9XG59XG4iLCAiLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFF1ZXJ5IFNldHRpbmdzIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5U2V0dGluZ3Mge1xuICAgIC8qKiBXaGF0IHRvIHJlbmRlciAnbnVsbCcgYXMgaW4gdGFibGVzLiBEZWZhdWx0cyB0byAnLScuICovXG4gICAgcmVuZGVyTnVsbEFzOiBzdHJpbmc7XG4gICAgLyoqIElmIGVuYWJsZWQsIHRhc2tzIGluIERhdGF2aWV3IHZpZXdzIHdpbGwgYXV0b21hdGljYWxseSBoYXZlIHRoZWlyIGNvbXBsZXRpb24gZGF0ZSBhcHBlbmRlZCB3aGVuIHRoZXkgYXJlIGNoZWNrZWQuICovXG4gICAgdGFza0NvbXBsZXRpb25UcmFja2luZzogYm9vbGVhbjtcbiAgICAvKiogSWYgZW5hYmxlZCwgYXV0b21hdGljIGNvbXBsZXRpb25zIHdpbGwgdXNlIGVtb2ppIHNob3J0aGFuZCDinIUgWVlZWS1NTS1ERCBpbnN0ZWFkIG9mIFtjb21wbGV0aW9uOjogZGF0ZV0uICovXG4gICAgdGFza0NvbXBsZXRpb25Vc2VFbW9qaVNob3J0aGFuZDogYm9vbGVhbjtcbiAgICAvKiogVGhlIG5hbWUgb2YgdGhlIGlubGluZSBmaWVsZCB0byBiZSBhZGRlZCBhcyBhIHRhc2sncyBjb21wbGV0aW9uIHdoZW4gY2hlY2tlZC4gT25seSB1c2VkIGlmIGNvbXBsZXRpb25UcmFja2luZyBpcyBlbmFibGVkIGFuZCBlbW9qaVNob3J0aGFuZCBpcyBub3QuICovXG4gICAgdGFza0NvbXBsZXRpb25UZXh0OiBzdHJpbmc7XG4gICAgLyoqIERhdGUgZm9ybWF0IG9mIHRoZSB0YXNrJ3MgY29tcGxldGlvbiB0aW1lc3RhbXAuIE9ubHkgdXNlZCBpZiBjb21wbGV0aW9uVHJhY2tpbmcgaXMgZW5hYmxlZCBhbmQgZW1vamlTaG9ydGhhbmQgaXMgbm90LiAqL1xuICAgIHRhc2tDb21wbGV0aW9uRGF0ZUZvcm1hdDogc3RyaW5nO1xuICAgIC8qKiBXaGV0aGVyIG9yIG5vdCBzdWJ0YXNrcyBzaG91bGQgYmUgcmVjdXJzaXZlbHkgY29tcGxldGVkIGluIGFkZGl0aW9uIHRvIHRoZWlyIHBhcmVudCB0YXNrLiAqL1xuICAgIHJlY3Vyc2l2ZVN1YlRhc2tDb21wbGV0aW9uOiBib29sZWFuO1xuICAgIC8qKiBJZiB0cnVlLCByZW5kZXIgYSBtb2RhbCB3aGljaCBzaG93cyBubyByZXN1bHRzIHdlcmUgcmV0dXJuZWQuICovXG4gICAgd2Fybk9uRW1wdHlSZXN1bHQ6IGJvb2xlYW47XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IGF1dG9tYXRpYyB2aWV3IHJlZnJlc2hpbmcgaXMgZW5hYmxlZC4gKi9cbiAgICByZWZyZXNoRW5hYmxlZDogYm9vbGVhbjtcbiAgICAvKiogVGhlIGludGVydmFsIHRoYXQgdmlld3MgYXJlIHJlZnJlc2hlZCwgYnkgZGVmYXVsdC4gKi9cbiAgICByZWZyZXNoSW50ZXJ2YWw6IG51bWJlcjtcbiAgICAvKiogVGhlIGRlZmF1bHQgZm9ybWF0IHRoYXQgZGF0ZXMgYXJlIHJlbmRlcmVkIGluICh1c2luZyBsdXhvbidzIG1vbWVudC1saWtlIGZvcm1hdHRpbmcpLiAqL1xuICAgIGRlZmF1bHREYXRlRm9ybWF0OiBzdHJpbmc7XG4gICAgLyoqIFRoZSBkZWZhdWx0IGZvcm1hdCB0aGF0IGRhdGUtdGltZXMgYXJlIHJlbmRlcmVkIGluICh1c2luZyBsdXhvbnMgbW9tZW50LWxpa2UgZm9ybWF0dGluZykuICovXG4gICAgZGVmYXVsdERhdGVUaW1lRm9ybWF0OiBzdHJpbmc7XG4gICAgLyoqIE1heGltdW0gZGVwdGggdGhhdCBvYmplY3RzIHdpbGwgYmUgZXhwYW5kZWQgd2hlbiBiZWluZyByZW5kZXJlZCByZWN1cnNpdmVseS4gKi9cbiAgICBtYXhSZWN1cnNpdmVSZW5kZXJEZXB0aDogbnVtYmVyO1xuICAgIC8qKiBUaGUgbmFtZSBvZiB0aGUgZGVmYXVsdCBJRCBmaWVsZCAoJ0ZpbGUnKS4gKi9cbiAgICB0YWJsZUlkQ29sdW1uTmFtZTogc3RyaW5nO1xuICAgIC8qKiBUaGUgbmFtZSBvZiBkZWZhdWx0IElEIGZpZWxkcyBvbiBncm91cGVkIGRhdGEgKCdHcm91cCcpLiAqL1xuICAgIHRhYmxlR3JvdXBDb2x1bW5OYW1lOiBzdHJpbmc7XG4gICAgLyoqIEluY2x1ZGUgdGhlIHJlc3VsdCBjb3VudCBhcyBwYXJ0IG9mIHRoZSBvdXRwdXQuICovXG4gICAgc2hvd1Jlc3VsdENvdW50OiBib29sZWFuO1xufVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9RVUVSWV9TRVRUSU5HUzogUXVlcnlTZXR0aW5ncyA9IHtcbiAgICByZW5kZXJOdWxsQXM6IFwiXFxcXC1cIixcbiAgICB0YXNrQ29tcGxldGlvblRyYWNraW5nOiBmYWxzZSxcbiAgICB0YXNrQ29tcGxldGlvblVzZUVtb2ppU2hvcnRoYW5kOiBmYWxzZSxcbiAgICB0YXNrQ29tcGxldGlvblRleHQ6IFwiY29tcGxldGlvblwiLFxuICAgIHRhc2tDb21wbGV0aW9uRGF0ZUZvcm1hdDogXCJ5eXl5LU1NLWRkXCIsXG4gICAgcmVjdXJzaXZlU3ViVGFza0NvbXBsZXRpb246IGZhbHNlLFxuICAgIHdhcm5PbkVtcHR5UmVzdWx0OiB0cnVlLFxuICAgIHJlZnJlc2hFbmFibGVkOiB0cnVlLFxuICAgIHJlZnJlc2hJbnRlcnZhbDogMjUwMCxcbiAgICBkZWZhdWx0RGF0ZUZvcm1hdDogXCJNTU1NIGRkLCB5eXl5XCIsXG4gICAgZGVmYXVsdERhdGVUaW1lRm9ybWF0OiBcImg6bW0gYSAtIE1NTU0gZGQsIHl5eXlcIixcbiAgICBtYXhSZWN1cnNpdmVSZW5kZXJEZXB0aDogNCxcblxuICAgIHRhYmxlSWRDb2x1bW5OYW1lOiBcIkZpbGVcIixcbiAgICB0YWJsZUdyb3VwQ29sdW1uTmFtZTogXCJHcm91cFwiLFxuICAgIHNob3dSZXN1bHRDb3VudDogdHJ1ZSxcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRXhwb3J0IFNldHRpbmdzIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IGludGVyZmFjZSBFeHBvcnRTZXR0aW5ncyB7XG4gICAgLyoqIFdoZXRoZXIgb3Igbm90IEhUTUwgc2hvdWxkIGJlIHVzZWQgZm9yIGZvcm1hdHRpbmcgaW4gZXhwb3J0cy4gKi9cbiAgICBhbGxvd0h0bWw6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX0VYUE9SVF9TRVRUSU5HUzogRXhwb3J0U2V0dGluZ3MgPSB7XG4gICAgYWxsb3dIdG1sOiB0cnVlLFxufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gR2VuZXJhbCBEYXRhdmlldyBTZXR0aW5ncyAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGF2aWV3U2V0dGluZ3MgZXh0ZW5kcyBRdWVyeVNldHRpbmdzLCBFeHBvcnRTZXR0aW5ncyB7XG4gICAgLyoqIFRoZSBwcmVmaXggZm9yIGlubGluZSBxdWVyaWVzIGJ5IGRlZmF1bHQuICovXG4gICAgaW5saW5lUXVlcnlQcmVmaXg6IHN0cmluZztcbiAgICAvKiogVGhlIHByZWZpeCBmb3IgaW5saW5lIEpTIHF1ZXJpZXMgYnkgZGVmYXVsdC4gKi9cbiAgICBpbmxpbmVKc1F1ZXJ5UHJlZml4OiBzdHJpbmc7XG4gICAgLyoqIElmIHRydWUsIGlubGluZSBxdWVyaWVzIGFyZSBhbHNvIGV2YWx1YXRlZCBpbiBmdWxsIGNvZGVibG9ja3MuICovXG4gICAgaW5saW5lUXVlcmllc0luQ29kZWJsb2NrczogYm9vbGVhbjtcbiAgICAvKiogRW5hYmxlIG9yIGRpc2FibGUgZXhlY3V0aW5nIERhdGF2aWV3SlMgcXVlcmllcy4gKi9cbiAgICBlbmFibGVEYXRhdmlld0pzOiBib29sZWFuO1xuICAgIC8qKiBFbmFibGUgb3IgZGlzYWJsZSByZWd1bGFyIGlubGluZSBxdWVyaWVzLiAqL1xuICAgIGVuYWJsZUlubGluZURhdGF2aWV3OiBib29sZWFuO1xuICAgIC8qKiBFbmFibGUgb3IgZGlzYWJsZSBleGVjdXRpbmcgaW5saW5lIERhdGF2aWV3SlMgcXVlcmllcy4gKi9cbiAgICBlbmFibGVJbmxpbmVEYXRhdmlld0pzOiBib29sZWFuO1xuICAgIC8qKiBFbmFibGUgb3IgZGlzYWJsZSByZW5kZXJpbmcgaW5saW5lIGZpZWxkcyBwcmV0dGlseSBpbiBSZWFkaW5nIFZpZXcuICovXG4gICAgcHJldHR5UmVuZGVySW5saW5lRmllbGRzOiBib29sZWFuO1xuICAgIC8qKiBFbmFibGUgb3IgZGlzYWJsZSByZW5kZXJpbmcgaW5saW5lIGZpZWxkcyBwcmV0dGlseSBpbiBMaXZlIFByZXZpZXcuICovXG4gICAgcHJldHR5UmVuZGVySW5saW5lRmllbGRzSW5MaXZlUHJldmlldzogYm9vbGVhbjtcbiAgICAvKiogVGhlIGtleXdvcmQgZm9yIERhdGF2aWV3SlMgYmxvY2tzLiAqL1xuICAgIGRhdGF2aWV3SnNLZXl3b3JkOiBzdHJpbmc7XG59XG5cbi8qKiBEZWZhdWx0IHNldHRpbmdzIGZvciBkYXRhdmlldyBvbiBpbnN0YWxsLiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IERhdGF2aWV3U2V0dGluZ3MgPSB7XG4gICAgLi4uREVGQVVMVF9RVUVSWV9TRVRUSU5HUyxcbiAgICAuLi5ERUZBVUxUX0VYUE9SVF9TRVRUSU5HUyxcbiAgICAuLi57XG4gICAgICAgIGlubGluZVF1ZXJ5UHJlZml4OiBcIj1cIixcbiAgICAgICAgaW5saW5lSnNRdWVyeVByZWZpeDogXCIkPVwiLFxuICAgICAgICBpbmxpbmVRdWVyaWVzSW5Db2RlYmxvY2tzOiB0cnVlLFxuICAgICAgICBlbmFibGVJbmxpbmVEYXRhdmlldzogdHJ1ZSxcbiAgICAgICAgZW5hYmxlRGF0YXZpZXdKczogZmFsc2UsXG4gICAgICAgIGVuYWJsZUlubGluZURhdGF2aWV3SnM6IGZhbHNlLFxuICAgICAgICBwcmV0dHlSZW5kZXJJbmxpbmVGaWVsZHM6IHRydWUsXG4gICAgICAgIHByZXR0eVJlbmRlcklubGluZUZpZWxkc0luTGl2ZVByZXZpZXc6IHRydWUsXG4gICAgICAgIGRhdGF2aWV3SnNLZXl3b3JkOiBcImRhdGF2aWV3anNcIixcbiAgICB9LFxufTtcbiIsICIvKiogRnVuY3Rpb25hbCByZXR1cm4gdHlwZSBmb3IgZXJyb3IgaGFuZGxpbmcuICovXG5leHBvcnQgY2xhc3MgU3VjY2VzczxULCBFPiB7XG4gICAgcHVibGljIHN1Y2Nlc3NmdWw6IHRydWU7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBUKSB7XG4gICAgICAgIHRoaXMuc3VjY2Vzc2Z1bCA9IHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIG1hcDxVPihmOiAoYTogVCkgPT4gVSk6IFJlc3VsdDxVLCBFPiB7XG4gICAgICAgIHJldHVybiBuZXcgU3VjY2VzcyhmKHRoaXMudmFsdWUpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmxhdE1hcDxVPihmOiAoYTogVCkgPT4gUmVzdWx0PFUsIEU+KTogUmVzdWx0PFUsIEU+IHtcbiAgICAgICAgcmV0dXJuIGYodGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIG1hcEVycjxVPihmOiAoZTogRSkgPT4gVSk6IFJlc3VsdDxULCBVPiB7XG4gICAgICAgIHJldHVybiB0aGlzIGFzIGFueSBhcyBSZXN1bHQ8VCwgVT47XG4gICAgfVxuXG4gICAgcHVibGljIGJpbWFwPFQyLCBFMj4oc3VjYzogKGE6IFQpID0+IFQyLCBfZmFpbDogKGI6IEUpID0+IEUyKTogUmVzdWx0PFQyLCBFMj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoc3VjYykgYXMgYW55O1xuICAgIH1cblxuICAgIHB1YmxpYyBvckVsc2UoX3ZhbHVlOiBUKTogVCB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYXN0PFU+KCk6IFJlc3VsdDxVLCBFPiB7XG4gICAgICAgIHJldHVybiB0aGlzIGFzIGFueTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3JFbHNlVGhyb3coX21lc3NhZ2U/OiAoZTogRSkgPT4gc3RyaW5nKTogVCB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbn1cblxuLyoqIEZ1bmN0aW9uYWwgcmV0dXJuIHR5cGUgZm9yIGVycm9yIGhhbmRsaW5nLiAqL1xuZXhwb3J0IGNsYXNzIEZhaWx1cmU8VCwgRT4ge1xuICAgIHB1YmxpYyBzdWNjZXNzZnVsOiBmYWxzZTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihwdWJsaWMgZXJyb3I6IEUpIHtcbiAgICAgICAgdGhpcy5zdWNjZXNzZnVsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljIG1hcDxVPihfZjogKGE6IFQpID0+IFUpOiBSZXN1bHQ8VSwgRT4ge1xuICAgICAgICByZXR1cm4gdGhpcyBhcyBhbnkgYXMgRmFpbHVyZTxVLCBFPjtcbiAgICB9XG5cbiAgICBwdWJsaWMgZmxhdE1hcDxVPihfZjogKGE6IFQpID0+IFJlc3VsdDxVLCBFPik6IFJlc3VsdDxVLCBFPiB7XG4gICAgICAgIHJldHVybiB0aGlzIGFzIGFueSBhcyBGYWlsdXJlPFUsIEU+O1xuICAgIH1cblxuICAgIHB1YmxpYyBtYXBFcnI8VT4oZjogKGU6IEUpID0+IFUpOiBSZXN1bHQ8VCwgVT4ge1xuICAgICAgICByZXR1cm4gbmV3IEZhaWx1cmUoZih0aGlzLmVycm9yKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGJpbWFwPFQyLCBFMj4oX3N1Y2M6IChhOiBUKSA9PiBUMiwgZmFpbDogKGI6IEUpID0+IEUyKTogUmVzdWx0PFQyLCBFMj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBFcnIoZmFpbCkgYXMgYW55O1xuICAgIH1cblxuICAgIHB1YmxpYyBvckVsc2UodmFsdWU6IFQpOiBUIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBjYXN0PFU+KCk6IFJlc3VsdDxVLCBFPiB7XG4gICAgICAgIHJldHVybiB0aGlzIGFzIGFueTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3JFbHNlVGhyb3cobWVzc2FnZT86IChlOiBFKSA9PiBzdHJpbmcpOiBUIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKHRoaXMuZXJyb3IpKTtcbiAgICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIHRoaXMuZXJyb3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgUmVzdWx0PFQsIEU+ID0gU3VjY2VzczxULCBFPiB8IEZhaWx1cmU8VCwgRT47XG5cbi8qKiBNb25hZGljICdSZXN1bHQnIHR5cGUgd2hpY2ggZW5jYXBzdWxhdGVzIHdoZXRoZXIgYSBwcm9jZWR1cmUgc3VjY2VlZGVkIG9yIGZhaWxlZCwgYXMgd2VsbCBhcyBpdCdzIHJldHVybiB2YWx1ZS4gKi9cbmV4cG9ydCBuYW1lc3BhY2UgUmVzdWx0IHtcbiAgICAvKiogQ29uc3RydWN0IGEgbmV3IHN1Y2Nlc3MgcmVzdWx0IHdyYXBwaW5nIHRoZSBnaXZlbiB2YWx1ZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gc3VjY2VzczxULCBFPih2YWx1ZTogVCk6IFJlc3VsdDxULCBFPiB7XG4gICAgICAgIHJldHVybiBuZXcgU3VjY2Vzcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqIENvbnN0cnVjdCBhIG5ldyBmYWlsdXJlIHZhbHVlIHdyYXBwaW5nIHRoZSBnaXZlbiBlcnJvci4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gZmFpbHVyZTxULCBFPihlcnJvcjogRSk6IFJlc3VsdDxULCBFPiB7XG4gICAgICAgIHJldHVybiBuZXcgRmFpbHVyZShlcnJvcik7XG4gICAgfVxuXG4gICAgLyoqIEpvaW4gdHdvIHJlc3VsdHMgd2l0aCBhIGJpLWZ1bmN0aW9uIGFuZCByZXR1cm4gYSBuZXcgcmVzdWx0LiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBmbGF0TWFwMjxUMSwgVDIsIE8sIEU+KFxuICAgICAgICBmaXJzdDogUmVzdWx0PFQxLCBFPixcbiAgICAgICAgc2Vjb25kOiBSZXN1bHQ8VDIsIEU+LFxuICAgICAgICBmOiAoYTogVDEsIGI6IFQyKSA9PiBSZXN1bHQ8TywgRT5cbiAgICApOiBSZXN1bHQ8TywgRT4ge1xuICAgICAgICBpZiAoZmlyc3Quc3VjY2Vzc2Z1bCkge1xuICAgICAgICAgICAgaWYgKHNlY29uZC5zdWNjZXNzZnVsKSByZXR1cm4gZihmaXJzdC52YWx1ZSwgc2Vjb25kLnZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIGZhaWx1cmUoc2Vjb25kLmVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWlsdXJlKGZpcnN0LmVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBKb2luIHR3byByZXN1bHRzIHdpdGggYSBiaS1mdW5jdGlvbiBhbmQgcmV0dXJuIGEgbmV3IHJlc3VsdC4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gbWFwMjxUMSwgVDIsIE8sIEU+KFxuICAgICAgICBmaXJzdDogUmVzdWx0PFQxLCBFPixcbiAgICAgICAgc2Vjb25kOiBSZXN1bHQ8VDIsIEU+LFxuICAgICAgICBmOiAoYTogVDEsIGI6IFQyKSA9PiBPXG4gICAgKTogUmVzdWx0PE8sIEU+IHtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXAyKGZpcnN0LCBzZWNvbmQsIChhLCBiKSA9PiBzdWNjZXNzKGYoYSwgYikpKTtcbiAgICB9XG59XG4iLCAiIWZ1bmN0aW9uKG4sdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5QYXJzaW1tb249dCgpOm4uUGFyc2ltbW9uPXQoKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciB0PXt9O2Z1bmN0aW9uIHIoZSl7aWYodFtlXSlyZXR1cm4gdFtlXS5leHBvcnRzO3ZhciB1PXRbZV09e2k6ZSxsOiExLGV4cG9ydHM6e319O3JldHVybiBuW2VdLmNhbGwodS5leHBvcnRzLHUsdS5leHBvcnRzLHIpLHUubD0hMCx1LmV4cG9ydHN9cmV0dXJuIHIubT1uLHIuYz10LHIuZD1mdW5jdGlvbihuLHQsZSl7ci5vKG4sdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLHQse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDplfSl9LHIucj1mdW5jdGlvbihuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci5uPWZ1bmN0aW9uKG4pe3ZhciB0PW4mJm4uX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBuLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIG59O3JldHVybiByLmQodCxcImFcIix0KSx0fSxyLm89ZnVuY3Rpb24obix0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sdCl9LHIucD1cIlwiLHIoci5zPTApfShbZnVuY3Rpb24obix0LHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUobil7aWYoISh0aGlzIGluc3RhbmNlb2YgZSkpcmV0dXJuIG5ldyBlKG4pO3RoaXMuXz1ufXZhciB1PWUucHJvdG90eXBlO2Z1bmN0aW9uIG8obix0KXtmb3IodmFyIHI9MDtyPG47cisrKXQocil9ZnVuY3Rpb24gaShuLHQscil7cmV0dXJuIGZ1bmN0aW9uKG4sdCl7byh0Lmxlbmd0aCxmdW5jdGlvbihyKXtuKHRbcl0scix0KX0pfShmdW5jdGlvbihyLGUsdSl7dD1uKHQscixlLHUpfSxyKSx0fWZ1bmN0aW9uIGEobix0KXtyZXR1cm4gaShmdW5jdGlvbih0LHIsZSx1KXtyZXR1cm4gdC5jb25jYXQoW24ocixlLHUpXSl9LFtdLHQpfWZ1bmN0aW9uIGYobix0KXt2YXIgcj17djowLGJ1Zjp0fTtyZXR1cm4gbyhuLGZ1bmN0aW9uKCl7dmFyIG47cj17djpyLnY8PDF8KG49ci5idWYsblswXT4+NyksYnVmOmZ1bmN0aW9uKG4pe3ZhciB0PWkoZnVuY3Rpb24obix0LHIsZSl7cmV0dXJuIG4uY29uY2F0KHI9PT1lLmxlbmd0aC0xP0J1ZmZlci5mcm9tKFt0LDBdKS5yZWFkVUludDE2QkUoMCk6ZS5yZWFkVUludDE2QkUocikpfSxbXSxuKTtyZXR1cm4gQnVmZmVyLmZyb20oYShmdW5jdGlvbihuKXtyZXR1cm4objw8MSY2NTUzNSk+Pjh9LHQpKX0oci5idWYpfX0pLHJ9ZnVuY3Rpb24gYygpe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBCdWZmZXJ9ZnVuY3Rpb24gcygpe2lmKCFjKCkpdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyIGdsb2JhbCBkb2VzIG5vdCBleGlzdDsgcGxlYXNlIHVzZSB3ZWJwYWNrIGlmIHlvdSBuZWVkIHRvIHBhcnNlIEJ1ZmZlcnMgaW4gdGhlIGJyb3dzZXIuXCIpfWZ1bmN0aW9uIGwobil7cygpO3ZhciB0PWkoZnVuY3Rpb24obix0KXtyZXR1cm4gbit0fSwwLG4pO2lmKHQlOCE9MCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYml0cyBbXCIrbi5qb2luKFwiLCBcIikrXCJdIGFkZCB1cCB0byBcIit0K1wiIHdoaWNoIGlzIG5vdCBhbiBldmVuIG51bWJlciBvZiBieXRlczsgdGhlIHRvdGFsIHNob3VsZCBiZSBkaXZpc2libGUgYnkgOFwiKTt2YXIgcix1PXQvOCxvPShyPWZ1bmN0aW9uKG4pe3JldHVybiBuPjQ4fSxpKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG58fChyKHQpP3Q6bil9LG51bGwsbikpO2lmKG8pdGhyb3cgbmV3IEVycm9yKG8rXCIgYml0IHJhbmdlIHJlcXVlc3RlZCBleGNlZWRzIDQ4IGJpdCAoNiBieXRlKSBOdW1iZXIgbWF4LlwiKTtyZXR1cm4gbmV3IGUoZnVuY3Rpb24odCxyKXt2YXIgZT11K3I7cmV0dXJuIGU+dC5sZW5ndGg/eChyLHUudG9TdHJpbmcoKStcIiBieXRlc1wiKTpiKGUsaShmdW5jdGlvbihuLHQpe3ZhciByPWYodCxuLmJ1Zik7cmV0dXJue2NvbGw6bi5jb2xsLmNvbmNhdChyLnYpLGJ1ZjpyLmJ1Zn19LHtjb2xsOltdLGJ1Zjp0LnNsaWNlKHIsZSl9LG4pLmNvbGwpfSl9ZnVuY3Rpb24gaChuLHQpe3JldHVybiBuZXcgZShmdW5jdGlvbihyLGUpe3JldHVybiBzKCksZSt0PnIubGVuZ3RoP3goZSx0K1wiIGJ5dGVzIGZvciBcIituKTpiKGUrdCxyLnNsaWNlKGUsZSt0KSl9KX1mdW5jdGlvbiBwKG4sdCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mKHI9dCl8fE1hdGguZmxvb3IocikhPT1yfHx0PDB8fHQ+Nil0aHJvdyBuZXcgRXJyb3IobitcIiByZXF1aXJlcyBpbnRlZ2VyIGxlbmd0aCBpbiByYW5nZSBbMCwgNl0uXCIpO3ZhciByfWZ1bmN0aW9uIGQobil7cmV0dXJuIHAoXCJ1aW50QkVcIixuKSxoKFwidWludEJFKFwiK24rXCIpXCIsbikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWRVSW50QkUoMCxuKX0pfWZ1bmN0aW9uIHYobil7cmV0dXJuIHAoXCJ1aW50TEVcIixuKSxoKFwidWludExFKFwiK24rXCIpXCIsbikubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlYWRVSW50TEUoMCxuKX0pfWZ1bmN0aW9uIGcobil7cmV0dXJuIHAoXCJpbnRCRVwiLG4pLGgoXCJpbnRCRShcIituK1wiKVwiLG4pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWFkSW50QkUoMCxuKX0pfWZ1bmN0aW9uIG0obil7cmV0dXJuIHAoXCJpbnRMRVwiLG4pLGgoXCJpbnRMRShcIituK1wiKVwiLG4pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWFkSW50TEUoMCxuKX0pfWZ1bmN0aW9uIHkobil7cmV0dXJuIG4gaW5zdGFuY2VvZiBlfWZ1bmN0aW9uIEUobil7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09e30udG9TdHJpbmcuY2FsbChuKX1mdW5jdGlvbiB3KG4pe3JldHVybiBjKCkmJkJ1ZmZlci5pc0J1ZmZlcihuKX1mdW5jdGlvbiBiKG4sdCl7cmV0dXJue3N0YXR1czohMCxpbmRleDpuLHZhbHVlOnQsZnVydGhlc3Q6LTEsZXhwZWN0ZWQ6W119fWZ1bmN0aW9uIHgobix0KXtyZXR1cm4gRSh0KXx8KHQ9W3RdKSx7c3RhdHVzOiExLGluZGV4Oi0xLHZhbHVlOm51bGwsZnVydGhlc3Q6bixleHBlY3RlZDp0fX1mdW5jdGlvbiBCKG4sdCl7aWYoIXQpcmV0dXJuIG47aWYobi5mdXJ0aGVzdD50LmZ1cnRoZXN0KXJldHVybiBuO3ZhciByPW4uZnVydGhlc3Q9PT10LmZ1cnRoZXN0P2Z1bmN0aW9uKG4sdCl7aWYoZnVuY3Rpb24oKXtpZih2b2lkIDAhPT1lLl9zdXBwb3J0c1NldClyZXR1cm4gZS5fc3VwcG9ydHNTZXQ7dmFyIG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNldDtyZXR1cm4gZS5fc3VwcG9ydHNTZXQ9bixufSgpJiZBcnJheS5mcm9tKXtmb3IodmFyIHI9bmV3IFNldChuKSx1PTA7dTx0Lmxlbmd0aDt1Kyspci5hZGQodFt1XSk7dmFyIG89QXJyYXkuZnJvbShyKTtyZXR1cm4gby5zb3J0KCksb31mb3IodmFyIGk9e30sYT0wO2E8bi5sZW5ndGg7YSsrKWlbblthXV09ITA7Zm9yKHZhciBmPTA7Zjx0Lmxlbmd0aDtmKyspaVt0W2ZdXT0hMDt2YXIgYz1bXTtmb3IodmFyIHMgaW4gaSkoe30pLmhhc093blByb3BlcnR5LmNhbGwoaSxzKSYmYy5wdXNoKHMpO3JldHVybiBjLnNvcnQoKSxjfShuLmV4cGVjdGVkLHQuZXhwZWN0ZWQpOnQuZXhwZWN0ZWQ7cmV0dXJue3N0YXR1czpuLnN0YXR1cyxpbmRleDpuLmluZGV4LHZhbHVlOm4udmFsdWUsZnVydGhlc3Q6dC5mdXJ0aGVzdCxleHBlY3RlZDpyfX12YXIgaj17fTtmdW5jdGlvbiBTKG4sdCl7aWYodyhuKSlyZXR1cm57b2Zmc2V0OnQsbGluZTotMSxjb2x1bW46LTF9O24gaW4ganx8KGpbbl09e30pO2Zvcih2YXIgcj1qW25dLGU9MCx1PTAsbz0wLGk9dDtpPj0wOyl7aWYoaSBpbiByKXtlPXJbaV0ubGluZSwwPT09byYmKG89cltpXS5saW5lU3RhcnQpO2JyZWFrfShcIlxcblwiPT09bi5jaGFyQXQoaSl8fFwiXFxyXCI9PT1uLmNoYXJBdChpKSYmXCJcXG5cIiE9PW4uY2hhckF0KGkrMSkpJiYodSsrLDA9PT1vJiYobz1pKzEpKSxpLS19dmFyIGE9ZSt1LGY9dC1vO3JldHVybiByW3RdPXtsaW5lOmEsbGluZVN0YXJ0Om99LHtvZmZzZXQ6dCxsaW5lOmErMSxjb2x1bW46ZisxfX1mdW5jdGlvbiBfKG4pe2lmKCF5KG4pKXRocm93IG5ldyBFcnJvcihcIm5vdCBhIHBhcnNlcjogXCIrbil9ZnVuY3Rpb24gTChuLHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBuP24uY2hhckF0KHQpOm5bdF19ZnVuY3Rpb24gTyhuKXtpZihcIm51bWJlclwiIT10eXBlb2Ygbil0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBudW1iZXI6IFwiK24pfWZ1bmN0aW9uIGsobil7aWYoXCJmdW5jdGlvblwiIT10eXBlb2Ygbil0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBmdW5jdGlvbjogXCIrbil9ZnVuY3Rpb24gUChuKXtpZihcInN0cmluZ1wiIT10eXBlb2Ygbil0aHJvdyBuZXcgRXJyb3IoXCJub3QgYSBzdHJpbmc6IFwiK24pfXZhciBxPTIsQT0zLEk9OCxGPTUqSSxNPTQqSSx6PVwiICBcIjtmdW5jdGlvbiBSKG4sdCl7cmV0dXJuIG5ldyBBcnJheSh0KzEpLmpvaW4obil9ZnVuY3Rpb24gVShuLHQscil7dmFyIGU9dC1uLmxlbmd0aDtyZXR1cm4gZTw9MD9uOlIocixlKStufWZ1bmN0aW9uIFcobix0LHIsZSl7cmV0dXJue2Zyb206bi10PjA/bi10OjAsdG86bityPmU/ZTpuK3J9fWZ1bmN0aW9uIEQobix0KXt2YXIgcixlLHUsbyxmLGM9dC5pbmRleCxzPWMub2Zmc2V0LGw9MTtpZihzPT09bi5sZW5ndGgpcmV0dXJuXCJHb3QgdGhlIGVuZCBvZiB0aGUgaW5wdXRcIjtpZih3KG4pKXt2YXIgaD1zLXMlSSxwPXMtaCxkPVcoaCxGLE0rSSxuLmxlbmd0aCksdj1hKGZ1bmN0aW9uKG4pe3JldHVybiBhKGZ1bmN0aW9uKG4pe3JldHVybiBVKG4udG9TdHJpbmcoMTYpLDIsXCIwXCIpfSxuKX0sZnVuY3Rpb24obix0KXt2YXIgcj1uLmxlbmd0aCxlPVtdLHU9MDtpZihyPD10KXJldHVybltuLnNsaWNlKCldO2Zvcih2YXIgbz0wO288cjtvKyspZVt1XXx8ZS5wdXNoKFtdKSxlW3VdLnB1c2gobltvXSksKG8rMSkldD09MCYmdSsrO3JldHVybiBlfShuLnNsaWNlKGQuZnJvbSxkLnRvKS50b0pTT04oKS5kYXRhLEkpKTtvPWZ1bmN0aW9uKG4pe3JldHVybiAwPT09bi5mcm9tJiYxPT09bi50bz97ZnJvbTpuLmZyb20sdG86bi50b306e2Zyb206bi5mcm9tL0ksdG86TWF0aC5mbG9vcihuLnRvL0kpfX0oZCksZT1oL0kscj0zKnAscD49NCYmKHIrPTEpLGw9Mix1PWEoZnVuY3Rpb24obil7cmV0dXJuIG4ubGVuZ3RoPD00P24uam9pbihcIiBcIik6bi5zbGljZSgwLDQpLmpvaW4oXCIgXCIpK1wiICBcIituLnNsaWNlKDQpLmpvaW4oXCIgXCIpfSx2KSwoZj0oOCooby50bz4wP28udG8tMTpvLnRvKSkudG9TdHJpbmcoMTYpLmxlbmd0aCk8MiYmKGY9Mil9ZWxzZXt2YXIgZz1uLnNwbGl0KC9cXHJcXG58W1xcblxcclxcdTIwMjhcXHUyMDI5XS8pO3I9Yy5jb2x1bW4tMSxlPWMubGluZS0xLG89VyhlLHEsQSxnLmxlbmd0aCksdT1nLnNsaWNlKG8uZnJvbSxvLnRvKSxmPW8udG8udG9TdHJpbmcoKS5sZW5ndGh9dmFyIG09ZS1vLmZyb207cmV0dXJuIHcobikmJihmPSg4KihvLnRvPjA/by50by0xOm8udG8pKS50b1N0cmluZygxNikubGVuZ3RoKTwyJiYoZj0yKSxpKGZ1bmN0aW9uKHQsZSx1KXt2YXIgaSxhPXU9PT1tLGM9YT9cIj4gXCI6ejtyZXR1cm4gaT13KG4pP1UoKDgqKG8uZnJvbSt1KSkudG9TdHJpbmcoMTYpLGYsXCIwXCIpOlUoKG8uZnJvbSt1KzEpLnRvU3RyaW5nKCksZixcIiBcIiksW10uY29uY2F0KHQsW2MraStcIiB8IFwiK2VdLGE/W3orUihcIiBcIixmKStcIiB8IFwiK1UoXCJcIixyLFwiIFwiKStSKFwiXlwiLGwpXTpbXSl9LFtdLHUpLmpvaW4oXCJcXG5cIil9ZnVuY3Rpb24gTihuLHQpe3JldHVybltcIlxcblwiLFwiLS0gUEFSU0lORyBGQUlMRUQgXCIrUihcIi1cIiw1MCksXCJcXG5cXG5cIixEKG4sdCksXCJcXG5cXG5cIiwocj10LmV4cGVjdGVkLDE9PT1yLmxlbmd0aD9cIkV4cGVjdGVkOlxcblxcblwiK3JbMF06XCJFeHBlY3RlZCBvbmUgb2YgdGhlIGZvbGxvd2luZzogXFxuXFxuXCIrci5qb2luKFwiLCBcIikpLFwiXFxuXCJdLmpvaW4oXCJcIik7dmFyIHJ9ZnVuY3Rpb24gRyhuKXtyZXR1cm4gdm9pZCAwIT09bi5mbGFncz9uLmZsYWdzOltuLmdsb2JhbD9cImdcIjpcIlwiLG4uaWdub3JlQ2FzZT9cImlcIjpcIlwiLG4ubXVsdGlsaW5lP1wibVwiOlwiXCIsbi51bmljb2RlP1widVwiOlwiXCIsbi5zdGlja3k/XCJ5XCI6XCJcIl0uam9pbihcIlwiKX1mdW5jdGlvbiBDKCl7Zm9yKHZhciBuPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSx0PW4ubGVuZ3RoLHI9MDtyPHQ7cis9MSlfKG5bcl0pO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7Zm9yKHZhciB1LG89bmV3IEFycmF5KHQpLGk9MDtpPHQ7aSs9MSl7aWYoISh1PUIobltpXS5fKHIsZSksdSkpLnN0YXR1cylyZXR1cm4gdTtvW2ldPXUudmFsdWUsZT11LmluZGV4fXJldHVybiBCKGIoZSxvKSx1KX0pfWZ1bmN0aW9uIEooKXt2YXIgbj1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7aWYoMD09PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNlcU1hcCBuZWVkcyBhdCBsZWFzdCBvbmUgYXJndW1lbnRcIik7dmFyIHQ9bi5wb3AoKTtyZXR1cm4gayh0KSxDLmFwcGx5KG51bGwsbikubWFwKGZ1bmN0aW9uKG4pe3JldHVybiB0LmFwcGx5KG51bGwsbil9KX1mdW5jdGlvbiBUKCl7dmFyIG49W10uc2xpY2UuY2FsbChhcmd1bWVudHMpLHQ9bi5sZW5ndGg7aWYoMD09PXQpcmV0dXJuIFkoXCJ6ZXJvIGFsdGVybmF0ZXNcIik7Zm9yKHZhciByPTA7cjx0O3IrPTEpXyhuW3JdKTtyZXR1cm4gZShmdW5jdGlvbih0LHIpe2Zvcih2YXIgZSx1PTA7dTxuLmxlbmd0aDt1Kz0xKWlmKChlPUIoblt1XS5fKHQsciksZSkpLnN0YXR1cylyZXR1cm4gZTtyZXR1cm4gZX0pfWZ1bmN0aW9uIFYobix0KXtyZXR1cm4gSChuLHQpLm9yKFgoW10pKX1mdW5jdGlvbiBIKG4sdCl7cmV0dXJuIF8obiksXyh0KSxKKG4sdC50aGVuKG4pLm1hbnkoKSxmdW5jdGlvbihuLHQpe3JldHVybltuXS5jb25jYXQodCl9KX1mdW5jdGlvbiBLKG4pe1Aobik7dmFyIHQ9XCInXCIrbitcIidcIjtyZXR1cm4gZShmdW5jdGlvbihyLGUpe3ZhciB1PWUrbi5sZW5ndGgsbz1yLnNsaWNlKGUsdSk7cmV0dXJuIG89PT1uP2IodSxvKTp4KGUsdCl9KX1mdW5jdGlvbiBRKG4sdCl7IWZ1bmN0aW9uKG4pe2lmKCEobiBpbnN0YW5jZW9mIFJlZ0V4cCkpdGhyb3cgbmV3IEVycm9yKFwibm90IGEgcmVnZXhwOiBcIituKTtmb3IodmFyIHQ9RyhuKSxyPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBlPXQuY2hhckF0KHIpO2lmKFwiaVwiIT09ZSYmXCJtXCIhPT1lJiZcInVcIiE9PWUmJlwic1wiIT09ZSl0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIHJlZ2V4cCBmbGFnIFwiJytlKydcIjogJytuKX19KG4pLGFyZ3VtZW50cy5sZW5ndGg+PTI/Tyh0KTp0PTA7dmFyIHI9ZnVuY3Rpb24obil7cmV0dXJuIFJlZ0V4cChcIl4oPzpcIituLnNvdXJjZStcIilcIixHKG4pKX0obiksdT1cIlwiK247cmV0dXJuIGUoZnVuY3Rpb24obixlKXt2YXIgbz1yLmV4ZWMobi5zbGljZShlKSk7aWYobyl7aWYoMDw9dCYmdDw9by5sZW5ndGgpe3ZhciBpPW9bMF0sYT1vW3RdO3JldHVybiBiKGUraS5sZW5ndGgsYSl9cmV0dXJuIHgoZSxcInZhbGlkIG1hdGNoIGdyb3VwICgwIHRvIFwiK28ubGVuZ3RoK1wiKSBpbiBcIit1KX1yZXR1cm4geChlLHUpfSl9ZnVuY3Rpb24gWChuKXtyZXR1cm4gZShmdW5jdGlvbih0LHIpe3JldHVybiBiKHIsbil9KX1mdW5jdGlvbiBZKG4pe3JldHVybiBlKGZ1bmN0aW9uKHQscil7cmV0dXJuIHgocixuKX0pfWZ1bmN0aW9uIFoobil7aWYoeShuKSlyZXR1cm4gZShmdW5jdGlvbih0LHIpe3ZhciBlPW4uXyh0LHIpO3JldHVybiBlLmluZGV4PXIsZS52YWx1ZT1cIlwiLGV9KTtpZihcInN0cmluZ1wiPT10eXBlb2YgbilyZXR1cm4gWihLKG4pKTtpZihuIGluc3RhbmNlb2YgUmVnRXhwKXJldHVybiBaKFEobikpO3Rocm93IG5ldyBFcnJvcihcIm5vdCBhIHN0cmluZywgcmVnZXhwLCBvciBwYXJzZXI6IFwiK24pfWZ1bmN0aW9uICQobil7cmV0dXJuIF8obiksZShmdW5jdGlvbih0LHIpe3ZhciBlPW4uXyh0LHIpLHU9dC5zbGljZShyLGUuaW5kZXgpO3JldHVybiBlLnN0YXR1cz94KHIsJ25vdCBcIicrdSsnXCInKTpiKHIsbnVsbCl9KX1mdW5jdGlvbiBubihuKXtyZXR1cm4gayhuKSxlKGZ1bmN0aW9uKHQscil7dmFyIGU9TCh0LHIpO3JldHVybiByPHQubGVuZ3RoJiZuKGUpP2IocisxLGUpOngocixcImEgY2hhcmFjdGVyL2J5dGUgbWF0Y2hpbmcgXCIrbil9KX1mdW5jdGlvbiB0bihuLHQpe2FyZ3VtZW50cy5sZW5ndGg8MiYmKHQ9bixuPXZvaWQgMCk7dmFyIHI9ZShmdW5jdGlvbihuLGUpe3JldHVybiByLl89dCgpLl8sci5fKG4sZSl9KTtyZXR1cm4gbj9yLmRlc2Mobik6cn1mdW5jdGlvbiBybigpe3JldHVybiBZKFwiZmFudGFzeS1sYW5kL2VtcHR5XCIpfXUucGFyc2U9ZnVuY3Rpb24obil7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIG4mJiF3KG4pKXRocm93IG5ldyBFcnJvcihcIi5wYXJzZSBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgc3RyaW5nIG9yIEJ1ZmZlciBhcyBpdHMgYXJndW1lbnRcIik7dmFyIHQscj10aGlzLnNraXAoYW4pLl8obiwwKTtyZXR1cm4gdD1yLnN0YXR1cz97c3RhdHVzOiEwLHZhbHVlOnIudmFsdWV9OntzdGF0dXM6ITEsaW5kZXg6UyhuLHIuZnVydGhlc3QpLGV4cGVjdGVkOnIuZXhwZWN0ZWR9LGRlbGV0ZSBqW25dLHR9LHUudHJ5UGFyc2U9ZnVuY3Rpb24obil7dmFyIHQ9dGhpcy5wYXJzZShuKTtpZih0LnN0YXR1cylyZXR1cm4gdC52YWx1ZTt2YXIgcj1OKG4sdCksZT1uZXcgRXJyb3Iocik7dGhyb3cgZS50eXBlPVwiUGFyc2ltbW9uRXJyb3JcIixlLnJlc3VsdD10LGV9LHUuYXNzZXJ0PWZ1bmN0aW9uKG4sdCl7cmV0dXJuIHRoaXMuY2hhaW4oZnVuY3Rpb24ocil7cmV0dXJuIG4ocik/WChyKTpZKHQpfSl9LHUub3I9ZnVuY3Rpb24obil7cmV0dXJuIFQodGhpcyxuKX0sdS50cmltPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLndyYXAobixuKX0sdS53cmFwPWZ1bmN0aW9uKG4sdCl7cmV0dXJuIEoobix0aGlzLHQsZnVuY3Rpb24obix0KXtyZXR1cm4gdH0pfSx1LnRocnU9ZnVuY3Rpb24obil7cmV0dXJuIG4odGhpcyl9LHUudGhlbj1mdW5jdGlvbihuKXtyZXR1cm4gXyhuKSxDKHRoaXMsbikubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuWzFdfSl9LHUubWFueT1mdW5jdGlvbigpe3ZhciBuPXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24odCxyKXtmb3IodmFyIGU9W10sdT12b2lkIDA7Oyl7aWYoISh1PUIobi5fKHQsciksdSkpLnN0YXR1cylyZXR1cm4gQihiKHIsZSksdSk7aWYocj09PXUuaW5kZXgpdGhyb3cgbmV3IEVycm9yKFwiaW5maW5pdGUgbG9vcCBkZXRlY3RlZCBpbiAubWFueSgpIHBhcnNlciAtLS0gY2FsbGluZyAubWFueSgpIG9uIGEgcGFyc2VyIHdoaWNoIGNhbiBhY2NlcHQgemVybyBjaGFyYWN0ZXJzIGlzIHVzdWFsbHkgdGhlIGNhdXNlXCIpO3I9dS5pbmRleCxlLnB1c2godS52YWx1ZSl9fSl9LHUudGllV2l0aD1mdW5jdGlvbihuKXtyZXR1cm4gUChuKSx0aGlzLm1hcChmdW5jdGlvbih0KXtpZihmdW5jdGlvbihuKXtpZighRShuKSl0aHJvdyBuZXcgRXJyb3IoXCJub3QgYW4gYXJyYXk6IFwiK24pfSh0KSx0Lmxlbmd0aCl7UCh0WzBdKTtmb3IodmFyIHI9dFswXSxlPTE7ZTx0Lmxlbmd0aDtlKyspUCh0W2VdKSxyKz1uK3RbZV07cmV0dXJuIHJ9cmV0dXJuXCJcIn0pfSx1LnRpZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRpZVdpdGgoXCJcIil9LHUudGltZXM9ZnVuY3Rpb24obix0KXt2YXIgcj10aGlzO3JldHVybiBhcmd1bWVudHMubGVuZ3RoPDImJih0PW4pLE8obiksTyh0KSxlKGZ1bmN0aW9uKGUsdSl7Zm9yKHZhciBvPVtdLGk9dm9pZCAwLGE9dm9pZCAwLGY9MDtmPG47Zis9MSl7aWYoYT1CKGk9ci5fKGUsdSksYSksIWkuc3RhdHVzKXJldHVybiBhO3U9aS5pbmRleCxvLnB1c2goaS52YWx1ZSl9Zm9yKDtmPHQmJihhPUIoaT1yLl8oZSx1KSxhKSxpLnN0YXR1cyk7Zis9MSl1PWkuaW5kZXgsby5wdXNoKGkudmFsdWUpO3JldHVybiBCKGIodSxvKSxhKX0pfSx1LnJlc3VsdD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gbn0pfSx1LmF0TW9zdD1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy50aW1lcygwLG4pfSx1LmF0TGVhc3Q9ZnVuY3Rpb24obil7cmV0dXJuIEoodGhpcy50aW1lcyhuKSx0aGlzLm1hbnkoKSxmdW5jdGlvbihuLHQpe3JldHVybiBuLmNvbmNhdCh0KX0pfSx1Lm1hcD1mdW5jdGlvbihuKXtrKG4pO3ZhciB0PXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXt2YXIgdT10Ll8ocixlKTtyZXR1cm4gdS5zdGF0dXM/QihiKHUuaW5kZXgsbih1LnZhbHVlKSksdSk6dX0pfSx1LmNvbnRyYW1hcD1mdW5jdGlvbihuKXtrKG4pO3ZhciB0PXRoaXM7cmV0dXJuIGUoZnVuY3Rpb24ocixlKXt2YXIgdT10LnBhcnNlKG4oci5zbGljZShlKSkpO3JldHVybiB1LnN0YXR1cz9iKGUrci5sZW5ndGgsdS52YWx1ZSk6dX0pfSx1LnByb21hcD1mdW5jdGlvbihuLHQpe3JldHVybiBrKG4pLGsodCksdGhpcy5jb250cmFtYXAobikubWFwKHQpfSx1LnNraXA9ZnVuY3Rpb24obil7cmV0dXJuIEModGhpcyxuKS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG5bMF19KX0sdS5tYXJrPWZ1bmN0aW9uKCl7cmV0dXJuIEooZW4sdGhpcyxlbixmdW5jdGlvbihuLHQscil7cmV0dXJue3N0YXJ0Om4sdmFsdWU6dCxlbmQ6cn19KX0sdS5ub2RlPWZ1bmN0aW9uKG4pe3JldHVybiBKKGVuLHRoaXMsZW4sZnVuY3Rpb24odCxyLGUpe3JldHVybntuYW1lOm4sdmFsdWU6cixzdGFydDp0LGVuZDplfX0pfSx1LnNlcEJ5PWZ1bmN0aW9uKG4pe3JldHVybiBWKHRoaXMsbil9LHUuc2VwQnkxPWZ1bmN0aW9uKG4pe3JldHVybiBIKHRoaXMsbil9LHUubG9va2FoZWFkPWZ1bmN0aW9uKG4pe3JldHVybiB0aGlzLnNraXAoWihuKSl9LHUubm90Rm9sbG93ZWRCeT1mdW5jdGlvbihuKXtyZXR1cm4gdGhpcy5za2lwKCQobikpfSx1LmRlc2M9ZnVuY3Rpb24obil7RShuKXx8KG49W25dKTt2YXIgdD10aGlzO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7dmFyIHU9dC5fKHIsZSk7cmV0dXJuIHUuc3RhdHVzfHwodS5leHBlY3RlZD1uKSx1fSl9LHUuZmFsbGJhY2s9ZnVuY3Rpb24obil7cmV0dXJuIHRoaXMub3IoWChuKSl9LHUuYXA9ZnVuY3Rpb24obil7cmV0dXJuIEoobix0aGlzLGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG4odCl9KX0sdS5jaGFpbj1mdW5jdGlvbihuKXt2YXIgdD10aGlzO3JldHVybiBlKGZ1bmN0aW9uKHIsZSl7dmFyIHU9dC5fKHIsZSk7cmV0dXJuIHUuc3RhdHVzP0Iobih1LnZhbHVlKS5fKHIsdS5pbmRleCksdSk6dX0pfSx1LmNvbmNhdD11Lm9yLHUuZW1wdHk9cm4sdS5vZj1YLHVbXCJmYW50YXN5LWxhbmQvYXBcIl09dS5hcCx1W1wiZmFudGFzeS1sYW5kL2NoYWluXCJdPXUuY2hhaW4sdVtcImZhbnRhc3ktbGFuZC9jb25jYXRcIl09dS5jb25jYXQsdVtcImZhbnRhc3ktbGFuZC9lbXB0eVwiXT11LmVtcHR5LHVbXCJmYW50YXN5LWxhbmQvb2ZcIl09dS5vZix1W1wiZmFudGFzeS1sYW5kL21hcFwiXT11Lm1hcDt2YXIgZW49ZShmdW5jdGlvbihuLHQpe3JldHVybiBiKHQsUyhuLHQpKX0pLHVuPWUoZnVuY3Rpb24obix0KXtyZXR1cm4gdD49bi5sZW5ndGg/eCh0LFwiYW55IGNoYXJhY3Rlci9ieXRlXCIpOmIodCsxLEwobix0KSl9KSxvbj1lKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIGIobi5sZW5ndGgsbi5zbGljZSh0KSl9KSxhbj1lKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIHQ8bi5sZW5ndGg/eCh0LFwiRU9GXCIpOmIodCxudWxsKX0pLGZuPVEoL1swLTldLykuZGVzYyhcImEgZGlnaXRcIiksY249USgvWzAtOV0qLykuZGVzYyhcIm9wdGlvbmFsIGRpZ2l0c1wiKSxzbj1RKC9bYS16XS9pKS5kZXNjKFwiYSBsZXR0ZXJcIiksbG49USgvW2Etel0qL2kpLmRlc2MoXCJvcHRpb25hbCBsZXR0ZXJzXCIpLGhuPVEoL1xccyovKS5kZXNjKFwib3B0aW9uYWwgd2hpdGVzcGFjZVwiKSxwbj1RKC9cXHMrLykuZGVzYyhcIndoaXRlc3BhY2VcIiksZG49SyhcIlxcclwiKSx2bj1LKFwiXFxuXCIpLGduPUsoXCJcXHJcXG5cIiksbW49VChnbix2bixkbikuZGVzYyhcIm5ld2xpbmVcIikseW49VChtbixhbik7ZS5hbGw9b24sZS5hbHQ9VCxlLmFueT11bixlLmNyPWRuLGUuY3JlYXRlTGFuZ3VhZ2U9ZnVuY3Rpb24obil7dmFyIHQ9e307Zm9yKHZhciByIGluIG4pKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4scikmJmZ1bmN0aW9uKHIpe3Rbcl09dG4oZnVuY3Rpb24oKXtyZXR1cm4gbltyXSh0KX0pfShyKTtyZXR1cm4gdH0sZS5jcmxmPWduLGUuY3VzdG9tPWZ1bmN0aW9uKG4pe3JldHVybiBlKG4oYix4KSl9LGUuZGlnaXQ9Zm4sZS5kaWdpdHM9Y24sZS5lbXB0eT1ybixlLmVuZD15bixlLmVvZj1hbixlLmZhaWw9WSxlLmZvcm1hdEVycm9yPU4sZS5pbmRleD1lbixlLmlzUGFyc2VyPXksZS5sYXp5PXRuLGUubGV0dGVyPXNuLGUubGV0dGVycz1sbixlLmxmPXZuLGUubG9va2FoZWFkPVosZS5tYWtlRmFpbHVyZT14LGUubWFrZVN1Y2Nlc3M9YixlLm5ld2xpbmU9bW4sZS5ub25lT2Y9ZnVuY3Rpb24obil7cmV0dXJuIG5uKGZ1bmN0aW9uKHQpe3JldHVybiBuLmluZGV4T2YodCk8MH0pLmRlc2MoXCJub25lIG9mICdcIituK1wiJ1wiKX0sZS5ub3RGb2xsb3dlZEJ5PSQsZS5vZj1YLGUub25lT2Y9ZnVuY3Rpb24obil7Zm9yKHZhciB0PW4uc3BsaXQoXCJcIikscj0wO3I8dC5sZW5ndGg7cisrKXRbcl09XCInXCIrdFtyXStcIidcIjtyZXR1cm4gbm4oZnVuY3Rpb24odCl7cmV0dXJuIG4uaW5kZXhPZih0KT49MH0pLmRlc2ModCl9LGUub3B0V2hpdGVzcGFjZT1obixlLlBhcnNlcj1lLGUucmFuZ2U9ZnVuY3Rpb24obix0KXtyZXR1cm4gbm4oZnVuY3Rpb24ocil7cmV0dXJuIG48PXImJnI8PXR9KS5kZXNjKG4rXCItXCIrdCl9LGUucmVnZXg9USxlLnJlZ2V4cD1RLGUuc2VwQnk9VixlLnNlcEJ5MT1ILGUuc2VxPUMsZS5zZXFNYXA9SixlLnNlcU9iaj1mdW5jdGlvbigpe2Zvcih2YXIgbix0PXt9LHI9MCx1PShuPWFyZ3VtZW50cyxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKSksbz11Lmxlbmd0aCxpPTA7aTxvO2krPTEpe3ZhciBhPXVbaV07aWYoIXkoYSkpe2lmKEUoYSkmJjI9PT1hLmxlbmd0aCYmXCJzdHJpbmdcIj09dHlwZW9mIGFbMF0mJnkoYVsxXSkpe3ZhciBmPWFbMF07aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZikpdGhyb3cgbmV3IEVycm9yKFwic2VxT2JqOiBkdXBsaWNhdGUga2V5IFwiK2YpO3RbZl09ITAscisrO2NvbnRpbnVlfXRocm93IG5ldyBFcnJvcihcInNlcU9iaiBhcmd1bWVudHMgbXVzdCBiZSBwYXJzZXJzIG9yIFtzdHJpbmcsIHBhcnNlcl0gYXJyYXkgcGFpcnMuXCIpfX1pZigwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJzZXFPYmogZXhwZWN0cyBhdCBsZWFzdCBvbmUgbmFtZWQgcGFyc2VyLCBmb3VuZCB6ZXJvXCIpO3JldHVybiBlKGZ1bmN0aW9uKG4sdCl7Zm9yKHZhciByLGU9e30saT0wO2k8bztpKz0xKXt2YXIgYSxmO2lmKEUodVtpXSk/KGE9dVtpXVswXSxmPXVbaV1bMV0pOihhPW51bGwsZj11W2ldKSwhKHI9QihmLl8obix0KSxyKSkuc3RhdHVzKXJldHVybiByO2EmJihlW2FdPXIudmFsdWUpLHQ9ci5pbmRleH1yZXR1cm4gQihiKHQsZSkscil9KX0sZS5zdHJpbmc9SyxlLnN1Y2NlZWQ9WCxlLnRha2VXaGlsZT1mdW5jdGlvbihuKXtyZXR1cm4gayhuKSxlKGZ1bmN0aW9uKHQscil7Zm9yKHZhciBlPXI7ZTx0Lmxlbmd0aCYmbihMKHQsZSkpOyllKys7cmV0dXJuIGIoZSx0LnNsaWNlKHIsZSkpfSl9LGUudGVzdD1ubixlLndoaXRlc3BhY2U9cG4sZVtcImZhbnRhc3ktbGFuZC9lbXB0eVwiXT1ybixlW1wiZmFudGFzeS1sYW5kL29mXCJdPVgsZS5CaW5hcnk9e2JpdFNlcTpsLGJpdFNlcU9iajpmdW5jdGlvbihuKXtzKCk7dmFyIHQ9e30scj0wLGU9YShmdW5jdGlvbihuKXtpZihFKG4pKXt2YXIgZT1uO2lmKDIhPT1lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJbXCIrZS5qb2luKFwiLCBcIikrXCJdIHNob3VsZCBiZSBsZW5ndGggMiwgZ290IGxlbmd0aCBcIitlLmxlbmd0aCk7aWYoUChlWzBdKSxPKGVbMV0pLE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGVbMF0pKXRocm93IG5ldyBFcnJvcihcImR1cGxpY2F0ZSBrZXkgaW4gYml0U2VxT2JqOiBcIitlWzBdKTtyZXR1cm4gdFtlWzBdXT0hMCxyKyssZX1yZXR1cm4gTyhuKSxbbnVsbCxuXX0sbik7aWYocjwxKXRocm93IG5ldyBFcnJvcihcImJpdFNlcU9iaiBleHBlY3RzIGF0IGxlYXN0IG9uZSBuYW1lZCBwYWlyLCBnb3QgW1wiK24uam9pbihcIiwgXCIpK1wiXVwiKTt2YXIgdT1hKGZ1bmN0aW9uKG4pe3JldHVybiBuWzBdfSxlKTtyZXR1cm4gbChhKGZ1bmN0aW9uKG4pe3JldHVybiBuWzFdfSxlKSkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBpKGZ1bmN0aW9uKG4sdCl7cmV0dXJuIG51bGwhPT10WzBdJiYoblt0WzBdXT10WzFdKSxufSx7fSxhKGZ1bmN0aW9uKHQscil7cmV0dXJuW3QsbltyXV19LHUpKX0pfSxieXRlOmZ1bmN0aW9uKG4pe2lmKHMoKSxPKG4pLG4+MjU1KXRocm93IG5ldyBFcnJvcihcIlZhbHVlIHNwZWNpZmllZCB0byBieXRlIGNvbnN0cnVjdG9yIChcIituK1wiPTB4XCIrbi50b1N0cmluZygxNikrXCIpIGlzIGxhcmdlciBpbiB2YWx1ZSB0aGFuIGEgc2luZ2xlIGJ5dGUuXCIpO3ZhciB0PShuPjE1P1wiMHhcIjpcIjB4MFwiKStuLnRvU3RyaW5nKDE2KTtyZXR1cm4gZShmdW5jdGlvbihyLGUpe3ZhciB1PUwocixlKTtyZXR1cm4gdT09PW4/YihlKzEsdSk6eChlLHQpfSl9LGJ1ZmZlcjpmdW5jdGlvbihuKXtyZXR1cm4gaChcImJ1ZmZlclwiLG4pLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gQnVmZmVyLmZyb20obil9KX0sZW5jb2RlZFN0cmluZzpmdW5jdGlvbihuLHQpe3JldHVybiBoKFwic3RyaW5nXCIsdCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnRvU3RyaW5nKG4pfSl9LHVpbnRCRTpkLHVpbnQ4QkU6ZCgxKSx1aW50MTZCRTpkKDIpLHVpbnQzMkJFOmQoNCksdWludExFOnYsdWludDhMRTp2KDEpLHVpbnQxNkxFOnYoMiksdWludDMyTEU6dig0KSxpbnRCRTpnLGludDhCRTpnKDEpLGludDE2QkU6ZygyKSxpbnQzMkJFOmcoNCksaW50TEU6bSxpbnQ4TEU6bSgxKSxpbnQxNkxFOm0oMiksaW50MzJMRTptKDQpLGZsb2F0QkU6aChcImZsb2F0QkVcIiw0KS5tYXAoZnVuY3Rpb24obil7cmV0dXJuIG4ucmVhZEZsb2F0QkUoMCl9KSxmbG9hdExFOmgoXCJmbG9hdExFXCIsNCkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuLnJlYWRGbG9hdExFKDApfSksZG91YmxlQkU6aChcImRvdWJsZUJFXCIsOCkubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuLnJlYWREb3VibGVCRSgwKX0pLGRvdWJsZUxFOmgoXCJkb3VibGVMRVwiLDgpLm1hcChmdW5jdGlvbihuKXtyZXR1cm4gbi5yZWFkRG91YmxlTEUoMCl9KX0sbi5leHBvcnRzPWV9XSl9KTsiLCAiZXhwb3J0IGRlZmF1bHQgKCkgPT4ge1xuXHQvLyBodHRwczovL210aHMuYmUvZW1vamlcblx0cmV0dXJuIC9bIyowLTldXFx1RkUwRj9cXHUyMEUzfFtcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjNDRlxcdTIzRUQtXFx1MjNFRlxcdTIzRjFcXHUyM0YyXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCXFx1MjVGQ1xcdTI1RkVcXHUyNjAwLVxcdTI2MDRcXHUyNjBFXFx1MjYxMVxcdTI2MTRcXHUyNjE1XFx1MjYxOFxcdTI2MjBcXHUyNjIyXFx1MjYyM1xcdTI2MjZcXHUyNjJBXFx1MjYyRVxcdTI2MkZcXHUyNjM4LVxcdTI2M0FcXHUyNjQwXFx1MjY0MlxcdTI2NDgtXFx1MjY1M1xcdTI2NUZcXHUyNjYwXFx1MjY2M1xcdTI2NjVcXHUyNjY2XFx1MjY2OFxcdTI2N0JcXHUyNjdFXFx1MjY3RlxcdTI2OTJcXHUyNjk0LVxcdTI2OTdcXHUyNjk5XFx1MjY5QlxcdTI2OUNcXHUyNkEwXFx1MjZBN1xcdTI2QUFcXHUyNkIwXFx1MjZCMVxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzhcXHUyNkNGXFx1MjZEMVxcdTI2RDNcXHUyNkU5XFx1MjZGMC1cXHUyNkY1XFx1MjZGN1xcdTI2RjhcXHUyNkZBXFx1MjcwMlxcdTI3MDhcXHUyNzA5XFx1MjcwRlxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NTdcXHUyNzYzXFx1MjdBMVxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV1cXHVGRTBGP3xbXFx1MjYxRFxcdTI3MENcXHUyNzBEXSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdTI3MEFcXHUyNzBCXSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHUyM0U5LVxcdTIzRUNcXHUyM0YwXFx1MjNGM1xcdTI1RkRcXHUyNjkzXFx1MjZBMVxcdTI2QUJcXHUyNkM1XFx1MjZDRVxcdTI2RDRcXHUyNkVBXFx1MjZGRFxcdTI3MDVcXHUyNzI4XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzk1LVxcdTI3OTdcXHUyN0IwXFx1MjdCRlxcdTJCNTBdfFxcdTI2RjkoPzpcXHVGRTBGfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/KD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFxcdTI3NjRcXHVGRTBGPyg/OlxcdTIwMEQoPzpcXHVEODNEXFx1REQyNXxcXHVEODNFXFx1REU3OSkpP3xcXHVEODNDKD86W1xcdURDMDRcXHVERDcwXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REUwMlxcdURFMzdcXHVERjIxXFx1REYyNC1cXHVERjJDXFx1REYzNlxcdURGN0RcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUVcXHVERjlGXFx1REZDRFxcdURGQ0VcXHVERkQ0LVxcdURGREZcXHVERkY1XFx1REZGN11cXHVGRTBGP3xbXFx1REY4NVxcdURGQzJcXHVERkM3XSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHVERkMzXFx1REZDNFxcdURGQ0FdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98W1xcdURGQ0JcXHVERkNDXSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98W1xcdURDQ0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1REUwMVxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTM2XFx1REUzOC1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjBcXHVERjJELVxcdURGMzVcXHVERjM3LVxcdURGN0NcXHVERjdFLVxcdURGODRcXHVERjg2LVxcdURGOTNcXHVERkEwLVxcdURGQzFcXHVERkM1XFx1REZDNlxcdURGQzhcXHVERkM5XFx1REZDRi1cXHVERkQzXFx1REZFMC1cXHVERkYwXFx1REZGOC1cXHVERkZGXXxcXHVEREU2XFx1RDgzQ1tcXHVEREU4LVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjJcXHVEREY0XFx1RERGNi1cXHVEREZBXFx1RERGQ1xcdURERkRcXHVEREZGXXxcXHVEREU3XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRlxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRVxcdURERkZdfFxcdURERThcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRVxcdURERjAtXFx1RERGNVxcdURERjdcXHVEREZBLVxcdURERkZdfFxcdURERTlcXHVEODNDW1xcdURERUFcXHVEREVDXFx1RERFRlxcdURERjBcXHVEREYyXFx1RERGNFxcdURERkZdfFxcdURERUFcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVEXFx1RERGNy1cXHVEREZBXXxcXHVEREVCXFx1RDgzQ1tcXHVEREVFLVxcdURERjBcXHVEREYyXFx1RERGNFxcdURERjddfFxcdURERUNcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVFXFx1RERGMS1cXHVEREYzXFx1RERGNS1cXHVEREZBXFx1RERGQ1xcdURERkVdfFxcdURERURcXHVEODNDW1xcdURERjBcXHVEREYyXFx1RERGM1xcdURERjdcXHVEREY5XFx1RERGQV18XFx1RERFRVxcdUQ4M0NbXFx1RERFOC1cXHVEREVBXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XXxcXHVEREVGXFx1RDgzQ1tcXHVEREVBXFx1RERGMlxcdURERjRcXHVEREY1XXxcXHVEREYwXFx1RDgzQ1tcXHVEREVBXFx1RERFQy1cXHVEREVFXFx1RERGMlxcdURERjNcXHVEREY1XFx1RERGN1xcdURERkNcXHVEREZFXFx1RERGRl18XFx1RERGMVxcdUQ4M0NbXFx1RERFNi1cXHVEREU4XFx1RERFRVxcdURERjBcXHVEREY3LVxcdURERkJcXHVEREZFXXxcXHVEREYyXFx1RDgzQ1tcXHVEREU2XFx1RERFOC1cXHVEREVEXFx1RERGMC1cXHVEREZGXXxcXHVEREYzXFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUEtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGNFxcdURERjVcXHVEREY3XFx1RERGQVxcdURERkZdfFxcdURERjRcXHVEODNDXFx1RERGMnxcXHVEREY1XFx1RDgzQ1tcXHVEREU2XFx1RERFQS1cXHVEREVEXFx1RERGMC1cXHVEREYzXFx1RERGNy1cXHVEREY5XFx1RERGQ1xcdURERkVdfFxcdURERjZcXHVEODNDXFx1RERFNnxcXHVEREY3XFx1RDgzQ1tcXHVEREVBXFx1RERGNFxcdURERjhcXHVEREZBXFx1RERGQ118XFx1RERGOFxcdUQ4M0NbXFx1RERFNi1cXHVEREVBXFx1RERFQy1cXHVEREY0XFx1RERGNy1cXHVEREY5XFx1RERGQlxcdURERkQtXFx1RERGRl18XFx1RERGOVxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVEXFx1RERFRi1cXHVEREY0XFx1RERGN1xcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkZdfFxcdURERkFcXHVEODNDW1xcdURERTZcXHVEREVDXFx1RERGMlxcdURERjNcXHVEREY4XFx1RERGRVxcdURERkZdfFxcdURERkJcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVFXFx1RERGM1xcdURERkFdfFxcdURERkNcXHVEODNDW1xcdURERUJcXHVEREY4XXxcXHVEREZEXFx1RDgzQ1xcdURERjB8XFx1RERGRVxcdUQ4M0NbXFx1RERFQVxcdURERjldfFxcdURERkZcXHVEODNDW1xcdURERTZcXHVEREYyXFx1RERGQ118XFx1REZGM1xcdUZFMEY/KD86XFx1MjAwRCg/OlxcdTI2QTdcXHVGRTBGP3xcXHVEODNDXFx1REYwOCkpP3xcXHVERkY0KD86XFx1MjAwRFxcdTI2MjBcXHVGRTBGP3xcXHVEQjQwXFx1REM2N1xcdURCNDBcXHVEQzYyXFx1REI0MCg/OlxcdURDNjVcXHVEQjQwXFx1REM2RVxcdURCNDBcXHVEQzY3fFxcdURDNzNcXHVEQjQwXFx1REM2M1xcdURCNDBcXHVEQzc0fFxcdURDNzdcXHVEQjQwXFx1REM2Q1xcdURCNDBcXHVEQzczKVxcdURCNDBcXHVEQzdGKT8pfFxcdUQ4M0QoPzpbXFx1REMwOFxcdURDMjZdKD86XFx1MjAwRFxcdTJCMUIpP3xbXFx1REMzRlxcdURDRkRcXHVERDQ5XFx1REQ0QVxcdURENkZcXHVERDcwXFx1REQ3M1xcdURENzYtXFx1REQ3OVxcdUREODdcXHVERDhBLVxcdUREOERcXHVEREE1XFx1RERBOFxcdUREQjFcXHVEREIyXFx1RERCQ1xcdUREQzItXFx1RERDNFxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERVxcdURERTFcXHVEREUzXFx1RERFOFxcdURERUZcXHVEREYzXFx1RERGQVxcdURFQ0JcXHVERUNELVxcdURFQ0ZcXHVERUUwLVxcdURFRTVcXHVERUU5XFx1REVGMFxcdURFRjNdXFx1RkUwRj98W1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2NlxcdURDNjdcXHVEQzZCLVxcdURDNkRcXHVEQzcyXFx1REM3NC1cXHVEQzc2XFx1REM3OFxcdURDN0NcXHVEQzgzXFx1REM4NVxcdURDOEZcXHVEQzkxXFx1RENBQVxcdUREN0FcXHVERDk1XFx1REQ5NlxcdURFNENcXHVERTRGXFx1REVDMFxcdURFQ0NdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdURDNkVcXHVEQzcwXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT8oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98W1xcdURENzRcXHVERDkwXSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98W1xcdURDMDAtXFx1REMwN1xcdURDMDktXFx1REMxNFxcdURDMTYtXFx1REMyNVxcdURDMjctXFx1REMzQVxcdURDM0MtXFx1REMzRVxcdURDNDBcXHVEQzQ0XFx1REM0NVxcdURDNTEtXFx1REM2NVxcdURDNkFcXHVEQzc5LVxcdURDN0JcXHVEQzdELVxcdURDODBcXHVEQzg0XFx1REM4OC1cXHVEQzhFXFx1REM5MFxcdURDOTItXFx1RENBOVxcdURDQUItXFx1RENGQ1xcdURDRkYtXFx1REQzRFxcdURENEItXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdUREQTRcXHVEREZCLVxcdURFMkRcXHVERTJGLVxcdURFMzRcXHVERTM3LVxcdURFNDRcXHVERTQ4LVxcdURFNEFcXHVERTgwLVxcdURFQTJcXHVERUE0LVxcdURFQjNcXHVERUI3LVxcdURFQkZcXHVERUMxLVxcdURFQzVcXHVERUQwLVxcdURFRDJcXHVERUQ1LVxcdURFRDdcXHVERURDLVxcdURFREZcXHVERUVCXFx1REVFQ1xcdURFRjQtXFx1REVGQ1xcdURGRTAtXFx1REZFQlxcdURGRjBdfFxcdURDMTUoPzpcXHUyMDBEXFx1RDgzRVxcdUREQkEpP3xcXHVEQzNCKD86XFx1MjAwRFxcdTI3NDRcXHVGRTBGPyk/fFxcdURDNDFcXHVGRTBGPyg/OlxcdTIwMERcXHVEODNEXFx1RERFOFxcdUZFMEY/KT98XFx1REM2OCg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4fFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldXFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzY2KD86XFx1MjAwRFxcdUQ4M0RcXHVEQzY2KT98XFx1REM2Nyg/OlxcdTIwMERcXHVEODNEW1xcdURDNjZcXHVEQzY3XSk/KXxbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEQzY2KD86XFx1MjAwRFxcdUQ4M0RcXHVEQzY2KT98XFx1REM2Nyg/OlxcdTIwMERcXHVEODNEW1xcdURDNjZcXHVEQzY3XSk/KXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQyg/OlxcdURGRkIoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OlxcdURDOEJcXHUyMDBEXFx1RDgzRCk/XFx1REM2OFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OFxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSkpKT98XFx1REZGQyg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSkpKT98XFx1REZGRCg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZCXFx1REZGQ1xcdURGRkVcXHVERkZGXSkpKT98XFx1REZGRSg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSkpKT98XFx1REZGRig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86XFx1REM4QlxcdTIwMERcXHVEODNEKT9cXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4XFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKSkpPykpP3xcXHVEQzY5KD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpcXHVEQzhCXFx1MjAwRFxcdUQ4M0QpP1tcXHVEQzY4XFx1REM2OV18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRCg/OltcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdURDNjYoPzpcXHUyMDBEXFx1RDgzRFxcdURDNjYpP3xcXHVEQzY3KD86XFx1MjAwRFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKT98XFx1REM2OVxcdTIwMERcXHVEODNEKD86XFx1REM2Nig/OlxcdTIwMERcXHVEODNEXFx1REM2Nik/fFxcdURDNjcoPzpcXHUyMDBEXFx1RDgzRFtcXHVEQzY2XFx1REM2N10pPykpfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDKD86XFx1REZGQig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XXxcXHVEQzhCXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XVxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSkpKT98XFx1REZGQyg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XXxcXHVEQzhCXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XVxcdUQ4M0NbXFx1REZGQlxcdURGRkQtXFx1REZGRl0pKSk/fFxcdURGRkQoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEXFx1RDgzRCg/OltcXHVEQzY4XFx1REM2OV18XFx1REM4QlxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV1cXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdKSkpP3xcXHVERkZFKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRFxcdUQ4M0QoPzpbXFx1REM2OFxcdURDNjldfFxcdURDOEJcXHUyMDBEXFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldXFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSkpKT98XFx1REZGRig/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMERcXHVEODNEKD86W1xcdURDNjhcXHVEQzY5XXxcXHVEQzhCXFx1MjAwRFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNEW1xcdURDNjhcXHVEQzY5XVxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXSkpKT8pKT98XFx1REM2Rig/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xcXHVERDc1KD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pPyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj8pP3xcXHVERTJFKD86XFx1MjAwRFxcdUQ4M0RcXHVEQ0E4KT98XFx1REUzNSg/OlxcdTIwMERcXHVEODNEXFx1RENBQik/fFxcdURFMzYoPzpcXHUyMDBEXFx1RDgzQ1xcdURGMkJcXHVGRTBGPyk/KXxcXHVEODNFKD86W1xcdUREMENcXHVERDBGXFx1REQxOC1cXHVERDFGXFx1REQzMC1cXHVERDM0XFx1REQzNlxcdURENzdcXHVEREI1XFx1RERCNlxcdUREQkJcXHVEREQyXFx1REREM1xcdURERDVcXHVERUMzLVxcdURFQzVcXHVERUYwXFx1REVGMi1cXHVERUY4XSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/fFtcXHVERDI2XFx1REQzNVxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCOFxcdUREQjlcXHVERENELVxcdUREQ0ZcXHVEREQ0XFx1RERENi1cXHVEREREXSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSk/KD86XFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGPyk/fFtcXHVERERFXFx1RERERl0oPzpcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXVxcdUZFMEY/KT98W1xcdUREMERcXHVERDBFXFx1REQxMC1cXHVERDE3XFx1REQyMC1cXHVERDI1XFx1REQyNy1cXHVERDJGXFx1REQzQVxcdUREM0YtXFx1REQ0NVxcdURENDctXFx1REQ3NlxcdURENzgtXFx1RERCNFxcdUREQjdcXHVEREJBXFx1RERCQy1cXHVERENDXFx1REREMFxcdURERTAtXFx1RERGRlxcdURFNzAtXFx1REU3Q1xcdURFODAtXFx1REU4OFxcdURFOTAtXFx1REVCRFxcdURFQkYtXFx1REVDMlxcdURFQ0UtXFx1REVEQlxcdURFRTAtXFx1REVFOF18XFx1REQzQyg/OlxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRj98XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98XFx1REREMSg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMSkpfFxcdUQ4M0MoPzpcXHVERkZCKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkMtXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSkpP3xcXHVERkZDKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRSg/OltcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF18XFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpKT98XFx1REZGRCg/OlxcdTIwMEQoPzpbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEY/fFxcdTI3NjRcXHVGRTBGP1xcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCXFx1REZGQ1xcdURGRkVcXHVERkZGXXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0UoPzpbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdfFxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKSk/fFxcdURGRkUoPzpcXHUyMDBEKD86W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGP3xcXHUyNzY0XFx1RkUwRj9cXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMVxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXFx1REZGRl18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSkpP3xcXHVERkZGKD86XFx1MjAwRCg/OltcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRj98XFx1Mjc2NFxcdUZFMEY/XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDFcXHVEODNDW1xcdURGRkItXFx1REZGRV18XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFKD86W1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXXxcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxXFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSkpPykpP3xcXHVERUYxKD86XFx1RDgzQyg/OlxcdURGRkIoPzpcXHUyMDBEXFx1RDgzRVxcdURFRjJcXHVEODNDW1xcdURGRkMtXFx1REZGRl0pP3xcXHVERkZDKD86XFx1MjAwRFxcdUQ4M0VcXHVERUYyXFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSk/fFxcdURGRkQoPzpcXHUyMDBEXFx1RDgzRVxcdURFRjJcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdKT98XFx1REZGRSg/OlxcdTIwMERcXHVEODNFXFx1REVGMlxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXFx1REZGRl0pP3xcXHVERkZGKD86XFx1MjAwRFxcdUQ4M0VcXHVERUYyXFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKT8pKT8pL2c7XG59O1xuIiwgImltcG9ydCB7IERhdGVUaW1lLCBEdXJhdGlvbiB9IGZyb20gXCJsdXhvblwiO1xuaW1wb3J0IHsgUmVzdWx0IH0gZnJvbSBcImFwaS9yZXN1bHRcIjtcbmltcG9ydCAqIGFzIFAgZnJvbSBcInBhcnNpbW1vblwiO1xuaW1wb3J0IGVtb2ppUmVnZXggZnJvbSBcImVtb2ppLXJlZ2V4XCI7XG5pbXBvcnQgeyBRdWVyeVNldHRpbmdzIH0gZnJvbSBcInNldHRpbmdzXCI7XG5cbi8qKiBOb3JtYWxpemUgYSBkdXJhdGlvbiB0byBhbGwgb2YgdGhlIHByb3BlciB1bml0cy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVEdXJhdGlvbihkdXI6IER1cmF0aW9uKSB7XG4gICAgaWYgKGR1ciA9PT0gdW5kZWZpbmVkIHx8IGR1ciA9PT0gbnVsbCkgcmV0dXJuIGR1cjtcblxuICAgIHJldHVybiBkdXIuc2hpZnRUb0FsbCgpLm5vcm1hbGl6ZSgpO1xufVxuXG4vKiogU3RyaXAgdGhlIHRpbWUgY29tcG9uZW50cyBvZiBhIGRhdGUgdGltZSBvYmplY3QuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBUaW1lKGR0OiBEYXRlVGltZSk6IERhdGVUaW1lIHtcbiAgICBpZiAoZHQgPT09IG51bGwgfHwgZHQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGR0O1xuXG4gICAgcmV0dXJuIERhdGVUaW1lLmZyb21PYmplY3Qoe1xuICAgICAgICB5ZWFyOiBkdC55ZWFyLFxuICAgICAgICBtb250aDogZHQubW9udGgsXG4gICAgICAgIGRheTogZHQuZGF5LFxuICAgIH0pO1xufVxuXG4vKiogVHJ5IHRvIGV4dHJhY3QgYSBZWVlZTU1ERCBkYXRlIGZyb20gYSBzdHJpbmcuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdERhdGUoc3RyOiBzdHJpbmcpOiBEYXRlVGltZSB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IGRhdGVNYXRjaCA9IC8oXFxkezR9KS0oXFxkezJ9KS0oXFxkezJ9KS8uZXhlYyhzdHIpO1xuICAgIGlmICghZGF0ZU1hdGNoKSBkYXRlTWF0Y2ggPSAvKFxcZHs0fSkoXFxkezJ9KShcXGR7Mn0pLy5leGVjKHN0cik7XG4gICAgaWYgKGRhdGVNYXRjaCkge1xuICAgICAgICBsZXQgeWVhciA9IE51bWJlci5wYXJzZUludChkYXRlTWF0Y2hbMV0pO1xuICAgICAgICBsZXQgbW9udGggPSBOdW1iZXIucGFyc2VJbnQoZGF0ZU1hdGNoWzJdKTtcbiAgICAgICAgbGV0IGRheSA9IE51bWJlci5wYXJzZUludChkYXRlTWF0Y2hbM10pO1xuICAgICAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXIsIG1vbnRoLCBkYXkgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqIEdldCB0aGUgZm9sZGVyIGNvbnRhaW5pbmcgdGhlIGdpdmVuIHBhdGggKGkuZS4sIGxpa2UgY29tcHV0aW5nICdwYXRoLy4uJykuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50Rm9sZGVyKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGguc3BsaXQoXCIvXCIpLnNsaWNlKDAsIC0xKS5qb2luKFwiL1wiKTtcbn1cblxuLyoqIEdldCB0aGUgZmlsZSBuYW1lIGZvciB0aGUgZmlsZSByZWZlcmVuY2VkIGluIHRoZSBnaXZlbiBwYXRoLCBieSBzdHJpcHBpbmcgdGhlIHBhcmVudCBmb2xkZXJzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVOYW1lKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGguaW5jbHVkZXMoXCIvXCIpID8gcGF0aC5zdWJzdHJpbmcocGF0aC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKSA6IHBhdGg7XG59XG5cbi8qKiBHZXQgdGhlIFwidGl0bGVcIiBmb3IgYSBmaWxlLCBieSBzdHJpcHBpbmcgb3RoZXIgcGFydHMgb2YgdGhlIHBhdGggYXMgd2VsbCBhcyB0aGUgZXh0ZW5zaW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVUaXRsZShwYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChwYXRoLmluY2x1ZGVzKFwiL1wiKSkgcGF0aCA9IHBhdGguc3Vic3RyaW5nKHBhdGgubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gICAgaWYgKHBhdGguZW5kc1dpdGgoXCIubWRcIikpIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDMpO1xuICAgIHJldHVybiBwYXRoO1xufVxuXG4vKiogR2V0IHRoZSBleHRlbnNpb24gb2YgYSBmaWxlIGZyb20gdGhlIGZpbGUgcGF0aC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlbnNpb24ocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAoIXBhdGguaW5jbHVkZXMoXCIuXCIpKSByZXR1cm4gXCJcIjtcbiAgICByZXR1cm4gcGF0aC5zdWJzdHJpbmcocGF0aC5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbn1cblxuLyoqIFBhcnNlIGFsbCBzdWJ0YWdzIG91dCBvZiB0aGUgZ2l2ZW4gdGFnLiBJLmUuLCAjaGVsbG8vaS9hbSB3b3VsZCB5aWVsZCBbI2hlbGxvL2kvYW0sICNoZWxsby9pLCAjaGVsbG9dLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RTdWJ0YWdzKHRhZzogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGxldCByZXN1bHQgPSBbdGFnXTtcbiAgICB3aGlsZSAodGFnLmluY2x1ZGVzKFwiL1wiKSkge1xuICAgICAgICB0YWcgPSB0YWcuc3Vic3RyaW5nKDAsIHRhZy5sYXN0SW5kZXhPZihcIi9cIikpO1xuICAgICAgICByZXN1bHQucHVzaCh0YWcpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBUcnkgY2FsbGluZyB0aGUgZ2l2ZW4gZnVuY3Rpb247IG9uIGZhaWx1cmUsIHJldHVybiB0aGUgZXJyb3IgbWVzc2FnZS4gICovXG5leHBvcnQgZnVuY3Rpb24gdHJ5T3JQcm9wb2dhdGU8VD4oZnVuYzogKCkgPT4gUmVzdWx0PFQsIHN0cmluZz4pOiBSZXN1bHQ8VCwgc3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gUmVzdWx0LmZhaWx1cmUoXCJcIiArIGVycm9yICsgXCJcXG5cXG5cIiArIGVycm9yLnN0YWNrKTtcbiAgICB9XG59XG5cbi8qKiBUcnkgYXN5bmNocm9ub3VzbHkgY2FsbGluZyB0aGUgZ2l2ZW4gZnVuY3Rpb247IG9uIGZhaWx1cmUsIHJldHVybiB0aGUgZXJyb3IgbWVzc2FnZS4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3luY1RyeU9yUHJvcG9nYXRlPFQ+KGZ1bmM6ICgpID0+IFByb21pc2U8UmVzdWx0PFQsIHN0cmluZz4+KTogUHJvbWlzZTxSZXN1bHQ8VCwgc3RyaW5nPj4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBmdW5jKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsdXJlKFwiXCIgKyBlcnJvciArIFwiXFxuXFxuXCIgKyBlcnJvci5zdGFjayk7XG4gICAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSByZWdleCBjaGFyYWN0ZXJzIGluIGEgc3RyaW5nLlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG5cbi8qKiBBIHBhcnNpbW1vbiBwYXJzZXIgd2hpY2ggY2Fub25pY2FsaXplcyB2YXJpYWJsZSBuYW1lcyB3aGlsZSBwcm9wZXJseSByZXNwZWN0aW5nIGVtb2ppLiAqL1xuY29uc3QgVkFSX05BTUVfQ0FOT05JQ0FMSVpFUjogUC5QYXJzZXI8c3RyaW5nPiA9IFAuYWx0KFxuICAgIFAucmVnZXgobmV3IFJlZ0V4cChlbW9qaVJlZ2V4KCksIFwiXCIpKSxcbiAgICBQLnJlZ2V4KC9bMC05XFxwe0xldHRlcn1fLV0rL3UpLm1hcChzdHIgPT4gc3RyLnRvTG9jYWxlTG93ZXJDYXNlKCkpLFxuICAgIFAud2hpdGVzcGFjZS5tYXAoXyA9PiBcIi1cIiksXG4gICAgUC5hbnkubWFwKF8gPT4gXCJcIilcbilcbiAgICAubWFueSgpXG4gICAgLm1hcChyZXN1bHQgPT4gcmVzdWx0LmpvaW4oXCJcIikpO1xuXG4vKiogQ29udmVydCBhbiBhcmJpdHJhcnkgdmFyaWFibGUgbmFtZSBpbnRvIHNvbWV0aGluZyBKUy9xdWVyeSBmcmllbmRseS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYW5vbmljYWxpemVWYXJOYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFZBUl9OQU1FX0NBTk9OSUNBTElaRVIudHJ5UGFyc2UobmFtZSk7XG59XG5cbmNvbnN0IEhFQURFUl9DQU5PTklDQUxJWkVSOiBQLlBhcnNlcjxzdHJpbmc+ID0gUC5hbHQoXG4gICAgUC5yZWdleChuZXcgUmVnRXhwKGVtb2ppUmVnZXgoKSwgXCJcIikpLFxuICAgIFAucmVnZXgoL1swLTlcXHB7TGV0dGVyfV8tXSsvdSksXG4gICAgUC53aGl0ZXNwYWNlLm1hcChfID0+IFwiIFwiKSxcbiAgICBQLmFueS5tYXAoXyA9PiBcIiBcIilcbilcbiAgICAubWFueSgpXG4gICAgLm1hcChyZXN1bHQgPT4ge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcIikuc3BsaXQoL1xccysvKS5qb2luKFwiIFwiKS50cmltKCk7XG4gICAgfSk7XG5cbi8qKlxuICogTm9ybWFsaXplcyB0aGUgdGV4dCBpbiBhIGhlYWRlciB0byBiZSBzb21ldGhpbmcgdGhhdCBpcyBhY3R1YWxseSBsaW5rYWJsZSB0by4gVGhpcyBtaW1pY3NcbiAqIGhvdyBPYnNpZGlhbiBkb2VzIGl0J3Mgbm9ybWFsaXphdGlvbiwgY29sbGFwc2luZyByZXBlYXRlZCBzcGFjZXMgYW5kIHN0cmlwcGluZyBvdXQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyRm9yTGluayhoZWFkZXI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIEhFQURFUl9DQU5PTklDQUxJWkVSLnRyeVBhcnNlKGhlYWRlcik7XG59XG5cbi8qKiBSZW5kZXIgYSBEYXRlVGltZSBpbiBhIG1pbmltYWwgZm9ybWF0IHRvIHNhdmUgc3BhY2UuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWluaW1hbERhdGUodGltZTogRGF0ZVRpbWUsIHNldHRpbmdzOiBRdWVyeVNldHRpbmdzLCBsb2NhbGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gcmVsZXZhbnQgdGltZSBzcGVjaWZpZWQsIGZhbGwgYmFjayB0byBqdXN0IHJlbmRlcmluZyB0aGUgZGF0ZS5cbiAgICBpZiAodGltZS5zZWNvbmQgPT0gMCAmJiB0aW1lLm1pbnV0ZSA9PSAwICYmIHRpbWUuaG91ciA9PSAwKSB7XG4gICAgICAgIHJldHVybiB0aW1lLnRvTG9jYWwoKS50b0Zvcm1hdChzZXR0aW5ncy5kZWZhdWx0RGF0ZUZvcm1hdCwgeyBsb2NhbGUgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpbWUudG9Mb2NhbCgpLnRvRm9ybWF0KHNldHRpbmdzLmRlZmF1bHREYXRlVGltZUZvcm1hdCwgeyBsb2NhbGUgfSk7XG59XG5cbi8qKiBSZW5kZXIgYSBkdXJhdGlvbiBpbiBhIG1pbmltYWwgZm9ybWF0IHRvIHNhdmUgc3BhY2UuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWluaW1hbER1cmF0aW9uKGR1cjogRHVyYXRpb24pOiBzdHJpbmcge1xuICAgIGR1ciA9IG5vcm1hbGl6ZUR1cmF0aW9uKGR1cik7XG5cbiAgICAvLyB0b0h1bWFuIG91dHB1dHMgemVybyBxdWFudGl0aWVzIGUuZy4gXCIwIHNlY29uZHNcIlxuICAgIGR1ciA9IER1cmF0aW9uLmZyb21PYmplY3QoXG4gICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhkdXIudG9PYmplY3QoKSkuZmlsdGVyKChbLCBxdWFudGl0eV0pID0+IHF1YW50aXR5ICE9IDApKVxuICAgICk7XG5cbiAgICByZXR1cm4gZHVyLnRvSHVtYW4oKTtcbn1cblxuLyoqIERldGVybWluZSBpZiB0d28gc2V0cyBhcmUgZXF1YWwgaW4gY29udGVudHMuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0c0VxdWFsPFQ+KGZpcnN0OiBTZXQ8VD4sIHNlY29uZDogU2V0PFQ+KTogYm9vbGVhbiB7XG4gICAgaWYgKGZpcnN0LnNpemUgIT0gc2Vjb25kLnNpemUpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBlbGVtIG9mIGZpcnN0KSBpZiAoIXNlY29uZC5oYXMoZWxlbSkpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0cnVlO1xufVxuIiwgImltcG9ydCB7IERhdGVUaW1lLCBEdXJhdGlvbiB9IGZyb20gXCJsdXhvblwiO1xuaW1wb3J0IHsgREVGQVVMVF9RVUVSWV9TRVRUSU5HUywgUXVlcnlTZXR0aW5ncyB9IGZyb20gXCJzZXR0aW5nc1wiO1xuaW1wb3J0IHsgZ2V0RmlsZVRpdGxlLCBub3JtYWxpemVIZWFkZXJGb3JMaW5rLCByZW5kZXJNaW5pbWFsRHVyYXRpb24gfSBmcm9tIFwidXRpbC9ub3JtYWxpemVcIjtcblxuLyoqIFNob3J0aGFuZCBmb3IgYSBtYXBwaW5nIGZyb20ga2V5cyB0byB2YWx1ZXMuICovXG5leHBvcnQgdHlwZSBEYXRhT2JqZWN0ID0geyBba2V5OiBzdHJpbmddOiBMaXRlcmFsIH07XG4vKiogVGhlIGxpdGVyYWwgdHlwZXMgc3VwcG9ydGVkIGJ5IHRoZSBxdWVyeSBlbmdpbmUuICovXG5leHBvcnQgdHlwZSBMaXRlcmFsVHlwZSA9XG4gICAgfCBcImJvb2xlYW5cIlxuICAgIHwgXCJudW1iZXJcIlxuICAgIHwgXCJzdHJpbmdcIlxuICAgIHwgXCJkYXRlXCJcbiAgICB8IFwiZHVyYXRpb25cIlxuICAgIHwgXCJsaW5rXCJcbiAgICB8IFwiYXJyYXlcIlxuICAgIHwgXCJvYmplY3RcIlxuICAgIHwgXCJmdW5jdGlvblwiXG4gICAgfCBcIm51bGxcIlxuICAgIHwgXCJodG1sXCJcbiAgICB8IFwid2lkZ2V0XCI7XG4vKiogVGhlIHJhdyB2YWx1ZXMgdGhhdCBhIGxpdGVyYWwgY2FuIHRha2Ugb24uICovXG5leHBvcnQgdHlwZSBMaXRlcmFsID1cbiAgICB8IGJvb2xlYW5cbiAgICB8IG51bWJlclxuICAgIHwgc3RyaW5nXG4gICAgfCBEYXRlVGltZVxuICAgIHwgRHVyYXRpb25cbiAgICB8IExpbmtcbiAgICB8IEFycmF5PExpdGVyYWw+XG4gICAgfCBEYXRhT2JqZWN0XG4gICAgfCBGdW5jdGlvblxuICAgIHwgbnVsbFxuICAgIHwgSFRNTEVsZW1lbnRcbiAgICB8IFdpZGdldDtcblxuLyoqIEEgZ3JvdXBpbmcgb24gYSB0eXBlIHdoaWNoIHN1cHBvcnRzIHJlY3Vyc2l2ZWx5LW5lc3RlZCBncm91cHMuICovXG5leHBvcnQgdHlwZSBHcm91cEVsZW1lbnQ8VD4gPSB7IGtleTogTGl0ZXJhbDsgcm93czogR3JvdXBpbmc8VD4gfTtcbmV4cG9ydCB0eXBlIEdyb3VwaW5nPFQ+ID0gVFtdIHwgR3JvdXBFbGVtZW50PFQ+W107XG5cbi8qKiBNYXBzIHRoZSBzdHJpbmcgdHlwZSB0byBpdCdzIGV4dGVybmFsLCBBUEktZmFjaW5nIHJlcHJlc2VudGF0aW9uLiAqL1xuZXhwb3J0IHR5cGUgTGl0ZXJhbFJlcHI8VCBleHRlbmRzIExpdGVyYWxUeXBlPiA9IFQgZXh0ZW5kcyBcImJvb2xlYW5cIlxuICAgID8gYm9vbGVhblxuICAgIDogVCBleHRlbmRzIFwibnVtYmVyXCJcbiAgICA/IG51bWJlclxuICAgIDogVCBleHRlbmRzIFwic3RyaW5nXCJcbiAgICA/IHN0cmluZ1xuICAgIDogVCBleHRlbmRzIFwiZHVyYXRpb25cIlxuICAgID8gRHVyYXRpb25cbiAgICA6IFQgZXh0ZW5kcyBcImRhdGVcIlxuICAgID8gRGF0ZVRpbWVcbiAgICA6IFQgZXh0ZW5kcyBcIm51bGxcIlxuICAgID8gbnVsbFxuICAgIDogVCBleHRlbmRzIFwibGlua1wiXG4gICAgPyBMaW5rXG4gICAgOiBUIGV4dGVuZHMgXCJhcnJheVwiXG4gICAgPyBBcnJheTxMaXRlcmFsPlxuICAgIDogVCBleHRlbmRzIFwib2JqZWN0XCJcbiAgICA/IFJlY29yZDxzdHJpbmcsIExpdGVyYWw+XG4gICAgOiBUIGV4dGVuZHMgXCJmdW5jdGlvblwiXG4gICAgPyBGdW5jdGlvblxuICAgIDogVCBleHRlbmRzIFwiaHRtbFwiXG4gICAgPyBIVE1MRWxlbWVudFxuICAgIDogVCBleHRlbmRzIFwid2lkZ2V0XCJcbiAgICA/IFdpZGdldFxuICAgIDogYW55O1xuXG4vKiogQSB3cmFwcGVkIGxpdGVyYWwgdmFsdWUgd2hpY2ggY2FuIGJlIHN3aXRjaGVkIG9uLiAqL1xuZXhwb3J0IHR5cGUgV3JhcHBlZExpdGVyYWwgPVxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJzdHJpbmdcIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwibnVtYmVyXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImJvb2xlYW5cIj5cbiAgICB8IExpdGVyYWxXcmFwcGVyPFwiZGF0ZVwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJkdXJhdGlvblwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJsaW5rXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcImFycmF5XCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcIm9iamVjdFwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJodG1sXCI+XG4gICAgfCBMaXRlcmFsV3JhcHBlcjxcIndpZGdldFwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJmdW5jdGlvblwiPlxuICAgIHwgTGl0ZXJhbFdyYXBwZXI8XCJudWxsXCI+O1xuXG5leHBvcnQgaW50ZXJmYWNlIExpdGVyYWxXcmFwcGVyPFQgZXh0ZW5kcyBMaXRlcmFsVHlwZT4ge1xuICAgIHR5cGU6IFQ7XG4gICAgdmFsdWU6IExpdGVyYWxSZXByPFQ+O1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFZhbHVlcyB7XG4gICAgLyoqIENvbnZlcnQgYW4gYXJiaXRyYXJ5IHZhbHVlIGludG8gYSByZWFzb25hYmxlLCBNYXJrZG93bi1mcmllbmRseSBzdHJpbmcgaWYgcG9zc2libGUuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKFxuICAgICAgICBmaWVsZDogYW55LFxuICAgICAgICBzZXR0aW5nOiBRdWVyeVNldHRpbmdzID0gREVGQVVMVF9RVUVSWV9TRVRUSU5HUyxcbiAgICAgICAgcmVjdXJzaXZlOiBib29sZWFuID0gZmFsc2VcbiAgICApOiBzdHJpbmcge1xuICAgICAgICBsZXQgd3JhcHBlZCA9IHdyYXBWYWx1ZShmaWVsZCk7XG4gICAgICAgIGlmICghd3JhcHBlZCkgcmV0dXJuIHNldHRpbmcucmVuZGVyTnVsbEFzO1xuXG4gICAgICAgIHN3aXRjaCAod3JhcHBlZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5nLnJlbmRlck51bGxBcztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB3cmFwcGVkLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZS5vdXRlckhUTUw7XG4gICAgICAgICAgICBjYXNlIFwid2lkZ2V0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUubWFya2Rvd24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUubWFya2Rvd24oKTtcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIjxmdW5jdGlvbj5cIjtcbiAgICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChyZWN1cnNpdmUpIHJlc3VsdCArPSBcIltcIjtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gd3JhcHBlZC52YWx1ZS5tYXAoZiA9PiB0b1N0cmluZyhmLCBzZXR0aW5nLCB0cnVlKSkuam9pbihcIiwgXCIpO1xuICAgICAgICAgICAgICAgIGlmIChyZWN1cnNpdmUpIHJlc3VsdCArPSBcIl1cIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgIFwieyBcIiArXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHdyYXBwZWQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGUgPT4gZVswXSArIFwiOiBcIiArIHRvU3RyaW5nKGVbMV0sIHNldHRpbmcsIHRydWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCIsIFwiKSArXG4gICAgICAgICAgICAgICAgICAgIFwiIH1cIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgICAgICAgIGlmICh3cmFwcGVkLnZhbHVlLnNlY29uZCA9PSAwICYmIHdyYXBwZWQudmFsdWUuaG91ciA9PSAwICYmIHdyYXBwZWQudmFsdWUubWludXRlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUudG9Gb3JtYXQoc2V0dGluZy5kZWZhdWx0RGF0ZUZvcm1hdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUudG9Gb3JtYXQoc2V0dGluZy5kZWZhdWx0RGF0ZVRpbWVGb3JtYXQpO1xuICAgICAgICAgICAgY2FzZSBcImR1cmF0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlck1pbmltYWxEdXJhdGlvbih3cmFwcGVkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBXcmFwIGEgbGl0ZXJhbCB2YWx1ZSBzbyB5b3UgY2FuIHN3aXRjaCBvbiBpdCBlYXNpbHkuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHdyYXBWYWx1ZSh2YWw6IExpdGVyYWwpOiBXcmFwcGVkTGl0ZXJhbCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmIChpc051bGwodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJudWxsXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNOdW1iZXIodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJudW1iZXJcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc1N0cmluZyh2YWwpKSByZXR1cm4geyB0eXBlOiBcInN0cmluZ1wiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbih2YWwpKSByZXR1cm4geyB0eXBlOiBcImJvb2xlYW5cIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0R1cmF0aW9uKHZhbCkpIHJldHVybiB7IHR5cGU6IFwiZHVyYXRpb25cIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0RhdGUodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJkYXRlXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNXaWRnZXQodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJ3aWRnZXRcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHJldHVybiB7IHR5cGU6IFwiYXJyYXlcIiwgdmFsdWU6IHZhbCB9O1xuICAgICAgICBlbHNlIGlmIChpc0xpbmsodmFsKSkgcmV0dXJuIHsgdHlwZTogXCJsaW5rXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbih2YWwpKSByZXR1cm4geyB0eXBlOiBcImZ1bmN0aW9uXCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSBpZiAoaXNIdG1sKHZhbCkpIHJldHVybiB7IHR5cGU6IFwiaHRtbFwiLCB2YWx1ZTogdmFsIH07XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHJldHVybiB7IHR5cGU6IFwib2JqZWN0XCIsIHZhbHVlOiB2YWwgfTtcbiAgICAgICAgZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKiBSZWN1cnNpdmVseSBtYXAgY29tcGxleCBvYmplY3RzIGF0IHRoZSBsZWF2ZXMuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIG1hcExlYXZlcyh2YWw6IExpdGVyYWwsIGZ1bmM6ICh0OiBMaXRlcmFsKSA9PiBMaXRlcmFsKTogTGl0ZXJhbCB7XG4gICAgICAgIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0OiBEYXRhT2JqZWN0ID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkgcmVzdWx0W2tleV0gPSBtYXBMZWF2ZXModmFsdWUsIGZ1bmMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ6IExpdGVyYWxbXSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsKSByZXN1bHQucHVzaChtYXBMZWF2ZXModmFsdWUsIGZ1bmMpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYyh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENvbXBhcmUgdHdvIGFyYml0cmFyeSBKYXZhU2NyaXB0IHZhbHVlcy4gUHJvZHVjZXMgYSB0b3RhbCBvcmRlcmluZyBvdmVyIEFOWSBwb3NzaWJsZSBkYXRhdmlldyB2YWx1ZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gY29tcGFyZVZhbHVlKHZhbDE6IExpdGVyYWwsIHZhbDI6IExpdGVyYWwsIGxpbmtOb3JtYWxpemVyPzogKGxpbms6IHN0cmluZykgPT4gc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgLy8gSGFuZGxlIHVuZGVmaW5lZC9udWxscyBmaXJzdC5cbiAgICAgICAgaWYgKHZhbDEgPT09IHVuZGVmaW5lZCkgdmFsMSA9IG51bGw7XG4gICAgICAgIGlmICh2YWwyID09PSB1bmRlZmluZWQpIHZhbDIgPSBudWxsO1xuICAgICAgICBpZiAodmFsMSA9PT0gbnVsbCAmJiB2YWwyID09PSBudWxsKSByZXR1cm4gMDtcbiAgICAgICAgZWxzZSBpZiAodmFsMSA9PT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgICAgICBlbHNlIGlmICh2YWwyID09PSBudWxsKSByZXR1cm4gMTtcblxuICAgICAgICAvLyBBIG5vbi1udWxsIHZhbHVlIG5vdyB3aGljaCB3ZSBjYW4gd3JhcCAmIGNvbXBhcmUgb24uXG4gICAgICAgIGxldCB3cmFwMSA9IHdyYXBWYWx1ZSh2YWwxKTtcbiAgICAgICAgbGV0IHdyYXAyID0gd3JhcFZhbHVlKHZhbDIpO1xuXG4gICAgICAgIGlmICh3cmFwMSA9PT0gdW5kZWZpbmVkICYmIHdyYXAyID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICAgICAgICBlbHNlIGlmICh3cmFwMSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XG4gICAgICAgIGVsc2UgaWYgKHdyYXAyID09PSB1bmRlZmluZWQpIHJldHVybiAxO1xuXG4gICAgICAgIC8vIFNob3J0LWNpcmN1aXQgb24gZGlmZmVyZW50IHR5cGVzIG9yIG9uIHJlZmVyZW5jZSBlcXVhbGl0eS5cbiAgICAgICAgaWYgKHdyYXAxLnR5cGUgIT0gd3JhcDIudHlwZSkgcmV0dXJuIHdyYXAxLnR5cGUubG9jYWxlQ29tcGFyZSh3cmFwMi50eXBlKTtcbiAgICAgICAgaWYgKHdyYXAxLnZhbHVlID09PSB3cmFwMi52YWx1ZSkgcmV0dXJuIDA7XG5cbiAgICAgICAgc3dpdGNoICh3cmFwMS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXAxLnZhbHVlLmxvY2FsZUNvbXBhcmUod3JhcDIudmFsdWUgYXMgc3RyaW5nKTtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICBpZiAod3JhcDEudmFsdWUgPCAod3JhcDIudmFsdWUgYXMgbnVtYmVyKSkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdyYXAxLnZhbHVlID09ICh3cmFwMi52YWx1ZSBhcyBudW1iZXIpKSByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIGlmICh3cmFwMS52YWx1ZSA9PSB3cmFwMi52YWx1ZSkgcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gd3JhcDEudmFsdWUgPyAxIDogLTE7XG4gICAgICAgICAgICBjYXNlIFwibGlua1wiOlxuICAgICAgICAgICAgICAgIGxldCBsaW5rMSA9IHdyYXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCBsaW5rMiA9IHdyYXAyLnZhbHVlIGFzIExpbms7XG4gICAgICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZSA9IGxpbmtOb3JtYWxpemVyID8/ICgoeDogc3RyaW5nKSA9PiB4KTtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbid0IGNvbXBhcmUgYnkgZmlsZSBuYW1lIG9yIGRpc3BsYXksIHNpbmNlIHRoYXQgd291bGQgYnJlYWsgbGluayBlcXVhbGl0eS4gQ29tcGFyZSBieSBwYXRoLlxuICAgICAgICAgICAgICAgIGxldCBwYXRoQ29tcGFyZSA9IG5vcm1hbGl6ZShsaW5rMS5wYXRoKS5sb2NhbGVDb21wYXJlKG5vcm1hbGl6ZShsaW5rMi5wYXRoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhDb21wYXJlICE9IDApIHJldHVybiBwYXRoQ29tcGFyZTtcblxuICAgICAgICAgICAgICAgIC8vIFRoZW4gY29tcGFyZSBieSB0eXBlLlxuICAgICAgICAgICAgICAgIGxldCB0eXBlQ29tcGFyZSA9IGxpbmsxLnR5cGUubG9jYWxlQ29tcGFyZShsaW5rMi50eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUNvbXBhcmUgIT0gMCkgcmV0dXJuIHR5cGVDb21wYXJlO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiBjb21wYXJlIGJ5IHN1YnBhdGggZXhpc3RlbmNlLlxuICAgICAgICAgICAgICAgIGlmIChsaW5rMS5zdWJwYXRoICYmICFsaW5rMi5zdWJwYXRoKSByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmsxLnN1YnBhdGggJiYgbGluazIuc3VicGF0aCkgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGlmICghbGluazEuc3VicGF0aCAmJiAhbGluazIuc3VicGF0aCkgcmV0dXJuIDA7XG5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBib3RoIGhhdmUgYSBzdWJwYXRoLCBjb21wYXJlIGJ5IHN1YnBhdGguXG4gICAgICAgICAgICAgICAgcmV0dXJuIChsaW5rMS5zdWJwYXRoID8/IFwiXCIpLmxvY2FsZUNvbXBhcmUobGluazIuc3VicGF0aCA/PyBcIlwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXAxLnZhbHVlIDwgKHdyYXAyLnZhbHVlIGFzIERhdGVUaW1lKVxuICAgICAgICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgICAgICAgIDogd3JhcDEudmFsdWUuZXF1YWxzKHdyYXAyLnZhbHVlIGFzIERhdGVUaW1lKVxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICAgICAgY2FzZSBcImR1cmF0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXAxLnZhbHVlIDwgKHdyYXAyLnZhbHVlIGFzIER1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IC0xXG4gICAgICAgICAgICAgICAgICAgIDogd3JhcDEudmFsdWUuZXF1YWxzKHdyYXAyLnZhbHVlIGFzIER1cmF0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgbGV0IGYxID0gd3JhcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgbGV0IGYyID0gd3JhcDIudmFsdWUgYXMgYW55W107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IE1hdGgubWluKGYxLmxlbmd0aCwgZjIubGVuZ3RoKTsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcCA9IGNvbXBhcmVWYWx1ZShmMVtpbmRleF0sIGYyW2luZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21wICE9IDApIHJldHVybiBjb21wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZjEubGVuZ3RoIC0gZjIubGVuZ3RoO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIGxldCBvMSA9IHdyYXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxldCBvMiA9IHdyYXAyLnZhbHVlIGFzIFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgICAgICAgICAgICAgbGV0IGsxID0gQXJyYXkuZnJvbShPYmplY3Qua2V5cyhvMSkpO1xuICAgICAgICAgICAgICAgIGxldCBrMiA9IEFycmF5LmZyb20oT2JqZWN0LmtleXMobzIpKTtcbiAgICAgICAgICAgICAgICBrMS5zb3J0KCk7XG4gICAgICAgICAgICAgICAgazIuc29ydCgpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGtleUNvbXBhcmUgPSBjb21wYXJlVmFsdWUoazEsIGsyKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Q29tcGFyZSAhPSAwKSByZXR1cm4ga2V5Q29tcGFyZTtcblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBrMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tcCA9IGNvbXBhcmVWYWx1ZShvMVtrZXldLCBvMltrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXAgIT0gMCkgcmV0dXJuIGNvbXA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlIFwid2lkZ2V0XCI6XG4gICAgICAgICAgICBjYXNlIFwiaHRtbFwiOlxuICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRmluZCB0aGUgY29ycmVzcG9uZGluZyBEYXRhdmVpdyB0eXBlIGZvciBhbiBhcmJpdHJhcnkgdmFsdWUuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHR5cGVPZih2YWw6IGFueSk6IExpdGVyYWxUeXBlIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHdyYXBWYWx1ZSh2YWwpPy50eXBlO1xuICAgIH1cblxuICAgIC8qKiBEZXRlcm1pbmUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIFwidHJ1dGh5XCIgKGkuZS4sIGlzIG5vbi1udWxsIGFuZCBoYXMgZGF0YSBpbiBpdCkuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzVHJ1dGh5KGZpZWxkOiBMaXRlcmFsKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCB3cmFwcGVkID0gd3JhcFZhbHVlKGZpZWxkKTtcbiAgICAgICAgaWYgKCF3cmFwcGVkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgc3dpdGNoICh3cmFwcGVkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZC52YWx1ZSAhPSAwO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlO1xuICAgICAgICAgICAgY2FzZSBcImxpbmtcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gISF3cmFwcGVkLnZhbHVlLnBhdGg7XG4gICAgICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLnRvTWlsbGlzKCkgIT0gMDtcbiAgICAgICAgICAgIGNhc2UgXCJkdXJhdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkLnZhbHVlLmFzKFwic2Vjb25kc1wiKSAhPSAwO1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh3cmFwcGVkLnZhbHVlKS5sZW5ndGggPiAwO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudmFsdWUubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY2FzZSBcImh0bWxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ3aWRnZXRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIERlZXAgY29weSBhIGZpZWxkLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBkZWVwQ29weTxUIGV4dGVuZHMgTGl0ZXJhbD4oZmllbGQ6IFQpOiBUIHtcbiAgICAgICAgaWYgKGZpZWxkID09PSBudWxsIHx8IGZpZWxkID09PSB1bmRlZmluZWQpIHJldHVybiBmaWVsZDtcblxuICAgICAgICBpZiAoVmFsdWVzLmlzQXJyYXkoZmllbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gKFtdIGFzIExpdGVyYWxbXSkuY29uY2F0KGZpZWxkLm1hcCh2ID0+IGRlZXBDb3B5KHYpKSkgYXMgVDtcbiAgICAgICAgfSBlbHNlIGlmIChWYWx1ZXMuaXNPYmplY3QoZmllbGQpKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCBMaXRlcmFsPiA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGZpZWxkKSkgcmVzdWx0W2tleV0gPSBkZWVwQ29weSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0IGFzIFQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsOiBhbnkpOiB2YWwgaXMgc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJzdHJpbmdcIjtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsOiBhbnkpOiB2YWwgaXMgbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT0gXCJudW1iZXJcIjtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNEYXRlKHZhbDogYW55KTogdmFsIGlzIERhdGVUaW1lIHtcbiAgICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIERhdGVUaW1lO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0R1cmF0aW9uKHZhbDogYW55KTogdmFsIGlzIER1cmF0aW9uIHtcbiAgICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc051bGwodmFsOiBhbnkpOiB2YWwgaXMgbnVsbCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkodmFsOiBhbnkpOiB2YWwgaXMgYW55W10ge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsOiBhbnkpOiB2YWwgaXMgYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09PSBcImJvb2xlYW5cIjtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNMaW5rKHZhbDogYW55KTogdmFsIGlzIExpbmsge1xuICAgICAgICByZXR1cm4gdmFsIGluc3RhbmNlb2YgTGluaztcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNXaWRnZXQodmFsOiBhbnkpOiB2YWwgaXMgV2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIFdpZGdldDtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNIdG1sKHZhbDogYW55KTogdmFsIGlzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gb2JqZWN0IChhbmQgbm90IGFueSBvdGhlciBkYXRhdmlldy1yZWNvZ25pemVkIG9iamVjdC1saWtlIHR5cGUpLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWw6IGFueSk6IHZhbCBpcyBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHR5cGVvZiB2YWwgPT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgIWlzSHRtbCh2YWwpICYmXG4gICAgICAgICAgICAhaXNXaWRnZXQodmFsKSAmJlxuICAgICAgICAgICAgIWlzQXJyYXkodmFsKSAmJlxuICAgICAgICAgICAgIWlzRHVyYXRpb24odmFsKSAmJlxuICAgICAgICAgICAgIWlzRGF0ZSh2YWwpICYmXG4gICAgICAgICAgICAhaXNMaW5rKHZhbCkgJiZcbiAgICAgICAgICAgIHZhbCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAhaXNOdWxsKHZhbClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWw6IGFueSk6IHZhbCBpcyBGdW5jdGlvbiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsID09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG59XG5cbi8vLy8vLy8vLy8vLy8vL1xuLy8gR3JvdXBpbmdzIC8vXG4vLy8vLy8vLy8vLy8vLy9cblxuZXhwb3J0IG5hbWVzcGFjZSBHcm91cGluZ3Mge1xuICAgIC8qKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBncm91cCBlbnRyeSBpcyBhIHN0YW5kYWxvbmUgdmFsdWUsIG9yIGEgZ3JvdXBpbmcgb2Ygc3ViLWVudHJpZXMuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudEdyb3VwPFQ+KGVudHJ5OiBUIHwgR3JvdXBFbGVtZW50PFQ+KTogZW50cnkgaXMgR3JvdXBFbGVtZW50PFQ+IHtcbiAgICAgICAgcmV0dXJuIFZhbHVlcy5pc09iamVjdChlbnRyeSkgJiYgT2JqZWN0LmtleXMoZW50cnkpLmxlbmd0aCA9PSAyICYmIFwia2V5XCIgaW4gZW50cnkgJiYgXCJyb3dzXCIgaW4gZW50cnk7XG4gICAgfVxuXG4gICAgLyoqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIGFycmF5IGlzIGEgZ3JvdXBpbmcgYXJyYXkuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGlzR3JvdXBpbmc8VD4oZW50cnk6IEdyb3VwaW5nPFQ+KTogZW50cnkgaXMgR3JvdXBFbGVtZW50PFQ+W10ge1xuICAgICAgICBmb3IgKGxldCBlbGVtZW50IG9mIGVudHJ5KSBpZiAoIWlzRWxlbWVudEdyb3VwKGVsZW1lbnQpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqIENvdW50IHRoZSB0b3RhbCBudW1iZXIgb2YgZWxlbWVudHMgaW4gYSByZWN1cnNpdmUgZ3JvdXBpbmcuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGNvdW50PFQ+KGVsZW1lbnRzOiBHcm91cGluZzxUPik6IG51bWJlciB7XG4gICAgICAgIGlmIChpc0dyb3VwaW5nKGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBzdWJncm91cCBvZiBlbGVtZW50cykgcmVzdWx0ICs9IGNvdW50KHN1Ymdyb3VwLnJvd3MpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vLy8vLy8vLy9cbi8vIExJTksgLy9cbi8vLy8vLy8vLy9cblxuLyoqIFRoZSBPYnNpZGlhbiAnbGluaycsIHVzZWQgZm9yIHVuaXF1ZWx5IGRlc2NyaWJpbmcgYSBmaWxlLCBoZWFkZXIsIG9yIGJsb2NrLiAqL1xuZXhwb3J0IGNsYXNzIExpbmsge1xuICAgIC8qKiBUaGUgZmlsZSBwYXRoIHRoaXMgbGluayBwb2ludHMgdG8uICovXG4gICAgcHVibGljIHBhdGg6IHN0cmluZztcbiAgICAvKiogVGhlIGRpc3BsYXkgbmFtZSBhc3NvY2lhdGVkIHdpdGggdGhlIGxpbmsuICovXG4gICAgcHVibGljIGRpc3BsYXk/OiBzdHJpbmc7XG4gICAgLyoqIFRoZSBibG9jayBJRCBvciBoZWFkZXIgdGhpcyBsaW5rIHBvaW50cyB0byB3aXRoaW4gYSBmaWxlLCBpZiByZWxldmFudC4gKi9cbiAgICBwdWJsaWMgc3VicGF0aD86IHN0cmluZztcbiAgICAvKiogSXMgdGhpcyBsaW5rIGFuIGVtYmVkZGVkIGxpbmsgKCEpPyAqL1xuICAgIHB1YmxpYyBlbWJlZDogYm9vbGVhbjtcbiAgICAvKiogVGhlIHR5cGUgb2YgdGhpcyBsaW5rLCB3aGljaCBkZXRlcm1pbmVzIHdoYXQgJ3N1YnBhdGgnIHJlZmVycyB0bywgaWYgYW55dGhpbmcuICovXG4gICAgcHVibGljIHR5cGU6IFwiZmlsZVwiIHwgXCJoZWFkZXJcIiB8IFwiYmxvY2tcIjtcblxuICAgIC8qKiBDcmVhdGUgYSBsaW5rIHRvIGEgc3BlY2lmaWMgZmlsZS4gKi9cbiAgICBwdWJsaWMgc3RhdGljIGZpbGUocGF0aDogc3RyaW5nLCBlbWJlZDogYm9vbGVhbiA9IGZhbHNlLCBkaXNwbGF5Pzogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluayh7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgZW1iZWQsXG4gICAgICAgICAgICBkaXNwbGF5LFxuICAgICAgICAgICAgc3VicGF0aDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaW5mZXIobGlua3BhdGg6IHN0cmluZywgZW1iZWQ6IGJvb2xlYW4gPSBmYWxzZSwgZGlzcGxheT86IHN0cmluZykge1xuICAgICAgICBpZiAobGlua3BhdGguaW5jbHVkZXMoXCIjXlwiKSkge1xuICAgICAgICAgICAgbGV0IHNwbGl0ID0gbGlua3BhdGguc3BsaXQoXCIjXlwiKTtcbiAgICAgICAgICAgIHJldHVybiBMaW5rLmJsb2NrKHNwbGl0WzBdLCBzcGxpdFsxXSwgZW1iZWQsIGRpc3BsYXkpO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmtwYXRoLmluY2x1ZGVzKFwiI1wiKSkge1xuICAgICAgICAgICAgbGV0IHNwbGl0ID0gbGlua3BhdGguc3BsaXQoXCIjXCIpO1xuICAgICAgICAgICAgcmV0dXJuIExpbmsuaGVhZGVyKHNwbGl0WzBdLCBzcGxpdFsxXSwgZW1iZWQsIGRpc3BsYXkpO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIExpbmsuZmlsZShsaW5rcGF0aCwgZW1iZWQsIGRpc3BsYXkpO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBsaW5rIHRvIGEgc3BlY2lmaWMgZmlsZSBhbmQgaGVhZGVyIGluIHRoYXQgZmlsZS4gKi9cbiAgICBwdWJsaWMgc3RhdGljIGhlYWRlcihwYXRoOiBzdHJpbmcsIGhlYWRlcjogc3RyaW5nLCBlbWJlZD86IGJvb2xlYW4sIGRpc3BsYXk/OiBzdHJpbmcpIHtcbiAgICAgICAgLy8gSGVhZGVycyBuZWVkIHRvIGJlIG5vcm1hbGl6ZWQgdG8gYWxwaGEtbnVtZXJpYyAmIHdpdGggZXh0cmEgc3BhY2luZyByZW1vdmVkLlxuICAgICAgICByZXR1cm4gbmV3IExpbmsoe1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGVtYmVkLFxuICAgICAgICAgICAgZGlzcGxheSxcbiAgICAgICAgICAgIHN1YnBhdGg6IG5vcm1hbGl6ZUhlYWRlckZvckxpbmsoaGVhZGVyKSxcbiAgICAgICAgICAgIHR5cGU6IFwiaGVhZGVyXCIsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgYSBsaW5rIHRvIGEgc3BlY2lmaWMgZmlsZSBhbmQgYmxvY2sgaW4gdGhhdCBmaWxlLiAqL1xuICAgIHB1YmxpYyBzdGF0aWMgYmxvY2socGF0aDogc3RyaW5nLCBibG9ja0lkOiBzdHJpbmcsIGVtYmVkPzogYm9vbGVhbiwgZGlzcGxheT86IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IExpbmsoe1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIGVtYmVkLFxuICAgICAgICAgICAgZGlzcGxheSxcbiAgICAgICAgICAgIHN1YnBhdGg6IGJsb2NrSWQsXG4gICAgICAgICAgICB0eXBlOiBcImJsb2NrXCIsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZnJvbU9iamVjdChvYmplY3Q6IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rKG9iamVjdCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihmaWVsZHM6IFBhcnRpYWw8TGluaz4pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBmaWVsZHMpO1xuICAgIH1cblxuICAgIC8qKiBDaGVja3MgZm9yIGxpbmsgZXF1YWxpdHkgKGkuZS4sIHRoYXQgdGhlIGxpbmtzIGFyZSBwb2ludGluZyB0byB0aGUgc2FtZSBleGFjdCBsb2NhdGlvbikuICovXG4gICAgcHVibGljIGVxdWFscyhvdGhlcjogTGluayk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAob3RoZXIgPT0gdW5kZWZpbmVkIHx8IG90aGVyID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wYXRoID09IG90aGVyLnBhdGggJiYgdGhpcy50eXBlID09IG90aGVyLnR5cGUgJiYgdGhpcy5zdWJwYXRoID09IG90aGVyLnN1YnBhdGg7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhpcyBsaW5rIHRvIGl0J3MgbWFya2Rvd24gcmVwcmVzZW50YXRpb24uICovXG4gICAgcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtkb3duKCk7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhpcyBsaW5rIHRvIGEgcmF3IG9iamVjdCB3aGljaCBpcyBzZXJpYWxpemF0aW9uLWZyaWVuZGx5LiAqL1xuICAgIHB1YmxpYyB0b09iamVjdCgpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogdGhpcy5wYXRoLCB0eXBlOiB0aGlzLnR5cGUsIHN1YnBhdGg6IHRoaXMuc3VicGF0aCwgZGlzcGxheTogdGhpcy5kaXNwbGF5LCBlbWJlZDogdGhpcy5lbWJlZCB9O1xuICAgIH1cblxuICAgIC8qKiBVcGRhdGUgdGhpcyBsaW5rIHdpdGggYSBuZXcgcGF0aC4gKi9cbiAgICAvL0B0cy1pZ25vcmU7IGVycm9yIGFwcGVhcmVkIGFmdGVyIHVwZGF0aW5nIE9ic2lkaWFuIHRvIDAuMTUuNDsgaXQgYWxzbyB1cGRhdGVkIG90aGVyIHBhY2thZ2VzIGJ1dCBkaWRuJ3Qgc2F5IHdoaWNoXG4gICAgcHVibGljIHdpdGhQYXRoKHBhdGg6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gbmV3IExpbmsoT2JqZWN0LmFzc2lnbih7fSwgdGhpcywgeyBwYXRoIH0pKTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJuIGEgbmV3IGxpbmsgd2hpY2ggcG9pbnRzIHRvIHRoZSBzYW1lIGxvY2F0aW9uIGJ1dCB3aXRoIGEgbmV3IGRpc3BsYXkgdmFsdWUuICovXG4gICAgcHVibGljIHdpdGhEaXNwbGF5KGRpc3BsYXk/OiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rKE9iamVjdC5hc3NpZ24oe30sIHRoaXMsIHsgZGlzcGxheSB9KSk7XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgYSBmaWxlIGxpbmsgaW50byBhIGxpbmsgdG8gYSBzcGVjaWZpYyBoZWFkZXIuICovXG4gICAgcHVibGljIHdpdGhIZWFkZXIoaGVhZGVyOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIExpbmsuaGVhZGVyKHRoaXMucGF0aCwgaGVhZGVyLCB0aGlzLmVtYmVkLCB0aGlzLmRpc3BsYXkpO1xuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0IGFueSBsaW5rIGludG8gYSBsaW5rIHRvIGl0cyBmaWxlLiAqL1xuICAgIHB1YmxpYyB0b0ZpbGUoKSB7XG4gICAgICAgIHJldHVybiBMaW5rLmZpbGUodGhpcy5wYXRoLCB0aGlzLmVtYmVkLCB0aGlzLmRpc3BsYXkpO1xuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0IHRoaXMgbGluayBpbnRvIGFuIGVtYmVkZGVkIGxpbmsuICovXG4gICAgcHVibGljIHRvRW1iZWQoKTogTGluayB7XG4gICAgICAgIGlmICh0aGlzLmVtYmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsaW5rID0gbmV3IExpbmsodGhpcyk7XG4gICAgICAgICAgICBsaW5rLmVtYmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBsaW5rO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhpcyBsaW5rIGludG8gYSBub24tZW1iZWRkZWQgbGluay4gKi9cbiAgICBwdWJsaWMgZnJvbUVtYmVkKCk6IExpbmsge1xuICAgICAgICBpZiAoIXRoaXMuZW1iZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGxpbmsgPSBuZXcgTGluayh0aGlzKTtcbiAgICAgICAgICAgIGxpbmsuZW1iZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBsaW5rO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENvbnZlcnQgdGhpcyBsaW5rIHRvIG1hcmtkb3duIHNvIGl0IGNhbiBiZSByZW5kZXJlZC4gKi9cbiAgICBwdWJsaWMgbWFya2Rvd24oKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICh0aGlzLmVtYmVkID8gXCIhXCIgOiBcIlwiKSArIFwiW1tcIiArIHRoaXMub2JzaWRpYW5MaW5rKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwifFwiICsgdGhpcy5kaXNwbGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwifFwiICsgZ2V0RmlsZVRpdGxlKHRoaXMucGF0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09IFwiaGVhZGVyXCIgfHwgdGhpcy50eXBlID09IFwiYmxvY2tcIikgcmVzdWx0ICs9IFwiID4gXCIgKyB0aGlzLnN1YnBhdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgKz0gXCJdXVwiO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKiBDb252ZXJ0IHRoZSBpbm5lciBwYXJ0IG9mIHRoZSBsaW5rIHRvIHNvbWV0aGluZyB0aGF0IE9ic2lkaWFuIGNhbiBvcGVuIC8gdW5kZXJzdGFuZC4gKi9cbiAgICBwdWJsaWMgb2JzaWRpYW5MaW5rKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGVzY2FwZWQgPSB0aGlzLnBhdGgucmVwbGFjZUFsbChcInxcIiwgXCJcXFxcfFwiKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcImhlYWRlclwiKSByZXR1cm4gZXNjYXBlZCArIFwiI1wiICsgdGhpcy5zdWJwYXRoPy5yZXBsYWNlQWxsKFwifFwiLCBcIlxcXFx8XCIpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09IFwiYmxvY2tcIikgcmV0dXJuIGVzY2FwZWQgKyBcIiNeXCIgKyB0aGlzLnN1YnBhdGg/LnJlcGxhY2VBbGwoXCJ8XCIsIFwiXFxcXHxcIik7XG4gICAgICAgIGVsc2UgcmV0dXJuIGVzY2FwZWQ7XG4gICAgfVxuXG4gICAgLyoqIFRoZSBzdHJpcHBlZCBuYW1lIG9mIHRoZSBmaWxlIHRoaXMgbGluayBwb2ludHMgdG8uICovXG4gICAgcHVibGljIGZpbGVOYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBnZXRGaWxlVGl0bGUodGhpcy5wYXRoKS5yZXBsYWNlKFwiLm1kXCIsIFwiXCIpO1xuICAgIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdJREdFVCBCQVNFIC8vXG4vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgdHJpdmlhbCBiYXNlIGNsYXNzIHdoaWNoIGp1c3QgZGVmaW5lcyB0aGUgJyR3aWRnZXQnIGlkZW50aWZpZXIgdHlwZS4gU3VidHlwZXMgb2ZcbiAqIHdpZGdldCBhcmUgcmVzcG9uc2libGUgZm9yIGFkZGluZyB3aGF0ZXZlciBtZXRhZGF0YSBpcyByZWxldmFudC4gSWYgeW91IHdhbnQgeW91ciB3aWRnZXRcbiAqIHRvIGhhdmUgcmVuZGVyaW5nIGZ1bmN0aW9uYWxpdHkgKHdoaWNoIHlvdSBwcm9iYWJseSBkbyksIHlvdSBzaG91bGQgZXh0ZW5kIGBSZW5kZXJXaWRnZXRgLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgV2lkZ2V0IHtcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljICR3aWRnZXQ6IHN0cmluZykge31cblxuICAgIC8qKlxuICAgICAqIEF0dGVtcHQgdG8gcmVuZGVyIHRoaXMgd2lkZ2V0IGluIG1hcmtkb3duLCBpZiBwb3NzaWJsZTsgaWYgbWFya2Rvd24gaXMgbm90IHBvc3NpYmxlLFxuICAgICAqIHRoZW4gdGhpcyB3aWxsIGF0dGVtcHQgdG8gcmVuZGVyIGFzIEhUTUwuIE5vdGUgdGhhdCBtYW55IHdpZGdldHMgaGF2ZSBpbnRlcmFjdGl2ZVxuICAgICAqIGNvbXBvbmVudHMgb3IgZGlmZmljdWx0IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbmQgdGhlIGBtYXJrZG93bmAgZnVuY3Rpb24gY2FuIHNpbXBseVxuICAgICAqIHJldHVybiBhIHBsYWNlaG9sZGVyIGluIHRoaXMgY2FzZSAoc3VjaCBhcyBgPGZ1bmN0aW9uPmAgb3IgYDx0YXNrLWxpc3Q+YCkuXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IG1hcmtkb3duKCk6IHN0cmluZztcbn1cblxuLyoqIEEgdHJpdmlhbCB3aWRnZXQgd2hpY2ggcmVuZGVycyBhIChrZXksIHZhbHVlKSBwYWlyLCBhbmQgYWxsb3dzIGFjY2Vzc2luZyB0aGUga2V5IGFuZCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBMaXN0UGFpcldpZGdldCBleHRlbmRzIFdpZGdldCB7XG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHB1YmxpYyBrZXk6IExpdGVyYWwsIHB1YmxpYyB2YWx1ZTogTGl0ZXJhbCkge1xuICAgICAgICBzdXBlcihcImRhdGF2aWV3Omxpc3QtcGFpclwiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbWFya2Rvd24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke1ZhbHVlcy50b1N0cmluZyh0aGlzLmtleSl9OiAke1ZhbHVlcy50b1N0cmluZyh0aGlzLnZhbHVlKX1gO1xuICAgIH1cbn1cblxuLyoqIEEgc2ltcGxlIHdpZGdldCB3aGljaCByZW5kZXJzIGFuIGV4dGVybmFsIGxpbmsuICovXG5leHBvcnQgY2xhc3MgRXh0ZXJuYWxMaW5rV2lkZ2V0IGV4dGVuZHMgV2lkZ2V0IHtcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHVibGljIHVybDogc3RyaW5nLCBwdWJsaWMgZGlzcGxheT86IHN0cmluZykge1xuICAgICAgICBzdXBlcihcImRhdGF2aWV3OmV4dGVybmFsLWxpbmtcIik7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG1hcmtkb3duKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5kaXNwbGF5ID8/IHRoaXMudXJsfV0oJHt0aGlzLnVybH0pYDtcbiAgICB9XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgV2lkZ2V0cyB7XG4gICAgLyoqIENyZWF0ZSBhIGxpc3QgcGFpciB3aWRnZXQgbWF0Y2hpbmcgdGhlIGdpdmVuIGtleSBhbmQgdmFsdWUuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGxpc3RQYWlyKGtleTogTGl0ZXJhbCwgdmFsdWU6IExpdGVyYWwpOiBMaXN0UGFpcldpZGdldCB7XG4gICAgICAgIHJldHVybiBuZXcgTGlzdFBhaXJXaWRnZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhbiBleHRlcm5hbCBsaW5rIHdpZGdldCB3aGljaCByZW5kZXJzIGFuIGV4dGVybmFsIE9ic2lkaWFuIGxpbmsuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGV4dGVybmFsTGluayh1cmw6IHN0cmluZywgZGlzcGxheT86IHN0cmluZyk6IEV4dGVybmFsTGlua1dpZGdldCB7XG4gICAgICAgIHJldHVybiBuZXcgRXh0ZXJuYWxMaW5rV2lkZ2V0KHVybCwgZGlzcGxheSk7XG4gICAgfVxuXG4gICAgLyoqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gd2lkZ2V0IGlzIGEgbGlzdCBwYWlyIHdpZGdldC4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNMaXN0UGFpcih3aWRnZXQ6IFdpZGdldCk6IHdpZGdldCBpcyBMaXN0UGFpcldpZGdldCB7XG4gICAgICAgIHJldHVybiB3aWRnZXQuJHdpZGdldCA9PT0gXCJkYXRhdmlldzpsaXN0LXBhaXJcIjtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbExpbmsod2lkZ2V0OiBXaWRnZXQpOiB3aWRnZXQgaXMgRXh0ZXJuYWxMaW5rV2lkZ2V0IHtcbiAgICAgICAgcmV0dXJuIHdpZGdldC4kd2lkZ2V0ID09PSBcImRhdGF2aWV3OmV4dGVybmFsLWxpbmtcIjtcbiAgICB9XG5cbiAgICAvKiogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gd2lkZ2V0IGlzIGFueSBraW5kIG9mIGJ1aWx0LWluIHdpZGdldCB3aXRoIHNwZWNpYWwgcmVuZGVyaW5nIGhhbmRsaW5nLiAqL1xuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0J1aWx0aW4od2lkZ2V0OiBXaWRnZXQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzTGlzdFBhaXIod2lkZ2V0KSB8fCBpc0V4dGVybmFsTGluayh3aWRnZXQpO1xuICAgIH1cbn1cbiIsICIvKiogRGVmaW5lcyB0aGUgQVNUIGZvciBhIGZpZWxkIHdoaWNoIGNhbiBiZSBldmFsdWF0ZWQuICovXG5pbXBvcnQgeyBMaXRlcmFsIH0gZnJvbSBcImRhdGEtbW9kZWwvdmFsdWVcIjtcblxuLyoqIENvbXBhcmlzb24gb3BlcmF0b3JzIHdoaWNoIHlpZWxkIHRydWUvZmFsc2UuICovXG5leHBvcnQgdHlwZSBDb21wYXJlT3AgPSBcIj5cIiB8IFwiPj1cIiB8IFwiPD1cIiB8IFwiPFwiIHwgXCI9XCIgfCBcIiE9XCI7XG4vKiogQXJpdGhtZXRpYyBvcGVyYXRvcnMgd2hpY2ggeWllbGQgbnVtYmVycyBhbmQgb3RoZXIgdmFsdWVzLiAqL1xuZXhwb3J0IHR5cGUgQXJpdGhtZXRpY09wID0gXCIrXCIgfCBcIi1cIiB8IFwiKlwiIHwgXCIvXCIgfCBcIiVcIiB8IFwiJlwiIHwgXCJ8XCI7XG4vKiogQWxsIHZhbGlkIGJpbmFyeSBvcGVyYXRvcnMuICovXG5leHBvcnQgdHlwZSBCaW5hcnlPcCA9IENvbXBhcmVPcCB8IEFyaXRobWV0aWNPcDtcbi8qKiBBIChwb3RlbnRpYWxseSBjb21wdXRlZCkgZmllbGQgdG8gc2VsZWN0IG9yIGNvbXBhcmUgYWdhaW5zdC4gKi9cbmV4cG9ydCB0eXBlIEZpZWxkID1cbiAgICB8IEJpbmFyeU9wRmllbGRcbiAgICB8IFZhcmlhYmxlRmllbGRcbiAgICB8IExpdGVyYWxGaWVsZFxuICAgIHwgRnVuY3Rpb25GaWVsZFxuICAgIHwgSW5kZXhGaWVsZFxuICAgIHwgTmVnYXRlZEZpZWxkXG4gICAgfCBMYW1iZGFGaWVsZFxuICAgIHwgT2JqZWN0RmllbGRcbiAgICB8IExpc3RGaWVsZDtcblxuLyoqIExpdGVyYWwgcmVwcmVzZW50YXRpb24gb2Ygc29tZSBmaWVsZCB0eXBlLiAqL1xuZXhwb3J0IGludGVyZmFjZSBMaXRlcmFsRmllbGQge1xuICAgIHR5cGU6IFwibGl0ZXJhbFwiO1xuICAgIHZhbHVlOiBMaXRlcmFsO1xufVxuXG4vKiogQSB2YXJpYWJsZSBmaWVsZCBmb3IgYSB2YXJpYWJsZSB3aXRoIGEgZ2l2ZW4gbmFtZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmFyaWFibGVGaWVsZCB7XG4gICAgdHlwZTogXCJ2YXJpYWJsZVwiO1xuICAgIG5hbWU6IHN0cmluZztcbn1cblxuLyoqIEEgbGlzdCwgd2hpY2ggaXMgYW4gb3JkZXJlZCBjb2xsZWN0aW9uIG9mIGZpZWxkcy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdEZpZWxkIHtcbiAgICB0eXBlOiBcImxpc3RcIjtcbiAgICB2YWx1ZXM6IEZpZWxkW107XG59XG5cbi8qKiBBbiBvYmplY3QsIHdoaWNoIGlzIGEgbWFwcGluZyBvZiBuYW1lIHRvIGZpZWxkLiAqL1xuZXhwb3J0IGludGVyZmFjZSBPYmplY3RGaWVsZCB7XG4gICAgdHlwZTogXCJvYmplY3RcIjtcbiAgICB2YWx1ZXM6IFJlY29yZDxzdHJpbmcsIEZpZWxkPjtcbn1cblxuLyoqIEEgYmluYXJ5IG9wZXJhdG9yIGZpZWxkIHdoaWNoIGNvbWJpbmVzIHR3byBzdWJub2RlcyBzb21laG93LiAqL1xuZXhwb3J0IGludGVyZmFjZSBCaW5hcnlPcEZpZWxkIHtcbiAgICB0eXBlOiBcImJpbmFyeW9wXCI7XG4gICAgbGVmdDogRmllbGQ7XG4gICAgcmlnaHQ6IEZpZWxkO1xuICAgIG9wOiBCaW5hcnlPcDtcbn1cblxuLyoqIEEgZnVuY3Rpb24gZmllbGQgd2hpY2ggY2FsbHMgYSBmdW5jdGlvbiBvbiAwIG9yIG1vcmUgYXJndW1lbnRzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbkZpZWxkIHtcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCI7XG4gICAgLyoqIEVpdGhlciB0aGUgbmFtZSBvZiB0aGUgZnVuY3Rpb24gYmVpbmcgY2FsbGVkLCBvciBhIEZ1bmN0aW9uIG9iamVjdC4gKi9cbiAgICBmdW5jOiBGaWVsZDtcbiAgICAvKiogVGhlIGFyZ3VtZW50cyBiZWluZyBwYXNzZWQgdG8gdGhlIGZ1bmN0aW9uLiAqL1xuICAgIGFyZ3VtZW50czogRmllbGRbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYW1iZGFGaWVsZCB7XG4gICAgdHlwZTogXCJsYW1iZGFcIjtcbiAgICAvKiogQW4gb3JkZXJlZCBsaXN0IG9mIG5hbWVkIGFyZ3VtZW50cy4gKi9cbiAgICBhcmd1bWVudHM6IHN0cmluZ1tdO1xuICAgIC8qKiBUaGUgZmllbGQgd2hpY2ggc2hvdWxkIGJlIGV2YWx1YXRlZCB3aXRoIHRoZSBhcmd1bWVudHMgaW4gY29udGV4dC4gKi9cbiAgICB2YWx1ZTogRmllbGQ7XG59XG5cbi8qKiBBIGZpZWxkIHdoaWNoIGluZGV4ZXMgYSB2YXJpYWJsZSBpbnRvIGFub3RoZXIgdmFyaWFibGUuICovXG5leHBvcnQgaW50ZXJmYWNlIEluZGV4RmllbGQge1xuICAgIHR5cGU6IFwiaW5kZXhcIjtcbiAgICAvKiogVGhlIGZpZWxkIHRvIGluZGV4IGludG8uICovXG4gICAgb2JqZWN0OiBGaWVsZDtcbiAgICAvKiogVGhlIGluZGV4LiAqL1xuICAgIGluZGV4OiBGaWVsZDtcbn1cblxuLyoqIEEgZmllbGQgd2hpY2ggbmVnYXRlcyB0aGUgdmFsdWUgb2YgdGhlIG9yaWdpbmFsIGZpZWxkLiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZWdhdGVkRmllbGQge1xuICAgIHR5cGU6IFwibmVnYXRlZFwiO1xuICAgIC8qKiBUaGUgY2hpbGQgZmllbGQgdG8gbmVnYXRlZC4gKi9cbiAgICBjaGlsZDogRmllbGQ7XG59XG5cbi8qKiBVdGlsaXR5IG1ldGhvZHMgZm9yIGNyZWF0aW5nICYgY29tcGFyaW5nIGZpZWxkcy4gKi9cbmV4cG9ydCBuYW1lc3BhY2UgRmllbGRzIHtcbiAgICBleHBvcnQgZnVuY3Rpb24gdmFyaWFibGUobmFtZTogc3RyaW5nKTogVmFyaWFibGVGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidmFyaWFibGVcIiwgbmFtZSB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsKHZhbHVlOiBMaXRlcmFsKTogTGl0ZXJhbEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeU9wKGxlZnQ6IEZpZWxkLCBvcDogQmluYXJ5T3AsIHJpZ2h0OiBGaWVsZCk6IEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJiaW5hcnlvcFwiLCBsZWZ0LCBvcCwgcmlnaHQgfSBhcyBCaW5hcnlPcEZpZWxkO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpbmRleChvYmo6IEZpZWxkLCBpbmRleDogRmllbGQpOiBJbmRleEZpZWxkIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJpbmRleFwiLCBvYmplY3Q6IG9iaiwgaW5kZXggfTtcbiAgICB9XG5cbiAgICAvKiogQ29udmVydHMgYSBzdHJpbmcgaW4gZG90LW5vdGF0aW9uLWZvcm1hdCBpbnRvIGEgdmFyaWFibGUgd2hpY2ggaW5kZXhlcy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gaW5kZXhWYXJpYWJsZShuYW1lOiBzdHJpbmcpOiBGaWVsZCB7XG4gICAgICAgIGxldCBwYXJ0cyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICAgICAgICBsZXQgcmVzdWx0OiBGaWVsZCA9IEZpZWxkcy52YXJpYWJsZShwYXJ0c1swXSk7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBwYXJ0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEZpZWxkcy5pbmRleChyZXN1bHQsIEZpZWxkcy5saXRlcmFsKHBhcnRzW2luZGV4XSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gbGFtYmRhKGFyZ3M6IHN0cmluZ1tdLCB2YWx1ZTogRmllbGQpOiBMYW1iZGFGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibGFtYmRhXCIsIGFyZ3VtZW50czogYXJncywgdmFsdWUgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gZnVuYyhmdW5jOiBGaWVsZCwgYXJnczogRmllbGRbXSk6IEZ1bmN0aW9uRmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImZ1bmN0aW9uXCIsIGZ1bmMsIGFyZ3VtZW50czogYXJncyB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBsaXN0KHZhbHVlczogRmllbGRbXSk6IExpc3RGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibGlzdFwiLCB2YWx1ZXMgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gb2JqZWN0KHZhbHVlczogUmVjb3JkPHN0cmluZywgRmllbGQ+KTogT2JqZWN0RmllbGQge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIm9iamVjdFwiLCB2YWx1ZXMgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gbmVnYXRlKGNoaWxkOiBGaWVsZCk6IE5lZ2F0ZWRGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibmVnYXRlZFwiLCBjaGlsZCB9O1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpc0NvbXBhcmVPcChvcDogQmluYXJ5T3ApOiBvcCBpcyBDb21wYXJlT3Age1xuICAgICAgICByZXR1cm4gb3AgPT0gXCI8PVwiIHx8IG9wID09IFwiPFwiIHx8IG9wID09IFwiPlwiIHx8IG9wID09IFwiPj1cIiB8fCBvcCA9PSBcIiE9XCIgfHwgb3AgPT0gXCI9XCI7XG4gICAgfVxuXG4gICAgZXhwb3J0IGNvbnN0IE5VTEwgPSBGaWVsZHMubGl0ZXJhbChudWxsKTtcbn1cbiIsICIvKiogQVNUIGltcGxlbWVudGF0aW9uIGZvciBxdWVyaWVzIG92ZXIgZGF0YSBzb3VyY2VzLiAqL1xuXG4vKiogVGhlIHNvdXJjZSBvZiBmaWxlcyBmb3IgYSBxdWVyeS4gKi9cbmV4cG9ydCB0eXBlIFNvdXJjZSA9IFRhZ1NvdXJjZSB8IENzdlNvdXJjZSB8IEZvbGRlclNvdXJjZSB8IExpbmtTb3VyY2UgfCBFbXB0eVNvdXJjZSB8IE5lZ2F0ZWRTb3VyY2UgfCBCaW5hcnlPcFNvdXJjZTtcbi8qKiBWYWxpZCBvcGVyYXRpb25zIGZvciBjb21iaW5pbmcgc291cmNlcy4gKi9cbmV4cG9ydCB0eXBlIFNvdXJjZU9wID0gXCImXCIgfCBcInxcIjtcblxuLyoqIEEgdGFnIGFzIGEgc291cmNlIG9mIGRhdGEuICovXG5leHBvcnQgaW50ZXJmYWNlIFRhZ1NvdXJjZSB7XG4gICAgdHlwZTogXCJ0YWdcIjtcbiAgICAvKiogVGhlIHRhZyB0byBzb3VyY2UgZnJvbS4gKi9cbiAgICB0YWc6IHN0cmluZztcbn1cblxuLyoqIEEgY3N2IGFzIGEgc291cmNlIG9mIGRhdGEuICovXG5leHBvcnQgaW50ZXJmYWNlIENzdlNvdXJjZSB7XG4gICAgdHlwZTogXCJjc3ZcIjtcbiAgICAvKiogVGhlIHBhdGggdG8gdGhlIENTViBmaWxlLiAqL1xuICAgIHBhdGg6IHN0cmluZztcbn1cblxuLyoqIEEgZm9sZGVyIHByZWZpeCBhcyBhIHNvdXJjZSBvZiBkYXRhLiAqL1xuZXhwb3J0IGludGVyZmFjZSBGb2xkZXJTb3VyY2Uge1xuICAgIHR5cGU6IFwiZm9sZGVyXCI7XG4gICAgLyoqIFRoZSBmb2xkZXIgcHJlZml4IHRvIHNvdXJjZSBmcm9tLiAqL1xuICAgIGZvbGRlcjogc3RyaW5nO1xufVxuXG4vKiogRWl0aGVyIGluY29taW5nIG9yIG91dGdvaW5nIGxpbmtzIHRvIGEgZ2l2ZW4gZmlsZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlua1NvdXJjZSB7XG4gICAgdHlwZTogXCJsaW5rXCI7XG4gICAgLyoqIFRoZSBmaWxlIHRvIGxvb2sgZm9yIGxpbmtzIHRvL2Zyb20uICAqL1xuICAgIGZpbGU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBUaGUgZGlyZWN0aW9uIHRvIGxvb2sgLSBpZiBpbmNvbWluZywgdGhlbiBhbGwgZmlsZXMgbGlua2luZyB0byB0aGUgdGFyZ2V0IGZpbGUuIElmIG91dGdvaW5nLCB0aGVuIGFsbCBmaWxlc1xuICAgICAqIHdoaWNoIHRoZSBmaWxlIGxpbmtzIHRvLlxuICAgICAqL1xuICAgIGRpcmVjdGlvbjogXCJpbmNvbWluZ1wiIHwgXCJvdXRnb2luZ1wiO1xufVxuXG4vKiogQSBzb3VyY2Ugd2hpY2ggaXMgZXZlcnl0aGluZyBFWENFUFQgdGhlIGZpbGVzIHJldHVybmVkIGJ5IHRoZSBnaXZlbiBzb3VyY2UuICovXG5leHBvcnQgaW50ZXJmYWNlIE5lZ2F0ZWRTb3VyY2Uge1xuICAgIHR5cGU6IFwibmVnYXRlXCI7XG4gICAgLyoqIFRoZSBzb3VyY2UgdG8gbmVnYXRlLiAqL1xuICAgIGNoaWxkOiBTb3VyY2U7XG59XG5cbi8qKiBBIHNvdXJjZSB3aGljaCB5aWVsZHMgbm90aGluZy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW1wdHlTb3VyY2Uge1xuICAgIHR5cGU6IFwiZW1wdHlcIjtcbn1cblxuLyoqIEEgc291cmNlIG1hZGUgYnkgY29tYmluaW5nIHN1YnNvdXJjZXMgd2l0aCBhIGxvZ2ljYWwgb3BlcmF0b3JzLiAqL1xuZXhwb3J0IGludGVyZmFjZSBCaW5hcnlPcFNvdXJjZSB7XG4gICAgdHlwZTogXCJiaW5hcnlvcFwiO1xuICAgIG9wOiBTb3VyY2VPcDtcbiAgICBsZWZ0OiBTb3VyY2U7XG4gICAgcmlnaHQ6IFNvdXJjZTtcbn1cblxuLyoqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIHNvdXJjZXMuICovXG5leHBvcnQgbmFtZXNwYWNlIFNvdXJjZXMge1xuICAgIC8qKiBDcmVhdGUgYSBzb3VyY2Ugd2hpY2ggc2VhcmNoZXMgZnJvbSBhIHRhZy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gdGFnKHRhZzogc3RyaW5nKTogVGFnU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0YWdcIiwgdGFnIH07XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCBmZXRjaGVzIGZyb20gYSBDU1YgZmlsZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gY3N2KHBhdGg6IHN0cmluZyk6IENzdlNvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiY3N2XCIsIHBhdGggfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIHNlYXJjaGVzIGZvciBmaWxlcyB1bmRlciBhIGZvbGRlciBwcmVmaXguICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGZvbGRlcihwcmVmaXg6IHN0cmluZyk6IEZvbGRlclNvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiZm9sZGVyXCIsIGZvbGRlcjogcHJlZml4IH07XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCBzZWFyY2hlcyBmb3IgZmlsZXMgd2hpY2ggbGluayB0by9mcm9tIGEgZ2l2ZW4gZmlsZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gbGluayhmaWxlOiBzdHJpbmcsIGluY29taW5nOiBib29sZWFuKTogTGlua1NvdXJjZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwibGlua1wiLCBmaWxlLCBkaXJlY3Rpb246IGluY29taW5nID8gXCJpbmNvbWluZ1wiIDogXCJvdXRnb2luZ1wiIH07XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCBqb2lucyB0d28gc291cmNlcyBieSBhIGxvZ2ljYWwgb3BlcmF0b3IgKGFuZC9vcikuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeU9wKGxlZnQ6IFNvdXJjZSwgb3A6IFNvdXJjZU9wLCByaWdodDogU291cmNlKTogU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJiaW5hcnlvcFwiLCBsZWZ0LCBvcCwgcmlnaHQgfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIHRha2VzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIHNvdXJjZXMuICovXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGFuZChsZWZ0OiBTb3VyY2UsIHJpZ2h0OiBTb3VyY2UpOiBTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImJpbmFyeW9wXCIsIGxlZnQsIG9wOiBcIiZcIiwgcmlnaHQgfTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGEgc291cmNlIHdoaWNoIHRha2VzIHRoZSB1bmlvbiBvZiB0d28gc291cmNlcy4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gb3IobGVmdDogU291cmNlLCByaWdodDogU291cmNlKTogU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJiaW5hcnlvcFwiLCBsZWZ0LCBvcDogXCJ8XCIsIHJpZ2h0IH07XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhIHNvdXJjZSB3aGljaCBuZWdhdGVzIHRoZSB1bmRlcmx5aW5nIHNvdXJjZS4gKi9cbiAgICBleHBvcnQgZnVuY3Rpb24gbmVnYXRlKGNoaWxkOiBTb3VyY2UpOiBOZWdhdGVkU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJuZWdhdGVcIiwgY2hpbGQgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gZW1wdHkoKTogRW1wdHlTb3VyY2Uge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVtcHR5XCIgfTtcbiAgICB9XG59XG4iLCAiaW1wb3J0IHsgRGF0ZVRpbWUsIER1cmF0aW9uIH0gZnJvbSBcImx1eG9uXCI7XG5pbXBvcnQgeyBMaXRlcmFsLCBMaW5rIH0gZnJvbSBcImRhdGEtbW9kZWwvdmFsdWVcIjtcbmltcG9ydCAqIGFzIFAgZnJvbSBcInBhcnNpbW1vblwiO1xuaW1wb3J0IHsgQmluYXJ5T3AsIEZpZWxkLCBGaWVsZHMsIExhbWJkYUZpZWxkLCBMaXN0RmllbGQsIExpdGVyYWxGaWVsZCwgT2JqZWN0RmllbGQsIFZhcmlhYmxlRmllbGQgfSBmcm9tIFwiLi9maWVsZFwiO1xuaW1wb3J0IHsgRm9sZGVyU291cmNlLCBOZWdhdGVkU291cmNlLCBTb3VyY2UsIFNvdXJjZU9wLCBTb3VyY2VzLCBUYWdTb3VyY2UsIENzdlNvdXJjZSB9IGZyb20gXCJkYXRhLWluZGV4L3NvdXJjZVwiO1xuaW1wb3J0IHsgbm9ybWFsaXplRHVyYXRpb24gfSBmcm9tIFwidXRpbC9ub3JtYWxpemVcIjtcbmltcG9ydCB7IFJlc3VsdCB9IGZyb20gXCJhcGkvcmVzdWx0XCI7XG5pbXBvcnQgZW1vamlSZWdleCBmcm9tIFwiZW1vamktcmVnZXhcIjtcblxuLyoqIEVtb2ppIHJlZ2V4IHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgZmxhZ3MuICovXG5jb25zdCBFTU9KSV9SRUdFWCA9IG5ldyBSZWdFeHAoZW1vamlSZWdleCgpLCBcIlwiKTtcblxuLyoqIFByb3ZpZGVzIGEgbG9va3VwIHRhYmxlIGZvciB1bml0IGR1cmF0aW9ucyBvZiB0aGUgZ2l2ZW4gdHlwZS4gKi9cbmV4cG9ydCBjb25zdCBEVVJBVElPTl9UWVBFUyA9IHtcbiAgICB5ZWFyOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgeWVhcnM6IDEgfSksXG4gICAgeWVhcnM6IER1cmF0aW9uLmZyb21PYmplY3QoeyB5ZWFyczogMSB9KSxcbiAgICB5cjogRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxIH0pLFxuICAgIHlyczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHllYXJzOiAxIH0pLFxuXG4gICAgbW9udGg6IER1cmF0aW9uLmZyb21PYmplY3QoeyBtb250aHM6IDEgfSksXG4gICAgbW9udGhzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiAxIH0pLFxuICAgIG1vOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbW9udGhzOiAxIH0pLFxuICAgIG1vczogRHVyYXRpb24uZnJvbU9iamVjdCh7IG1vbnRoczogMSB9KSxcblxuICAgIHdlZWs6IER1cmF0aW9uLmZyb21PYmplY3QoeyB3ZWVrczogMSB9KSxcbiAgICB3ZWVrczogRHVyYXRpb24uZnJvbU9iamVjdCh7IHdlZWtzOiAxIH0pLFxuICAgIHdrOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgd2Vla3M6IDEgfSksXG4gICAgd2tzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgd2Vla3M6IDEgfSksXG4gICAgdzogRHVyYXRpb24uZnJvbU9iamVjdCh7IHdlZWtzOiAxIH0pLFxuXG4gICAgZGF5OiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSB9KSxcbiAgICBkYXlzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSB9KSxcbiAgICBkOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgZGF5czogMSB9KSxcblxuICAgIGhvdXI6IER1cmF0aW9uLmZyb21PYmplY3QoeyBob3VyczogMSB9KSxcbiAgICBob3VyczogRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxIH0pLFxuICAgIGhyOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEgfSksXG4gICAgaHJzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgaG91cnM6IDEgfSksXG4gICAgaDogRHVyYXRpb24uZnJvbU9iamVjdCh7IGhvdXJzOiAxIH0pLFxuXG4gICAgbWludXRlOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogMSB9KSxcbiAgICBtaW51dGVzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgbWludXRlczogMSB9KSxcbiAgICBtaW46IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAxIH0pLFxuICAgIG1pbnM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAxIH0pLFxuICAgIG06IER1cmF0aW9uLmZyb21PYmplY3QoeyBtaW51dGVzOiAxIH0pLFxuXG4gICAgc2Vjb25kOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgc2Vjb25kczogMSB9KSxcbiAgICBzZWNvbmRzOiBEdXJhdGlvbi5mcm9tT2JqZWN0KHsgc2Vjb25kczogMSB9KSxcbiAgICBzZWM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBzZWNvbmRzOiAxIH0pLFxuICAgIHNlY3M6IER1cmF0aW9uLmZyb21PYmplY3QoeyBzZWNvbmRzOiAxIH0pLFxuICAgIHM6IER1cmF0aW9uLmZyb21PYmplY3QoeyBzZWNvbmRzOiAxIH0pLFxufTtcblxuLyoqIFNob3J0aGFuZCBmb3IgY29tbW9uIGRhdGVzIChyZWxhdGl2ZSB0byByaWdodCBub3cpLiAqL1xuZXhwb3J0IGNvbnN0IERBVEVfU0hPUlRIQU5EUyA9IHtcbiAgICBub3c6ICgpID0+IERhdGVUaW1lLmxvY2FsKCksXG4gICAgdG9kYXk6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuc3RhcnRPZihcImRheVwiKSxcbiAgICB5ZXN0ZXJkYXk6ICgpID0+XG4gICAgICAgIERhdGVUaW1lLmxvY2FsKClcbiAgICAgICAgICAgIC5zdGFydE9mKFwiZGF5XCIpXG4gICAgICAgICAgICAubWludXMoRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDEgfSkpLFxuICAgIHRvbW9ycm93OiAoKSA9PlxuICAgICAgICBEYXRlVGltZS5sb2NhbCgpXG4gICAgICAgICAgICAuc3RhcnRPZihcImRheVwiKVxuICAgICAgICAgICAgLnBsdXMoRHVyYXRpb24uZnJvbU9iamVjdCh7IGRheXM6IDEgfSkpLFxuICAgIHNvdzogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwid2Vla1wiKSxcbiAgICBcInN0YXJ0LW9mLXdlZWtcIjogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwid2Vla1wiKSxcbiAgICBlb3c6ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuZW5kT2YoXCJ3ZWVrXCIpLFxuICAgIFwiZW5kLW9mLXdlZWtcIjogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5lbmRPZihcIndlZWtcIiksXG4gICAgc295OiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJ5ZWFyXCIpLFxuICAgIFwic3RhcnQtb2YteWVhclwiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLnN0YXJ0T2YoXCJ5ZWFyXCIpLFxuICAgIGVveTogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5lbmRPZihcInllYXJcIiksXG4gICAgXCJlbmQtb2YteWVhclwiOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLmVuZE9mKFwieWVhclwiKSxcbiAgICBzb206ICgpID0+IERhdGVUaW1lLmxvY2FsKCkuc3RhcnRPZihcIm1vbnRoXCIpLFxuICAgIFwic3RhcnQtb2YtbW9udGhcIjogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5zdGFydE9mKFwibW9udGhcIiksXG4gICAgZW9tOiAoKSA9PiBEYXRlVGltZS5sb2NhbCgpLmVuZE9mKFwibW9udGhcIiksXG4gICAgXCJlbmQtb2YtbW9udGhcIjogKCkgPT4gRGF0ZVRpbWUubG9jYWwoKS5lbmRPZihcIm1vbnRoXCIpLFxufTtcblxuLyoqXG4gKiBLZXl3b3JkcyB3aGljaCBjYW5ub3QgYmUgdXNlZCBhcyB2YXJpYWJsZXMgZGlyZWN0bHkuIFVzZSBgcm93Ljx0aGluZz5gIGlmIGl0IGlzIGEgdmFyaWFibGUgeW91IGhhdmUgZGVmaW5lZCBhbmQgd2FudFxuICogdG8gYWNjZXNzLlxuICovXG5leHBvcnQgY29uc3QgS0VZV09SRFMgPSBbXCJGUk9NXCIsIFwiV0hFUkVcIiwgXCJMSU1JVFwiLCBcIkdST1VQXCIsIFwiRkxBVFRFTlwiXTtcblxuLy8vLy8vLy8vLy8vLy8vXG4vLyBVdGlsaXRpZXMgLy9cbi8vLy8vLy8vLy8vLy8vL1xuXG4vKiogU3BsaXQgb24gdW5lc2NhcGVkIHBpcGVzIGluIGFuIGlubmVyIGxpbmsuICovXG5mdW5jdGlvbiBzcGxpdE9uVW5lc2NhcGVkUGlwZShsaW5rOiBzdHJpbmcpOiBbc3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWRdIHtcbiAgICBsZXQgcGlwZSA9IC0xO1xuICAgIHdoaWxlICgocGlwZSA9IGxpbmsuaW5kZXhPZihcInxcIiwgcGlwZSArIDEpKSA+PSAwKSB7XG4gICAgICAgIGlmIChwaXBlID4gMCAmJiBsaW5rW3BpcGUgLSAxXSA9PSBcIlxcXFxcIikgY29udGludWU7XG4gICAgICAgIHJldHVybiBbbGluay5zdWJzdHJpbmcoMCwgcGlwZSkucmVwbGFjZSgvXFxcXFxcfC9nLCBcInxcIiksIGxpbmsuc3Vic3RyaW5nKHBpcGUgKyAxKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtsaW5rLnJlcGxhY2UoL1xcXFxcXHwvZywgXCJ8XCIpLCB1bmRlZmluZWRdO1xufVxuXG4vKiogQXR0ZW1wdCB0byBwYXJzZSB0aGUgaW5zaWRlIG9mIGEgbGluayB0byBwdWxsIG91dCBkaXNwbGF5IG5hbWUsIHN1YnBhdGgsIGV0Yy4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUlubmVyTGluayhyYXdsaW5rOiBzdHJpbmcpOiBMaW5rIHtcbiAgICBsZXQgW2xpbmssIGRpc3BsYXldID0gc3BsaXRPblVuZXNjYXBlZFBpcGUocmF3bGluayk7XG4gICAgcmV0dXJuIExpbmsuaW5mZXIobGluaywgZmFsc2UsIGRpc3BsYXkpO1xufVxuXG4vKiogQ3JlYXRlIGEgbGVmdC1hc3NvY2lhdGl2ZSBiaW5hcnkgcGFyc2VyIHdoaWNoIHBhcnNlcyB0aGUgZ2l2ZW4gc3ViLWVsZW1lbnQgYW5kIHNlcGFyYXRvci4gSGFuZGxlcyB3aGl0ZXNwYWNlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJpbmFyeVBhcnNlcjxULCBVPihcbiAgICBjaGlsZDogUC5QYXJzZXI8VD4sXG4gICAgc2VwOiBQLlBhcnNlcjxVPixcbiAgICBjb21iaW5lOiAoYTogVCwgYjogVSwgYzogVCkgPT4gVFxuKTogUC5QYXJzZXI8VD4ge1xuICAgIHJldHVybiBQLnNlcU1hcChjaGlsZCwgUC5zZXEoUC5vcHRXaGl0ZXNwYWNlLCBzZXAsIFAub3B0V2hpdGVzcGFjZSwgY2hpbGQpLm1hbnkoKSwgKGZpcnN0LCByZXN0KSA9PiB7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PSAwKSByZXR1cm4gZmlyc3Q7XG5cbiAgICAgICAgbGV0IG5vZGUgPSBjb21iaW5lKGZpcnN0LCByZXN0WzBdWzFdLCByZXN0WzBdWzNdKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IHJlc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBub2RlID0gY29tYmluZShub2RlLCByZXN0W2luZGV4XVsxXSwgcmVzdFtpbmRleF1bM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hhaW5PcHQ8VD4oYmFzZTogUC5QYXJzZXI8VD4sIC4uLmZ1bmNzOiAoKHI6IFQpID0+IFAuUGFyc2VyPFQ+KVtdKTogUC5QYXJzZXI8VD4ge1xuICAgIHJldHVybiBQLmN1c3RvbSgoc3VjY2VzcywgZmFpbHVyZSkgPT4ge1xuICAgICAgICByZXR1cm4gKGlucHV0LCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gKGJhc2UgYXMgYW55KS5fKGlucHV0LCBpKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LnN0YXR1cykgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICAgICAgZm9yIChsZXQgZnVuYyBvZiBmdW5jcykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gKGZ1bmMocmVzdWx0LnZhbHVlIGFzIFQpIGFzIGFueSkuXyhpbnB1dCwgcmVzdWx0LmluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHQuc3RhdHVzKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHByZXNzaW9uIFBhcnNpbmcgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgdHlwZSBQb3N0Zml4RnJhZ21lbnQgPVxuICAgIHwgeyB0eXBlOiBcImRvdFwiOyBmaWVsZDogc3RyaW5nIH1cbiAgICB8IHsgdHlwZTogXCJpbmRleFwiOyBmaWVsZDogRmllbGQgfVxuICAgIHwgeyB0eXBlOiBcImZ1bmN0aW9uXCI7IGZpZWxkczogRmllbGRbXSB9O1xuXG5leHBvcnQgaW50ZXJmYWNlIEV4cHJlc3Npb25MYW5ndWFnZSB7XG4gICAgbnVtYmVyOiBudW1iZXI7XG4gICAgc3RyaW5nOiBzdHJpbmc7XG4gICAgZXNjYXBlQ2hhcmFjdGVyOiBzdHJpbmc7XG4gICAgYm9vbDogYm9vbGVhbjtcbiAgICB0YWc6IHN0cmluZztcbiAgICBpZGVudGlmaWVyOiBzdHJpbmc7XG4gICAgbGluazogTGluaztcbiAgICBlbWJlZExpbms6IExpbms7XG4gICAgcm9vdERhdGU6IERhdGVUaW1lO1xuICAgIGRhdGVTaG9ydGhhbmQ6IGtleW9mIHR5cGVvZiBEQVRFX1NIT1JUSEFORFM7XG4gICAgZGF0ZTogRGF0ZVRpbWU7XG4gICAgZGF0ZVBsdXM6IERhdGVUaW1lO1xuICAgIGR1cmF0aW9uVHlwZToga2V5b2YgdHlwZW9mIERVUkFUSU9OX1RZUEVTO1xuICAgIGR1cmF0aW9uOiBEdXJhdGlvbjtcbiAgICByYXdOdWxsOiBzdHJpbmc7XG5cbiAgICBiaW5hcnlQbHVzTWludXM6IEJpbmFyeU9wO1xuICAgIGJpbmFyeU11bERpdjogQmluYXJ5T3A7XG4gICAgYmluYXJ5Q29tcGFyZU9wOiBCaW5hcnlPcDtcbiAgICBiaW5hcnlCb29sZWFuT3A6IEJpbmFyeU9wO1xuXG4gICAgLy8gU291cmNlLXJlbGF0ZWQgcGFyc2Vycy5cbiAgICB0YWdTb3VyY2U6IFRhZ1NvdXJjZTtcbiAgICBjc3ZTb3VyY2U6IENzdlNvdXJjZTtcbiAgICBmb2xkZXJTb3VyY2U6IEZvbGRlclNvdXJjZTtcbiAgICBwYXJlbnNTb3VyY2U6IFNvdXJjZTtcbiAgICBhdG9tU291cmNlOiBTb3VyY2U7XG4gICAgbGlua0luY29taW5nU291cmNlOiBTb3VyY2U7XG4gICAgbGlua091dGdvaW5nU291cmNlOiBTb3VyY2U7XG4gICAgbmVnYXRlU291cmNlOiBOZWdhdGVkU291cmNlO1xuICAgIGJpbmFyeU9wU291cmNlOiBTb3VyY2U7XG4gICAgc291cmNlOiBTb3VyY2U7XG5cbiAgICAvLyBGaWVsZC1yZWxhdGVkIHBhcnNlcnMuXG4gICAgdmFyaWFibGVGaWVsZDogVmFyaWFibGVGaWVsZDtcbiAgICBudW1iZXJGaWVsZDogTGl0ZXJhbEZpZWxkO1xuICAgIGJvb2xGaWVsZDogTGl0ZXJhbEZpZWxkO1xuICAgIHN0cmluZ0ZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgZGF0ZUZpZWxkOiBMaXRlcmFsRmllbGQ7XG4gICAgZHVyYXRpb25GaWVsZDogTGl0ZXJhbEZpZWxkO1xuICAgIGxpbmtGaWVsZDogTGl0ZXJhbEZpZWxkO1xuICAgIG51bGxGaWVsZDogTGl0ZXJhbEZpZWxkO1xuXG4gICAgbGlzdEZpZWxkOiBMaXN0RmllbGQ7XG4gICAgb2JqZWN0RmllbGQ6IE9iamVjdEZpZWxkO1xuXG4gICAgYXRvbUlubGluZUZpZWxkOiBMaXRlcmFsO1xuICAgIGlubGluZUZpZWxkTGlzdDogTGl0ZXJhbFtdO1xuICAgIGlubGluZUZpZWxkOiBMaXRlcmFsO1xuXG4gICAgbmVnYXRlZEZpZWxkOiBGaWVsZDtcbiAgICBhdG9tRmllbGQ6IEZpZWxkO1xuICAgIGluZGV4RmllbGQ6IEZpZWxkO1xuICAgIGxhbWJkYUZpZWxkOiBMYW1iZGFGaWVsZDtcblxuICAgIC8vIFBvc3RmaXggcGFyc2VycyBmb3IgZnVuY3Rpb24gY2FsbHMgJiB0aGUgbGlrZS5cbiAgICBkb3RQb3N0Zml4OiBQb3N0Zml4RnJhZ21lbnQ7XG4gICAgaW5kZXhQb3N0Zml4OiBQb3N0Zml4RnJhZ21lbnQ7XG4gICAgZnVuY3Rpb25Qb3N0Zml4OiBQb3N0Zml4RnJhZ21lbnQ7XG5cbiAgICAvLyBCaW5hcnkgb3AgcGFyc2Vycy5cbiAgICBiaW5hcnlNdWxEaXZGaWVsZDogRmllbGQ7XG4gICAgYmluYXJ5UGx1c01pbnVzRmllbGQ6IEZpZWxkO1xuICAgIGJpbmFyeUNvbXBhcmVGaWVsZDogRmllbGQ7XG4gICAgYmluYXJ5Qm9vbGVhbkZpZWxkOiBGaWVsZDtcbiAgICBiaW5hcnlPcEZpZWxkOiBGaWVsZDtcbiAgICBwYXJlbnNGaWVsZDogRmllbGQ7XG4gICAgZmllbGQ6IEZpZWxkO1xufVxuXG5leHBvcnQgY29uc3QgRVhQUkVTU0lPTiA9IFAuY3JlYXRlTGFuZ3VhZ2U8RXhwcmVzc2lvbkxhbmd1YWdlPih7XG4gICAgLy8gQSBmbG9hdGluZyBwb2ludCBudW1iZXI7IHRoZSBkZWNpbWFsIHBvaW50IGlzIG9wdGlvbmFsLlxuICAgIG51bWJlcjogcSA9PlxuICAgICAgICBQLnJlZ2V4cCgvLT9bMC05XSsoXFwuWzAtOV0rKT8vKVxuICAgICAgICAgICAgLm1hcChzdHIgPT4gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKSlcbiAgICAgICAgICAgIC5kZXNjKFwibnVtYmVyXCIpLFxuXG4gICAgLy8gQSBxdW90ZS1zdXJyb3VuZGVkIHN0cmluZyB3aGljaCBzdXBwb3J0cyBlc2NhcGUgY2hhcmFjdGVycyAoJ1xcJykuXG4gICAgc3RyaW5nOiBxID0+XG4gICAgICAgIFAuc3RyaW5nKCdcIicpXG4gICAgICAgICAgICAudGhlbihcbiAgICAgICAgICAgICAgICBQLmFsdChxLmVzY2FwZUNoYXJhY3RlciwgUC5ub25lT2YoJ1wiXFxcXCcpKVxuICAgICAgICAgICAgICAgICAgICAuYXRMZWFzdCgwKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGNoYXJzID0+IGNoYXJzLmpvaW4oXCJcIikpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc2tpcChQLnN0cmluZygnXCInKSlcbiAgICAgICAgICAgIC5kZXNjKFwic3RyaW5nXCIpLFxuXG4gICAgZXNjYXBlQ2hhcmFjdGVyOiBfID0+XG4gICAgICAgIFAuc3RyaW5nKFwiXFxcXFwiKVxuICAgICAgICAgICAgLnRoZW4oUC5hbnkpXG4gICAgICAgICAgICAubWFwKGVzY2FwZWQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBlc2NhcGluZyBhIGJhY2tzbGFzaCBvciBhIHF1b3RlLCBwYXNzIGluIG9uIGluIGVzY2FwZWQgZm9ybVxuICAgICAgICAgICAgICAgIGlmIChlc2NhcGVkID09PSAnXCInKSByZXR1cm4gJ1wiJztcbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZCA9PT0gXCJcXFxcXCIpIHJldHVybiBcIlxcXFxcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBcIlxcXFxcIiArIGVzY2FwZWQ7XG4gICAgICAgICAgICB9KSxcblxuICAgIC8vIEEgYm9vbGVhbiB0cnVlL2ZhbHNlIHZhbHVlLlxuICAgIGJvb2w6IF8gPT5cbiAgICAgICAgUC5yZWdleHAoL3RydWV8ZmFsc2V8VHJ1ZXxGYWxzZS8pXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBzdHIudG9Mb3dlckNhc2UoKSA9PSBcInRydWVcIilcbiAgICAgICAgICAgIC5kZXNjKFwiYm9vbGVhbiAoJ3RydWUnIG9yICdmYWxzZScpXCIpLFxuXG4gICAgLy8gQSB0YWcgb2YgdGhlIGZvcm0gJyNzdHVmZi9oZWxsby10aGVyZScuXG4gICAgdGFnOiBfID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIjXCIpLFxuICAgICAgICAgICAgUC5hbHQoUC5yZWdleHAoL1teXFx1MjAwMC1cXHUyMDZGXFx1MkUwMC1cXHUyRTdGJyFcIiMkJSYoKSorLC46Ozw9Pj9AXmB7fH1+XFxbXFxdXFxcXFxcc10vKS5kZXNjKFwidGV4dFwiKSkubWFueSgpLFxuICAgICAgICAgICAgKHN0YXJ0LCByZXN0KSA9PiBzdGFydCArIHJlc3Quam9pbihcIlwiKVxuICAgICAgICApLmRlc2MoXCJ0YWcgKCcjaGVsbG8vc3R1ZmYnKVwiKSxcblxuICAgIC8vIEEgdmFyaWFibGUgaWRlbnRpZmllciwgd2hpY2ggaXMgYWxwaGFudW1lcmljIGFuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIgb3IuLi4gZW1vamkuXG4gICAgaWRlbnRpZmllcjogXyA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIFAuYWx0KFAucmVnZXhwKC9cXHB7TGV0dGVyfS91KSwgUC5yZWdleHAoRU1PSklfUkVHRVgpLmRlc2MoXCJ0ZXh0XCIpKSxcbiAgICAgICAgICAgIFAuYWx0KFAucmVnZXhwKC9bMC05XFxwe0xldHRlcn1fLV0vdSksIFAucmVnZXhwKEVNT0pJX1JFR0VYKS5kZXNjKFwidGV4dFwiKSkubWFueSgpLFxuICAgICAgICAgICAgKGZpcnN0LCByZXN0KSA9PiBmaXJzdCArIHJlc3Quam9pbihcIlwiKVxuICAgICAgICApLmRlc2MoXCJ2YXJpYWJsZSBpZGVudGlmaWVyXCIpLFxuXG4gICAgLy8gQW4gT2JzaWRpYW4gbGluayBvZiB0aGUgZm9ybSBbWzxsaW5rPl1dLlxuICAgIGxpbms6IF8gPT5cbiAgICAgICAgUC5yZWdleHAoL1xcW1xcWyhbXlxcW1xcXV0qPylcXF1cXF0vdSwgMSlcbiAgICAgICAgICAgIC5tYXAobGlua0lubmVyID0+IHBhcnNlSW5uZXJMaW5rKGxpbmtJbm5lcikpXG4gICAgICAgICAgICAuZGVzYyhcImZpbGUgbGlua1wiKSxcblxuICAgIC8vIEFuIGVtYmVkZGFibGUgbGluayB3aGljaCBjYW4gc3RhcnQgd2l0aCAnIScuIFRoaXMgb3ZlcmxhcHMgd2l0aCB0aGUgbm9ybWFsIG5lZ2F0aW9uIG9wZXJhdG9yLCBzbyBpdCBpcyBvbmx5XG4gICAgLy8gcHJvdmlkZWQgZm9yIG1ldGFkYXRhIHBhcnNpbmcuXG4gICAgZW1iZWRMaW5rOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiIVwiKS5hdE1vc3QoMSksIHEubGluaywgKHAsIGwpID0+IHtcbiAgICAgICAgICAgIGlmIChwLmxlbmd0aCA+IDApIGwuZW1iZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH0pLmRlc2MoXCJmaWxlIGxpbmtcIiksXG5cbiAgICAvLyBCaW5hcnkgcGx1cyBvciBtaW51cyBvcGVyYXRvci5cbiAgICBiaW5hcnlQbHVzTWludXM6IF8gPT5cbiAgICAgICAgUC5yZWdleHAoL1xcK3wtLylcbiAgICAgICAgICAgIC5tYXAoc3RyID0+IHN0ciBhcyBCaW5hcnlPcClcbiAgICAgICAgICAgIC5kZXNjKFwiJysnIG9yICctJ1wiKSxcblxuICAgIC8vIEJpbmFyeSB0aW1lcyBvciBkaXZpZGUgb3BlcmF0b3IuXG4gICAgYmluYXJ5TXVsRGl2OiBfID0+XG4gICAgICAgIFAucmVnZXhwKC9cXCp8XFwvfCUvKVxuICAgICAgICAgICAgLm1hcChzdHIgPT4gc3RyIGFzIEJpbmFyeU9wKVxuICAgICAgICAgICAgLmRlc2MoXCInKicgb3IgJy8nIG9yICclJ1wiKSxcblxuICAgIC8vIEJpbmFyeSBjb21wYXJpc29uIG9wZXJhdG9yLlxuICAgIGJpbmFyeUNvbXBhcmVPcDogXyA9PlxuICAgICAgICBQLnJlZ2V4cCgvPj18PD18IT18Pnw8fD0vKVxuICAgICAgICAgICAgLm1hcChzdHIgPT4gc3RyIGFzIEJpbmFyeU9wKVxuICAgICAgICAgICAgLmRlc2MoXCInPj0nIG9yICc8PScgb3IgJyE9JyBvciAnPScgb3IgJz4nIG9yICc8J1wiKSxcblxuICAgIC8vIEJpbmFyeSBib29sZWFuIGNvbWJpbmF0aW9uIG9wZXJhdG9yLlxuICAgIGJpbmFyeUJvb2xlYW5PcDogXyA9PlxuICAgICAgICBQLnJlZ2V4cCgvYW5kfG9yfCZ8XFx8L2kpXG4gICAgICAgICAgICAubWFwKHN0ciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0ci50b0xvd2VyQ2FzZSgpID09IFwiYW5kXCIpIHJldHVybiBcIiZcIjtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHIudG9Mb3dlckNhc2UoKSA9PSBcIm9yXCIpIHJldHVybiBcInxcIjtcbiAgICAgICAgICAgICAgICBlbHNlIHJldHVybiBzdHIgYXMgQmluYXJ5T3A7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlc2MoXCInYW5kJyBvciAnb3InXCIpLFxuXG4gICAgLy8gQSBkYXRlIHdoaWNoIGNhbiBiZSBZWVlZLU1NWy1ERFRISDptbTpzc10uXG4gICAgcm9vdERhdGU6IF8gPT5cbiAgICAgICAgUC5zZXFNYXAoUC5yZWdleHAoL1xcZHs0fS8pLCBQLnN0cmluZyhcIi1cIiksIFAucmVnZXhwKC9cXGR7Mn0vKSwgKHllYXIsIF8sIG1vbnRoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZVRpbWUuZnJvbU9iamVjdCh7IHllYXI6IE51bWJlci5wYXJzZUludCh5ZWFyKSwgbW9udGg6IE51bWJlci5wYXJzZUludChtb250aCkgfSk7XG4gICAgICAgIH0pLmRlc2MoXCJkYXRlIGluIGZvcm1hdCBZWVlZLU1NWy1ERFRISC1NTS1TUy5NU11cIiksXG4gICAgZGF0ZVNob3J0aGFuZDogXyA9PlxuICAgICAgICBQLmFsdChcbiAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKERBVEVfU0hPUlRIQU5EUylcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aClcbiAgICAgICAgICAgICAgICAubWFwKFAuc3RyaW5nKVxuICAgICAgICApIGFzIFAuUGFyc2VyPGtleW9mIHR5cGVvZiBEQVRFX1NIT1JUSEFORFM+LFxuICAgIGRhdGU6IHEgPT5cbiAgICAgICAgY2hhaW5PcHQ8RGF0ZVRpbWU+KFxuICAgICAgICAgICAgcS5yb290RGF0ZSxcbiAgICAgICAgICAgICh5bTogRGF0ZVRpbWUpID0+XG4gICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCItXCIpLCBQLnJlZ2V4cCgvXFxkezJ9LyksIChfLCBkYXkpID0+IHltLnNldCh7IGRheTogTnVtYmVyLnBhcnNlSW50KGRheSkgfSkpLFxuICAgICAgICAgICAgKHltZDogRGF0ZVRpbWUpID0+XG4gICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCJUXCIpLCBQLnJlZ2V4cCgvXFxkezJ9LyksIChfLCBob3VyKSA9PiB5bWQuc2V0KHsgaG91cjogTnVtYmVyLnBhcnNlSW50KGhvdXIpIH0pKSxcbiAgICAgICAgICAgICh5bWRoOiBEYXRlVGltZSkgPT5cbiAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIjpcIiksIFAucmVnZXhwKC9cXGR7Mn0vKSwgKF8sIG1pbnV0ZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgeW1kaC5zZXQoeyBtaW51dGU6IE51bWJlci5wYXJzZUludChtaW51dGUpIH0pXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICh5bWRobTogRGF0ZVRpbWUpID0+XG4gICAgICAgICAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCI6XCIpLCBQLnJlZ2V4cCgvXFxkezJ9LyksIChfLCBzZWNvbmQpID0+XG4gICAgICAgICAgICAgICAgICAgIHltZGhtLnNldCh7IHNlY29uZDogTnVtYmVyLnBhcnNlSW50KHNlY29uZCkgfSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKHltZGhtczogRGF0ZVRpbWUpID0+XG4gICAgICAgICAgICAgICAgUC5hbHQoXG4gICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiLlwiKSwgUC5yZWdleHAoL1xcZHszfS8pLCAoXywgbWlsbGlzZWNvbmQpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICB5bWRobXMuc2V0KHsgbWlsbGlzZWNvbmQ6IE51bWJlci5wYXJzZUludChtaWxsaXNlY29uZCkgfSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgUC5zdWNjZWVkKHltZGhtcykgLy8gcGFzc1xuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAoZHQ6IERhdGVUaW1lKSA9PlxuICAgICAgICAgICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIitcIikub3IoUC5zdHJpbmcoXCItXCIpKSwgUC5yZWdleHAoL1xcZHsxLDJ9KDpcXGR7Mn0pPy8pLCAocG0sIGhyKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgZHQuc2V0Wm9uZShcIlVUQ1wiICsgcG0gKyBociwgeyBrZWVwTG9jYWxUaW1lOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiWlwiKSwgKCkgPT4gZHQuc2V0Wm9uZShcInV0Y1wiLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSkpLFxuICAgICAgICAgICAgICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcIltcIiksIFAucmVnZXhwKC9bMC05QS1aYS16Ky1cXC9dKy91KSwgUC5zdHJpbmcoXCJdXCIpLCAoX2EsIHpvbmUsIF9iKSA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgZHQuc2V0Wm9uZSh6b25lLCB7IGtlZXBMb2NhbFRpbWU6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgICAgLmFzc2VydCgoZHQ6IERhdGVUaW1lKSA9PiBkdC5pc1ZhbGlkLCBcInZhbGlkIGRhdGVcIilcbiAgICAgICAgICAgIC5kZXNjKFwiZGF0ZSBpbiBmb3JtYXQgWVlZWS1NTVstRERUSEgtTU0tU1MuTVNdXCIpLFxuXG4gICAgLy8gQSBkYXRlLCBwbHVzIHZhcmlvdXMgc2hvcnRoYW5kIHRpbWVzIG9mIGRheSBpdCBjb3VsZCBiZS5cbiAgICBkYXRlUGx1czogcSA9PlxuICAgICAgICBQLmFsdDxEYXRlVGltZT4oXG4gICAgICAgICAgICBxLmRhdGVTaG9ydGhhbmQubWFwKGQgPT4gREFURV9TSE9SVEhBTkRTW2RdKCkpLFxuICAgICAgICAgICAgcS5kYXRlXG4gICAgICAgICkuZGVzYyhcImRhdGUgaW4gZm9ybWF0IFlZWVktTU1bLUREVEhILU1NLVNTLk1TXSBvciBpbiBzaG9ydGhhbmRcIiksXG5cbiAgICAvLyBBIGR1cmF0aW9uIG9mIHRpbWUuXG4gICAgZHVyYXRpb25UeXBlOiBfID0+XG4gICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgLi4uT2JqZWN0LmtleXMoRFVSQVRJT05fVFlQRVMpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgLm1hcChQLnN0cmluZylcbiAgICAgICAgKSBhcyBQLlBhcnNlcjxrZXlvZiB0eXBlb2YgRFVSQVRJT05fVFlQRVM+LFxuICAgIGR1cmF0aW9uOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKHEubnVtYmVyLCBQLm9wdFdoaXRlc3BhY2UsIHEuZHVyYXRpb25UeXBlLCAoY291bnQsIF8sIHQpID0+IERVUkFUSU9OX1RZUEVTW3RdLm1hcFVuaXRzKHggPT4geCAqIGNvdW50KSlcbiAgICAgICAgICAgIC5zZXBCeTEoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKS5vcihQLm9wdFdoaXRlc3BhY2UpKVxuICAgICAgICAgICAgLm1hcChkdXJhdGlvbnMgPT4gZHVyYXRpb25zLnJlZHVjZSgocCwgYykgPT4gcC5wbHVzKGMpKSlcbiAgICAgICAgICAgIC5kZXNjKFwiZHVyYXRpb24gbGlrZSA0aHIybWluXCIpLFxuXG4gICAgLy8gQSByYXcgbnVsbCB2YWx1ZS5cbiAgICByYXdOdWxsOiBfID0+IFAuc3RyaW5nKFwibnVsbFwiKSxcblxuICAgIC8vIFNvdXJjZSBwYXJzaW5nLlxuICAgIHRhZ1NvdXJjZTogcSA9PiBxLnRhZy5tYXAodGFnID0+IFNvdXJjZXMudGFnKHRhZykpLFxuICAgIGNzdlNvdXJjZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnN0cmluZyhcImNzdihcIikuc2tpcChQLm9wdFdoaXRlc3BhY2UpLCBxLnN0cmluZywgUC5zdHJpbmcoXCIpXCIpLCAoXzEsIHBhdGgsIF8yKSA9PiBTb3VyY2VzLmNzdihwYXRoKSksXG4gICAgbGlua0luY29taW5nU291cmNlOiBxID0+IHEubGluay5tYXAobGluayA9PiBTb3VyY2VzLmxpbmsobGluay5wYXRoLCB0cnVlKSksXG4gICAgbGlua091dGdvaW5nU291cmNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwib3V0Z29pbmcoXCIpLnNraXAoUC5vcHRXaGl0ZXNwYWNlKSwgcS5saW5rLCBQLnN0cmluZyhcIilcIiksIChfMSwgbGluaywgXzIpID0+XG4gICAgICAgICAgICBTb3VyY2VzLmxpbmsobGluay5wYXRoLCBmYWxzZSlcbiAgICAgICAgKSxcbiAgICBmb2xkZXJTb3VyY2U6IHEgPT4gcS5zdHJpbmcubWFwKHN0ciA9PiBTb3VyY2VzLmZvbGRlcihzdHIpKSxcbiAgICBwYXJlbnNTb3VyY2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnN0cmluZyhcIihcIiksXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBxLnNvdXJjZSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKVwiKSxcbiAgICAgICAgICAgIChfMSwgXzIsIGZpZWxkLCBfMywgXzQpID0+IGZpZWxkXG4gICAgICAgICksXG4gICAgbmVnYXRlU291cmNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAuYWx0KFAuc3RyaW5nKFwiLVwiKSwgUC5zdHJpbmcoXCIhXCIpKSwgcS5hdG9tU291cmNlLCAoXywgc291cmNlKSA9PiBTb3VyY2VzLm5lZ2F0ZShzb3VyY2UpKSxcbiAgICBhdG9tU291cmNlOiBxID0+XG4gICAgICAgIFAuYWx0PFNvdXJjZT4oXG4gICAgICAgICAgICBxLnBhcmVuc1NvdXJjZSxcbiAgICAgICAgICAgIHEubmVnYXRlU291cmNlLFxuICAgICAgICAgICAgcS5saW5rT3V0Z29pbmdTb3VyY2UsXG4gICAgICAgICAgICBxLmxpbmtJbmNvbWluZ1NvdXJjZSxcbiAgICAgICAgICAgIHEuZm9sZGVyU291cmNlLFxuICAgICAgICAgICAgcS50YWdTb3VyY2UsXG4gICAgICAgICAgICBxLmNzdlNvdXJjZVxuICAgICAgICApLFxuICAgIGJpbmFyeU9wU291cmNlOiBxID0+XG4gICAgICAgIGNyZWF0ZUJpbmFyeVBhcnNlcihcbiAgICAgICAgICAgIHEuYXRvbVNvdXJjZSxcbiAgICAgICAgICAgIHEuYmluYXJ5Qm9vbGVhbk9wLm1hcChzID0+IHMgYXMgU291cmNlT3ApLFxuICAgICAgICAgICAgU291cmNlcy5iaW5hcnlPcFxuICAgICAgICApLFxuICAgIHNvdXJjZTogcSA9PiBxLmJpbmFyeU9wU291cmNlLFxuXG4gICAgLy8gRmllbGQgcGFyc2luZy5cbiAgICB2YXJpYWJsZUZpZWxkOiBxID0+XG4gICAgICAgIHEuaWRlbnRpZmllclxuICAgICAgICAgICAgLmNoYWluKHIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChLRVlXT1JEUy5pbmNsdWRlcyhyLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQLmZhaWwoXCJWYXJpYWJsZSBmaWVsZHMgY2Fubm90IGJlIGEga2V5d29yZCAoXCIgKyBLRVlXT1JEUy5qb2luKFwiIG9yIFwiKSArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUC5zdWNjZWVkKEZpZWxkcy52YXJpYWJsZShyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kZXNjKFwidmFyaWFibGVcIiksXG4gICAgbnVtYmVyRmllbGQ6IHEgPT4gcS5udW1iZXIubWFwKHZhbCA9PiBGaWVsZHMubGl0ZXJhbCh2YWwpKS5kZXNjKFwibnVtYmVyXCIpLFxuICAgIHN0cmluZ0ZpZWxkOiBxID0+IHEuc3RyaW5nLm1hcCh2YWwgPT4gRmllbGRzLmxpdGVyYWwodmFsKSkuZGVzYyhcInN0cmluZ1wiKSxcbiAgICBib29sRmllbGQ6IHEgPT4gcS5ib29sLm1hcCh2YWwgPT4gRmllbGRzLmxpdGVyYWwodmFsKSkuZGVzYyhcImJvb2xlYW5cIiksXG4gICAgZGF0ZUZpZWxkOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5zdHJpbmcoXCJkYXRlKFwiKSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuZGF0ZVBsdXMsXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBQLnN0cmluZyhcIilcIiksXG4gICAgICAgICAgICAocHJlZml4LCBfMSwgZGF0ZSwgXzIsIHBvc3RmaXgpID0+IEZpZWxkcy5saXRlcmFsKGRhdGUpXG4gICAgICAgICkuZGVzYyhcImRhdGVcIiksXG4gICAgZHVyYXRpb25GaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiZHVyKFwiKSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHEuZHVyYXRpb24sXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBQLnN0cmluZyhcIilcIiksXG4gICAgICAgICAgICAocHJlZml4LCBfMSwgZHVyLCBfMiwgcG9zdGZpeCkgPT4gRmllbGRzLmxpdGVyYWwoZHVyKVxuICAgICAgICApLmRlc2MoXCJkdXJhdGlvblwiKSxcbiAgICBudWxsRmllbGQ6IHEgPT4gcS5yYXdOdWxsLm1hcChfID0+IEZpZWxkcy5OVUxMKSxcbiAgICBsaW5rRmllbGQ6IHEgPT4gcS5saW5rLm1hcChmID0+IEZpZWxkcy5saXRlcmFsKGYpKSxcbiAgICBsaXN0RmllbGQ6IHEgPT5cbiAgICAgICAgcS5maWVsZFxuICAgICAgICAgICAgLnNlcEJ5KFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpXG4gICAgICAgICAgICAud3JhcChQLnN0cmluZyhcIltcIikuc2tpcChQLm9wdFdoaXRlc3BhY2UpLCBQLm9wdFdoaXRlc3BhY2UudGhlbihQLnN0cmluZyhcIl1cIikpKVxuICAgICAgICAgICAgLm1hcChsID0+IEZpZWxkcy5saXN0KGwpKVxuICAgICAgICAgICAgLmRlc2MoXCJsaXN0ICgnWzEsIDIsIDNdJylcIiksXG4gICAgb2JqZWN0RmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAocS5pZGVudGlmaWVyLm9yKHEuc3RyaW5nKSwgUC5zdHJpbmcoXCI6XCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSwgcS5maWVsZCwgKG5hbWUsIF9zZXAsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lLCB2YWx1ZSB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnNlcEJ5KFAuc3RyaW5nKFwiLFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpXG4gICAgICAgICAgICAud3JhcChQLnN0cmluZyhcIntcIikuc2tpcChQLm9wdFdoaXRlc3BhY2UpLCBQLm9wdFdoaXRlc3BhY2UudGhlbihQLnN0cmluZyhcIn1cIikpKVxuICAgICAgICAgICAgLm1hcCh2YWxzID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzOiBSZWNvcmQ8c3RyaW5nLCBGaWVsZD4gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiB2YWxzKSByZXNbZW50cnkubmFtZV0gPSBlbnRyeS52YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRzLm9iamVjdChyZXMpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5kZXNjKFwib2JqZWN0ICgneyBhOiAxLCBiOiAyIH0nKVwiKSxcblxuICAgIGF0b21JbmxpbmVGaWVsZDogcSA9PlxuICAgICAgICBQLmFsdChcbiAgICAgICAgICAgIHEuZGF0ZSxcbiAgICAgICAgICAgIHEuZHVyYXRpb24ubWFwKGQgPT4gbm9ybWFsaXplRHVyYXRpb24oZCkpLFxuICAgICAgICAgICAgcS5zdHJpbmcsXG4gICAgICAgICAgICBxLnRhZyxcbiAgICAgICAgICAgIHEuZW1iZWRMaW5rLFxuICAgICAgICAgICAgcS5ib29sLFxuICAgICAgICAgICAgcS5udW1iZXIsXG4gICAgICAgICAgICBxLnJhd051bGxcbiAgICAgICAgKSxcbiAgICBpbmxpbmVGaWVsZExpc3Q6IHEgPT4gcS5hdG9tSW5saW5lRmllbGQuc2VwQnkoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKS5sb29rYWhlYWQocS5hdG9tSW5saW5lRmllbGQpKSxcbiAgICBpbmxpbmVGaWVsZDogcSA9PlxuICAgICAgICBQLmFsdChcbiAgICAgICAgICAgIFAuc2VxTWFwKHEuYXRvbUlubGluZUZpZWxkLCBQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpLCBxLmlubGluZUZpZWxkTGlzdCwgKGYsIF9zLCBsKSA9PlxuICAgICAgICAgICAgICAgIFtmXS5jb25jYXQobClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBxLmF0b21JbmxpbmVGaWVsZFxuICAgICAgICApLFxuXG4gICAgYXRvbUZpZWxkOiBxID0+XG4gICAgICAgIFAuYWx0KFxuICAgICAgICAgICAgLy8gUGxhY2UgZW1iZWQgbGlua3MgYWJvdmUgbmVnYXRlZCBmaWVsZHMgYXMgdGhleSBhcmUgdGhlIHNwZWNpYWwgcGFyc2VyIGNhc2UgJyFbW3RoaW5nXV0nIGFuZCBhcmUgZ2VuZXJhbGx5IHVuYW1iaWdpb3VzLlxuICAgICAgICAgICAgcS5lbWJlZExpbmsubWFwKGwgPT4gRmllbGRzLmxpdGVyYWwobCkpLFxuICAgICAgICAgICAgcS5uZWdhdGVkRmllbGQsXG4gICAgICAgICAgICBxLmxpbmtGaWVsZCxcbiAgICAgICAgICAgIHEubGlzdEZpZWxkLFxuICAgICAgICAgICAgcS5vYmplY3RGaWVsZCxcbiAgICAgICAgICAgIHEubGFtYmRhRmllbGQsXG4gICAgICAgICAgICBxLnBhcmVuc0ZpZWxkLFxuICAgICAgICAgICAgcS5ib29sRmllbGQsXG4gICAgICAgICAgICBxLm51bWJlckZpZWxkLFxuICAgICAgICAgICAgcS5zdHJpbmdGaWVsZCxcbiAgICAgICAgICAgIHEuZGF0ZUZpZWxkLFxuICAgICAgICAgICAgcS5kdXJhdGlvbkZpZWxkLFxuICAgICAgICAgICAgcS5udWxsRmllbGQsXG4gICAgICAgICAgICBxLnZhcmlhYmxlRmllbGRcbiAgICAgICAgKSxcbiAgICBpbmRleEZpZWxkOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKHEuYXRvbUZpZWxkLCBQLmFsdChxLmRvdFBvc3RmaXgsIHEuaW5kZXhQb3N0Zml4LCBxLmZ1bmN0aW9uUG9zdGZpeCkubWFueSgpLCAob2JqLCBwb3N0Zml4ZXMpID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBvYmo7XG4gICAgICAgICAgICBmb3IgKGxldCBwb3N0IG9mIHBvc3RmaXhlcykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocG9zdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkb3RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEZpZWxkcy5pbmRleChyZXN1bHQsIEZpZWxkcy5saXRlcmFsKHBvc3QuZmllbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5kZXhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IEZpZWxkcy5pbmRleChyZXN1bHQsIHBvc3QuZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gRmllbGRzLmZ1bmMocmVzdWx0LCBwb3N0LmZpZWxkcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pLFxuICAgIG5lZ2F0ZWRGaWVsZDogcSA9PiBQLnNlcU1hcChQLnN0cmluZyhcIiFcIiksIHEuaW5kZXhGaWVsZCwgKF8sIGZpZWxkKSA9PiBGaWVsZHMubmVnYXRlKGZpZWxkKSkuZGVzYyhcIm5lZ2F0ZWQgZmllbGRcIiksXG4gICAgcGFyZW5zRmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBQLnN0cmluZyhcIihcIiksXG4gICAgICAgICAgICBQLm9wdFdoaXRlc3BhY2UsXG4gICAgICAgICAgICBxLmZpZWxkLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIpXCIpLFxuICAgICAgICAgICAgKF8xLCBfMiwgZmllbGQsIF8zLCBfNCkgPT4gZmllbGRcbiAgICAgICAgKSxcbiAgICBsYW1iZGFGaWVsZDogcSA9PlxuICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgIHEuaWRlbnRpZmllclxuICAgICAgICAgICAgICAgIC5zZXBCeShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKVxuICAgICAgICAgICAgICAgIC53cmFwKFAuc3RyaW5nKFwiKFwiKS50cmltKFAub3B0V2hpdGVzcGFjZSksIFAuc3RyaW5nKFwiKVwiKS50cmltKFAub3B0V2hpdGVzcGFjZSkpLFxuICAgICAgICAgICAgUC5zdHJpbmcoXCI9PlwiKS50cmltKFAub3B0V2hpdGVzcGFjZSksXG4gICAgICAgICAgICBxLmZpZWxkLFxuICAgICAgICAgICAgKGlkZW50LCBfaWdub3JlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibGFtYmRhXCIsIGFyZ3VtZW50czogaWRlbnQsIHZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG5cbiAgICBkb3RQb3N0Zml4OiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAuc3RyaW5nKFwiLlwiKSwgcS5pZGVudGlmaWVyLCAoXywgZmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiZG90XCIsIGZpZWxkOiBmaWVsZCB9O1xuICAgICAgICB9KSxcbiAgICBpbmRleFBvc3RmaXg6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5zdHJpbmcoXCJbXCIpLCBQLm9wdFdoaXRlc3BhY2UsIHEuZmllbGQsIFAub3B0V2hpdGVzcGFjZSwgUC5zdHJpbmcoXCJdXCIpLCAoXywgXzIsIGZpZWxkLCBfMywgXzQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiaW5kZXhcIiwgZmllbGQgfTtcbiAgICAgICAgfSksXG4gICAgZnVuY3Rpb25Qb3N0Zml4OiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5zdHJpbmcoXCIoXCIpLFxuICAgICAgICAgICAgUC5vcHRXaGl0ZXNwYWNlLFxuICAgICAgICAgICAgcS5maWVsZC5zZXBCeShQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKSxcbiAgICAgICAgICAgIFAub3B0V2hpdGVzcGFjZSxcbiAgICAgICAgICAgIFAuc3RyaW5nKFwiKVwiKSxcbiAgICAgICAgICAgIChfLCBfMSwgZmllbGRzLCBfMiwgXzMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImZ1bmN0aW9uXCIsIGZpZWxkcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICApLFxuXG4gICAgLy8gVGhlIHByZWNlZGVuY2UgaGllcmFyY2h5IG9mIG9wZXJhdG9ycyAtIG11bHRpcGx5L2RpdmlkZSwgYWRkL3N1YnRyYWN0LCBjb21wYXJlLCBhbmQgdGhlbiBib29sZWFuIG9wZXJhdGlvbnMuXG4gICAgYmluYXJ5TXVsRGl2RmllbGQ6IHEgPT4gY3JlYXRlQmluYXJ5UGFyc2VyKHEuaW5kZXhGaWVsZCwgcS5iaW5hcnlNdWxEaXYsIEZpZWxkcy5iaW5hcnlPcCksXG4gICAgYmluYXJ5UGx1c01pbnVzRmllbGQ6IHEgPT4gY3JlYXRlQmluYXJ5UGFyc2VyKHEuYmluYXJ5TXVsRGl2RmllbGQsIHEuYmluYXJ5UGx1c01pbnVzLCBGaWVsZHMuYmluYXJ5T3ApLFxuICAgIGJpbmFyeUNvbXBhcmVGaWVsZDogcSA9PiBjcmVhdGVCaW5hcnlQYXJzZXIocS5iaW5hcnlQbHVzTWludXNGaWVsZCwgcS5iaW5hcnlDb21wYXJlT3AsIEZpZWxkcy5iaW5hcnlPcCksXG4gICAgYmluYXJ5Qm9vbGVhbkZpZWxkOiBxID0+IGNyZWF0ZUJpbmFyeVBhcnNlcihxLmJpbmFyeUNvbXBhcmVGaWVsZCwgcS5iaW5hcnlCb29sZWFuT3AsIEZpZWxkcy5iaW5hcnlPcCksXG4gICAgYmluYXJ5T3BGaWVsZDogcSA9PiBxLmJpbmFyeUJvb2xlYW5GaWVsZCxcblxuICAgIGZpZWxkOiBxID0+IHEuYmluYXJ5T3BGaWVsZCxcbn0pO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gcGFyc2UgYSBmaWVsZCBmcm9tIHRoZSBnaXZlbiB0ZXh0LCByZXR1cm5pbmcgYSBzdHJpbmcgZXJyb3IgaWYgdGhlXG4gKiBwYXJzZSBmYWlsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZpZWxkKHRleHQ6IHN0cmluZyk6IFJlc3VsdDxGaWVsZCwgc3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5zdWNjZXNzKEVYUFJFU1NJT04uZmllbGQudHJ5UGFyc2UodGV4dCkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBSZXN1bHQuZmFpbHVyZShcIlwiICsgZXJyb3IpO1xuICAgIH1cbn1cbiIsICIvKiogUHJvdmlkZXMgYW4gQVNUIGZvciBjb21wbGV4IHF1ZXJpZXMuICovXG5pbXBvcnQgeyBTb3VyY2UgfSBmcm9tIFwiZGF0YS1pbmRleC9zb3VyY2VcIjtcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSBcImV4cHJlc3Npb24vZmllbGRcIjtcblxuLyoqIFRoZSBzdXBwb3J0ZWQgcXVlcnkgdHlwZXMgKGNvcnJlc3BvbmRpbmcgdG8gdmlldyB0eXBlcykuICovXG5leHBvcnQgdHlwZSBRdWVyeVR5cGUgPSBcImxpc3RcIiB8IFwidGFibGVcIiB8IFwidGFza1wiIHwgXCJjYWxlbmRhclwiO1xuXG4vKiogQSBzaW5nbGUtbGluZSBjb21tZW50LiAqL1xuZXhwb3J0IHR5cGUgQ29tbWVudCA9IHN0cmluZztcblxuLyoqIEZpZWxkcyB1c2VkIGluIHRoZSBxdWVyeSBwb3J0aW9uLiAqL1xuZXhwb3J0IGludGVyZmFjZSBOYW1lZEZpZWxkIHtcbiAgICAvKiogVGhlIGVmZmVjdGl2ZSBuYW1lIG9mIHRoaXMgZmllbGQuICovXG4gICAgbmFtZTogc3RyaW5nO1xuICAgIC8qKiBUaGUgdmFsdWUgb2YgdGhpcyBmaWVsZC4gKi9cbiAgICBmaWVsZDogRmllbGQ7XG59XG5cbi8qKiBBIHF1ZXJ5IHNvcnQgYnkgZmllbGQsIGZvciBkZXRlcm1pbmluZyBzb3J0IG9yZGVyLiAqL1xuZXhwb3J0IGludGVyZmFjZSBRdWVyeVNvcnRCeSB7XG4gICAgLyoqIFRoZSBmaWVsZCB0byBzb3J0IG9uLiAqL1xuICAgIGZpZWxkOiBGaWVsZDtcbiAgICAvKiogVGhlIGRpcmVjdGlvbiB0byBzb3J0IGluLiAqL1xuICAgIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiO1xufVxuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHF1aWNrbHkgY3JlYXRpbmcgZmllbGRzLiAqL1xuZXhwb3J0IG5hbWVzcGFjZSBRdWVyeUZpZWxkcyB7XG4gICAgZXhwb3J0IGZ1bmN0aW9uIG5hbWVkKG5hbWU6IHN0cmluZywgZmllbGQ6IEZpZWxkKTogTmFtZWRGaWVsZCB7XG4gICAgICAgIHJldHVybiB7IG5hbWUsIGZpZWxkIH0gYXMgTmFtZWRGaWVsZDtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gc29ydEJ5KGZpZWxkOiBGaWVsZCwgZGlyOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIpOiBRdWVyeVNvcnRCeSB7XG4gICAgICAgIHJldHVybiB7IGZpZWxkLCBkaXJlY3Rpb246IGRpciB9O1xuICAgIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gUXVlcnkgRGVmaW5pdGlvbiAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKiogQSBxdWVyeSB3aGljaCBzaG91bGQgcmVuZGVyIGEgbGlzdCBvZiBlbGVtZW50cy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTGlzdFF1ZXJ5IHtcbiAgICB0eXBlOiBcImxpc3RcIjtcbiAgICAvKiogV2hhdCBzaG91bGQgYmUgcmVuZGVyZWQgaW4gdGhlIGxpc3QuICovXG4gICAgZm9ybWF0PzogRmllbGQ7XG4gICAgLyoqIElmIHRydWUsIHNob3cgdGhlIGRlZmF1bHQgREkgZmllbGQ7IG90aGVyd2lzZSwgZG9uJ3QuICovXG4gICAgc2hvd0lkOiBib29sZWFuO1xufVxuXG4vKiogQSBxdWVyeSB3aGljaCByZW5kZXJzIGEgdGFibGUgb2YgZWxlbWVudHMuICovXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlUXVlcnkge1xuICAgIHR5cGU6IFwidGFibGVcIjtcbiAgICAvKiogVGhlIGZpZWxkcyAoY29tcHV0ZWQgb3Igb3RoZXJ3aXNlKSB0byBzZWxlY3QuICovXG4gICAgZmllbGRzOiBOYW1lZEZpZWxkW107XG4gICAgLyoqIElmIHRydWUsIHNob3cgdGhlIGRlZmF1bHQgSUQgZmllbGQ7IG90aGVyd2lzZSwgZG9uJ3QuICovXG4gICAgc2hvd0lkOiBib29sZWFuO1xufVxuXG4vKiogQSBxdWVyeSB3aGljaCByZW5kZXJzIGEgY29sbGVjdGlvbiBvZiB0YXNrcy4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGFza1F1ZXJ5IHtcbiAgICB0eXBlOiBcInRhc2tcIjtcbn1cblxuLyoqIEEgcXVlcnkgd2hpY2ggcmVuZGVycyBhIGNvbGxlY3Rpb24gb2Ygbm90ZXMgaW4gYSBjYWxlbmRhciB2aWV3LiAqL1xuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhclF1ZXJ5IHtcbiAgICB0eXBlOiBcImNhbGVuZGFyXCI7XG4gICAgLyoqIFRoZSBkYXRlIGZpZWxkIHRoYXQgd2UnbGwgYmUgZ3JvdXBpbmcgbm90ZXMgYnkgZm9yIHRoZSBjYWxlbmRhciB2aWV3ICovXG4gICAgZmllbGQ6IE5hbWVkRmllbGQ7XG59XG5cbmV4cG9ydCB0eXBlIFF1ZXJ5SGVhZGVyID0gTGlzdFF1ZXJ5IHwgVGFibGVRdWVyeSB8IFRhc2tRdWVyeSB8IENhbGVuZGFyUXVlcnk7XG5cbi8qKiBBIHN0ZXAgd2hpY2ggb25seSByZXRhaW5zIHJvd3Mgd2hvc2UgJ2NsYXVzZScgZmllbGQgaXMgdHJ1dGh5LiAqL1xuZXhwb3J0IGludGVyZmFjZSBXaGVyZVN0ZXAge1xuICAgIHR5cGU6IFwid2hlcmVcIjtcbiAgICBjbGF1c2U6IEZpZWxkO1xufVxuXG4vKiogQSBzdGVwIHdoaWNoIHNvcnRzIGFsbCBjdXJyZW50IHJvd3MgYnkgdGhlIGdpdmVuIGxpc3Qgb2Ygc29ydHMuICovXG5leHBvcnQgaW50ZXJmYWNlIFNvcnRCeVN0ZXAge1xuICAgIHR5cGU6IFwic29ydFwiO1xuICAgIGZpZWxkczogUXVlcnlTb3J0QnlbXTtcbn1cblxuLyoqIEEgc3RlcCB3aGljaCB0cnVuY2F0ZXMgdGhlIG51bWJlciBvZiByb3dzIHRvIHRoZSBnaXZlbiBhbW91bnQuICovXG5leHBvcnQgaW50ZXJmYWNlIExpbWl0U3RlcCB7XG4gICAgdHlwZTogXCJsaW1pdFwiO1xuICAgIGFtb3VudDogRmllbGQ7XG59XG5cbi8qKiBBIHN0ZXAgd2hpY2ggZmxhdHRlbnMgcm93cyBpbnRvIG11bHRpcGxlIGNoaWxkIHJvd3MuICovXG5leHBvcnQgaW50ZXJmYWNlIEZsYXR0ZW5TdGVwIHtcbiAgICB0eXBlOiBcImZsYXR0ZW5cIjtcbiAgICBmaWVsZDogTmFtZWRGaWVsZDtcbn1cblxuLyoqIEEgc3RlcCB3aGljaCBncm91cHMgcm93cyBpbnRvIGdyb3VwcyBieSB0aGUgZ2l2ZW4gZmllbGQuICovXG5leHBvcnQgaW50ZXJmYWNlIEdyb3VwU3RlcCB7XG4gICAgdHlwZTogXCJncm91cFwiO1xuICAgIGZpZWxkOiBOYW1lZEZpZWxkO1xufVxuXG4vKiogQSB2aXJ0dWFsIHN0ZXAgd2hpY2ggZXh0cmFjdHMgYW4gYXJyYXkgb2YgdmFsdWVzIGZyb20gZWFjaCByb3cuICovXG5leHBvcnQgaW50ZXJmYWNlIEV4dHJhY3RTdGVwIHtcbiAgICB0eXBlOiBcImV4dHJhY3RcIjtcbiAgICBmaWVsZHM6IFJlY29yZDxzdHJpbmcsIEZpZWxkPjtcbn1cblxuZXhwb3J0IHR5cGUgUXVlcnlPcGVyYXRpb24gPSBXaGVyZVN0ZXAgfCBTb3J0QnlTdGVwIHwgTGltaXRTdGVwIHwgRmxhdHRlblN0ZXAgfCBHcm91cFN0ZXAgfCBFeHRyYWN0U3RlcDtcblxuLyoqXG4gKiBBIHF1ZXJ5IG92ZXIgdGhlIE9ic2lkaWFuIGRhdGFiYXNlLiBRdWVyaWVzIGhhdmUgYSBzcGVjaWZpYyBhbmQgZGV0ZXJtaW5pc3RpYyBleGVjdXRpb24gb3JkZXI6XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnkge1xuICAgIC8qKiBUaGUgdmlldyB0eXBlIHRvIHJlbmRlciB0aGlzIHF1ZXJ5IGluLiAqL1xuICAgIGhlYWRlcjogUXVlcnlIZWFkZXI7XG4gICAgLyoqIFRoZSBzb3VyY2UgdGhhdCBmaWxlIGNhbmRpZGF0ZXMgd2lsbCBjb21lIGZyb20uICovXG4gICAgc291cmNlOiBTb3VyY2U7XG4gICAgLyoqIFRoZSBvcGVyYXRpb25zIHRvIGFwcGx5IHRvIHRoZSBkYXRhIHRvIHByb2R1Y2UgdGhlIGZpbmFsIHJlc3VsdCB0aGF0IHdpbGwgYmUgcmVuZGVyZWQuICovXG4gICAgb3BlcmF0aW9uczogUXVlcnlPcGVyYXRpb25bXTtcbn1cbiIsICJpbXBvcnQgeyBFWFBSRVNTSU9OIH0gZnJvbSBcImV4cHJlc3Npb24vcGFyc2VcIjtcbmltcG9ydCAqIGFzIFAgZnJvbSBcInBhcnNpbW1vblwiO1xuaW1wb3J0IHtcbiAgICBGbGF0dGVuU3RlcCxcbiAgICBHcm91cFN0ZXAsXG4gICAgTGltaXRTdGVwLFxuICAgIE5hbWVkRmllbGQsXG4gICAgUXVlcnksXG4gICAgUXVlcnlGaWVsZHMsXG4gICAgUXVlcnlIZWFkZXIsXG4gICAgUXVlcnlPcGVyYXRpb24sXG4gICAgUXVlcnlTb3J0QnksXG4gICAgUXVlcnlUeXBlLFxuICAgIFNvcnRCeVN0ZXAsXG4gICAgV2hlcmVTdGVwLFxuICAgIENvbW1lbnQsXG59IGZyb20gXCIuL3F1ZXJ5XCI7XG5pbXBvcnQgeyBTb3VyY2UsIFNvdXJjZXMgfSBmcm9tIFwiZGF0YS1pbmRleC9zb3VyY2VcIjtcbmltcG9ydCB7IERFRkFVTFRfUVVFUllfU0VUVElOR1MgfSBmcm9tIFwic2V0dGluZ3NcIjtcbmltcG9ydCB7IFJlc3VsdCB9IGZyb20gXCJhcGkvcmVzdWx0XCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFF1ZXJ5IFBhcnNpbmcgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqIFR5cGluZ3MgZm9yIHRoZSBvdXRwdXRzIG9mIGFsbCBvZiB0aGUgcGFyc2VyIGNvbWJpbmF0b3JzLiAqL1xuaW50ZXJmYWNlIFF1ZXJ5TGFuZ3VhZ2VUeXBlcyB7XG4gICAgcXVlcnlUeXBlOiBRdWVyeVR5cGU7XG4gICAgY29tbWVudDogQ29tbWVudDtcblxuICAgIGV4cGxpY2l0TmFtZWRGaWVsZDogTmFtZWRGaWVsZDtcbiAgICBuYW1lZEZpZWxkOiBOYW1lZEZpZWxkO1xuICAgIHNvcnRGaWVsZDogUXVlcnlTb3J0Qnk7XG5cbiAgICAvLyBFbnRpcmUgY2xhdXNlcyBpbiBxdWVyaWVzLlxuICAgIGhlYWRlckNsYXVzZTogUXVlcnlIZWFkZXI7XG4gICAgZnJvbUNsYXVzZTogU291cmNlO1xuICAgIHdoZXJlQ2xhdXNlOiBXaGVyZVN0ZXA7XG4gICAgc29ydEJ5Q2xhdXNlOiBTb3J0QnlTdGVwO1xuICAgIGxpbWl0Q2xhdXNlOiBMaW1pdFN0ZXA7XG4gICAgZmxhdHRlbkNsYXVzZTogRmxhdHRlblN0ZXA7XG4gICAgZ3JvdXBCeUNsYXVzZTogR3JvdXBTdGVwO1xuICAgIGNsYXVzZTogUXVlcnlPcGVyYXRpb247XG4gICAgcXVlcnk6IFF1ZXJ5O1xufVxuXG4vKiogUmV0dXJuIGEgbmV3IHBhcnNlciB3aGljaCBleGVjdXRlcyB0aGUgdW5kZXJseWluZyBwYXJzZXIgYW5kIHJldHVybnMgaXQncyByYXcgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhcHR1cmVSYXc8VD4oYmFzZTogUC5QYXJzZXI8VD4pOiBQLlBhcnNlcjxbVCwgc3RyaW5nXT4ge1xuICAgIHJldHVybiBQLmN1c3RvbSgoc3VjY2VzcywgZmFpbHVyZSkgPT4ge1xuICAgICAgICByZXR1cm4gKGlucHV0LCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gKGJhc2UgYXMgYW55KS5fKGlucHV0LCBpKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LnN0YXR1cykgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCwgeyB2YWx1ZTogW3Jlc3VsdC52YWx1ZSwgaW5wdXQuc3Vic3RyaW5nKGksIHJlc3VsdC5pbmRleCldIH0pO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG4vKiogU3RyaXAgbmV3bGluZXMgYW5kIGV4Y2VzcyB3aGl0ZXNwYWNlIG91dCBvZiB0ZXh0LiAqL1xuZnVuY3Rpb24gc3RyaXBOZXdsaW5lcyh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiB0ZXh0XG4gICAgICAgIC5zcGxpdCgvW1xcclxcbl0rLylcbiAgICAgICAgLm1hcCh0ID0+IHQudHJpbSgpKVxuICAgICAgICAuam9pbihcIlwiKTtcbn1cblxuLyoqIEdpdmVuIGBwYXJzZXJgLCByZXR1cm4gdGhlIHBhcnNlciB0aGF0IHJldHVybnMgYGlmX2VvZigpYCBpZiBFT0YgaXMgZm91bmQsXG4gKiBvdGhlcndpc2UgYHBhcnNlcmAgcHJlY2VkZWQgYnkgKG5vbi1vcHRpb25hbCkgd2hpdGVzcGFjZSAqL1xuZnVuY3Rpb24gcHJlY2VkZWRCeVdoaXRlc3BhY2VJZk5vdEVvZjxUPihpZl9lb2Y6IChfOiB1bmRlZmluZWQpID0+IFQsIHBhcnNlcjogUC5QYXJzZXI8VD4pOiBQLlBhcnNlcjxUPiB7XG4gICAgcmV0dXJuIFAuZW9mLm1hcChpZl9lb2YpLm9yKFAud2hpdGVzcGFjZS50aGVuKHBhcnNlcikpO1xufVxuXG4vKiogQSBwYXJzaW1tb24tcG93ZXJlZCBwYXJzZXItY29tYmluYXRvciBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcXVlcnkgbGFuZ3VhZ2UuICovXG5leHBvcnQgY29uc3QgUVVFUllfTEFOR1VBR0UgPSBQLmNyZWF0ZUxhbmd1YWdlPFF1ZXJ5TGFuZ3VhZ2VUeXBlcz4oe1xuICAgIC8vIFNpbXBsZSBhdG9tIHBhcnNpbmcsIGxpa2Ugd29yZHMsIGlkZW50aWZpZXJzLCBudW1iZXJzLlxuICAgIHF1ZXJ5VHlwZTogcSA9PlxuICAgICAgICBQLmFsdDxzdHJpbmc+KFAucmVnZXhwKC9UQUJMRXxMSVNUfFRBU0t8Q0FMRU5EQVIvaSkpXG4gICAgICAgICAgICAubWFwKHN0ciA9PiBzdHIudG9Mb3dlckNhc2UoKSBhcyBRdWVyeVR5cGUpXG4gICAgICAgICAgICAuZGVzYyhcInF1ZXJ5IHR5cGUgKCdUQUJMRScsICdMSVNUJywgJ1RBU0snLCBvciAnQ0FMRU5EQVInKVwiKSxcbiAgICBleHBsaWNpdE5hbWVkRmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBFWFBSRVNTSU9OLmZpZWxkLnNraXAoUC53aGl0ZXNwYWNlKSxcbiAgICAgICAgICAgIFAucmVnZXhwKC9BUy9pKS5za2lwKFAud2hpdGVzcGFjZSksXG4gICAgICAgICAgICBFWFBSRVNTSU9OLmlkZW50aWZpZXIub3IoRVhQUkVTU0lPTi5zdHJpbmcpLFxuICAgICAgICAgICAgKGZpZWxkLCBfYXMsIGlkZW50KSA9PiBRdWVyeUZpZWxkcy5uYW1lZChpZGVudCwgZmllbGQpXG4gICAgICAgICksXG4gICAgY29tbWVudDogKCkgPT5cbiAgICAgICAgUC5QYXJzZXIoKGlucHV0LCBpKSA9PiB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhIGNvbW1lbnQsIHdoaWNoIGlzIGEgbGluZSBzdGFydGluZyB3aXRoIC8vLlxuICAgICAgICAgICAgbGV0IGxpbmUgPSBpbnB1dC5zdWJzdHJpbmcoaSk7XG4gICAgICAgICAgICBpZiAoIWxpbmUuc3RhcnRzV2l0aChcIi8vXCIpKSByZXR1cm4gUC5tYWtlRmFpbHVyZShpLCBcIk5vdCBhIGNvbW1lbnRcIik7XG4gICAgICAgICAgICAvLyBUaGUgY29tbWVudCBlbmRzIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgICAgICAgICBsaW5lID0gbGluZS5zcGxpdChcIlxcblwiKVswXTtcbiAgICAgICAgICAgIGxldCBjb21tZW50ID0gbGluZS5zdWJzdHJpbmcoMikudHJpbSgpO1xuICAgICAgICAgICAgcmV0dXJuIFAubWFrZVN1Y2Nlc3MoaSArIGxpbmUubGVuZ3RoLCBjb21tZW50KTtcbiAgICAgICAgfSksXG4gICAgbmFtZWRGaWVsZDogcSA9PlxuICAgICAgICBQLmFsdDxOYW1lZEZpZWxkPihcbiAgICAgICAgICAgIHEuZXhwbGljaXROYW1lZEZpZWxkLFxuICAgICAgICAgICAgY2FwdHVyZVJhdyhFWFBSRVNTSU9OLmZpZWxkKS5tYXAoKFt2YWx1ZSwgdGV4dF0pID0+IFF1ZXJ5RmllbGRzLm5hbWVkKHN0cmlwTmV3bGluZXModGV4dCksIHZhbHVlKSlcbiAgICAgICAgKSxcbiAgICBzb3J0RmllbGQ6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBFWFBSRVNTSU9OLmZpZWxkLnNraXAoUC5vcHRXaGl0ZXNwYWNlKSxcbiAgICAgICAgICAgIFAucmVnZXhwKC9BU0NFTkRJTkd8REVTQ0VORElOR3xBU0N8REVTQy9pKS5hdE1vc3QoMSksXG4gICAgICAgICAgICAoZmllbGQsIGRpcikgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSBkaXIubGVuZ3RoID09IDAgPyBcImFzY2VuZGluZ1wiIDogZGlyWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImRlc2NcIikgZGlyZWN0aW9uID0gXCJkZXNjZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImFzY1wiKSBkaXJlY3Rpb24gPSBcImFzY2VuZGluZ1wiO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24gYXMgXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG5cbiAgICBoZWFkZXJDbGF1c2U6IHEgPT5cbiAgICAgICAgcS5xdWVyeVR5cGVcbiAgICAgICAgICAgIC5jaGFpbih0eXBlID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRhYmxlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVjZWRlZEJ5V2hpdGVzcGFjZUlmTm90RW9mKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgpID0+ICh7IHR5cGUsIGZpZWxkczogW10sIHNob3dJZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLnNlcU1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5yZWdleHAoL1dJVEhPVVRcXHMrSUQvaSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5za2lwKFAub3B0V2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdE1vc3QoMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuc2VwQnkocS5uYW1lZEZpZWxkLCBQLnN0cmluZyhcIixcIikudHJpbShQLm9wdFdoaXRlc3BhY2UpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdpdGhvdXRJZCwgZmllbGRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlLCBmaWVsZHMsIHNob3dJZDogd2l0aG91dElkLmxlbmd0aCA9PSAwIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsaXN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlY2VkZWRCeVdoaXRlc3BhY2VJZk5vdEVvZihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKSA9PiAoeyB0eXBlLCBmb3JtYXQ6IHVuZGVmaW5lZCwgc2hvd0lkOiB0cnVlIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQLnJlZ2V4cCgvV0lUSE9VVFxccytJRC9pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNraXAoUC5vcHRXaGl0ZXNwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0TW9zdCgxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRVhQUkVTU0lPTi5maWVsZC5hdE1vc3QoMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3aXRob3V0SWQsIGZvcm1hdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogZm9ybWF0Lmxlbmd0aCA9PSAxID8gZm9ybWF0WzBdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dJZDogd2l0aG91dElkLmxlbmd0aCA9PSAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0YXNrXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUC5zdWNjZWVkKHsgdHlwZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNhbGVuZGFyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUC53aGl0ZXNwYWNlLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5zZXFNYXAocS5uYW1lZEZpZWxkLCBmaWVsZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0lkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gYXMgUXVlcnlIZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUC5mYWlsKGBVbnJlY29nbml6ZWQgcXVlcnkgdHlwZSAnJHt0eXBlfSdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRlc2MoXCJUQUJMRSBvciBMSVNUIG9yIFRBU0sgb3IgQ0FMRU5EQVJcIiksXG4gICAgZnJvbUNsYXVzZTogcSA9PiBQLnNlcU1hcChQLnJlZ2V4cCgvRlJPTS9pKSwgUC53aGl0ZXNwYWNlLCBFWFBSRVNTSU9OLnNvdXJjZSwgKF8xLCBfMiwgc291cmNlKSA9PiBzb3VyY2UpLFxuICAgIHdoZXJlQ2xhdXNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFAucmVnZXhwKC9XSEVSRS9pKSwgUC53aGl0ZXNwYWNlLCBFWFBSRVNTSU9OLmZpZWxkLCAod2hlcmUsIF8sIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIndoZXJlXCIsIGNsYXVzZTogZmllbGQgfSBhcyBXaGVyZVN0ZXA7XG4gICAgICAgIH0pLmRlc2MoXCJXSEVSRSA8ZXhwcmVzc2lvbj5cIiksXG4gICAgc29ydEJ5Q2xhdXNlOiBxID0+XG4gICAgICAgIFAuc2VxTWFwKFxuICAgICAgICAgICAgUC5yZWdleHAoL1NPUlQvaSksXG4gICAgICAgICAgICBQLndoaXRlc3BhY2UsXG4gICAgICAgICAgICBxLnNvcnRGaWVsZC5zZXBCeTEoUC5zdHJpbmcoXCIsXCIpLnRyaW0oUC5vcHRXaGl0ZXNwYWNlKSksXG4gICAgICAgICAgICAoc29ydCwgXzEsIGZpZWxkcykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwic29ydFwiLCBmaWVsZHMgfSBhcyBTb3J0QnlTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICApLmRlc2MoXCJTT1JUIGZpZWxkIFtBU0MvREVTQ11cIiksXG4gICAgbGltaXRDbGF1c2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5yZWdleHAoL0xJTUlUL2kpLCBQLndoaXRlc3BhY2UsIEVYUFJFU1NJT04uZmllbGQsIChsaW1pdCwgXzEsIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImxpbWl0XCIsIGFtb3VudDogZmllbGQgfSBhcyBMaW1pdFN0ZXA7XG4gICAgICAgIH0pLmRlc2MoXCJMSU1JVCA8dmFsdWU+XCIpLFxuICAgIGZsYXR0ZW5DbGF1c2U6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoUC5yZWdleHAoL0ZMQVRURU4vaSkuc2tpcChQLndoaXRlc3BhY2UpLCBxLm5hbWVkRmllbGQsIChfLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJmbGF0dGVuXCIsIGZpZWxkIH0gYXMgRmxhdHRlblN0ZXA7XG4gICAgICAgIH0pLmRlc2MoXCJGTEFUVEVOIDx2YWx1ZT4gW0FTIDxuYW1lPl1cIiksXG4gICAgZ3JvdXBCeUNsYXVzZTogcSA9PlxuICAgICAgICBQLnNlcU1hcChQLnJlZ2V4cCgvR1JPVVAgQlkvaSkuc2tpcChQLndoaXRlc3BhY2UpLCBxLm5hbWVkRmllbGQsIChfLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJncm91cFwiLCBmaWVsZCB9IGFzIEdyb3VwU3RlcDtcbiAgICAgICAgfSkuZGVzYyhcIkdST1VQIEJZIDx2YWx1ZT4gW0FTIDxuYW1lPl1cIiksXG4gICAgLy8gRnVsbCBxdWVyeSBwYXJzaW5nLlxuICAgIGNsYXVzZTogcSA9PiBQLmFsdChxLmZyb21DbGF1c2UsIHEud2hlcmVDbGF1c2UsIHEuc29ydEJ5Q2xhdXNlLCBxLmxpbWl0Q2xhdXNlLCBxLmdyb3VwQnlDbGF1c2UsIHEuZmxhdHRlbkNsYXVzZSksXG4gICAgcXVlcnk6IHEgPT5cbiAgICAgICAgUC5zZXFNYXAoXG4gICAgICAgICAgICBxLmhlYWRlckNsYXVzZS50cmltKG9wdGlvbmFsV2hpdGVzcGFjZU9yQ29tbWVudCksXG4gICAgICAgICAgICBxLmZyb21DbGF1c2UudHJpbShvcHRpb25hbFdoaXRlc3BhY2VPckNvbW1lbnQpLmF0TW9zdCgxKSxcbiAgICAgICAgICAgIHEuY2xhdXNlLnRyaW0ob3B0aW9uYWxXaGl0ZXNwYWNlT3JDb21tZW50KS5tYW55KCksXG4gICAgICAgICAgICAoaGVhZGVyLCBmcm9tLCBjbGF1c2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGZyb20ubGVuZ3RoID09IDAgPyBTb3VyY2VzLmZvbGRlcihcIlwiKSA6IGZyb21bMF0sXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnM6IGNsYXVzZXMsXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzOiBERUZBVUxUX1FVRVJZX1NFVFRJTkdTLFxuICAgICAgICAgICAgICAgIH0gYXMgUXVlcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICksXG59KTtcblxuLyoqXG4gKiBBIHBhcnNlciBmb3Igb3B0aW9uYWwgd2hpdGVzcGFjZSBvciBjb21tZW50cy4gVGhpcyBpcyB1c2VkIHRvIGV4Y2x1ZGUgd2hpdGVzcGFjZSBhbmQgY29tbWVudHMgZnJvbSBvdGhlciBwYXJzZXJzLlxuICovXG5jb25zdCBvcHRpb25hbFdoaXRlc3BhY2VPckNvbW1lbnQ6IFAuUGFyc2VyPHN0cmluZz4gPSBQLmFsdChQLndoaXRlc3BhY2UsIFFVRVJZX0xBTkdVQUdFLmNvbW1lbnQpXG4gICAgLm1hbnkoKSAvLyBVc2UgbWFueSgpIHNpbmNlIHRoZXJlIG1heSBiZSB6ZXJvIHdoaXRlc3BhY2VzIG9yIGNvbW1lbnRzLlxuICAgIC8vIFRyYW5zZm9ybSB0aGUgbWFueSB0byBhIHNpbmdsZSByZXN1bHQuXG4gICAgLm1hcChhcnIgPT4gYXJyLmpvaW4oXCJcIikpO1xuXG4vKipcbiAqIEF0dGVtcHQgdG8gcGFyc2UgYSBxdWVyeSBmcm9tIHRoZSBnaXZlbiBxdWVyeSB0ZXh0LCByZXR1cm5pbmcgYSBzdHJpbmcgZXJyb3JcbiAqIGlmIHRoZSBwYXJzZSBmYWlsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVF1ZXJ5KHRleHQ6IHN0cmluZyk6IFJlc3VsdDxRdWVyeSwgc3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gUVVFUllfTEFOR1VBR0UucXVlcnkudHJ5UGFyc2UodGV4dCk7XG4gICAgICAgIHJldHVybiBSZXN1bHQuc3VjY2VzcyhxdWVyeSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFJlc3VsdC5mYWlsdXJlKFwiXCIgKyBlcnJvcik7XG4gICAgfVxufVxuIiwgIi8vIEJhc2ljIEFQSSB0eXBlLlxuZXhwb3J0IHR5cGUgeyBEYXRhdmlld0FwaSB9IGZyb20gXCJhcGkvcGx1Z2luLWFwaVwiO1xuXG4vLyBDb3JlIERhdGF2aWV3IHR5cGVzLlxuZXhwb3J0IHR5cGUgeyBEYXRlVGltZSwgRHVyYXRpb24gfSBmcm9tIFwibHV4b25cIjtcbmV4cG9ydCB0eXBlIHtcbiAgICBMaW5rLFxuICAgIERhdGFPYmplY3QsXG4gICAgTGl0ZXJhbFR5cGUsXG4gICAgTGl0ZXJhbCxcbiAgICBMaXRlcmFsUmVwcixcbiAgICBXcmFwcGVkTGl0ZXJhbCxcbiAgICBMaXRlcmFsV3JhcHBlcixcbiAgICBXaWRnZXQsXG59IGZyb20gXCJkYXRhLW1vZGVsL3ZhbHVlXCI7XG5cbmV4cG9ydCB0eXBlIHsgUmVzdWx0LCBTdWNjZXNzLCBGYWlsdXJlIH0gZnJvbSBcImFwaS9yZXN1bHRcIjtcbmV4cG9ydCB0eXBlIHsgRGF0YUFycmF5IH0gZnJvbSBcImFwaS9kYXRhLWFycmF5XCI7XG5cbi8vIERhdGF2aWV3IEluZGV4LlxuZXhwb3J0IHR5cGUgeyBMaXN0SXRlbSwgUGFnZU1ldGFkYXRhIH0gZnJvbSBcImRhdGEtbW9kZWwvbWFya2Rvd25cIjtcbmV4cG9ydCB0eXBlIHsgRnVsbEluZGV4LCBQcmVmaXhJbmRleCwgSW5kZXhNYXAgfSBmcm9tIFwiZGF0YS1pbmRleC9pbmRleFwiO1xuXG4vLyBTZXJpYWxpemVkIHR5cGVzIHdoaWNoIGRlc2NyaWJlIGFsbCBvdXRwdXRzIG9mIHNlcmlhbGl6YXRpb24uXG5leHBvcnQgdHlwZSB7IFNNYXJrZG93blBhZ2UsIFNMaXN0RW50cnksIFNUYXNrIH0gZnJvbSBcImRhdGEtbW9kZWwvc2VyaWFsaXplZC9tYXJrZG93blwiO1xuXG4vLyBVc2VmdWwgdXRpbGl0aWVzIGZvciBkaXJlY3RseSB1c2luZyBkYXRhdmlldyBwYXJzZXJzLlxuZXhwb3J0IHtcbiAgICBEVVJBVElPTl9UWVBFUyxcbiAgICBEQVRFX1NIT1JUSEFORFMsXG4gICAgS0VZV09SRFMsXG4gICAgRXhwcmVzc2lvbkxhbmd1YWdlLFxuICAgIEVYUFJFU1NJT04sXG4gICAgcGFyc2VGaWVsZCxcbn0gZnJvbSBcImV4cHJlc3Npb24vcGFyc2VcIjtcbmV4cG9ydCB7IFFVRVJZX0xBTkdVQUdFIH0gZnJvbSBcInF1ZXJ5L3BhcnNlXCI7XG5leHBvcnQgeyBRdWVyeSB9IGZyb20gXCJxdWVyeS9xdWVyeVwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSW1wbGVtZW50YXRpb24gLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmltcG9ydCB0eXBlIHsgRGF0YXZpZXdBcGkgfSBmcm9tIFwiYXBpL3BsdWdpbi1hcGlcIjtcblxuaW1wb3J0IFwib2JzaWRpYW5cIjtcbmltcG9ydCB0eXBlIHsgQXBwIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zLlxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgRGF0YXZpZXcgQVBJIGZyb20gdGhlIGFwcCBpZiBwcm92aWRlZDsgaWYgbm90LCBpdCBpcyBpbmZlcnJlZCBmcm9tIHRoZSBnbG9iYWwgQVBJIG9iamVjdCBpbnN0YWxsZWRcbiAqIG9uIHRoZSB3aW5kb3cuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRBUEkgPSAoYXBwPzogQXBwKTogRGF0YXZpZXdBcGkgfCB1bmRlZmluZWQgPT4ge1xuICAgIGlmIChhcHApIHJldHVybiBhcHAucGx1Z2lucy5wbHVnaW5zLmRhdGF2aWV3Py5hcGk7XG4gICAgZWxzZSByZXR1cm4gd2luZG93LkRhdGF2aWV3QVBJO1xufTtcblxuLyoqIERldGVybWluZSBpZiBEYXRhdmlldyBpcyBlbmFibGVkIGluIHRoZSBnaXZlbiBhcHBsaWNhdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBpc1BsdWdpbkVuYWJsZWQgPSAoYXBwOiBBcHApID0+IGFwcC5wbHVnaW5zLmVuYWJsZWRQbHVnaW5zLmhhcyhcImRhdGF2aWV3XCIpO1xuIiwgIi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAyMSAqL1xuXG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG52YXIgSUNBTDtcbihmdW5jdGlvbigpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gQ29tbW9uSlMsIHdoZXJlIGV4cG9ydHMgbWF5IGJlIGRpZmZlcmVudCBlYWNoIHRpbWUuXG4gICAgSUNBTCA9IG1vZHVsZS5leHBvcnRzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MU2NyaXB0RWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ25vTW9kdWxlJyBpbiBIVE1MU2NyaXB0RWxlbWVudC5wcm90b3R5cGUpIHtcbiAgICAvLyBVbnRpbCB3ZSB1c2UgRVM2IGV4cG9ydHMsIHVzaW5nIDxzY3JpcHQgdHlwZT1cIm1vZHVsZVwiPiB3ZSBkZWZpbmUgSUNBTCBvbiB0aGUgd2luZG93IGdsb2JhbC5cbiAgICB3aW5kb3cuSUNBTCA9IElDQUwgPSB7fTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgSUNBTCAhPT0gJ29iamVjdCcpIHtcbiAgICBJQ0FMID0ge307XG4gIH1cbn0pKCk7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuLyoqXG4gKiBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgYmVmb3JlIGlDYWxlbmRhciBsaW5lIGZvbGRpbmcgc2hvdWxkIG9jY3VyXG4gKiBAdHlwZSB7TnVtYmVyfVxuICogQGRlZmF1bHQgNzVcbiAqL1xuSUNBTC5mb2xkTGVuZ3RoID0gNzU7XG5cblxuLyoqXG4gKiBUaGUgY2hhcmFjdGVyKHMpIHRvIGJlIHVzZWQgZm9yIGEgbmV3bGluZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgcHJvdmlkZWQgYnlcbiAqIHJmYzU1NDUuXG4gKiBAdHlwZSB7U3RyaW5nfVxuICogQGRlZmF1bHQgXCJcXHJcXG5cIlxuICovXG5JQ0FMLm5ld0xpbmVDaGFyID0gJ1xcclxcbic7XG5cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb25zIHVzZWQgaW4gdmFyaW91cyBwbGFjZXMgd2l0aGluIGljYWwuanNcbiAqIEBuYW1lc3BhY2VcbiAqL1xuSUNBTC5oZWxwZXJzID0ge1xuICAvKipcbiAgICogQ29tcGlsZXMgYSBsaXN0IG9mIGFsbCByZWZlcmVuY2VkIFRaSURzIGluIGFsbCBzdWJjb21wb25lbnRzIGFuZFxuICAgKiByZW1vdmVzIGFueSBleHRyYSBWVElNRVpPTkUgc3ViY29tcG9uZW50cy4gSW4gYWRkaXRpb24sIGlmIGFueSBUWklEc1xuICAgKiBhcmUgcmVmZXJlbmNlZCBieSBhIGNvbXBvbmVudCwgYnV0IGEgVlRJTUVaT05FIGRvZXMgbm90IGV4aXN0LFxuICAgKiBhbiBhdHRlbXB0IHdpbGwgYmUgbWFkZSB0byBnZW5lcmF0ZSBhIFZUSU1FWk9ORSB1c2luZyBJQ0FMLlRpbWV6b25lU2VydmljZS5cbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gdmNhbCAgICAgVGhlIHRvcC1sZXZlbCBWQ0FMRU5EQVIgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtJQ0FMLkNvbXBvbmVudH0gICAgICAgICBUaGUgSUNBTC5Db21wb25lbnQgdGhhdCB3YXMgcGFzc2VkIGluLlxuICAgKi9cbiAgdXBkYXRlVGltZXpvbmVzOiBmdW5jdGlvbih2Y2FsKSB7XG4gICAgdmFyIGFsbHN1YnMsIHByb3BlcnRpZXMsIHZ0aW1lem9uZXMsIHJlcVR6aWQsIGksIHR6aWQ7XG5cbiAgICBpZiAoIXZjYWwgfHwgdmNhbC5uYW1lICE9PSBcInZjYWxlbmRhclwiKSB7XG4gICAgICAvL25vdCBhIHRvcC1sZXZlbCB2Y2FsZW5kYXIgY29tcG9uZW50XG4gICAgICByZXR1cm4gdmNhbDtcbiAgICB9XG5cbiAgICAvL1N0b3JlIHZ0aW1lem9uZSBzdWJjb21wb25lbnRzIGluIGFuIG9iamVjdCByZWZlcmVuY2UgYnkgdHppZC5cbiAgICAvL1N0b3JlIHByb3BlcnRpZXMgZnJvbSBldmVyeXRoaW5nIGVsc2UgaW4gYW5vdGhlciBhcnJheVxuICAgIGFsbHN1YnMgPSB2Y2FsLmdldEFsbFN1YmNvbXBvbmVudHMoKTtcbiAgICBwcm9wZXJ0aWVzID0gW107XG4gICAgdnRpbWV6b25lcyA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBhbGxzdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWxsc3Vic1tpXS5uYW1lID09PSBcInZ0aW1lem9uZVwiKSB7XG4gICAgICAgIHR6aWQgPSBhbGxzdWJzW2ldLmdldEZpcnN0UHJvcGVydHkoXCJ0emlkXCIpLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgdnRpbWV6b25lc1t0emlkXSA9IGFsbHN1YnNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcy5jb25jYXQoYWxsc3Vic1tpXS5nZXRBbGxQcm9wZXJ0aWVzKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vY3JlYXRlIGFuIG9iamVjdCB3aXRoIG9uZSBlbnRyeSBmb3IgZWFjaCByZXF1aXJlZCB0elxuICAgIHJlcVR6aWQgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCh0emlkID0gcHJvcGVydGllc1tpXS5nZXRQYXJhbWV0ZXIoXCJ0emlkXCIpKSkge1xuICAgICAgICByZXFUemlkW3R6aWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL2RlbGV0ZSBhbnkgdnRpbWV6b25lcyB0aGF0IGFyZSBub3Qgb24gdGhlIHJlcVR6aWQgbGlzdC5cbiAgICBmb3IgKGkgaW4gdnRpbWV6b25lcykge1xuICAgICAgaWYgKHZ0aW1lem9uZXMuaGFzT3duUHJvcGVydHkoaSkgJiYgIXJlcVR6aWRbaV0pIHtcbiAgICAgICAgdmNhbC5yZW1vdmVTdWJjb21wb25lbnQodnRpbWV6b25lc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9jcmVhdGUgYW55IG1pc3NpbmcsIGJ1dCByZWdpc3RlcmVkIHRpbWV6b25lc1xuICAgIGZvciAoaSBpbiByZXFUemlkKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHJlcVR6aWQuaGFzT3duUHJvcGVydHkoaSkgJiZcbiAgICAgICAgIXZ0aW1lem9uZXNbaV0gJiZcbiAgICAgICAgSUNBTC5UaW1lem9uZVNlcnZpY2UuaGFzKGkpXG4gICAgICApIHtcbiAgICAgICAgdmNhbC5hZGRTdWJjb21wb25lbnQoSUNBTC5UaW1lem9uZVNlcnZpY2UuZ2V0KGkpLmNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZjYWw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdHlwZSBpcyBvZiB0aGUgbnVtYmVyIHR5cGUgYW5kIGFsc28gTmFOLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyICAgICBUaGUgbnVtYmVyIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgIFRydWUsIGlmIHRoZSBudW1iZXIgaXMgc3RyaWN0bHkgTmFOXG4gICAqL1xuICBpc1N0cmljdGx5TmFOOiBmdW5jdGlvbihudW1iZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mKG51bWJlcikgPT09ICdudW1iZXInICYmIGlzTmFOKG51bWJlcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIHN0cmluZyB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGFuIGludGVnZXIsIHdoZW4gdGhlIHZhbGlkIGlzXG4gICAqIG5vdCBhbiBpbnRlZ2VyIHRocm93cyBhIGRlY29yYXRpb24gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgIFJhdyBzdHJpbmcgaW5wdXRcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgUGFyc2VkIGludGVnZXJcbiAgICovXG4gIHN0cmljdFBhcnNlSW50OiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbnQoc3RyaW5nLCAxMCk7XG5cbiAgICBpZiAoSUNBTC5oZWxwZXJzLmlzU3RyaWN0bHlOYU4ocmVzdWx0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ291bGQgbm90IGV4dHJhY3QgaW50ZWdlciBmcm9tIFwiJyArIHN0cmluZyArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBvciByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2Ugb2YgYSBnaXZlbiB0eXBlIHdpdGggdGhlIGluaXRpYWxpemF0aW9uXG4gICAqIGRhdGEgaWYgdGhlIGRhdGEgaXMgbm90IGFscmVhZHkgYW4gaW5zdGFuY2Ugb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciB0aW1lID0gbmV3IElDQUwuVGltZSguLi4pO1xuICAgKiB2YXIgcmVzdWx0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZSh0aW1lLCBJQ0FMLlRpbWUpO1xuICAgKlxuICAgKiAocmVzdWx0IGluc3RhbmNlb2YgSUNBTC5UaW1lKVxuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIHJlc3VsdCA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUoe30sIElDQUwuVGltZSk7XG4gICAqIChyZXN1bHQgaXNudGFuY2VvZiBJQ0FMLlRpbWUpXG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgICAgICAgb2JqZWN0IGluaXRpYWxpemF0aW9uIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGUgICAgICAgb2JqZWN0IHR5cGUgKGxpa2UgSUNBTC5UaW1lKVxuICAgKiBAcmV0dXJuIHs/fSAgICAgICAgICAgICAgICBBbiBpbnN0YW5jZSBvZiB0aGUgZm91bmQgdHlwZS5cbiAgICovXG4gIGZvcm1hdENsYXNzVHlwZTogZnVuY3Rpb24gZm9ybWF0Q2xhc3NUeXBlKGRhdGEsIHR5cGUpIHtcbiAgICBpZiAodHlwZW9mKGRhdGEpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHR5cGUoZGF0YSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElkZW50aWNhbCB0byBpbmRleE9mIGJ1dCB3aWxsIG9ubHkgbWF0Y2ggdmFsdWVzIHdoZW4gdGhleSBhcmUgbm90IHByZWNlZGVkXG4gICAqIGJ5IGEgYmFja3NsYXNoIGNoYXJhY3Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAgICAgICAgIFN0cmluZyB0byBzZWFyY2hcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlYXJjaCAgICAgICAgIFZhbHVlIHRvIGxvb2sgZm9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgICAgICAgICAgICBTdGFydCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgVGhlIHBvc2l0aW9uLCBvciAtMSBpZiBub3QgZm91bmRcbiAgICovXG4gIHVuZXNjYXBlZEluZGV4T2Y6IGZ1bmN0aW9uKGJ1ZmZlciwgc2VhcmNoLCBwb3MpIHtcbiAgICB3aGlsZSAoKHBvcyA9IGJ1ZmZlci5pbmRleE9mKHNlYXJjaCwgcG9zKSkgIT09IC0xKSB7XG4gICAgICBpZiAocG9zID4gMCAmJiBidWZmZXJbcG9zIC0gMV0gPT09ICdcXFxcJykge1xuICAgICAgICBwb3MgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZCB0aGUgaW5kZXggZm9yIGluc2VydGlvbiB1c2luZyBiaW5hcnkgc2VhcmNoLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBsaXN0ICAgICAgICAgICAgVGhlIGxpc3QgdG8gc2VhcmNoXG4gICAqIEBwYXJhbSB7P30gc2Vla1ZhbCAgICAgICAgICAgICBUaGUgdmFsdWUgdG8gaW5zZXJ0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oPyw/KX0gY21wZnVuYyBUaGUgY29tcGFyaXNvbiBmdW5jLCB0aGF0IGNhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wYXJlIHR3byBzZWVrVmFsc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgVGhlIGluc2VydCBwb3NpdGlvblxuICAgKi9cbiAgYmluc2VhcmNoSW5zZXJ0OiBmdW5jdGlvbihsaXN0LCBzZWVrVmFsLCBjbXBmdW5jKSB7XG4gICAgaWYgKCFsaXN0Lmxlbmd0aClcbiAgICAgIHJldHVybiAwO1xuXG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBsaXN0Lmxlbmd0aCAtIDEsXG4gICAgICAgIG1pZCwgY21wdmFsO1xuXG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICBtaWQgPSBsb3cgKyBNYXRoLmZsb29yKChoaWdoIC0gbG93KSAvIDIpO1xuICAgICAgY21wdmFsID0gY21wZnVuYyhzZWVrVmFsLCBsaXN0W21pZF0pO1xuXG4gICAgICBpZiAoY21wdmFsIDwgMClcbiAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICBlbHNlIGlmIChjbXB2YWwgPiAwKVxuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoY21wdmFsIDwgMClcbiAgICAgIHJldHVybiBtaWQ7IC8vIGluc2VydGlvbiBpcyBkaXNwbGFjaW5nLCBzbyB1c2UgbWlkIG91dHJpZ2h0LlxuICAgIGVsc2UgaWYgKGNtcHZhbCA+IDApXG4gICAgICByZXR1cm4gbWlkICsgMTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbWlkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgZGVidWcgb3V0cHV0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkdW1wbjogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFJQ0FMLmRlYnVnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiAoY29uc29sZSkgIT09ICd1bmRlZmluZWQnICYmICdsb2cnIGluIGNvbnNvbGUpIHtcbiAgICAgIElDQUwuaGVscGVycy5kdW1wbiA9IGZ1bmN0aW9uIGNvbnNvbGVEdW1wbihpbnB1dCkge1xuICAgICAgICBjb25zb2xlLmxvZyhpbnB1dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBJQ0FMLmhlbHBlcnMuZHVtcG4gPSBmdW5jdGlvbiBnZWNrb0R1bXBuKGlucHV0KSB7XG4gICAgICAgIGR1bXAoaW5wdXQgKyAnXFxuJyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIElDQUwuaGVscGVycy5kdW1wbihhcmd1bWVudHNbMF0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9uZSB0aGUgcGFzc2VkIG9iamVjdCBvciBwcmltaXRpdmUuIEJ5IGRlZmF1bHQgYSBzaGFsbG93IGNsb25lIHdpbGwgYmVcbiAgICogZXhlY3V0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gYVNyYyAgICAgICAgICAgIFRoZSB0aGluZyB0byBjbG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGVlcCAgICBJZiB0cnVlLCBhIGRlZXAgY2xvbmUgd2lsbCBiZSBwZXJmb3JtZWRcbiAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgVGhlIGNvcHkgb2YgdGhlIHRoaW5nXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24oYVNyYywgYURlZXApIHtcbiAgICBpZiAoIWFTcmMgfHwgdHlwZW9mIGFTcmMgIT0gXCJvYmplY3RcIikge1xuICAgICAgcmV0dXJuIGFTcmM7XG4gICAgfSBlbHNlIGlmIChhU3JjIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGFTcmMuZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKFwiY2xvbmVcIiBpbiBhU3JjKSB7XG4gICAgICByZXR1cm4gYVNyYy5jbG9uZSgpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhU3JjKSkge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhU3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyci5wdXNoKGFEZWVwID8gSUNBTC5oZWxwZXJzLmNsb25lKGFTcmNbaV0sIHRydWUpIDogYVNyY1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2JqID0ge307XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGFTcmMpIHtcbiAgICAgICAgLy8gdXNlcyBwcm90b3R5cGUgbWV0aG9kIHRvIGFsbG93IHVzZSBvZiBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFTcmMsIG5hbWUpKSB7XG4gICAgICAgICAgaWYgKGFEZWVwKSB7XG4gICAgICAgICAgICBvYmpbbmFtZV0gPSBJQ0FMLmhlbHBlcnMuY2xvbmUoYVNyY1tuYW1lXSwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtuYW1lXSA9IGFTcmNbbmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybXMgaUNhbGVuZGFyIGxpbmUgZm9sZGluZy4gQSBsaW5lIGVuZGluZyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgYW5kXG4gICAqIHRoZSBuZXh0IGxpbmUgYmVnaW5zIHdpdGggYSB3aGl0ZXNwYWNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBTVU1NQVJZOlRoaXMgbGluZSB3aWxsIGJlIGZvbGRcbiAgICogIGVkIHJpZ2h0IGluIHRoZSBtaWRkbGUgb2YgYSB3b3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYUxpbmUgICAgICBUaGUgbGluZSB0byBmb2xkXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBmb2xkZWQgbGluZVxuICAgKi9cbiAgZm9sZGxpbmU6IGZ1bmN0aW9uIGZvbGRsaW5lKGFMaW5lKSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgdmFyIGxpbmUgPSBhTGluZSB8fCBcIlwiLCBwb3MgPSAwLCBsaW5lX2xlbmd0aCA9IDA7XG4gICAgLy9wb3MgY291bnRzIHBvc2l0aW9uIGluIGxpbmUgZm9yIHRoZSBVVEYtMTYgcHJlc2VudGF0aW9uXG4gICAgLy9saW5lX2xlbmd0aCBjb3VudHMgdGhlIGJ5dGVzIGZvciB0aGUgVVRGLTggcHJlc2VudGF0aW9uXG4gICAgd2hpbGUgKGxpbmUubGVuZ3RoKSB7XG4gICAgICB2YXIgY3AgPSBsaW5lLmNvZGVQb2ludEF0KHBvcyk7XG4gICAgICBpZiAoY3AgPCAxMjgpICsrbGluZV9sZW5ndGg7XG4gICAgICBlbHNlIGlmIChjcCA8IDIwNDgpIGxpbmVfbGVuZ3RoICs9IDI7Ly9uZWVkcyAyIFVURi04IGJ5dGVzXG4gICAgICBlbHNlIGlmIChjcCA8IDY1NTM2KSBsaW5lX2xlbmd0aCArPSAzO1xuICAgICAgZWxzZSBsaW5lX2xlbmd0aCArPSA0OyAvL2NwIGlzIGxlc3MgdGhhbiAxMTE0MTEyXG4gICAgICBpZiAobGluZV9sZW5ndGggPCBJQ0FMLmZvbGRMZW5ndGggKyAxKVxuICAgICAgICBwb3MgKz0gY3AgPiA2NTUzNSA/IDIgOiAxO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBJQ0FMLm5ld0xpbmVDaGFyICsgXCIgXCIgKyBsaW5lLnN1YnN0cmluZygwLCBwb3MpO1xuICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcocG9zKTtcbiAgICAgICAgcG9zID0gbGluZV9sZW5ndGggPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnN1YnN0cihJQ0FMLm5ld0xpbmVDaGFyLmxlbmd0aCArIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQYWRzIHRoZSBnaXZlbiBzdHJpbmcgb3IgbnVtYmVyIHdpdGggemVyb3Mgc28gaXQgd2lsbCBoYXZlIGF0IGxlYXN0IHR3b1xuICAgKiBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGRhdGEgICAgVGhlIHN0cmluZyBvciBudW1iZXIgdG8gcGFkXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgICBUaGUgbnVtYmVyIHBhZGRlZCBhcyBhIHN0cmluZ1xuICAgKi9cbiAgcGFkMjogZnVuY3Rpb24gcGFkKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mKGRhdGEpICE9PSAnc3RyaW5nJykge1xuICAgICAgLy8gaGFuZGxlIGZyYWN0aW9ucy5cbiAgICAgIGlmICh0eXBlb2YoZGF0YSkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGRhdGEgPSBwYXJzZUludChkYXRhKTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBTdHJpbmcoZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuICcwMCc7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiAnMCcgKyBkYXRhO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcnVuY2F0ZXMgdGhlIGdpdmVuIG51bWJlciwgY29ycmVjdGx5IGhhbmRsaW5nIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgICAgIFRoZSBudW1iZXIgdG8gdHJ1bmNhdGVcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgVGhlIHRydW5jYXRlZCBudW1iZXJcbiAgICovXG4gIHRydW5jOiBmdW5jdGlvbiB0cnVuYyhudW1iZXIpIHtcbiAgICByZXR1cm4gKG51bWJlciA8IDAgPyBNYXRoLmNlaWwobnVtYmVyKSA6IE1hdGguZmxvb3IobnVtYmVyKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvb3ItbWFuJ3MgY3Jvc3MtYnJvd3NlciBpbmhlcml0YW5jZSBmb3IgSmF2YVNjcmlwdC4gRG9lc24ndCBzdXBwb3J0IGFsbFxuICAgKiB0aGUgZmVhdHVyZXMsIGJ1dCBlbm91Z2ggZm9yIG91ciB1c2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZSAgICAgVGhlIGJhc2UgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkICAgIFRoZSBjaGlsZCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhICAgICAgRXh0ZW5kcyB0aGUgcHJvdG90eXBlIHdpdGggZXh0cmEgcHJvcGVydGllc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBtZXRob2RzXG4gICAqL1xuICBpbmhlcml0czogZnVuY3Rpb24oYmFzZSwgY2hpbGQsIGV4dHJhKSB7XG4gICAgZnVuY3Rpb24gRigpIHt9XG4gICAgRi5wcm90b3R5cGUgPSBiYXNlLnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgRigpO1xuXG4gICAgaWYgKGV4dHJhKSB7XG4gICAgICBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGV4dHJhLCBjaGlsZC5wcm90b3R5cGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUG9vci1tYW4ncyBjcm9zcy1icm93c2VyIG9iamVjdCBleHRlbnNpb24uIERvZXNuJ3Qgc3VwcG9ydCBhbGwgdGhlXG4gICAqIGZlYXR1cmVzLCBidXQgZW5vdWdoIGZvciBvdXIgdXNhZ2UuIE5vdGUgdGhhdCB0aGUgdGFyZ2V0J3MgcHJvcGVydGllcyBhcmVcbiAgICogbm90IG92ZXJ3cml0dGVuIHdpdGggdGhlIHNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgY2hpbGQgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKHBhcmVudCwge1xuICAgKiAgIFwiYmFyXCI6IDEyM1xuICAgKiB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSAgICAgVGhlIG9iamVjdCB0byBleHRlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAgICAgVGhlIG9iamVjdCB0byBleHRlbmQgd2l0aFxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBSZXR1cm5zIHRoZSB0YXJnZXQuXG4gICAqL1xuICBleHRlbmQ6IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgdmFyIGRlc2NyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG4gICAgICBpZiAoZGVzY3IgJiYgIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG59O1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuLyoqIEBuYW1lc3BhY2UgSUNBTCAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5kZXNpZ24gPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgRlJPTV9JQ0FMX05FV0xJTkUgPSAvXFxcXFxcXFx8XFxcXDt8XFxcXCx8XFxcXFtObl0vZztcbiAgdmFyIFRPX0lDQUxfTkVXTElORSA9IC9cXFxcfDt8LHxcXG4vZztcbiAgdmFyIEZST01fVkNBUkRfTkVXTElORSA9IC9cXFxcXFxcXHxcXFxcLHxcXFxcW05uXS9nO1xuICB2YXIgVE9fVkNBUkRfTkVXTElORSA9IC9cXFxcfCx8XFxuL2c7XG5cbiAgZnVuY3Rpb24gY3JlYXRlVGV4dFR5cGUoZnJvbU5ld2xpbmUsIHRvTmV3bGluZSkge1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBtYXRjaGVzOiAvLiovLFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlLCBzdHJ1Y3R1cmVkRXNjYXBlKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlTmV3bGluZShhVmFsdWUsIGZyb21OZXdsaW5lLCBzdHJ1Y3R1cmVkRXNjYXBlKTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlLCBzdHJ1Y3R1cmVkRXNjYXBlKSB7XG4gICAgICAgIHZhciByZWdFeCA9IHRvTmV3bGluZTtcbiAgICAgICAgaWYgKHN0cnVjdHVyZWRFc2NhcGUpXG4gICAgICAgICAgcmVnRXggPSBuZXcgUmVnRXhwKHJlZ0V4LnNvdXJjZSArICd8JyArIHN0cnVjdHVyZWRFc2NhcGUpO1xuICAgICAgICByZXR1cm4gYVZhbHVlLnJlcGxhY2UocmVnRXgsIGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIHN3aXRjaCAoc3RyKSB7XG4gICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFxcXFxcXCI7XG4gICAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFw7XCI7XG4gICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgIHJldHVybiBcIlxcXFwsXCI7XG4gICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiXFxcXG5cIjtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gZGVmYXVsdCB0eXBlcyB1c2VkIG11bHRpcGxlIHRpbWVzXG4gIHZhciBERUZBVUxUX1RZUEVfVEVYVCA9IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfVEVYVF9NVUxUSSA9IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBtdWx0aVZhbHVlOiBcIixcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCA9IHsgZGVmYXVsdFR5cGU6IFwidGV4dFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfSU5URUdFUiA9IHsgZGVmYXVsdFR5cGU6IFwiaW50ZWdlclwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfREFURVRJTUVfREFURSA9IHsgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSB9O1xuICB2YXIgREVGQVVMVF9UWVBFX0RBVEVUSU1FID0geyBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1VSSSA9IHsgZGVmYXVsdFR5cGU6IFwidXJpXCIgfTtcbiAgdmFyIERFRkFVTFRfVFlQRV9VVENPRkZTRVQgPSB7IGRlZmF1bHRUeXBlOiBcInV0Yy1vZmZzZXRcIiB9O1xuICB2YXIgREVGQVVMVF9UWVBFX1JFQ1VSID0geyBkZWZhdWx0VHlwZTogXCJyZWN1clwiIH07XG4gIHZhciBERUZBVUxUX1RZUEVfREFURV9BTkRPUl9USU1FID0geyBkZWZhdWx0VHlwZTogXCJkYXRlLWFuZC1vci10aW1lXCIsIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiLCBcInRleHRcIl0gfTtcblxuICBmdW5jdGlvbiByZXBsYWNlTmV3bGluZVJlcGxhY2Uoc3RyaW5nKSB7XG4gICAgc3dpdGNoIChzdHJpbmcpIHtcbiAgICAgIGNhc2UgXCJcXFxcXFxcXFwiOlxuICAgICAgICByZXR1cm4gXCJcXFxcXCI7XG4gICAgICBjYXNlIFwiXFxcXDtcIjpcbiAgICAgICAgcmV0dXJuIFwiO1wiO1xuICAgICAgY2FzZSBcIlxcXFwsXCI6XG4gICAgICAgIHJldHVybiBcIixcIjtcbiAgICAgIGNhc2UgXCJcXFxcblwiOlxuICAgICAgY2FzZSBcIlxcXFxOXCI6XG4gICAgICAgIHJldHVybiBcIlxcblwiO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZU5ld2xpbmUodmFsdWUsIG5ld2xpbmUsIHN0cnVjdHVyZWRFc2NhcGUpIHtcbiAgICAvLyBhdm9pZCByZWdleCB3aGVuIHBvc3NpYmxlLlxuICAgIGlmICh2YWx1ZS5pbmRleE9mKCdcXFxcJykgPT09IC0xKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChzdHJ1Y3R1cmVkRXNjYXBlKVxuICAgICAgbmV3bGluZSA9IG5ldyBSZWdFeHAobmV3bGluZS5zb3VyY2UgKyAnfFxcXFxcXFxcJyArIHN0cnVjdHVyZWRFc2NhcGUpO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKG5ld2xpbmUsIHJlcGxhY2VOZXdsaW5lUmVwbGFjZSk7XG4gIH1cblxuICB2YXIgY29tbW9uUHJvcGVydGllcyA9IHtcbiAgICBcImNhdGVnb3JpZXNcIjogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgXCJ1cmxcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInZlcnNpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJ1aWRcIjogREVGQVVMVF9UWVBFX1RFWFRcbiAgfTtcblxuICB2YXIgY29tbW9uVmFsdWVzID0ge1xuICAgIFwiYm9vbGVhblwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlRSVUVcIiwgXCJGQUxTRVwiXSxcblxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKGFWYWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ1RSVUUnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY2FzZSAnRkFMU0UnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvL1RPRE86IHBhcnNlciB3YXJuaW5nXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gJ1RSVUUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnRkFMU0UnO1xuICAgICAgfVxuXG4gICAgfSxcbiAgICBmbG9hdDoge1xuICAgICAgbWF0Y2hlczogL15bKy1dP1xcZCtcXC5cXGQrJC8sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlRmxvYXQoYVZhbHVlKTtcbiAgICAgICAgaWYgKElDQUwuaGVscGVycy5pc1N0cmljdGx5TmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICAvLyBUT0RPOiBwYXJzZXIgd2FybmluZ1xuICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYVZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGludGVnZXI6IHtcbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KGFWYWx1ZSk7XG4gICAgICAgIGlmIChJQ0FMLmhlbHBlcnMuaXNTdHJpY3RseU5hTihwYXJzZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoYVZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFwidXRjLW9mZnNldFwiOiB7XG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDcpIHtcbiAgICAgICAgICAvLyBubyBzZWNvbmRzXG4gICAgICAgICAgLy8gLTA1MDBcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCAzKSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNCwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIC8vIC0wNTAwMDBcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCAzKSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNCwgMikgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDcsIDIpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIGlmIChhVmFsdWUubGVuZ3RoIDwgNikge1xuICAgICAgICAgIC8vIG5vIHNlY29uZHNcbiAgICAgICAgICAvLyAtMDU6MDBcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCAzKSArICc6JyArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMywgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2Vjb25kc1xuICAgICAgICAgIC8vIC0wNTowMDowMFxuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDMpICsgJzonICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigzLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNSwgMik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVXRjT2Zmc2V0LmZyb21TdHJpbmcoYVZhbHVlKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBpY2FsUGFyYW1zID0ge1xuICAgIC8vIEFsdGhvdWdoIHRoZSBzeW50YXggaXMgRFFVT1RFIHVyaSBEUVVPVEUsIEkgZG9uJ3QgdGhpbmsgd2Ugc2hvdWxkXG4gICAgLy8gZW5mb2NlIGFueXRoaW5nIGFzaWRlIGZyb20gaXQgYmVpbmcgYSB2YWxpZCBjb250ZW50IGxpbmUuXG4gICAgLy9cbiAgICAvLyBBdCBsZWFzdCBzb21lIHBhcmFtcyByZXF1aXJlIC0gaWYgbXVsdGkgdmFsdWVzIGFyZSB1c2VkIC0gRFFVT1RFc1xuICAgIC8vIGZvciBlYWNoIG9mIGl0cyB2YWx1ZXMgLSBlLmcuIGRlbGVnYXRlZC1mcm9tPVwidXJpMVwiLFwidXJpMlwiXG4gICAgLy8gVG8gaW5kaWNhdGUgdGhpcywgSSBpbnRyb2R1Y2VkIHRoZSBuZXcgay92IHBhaXJcbiAgICAvLyBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgICAvL1xuICAgIC8vIFwiQUxUUkVQXCI6IHsgLi4uIH0sXG5cbiAgICAvLyBDTiBqdXN0IHdhbnRzIGEgcGFyYW0tdmFsdWVcbiAgICAvLyBcIkNOXCI6IHsgLi4uIH1cblxuICAgIFwiY3V0eXBlXCI6IHtcbiAgICAgIHZhbHVlczogW1wiSU5ESVZJRFVBTFwiLCBcIkdST1VQXCIsIFwiUkVTT1VSQ0VcIiwgXCJST09NXCIsIFwiVU5LTk9XTlwiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH0sXG5cbiAgICBcImRlbGVnYXRlZC1mcm9tXCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCIsXG4gICAgICBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgICB9LFxuICAgIFwiZGVsZWdhdGVkLXRvXCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCIsXG4gICAgICBtdWx0aVZhbHVlU2VwYXJhdGVEUXVvdGU6IHRydWVcbiAgICB9LFxuICAgIC8vIFwiRElSXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgICBcImVuY29kaW5nXCI6IHtcbiAgICAgIHZhbHVlczogW1wiOEJJVFwiLCBcIkJBU0U2NFwiXVxuICAgIH0sXG4gICAgLy8gXCJGTVRUWVBFXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgICBcImZidHlwZVwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIkZSRUVcIiwgXCJCVVNZXCIsIFwiQlVTWS1VTkFWQUlMQUJMRVwiLCBcIkJVU1ktVEVOVEFUSVZFXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfSxcbiAgICAvLyBcIkxBTkdVQUdFXCI6IHsgLi4uIH0sIC8vIFNlZSBBTFRSRVBcbiAgICBcIm1lbWJlclwiOiB7XG4gICAgICB2YWx1ZVR5cGU6IFwiY2FsLWFkZHJlc3NcIixcbiAgICAgIG11bHRpVmFsdWU6IFwiLFwiLFxuICAgICAgbXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlOiB0cnVlXG4gICAgfSxcbiAgICBcInBhcnRzdGF0XCI6IHtcbiAgICAgIC8vIFRPRE8gVGhlc2UgdmFsdWVzIGFyZSBhY3R1YWxseSBkaWZmZXJlbnQgcGVyLWNvbXBvbmVudFxuICAgICAgdmFsdWVzOiBbXCJORUVEUy1BQ1RJT05cIiwgXCJBQ0NFUFRFRFwiLCBcIkRFQ0xJTkVEXCIsIFwiVEVOVEFUSVZFXCIsXG4gICAgICAgICAgICAgICBcIkRFTEVHQVRFRFwiLCBcIkNPTVBMRVRFRFwiLCBcIklOLVBST0NFU1NcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9LFxuICAgIFwicmFuZ2VcIjoge1xuICAgICAgdmFsdWVzOiBbXCJUSElTQU5ERlVUVVJFXCJdXG4gICAgfSxcbiAgICBcInJlbGF0ZWRcIjoge1xuICAgICAgdmFsdWVzOiBbXCJTVEFSVFwiLCBcIkVORFwiXVxuICAgIH0sXG4gICAgXCJyZWx0eXBlXCI6IHtcbiAgICAgIHZhbHVlczogW1wiUEFSRU5UXCIsIFwiQ0hJTERcIiwgXCJTSUJMSU5HXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfSxcbiAgICBcInJvbGVcIjoge1xuICAgICAgdmFsdWVzOiBbXCJSRVEtUEFSVElDSVBBTlRcIiwgXCJDSEFJUlwiLFxuICAgICAgICAgICAgICAgXCJPUFQtUEFSVElDSVBBTlRcIiwgXCJOT04tUEFSVElDSVBBTlRcIl0sXG4gICAgICBhbGxvd1hOYW1lOiB0cnVlLFxuICAgICAgYWxsb3dJYW5hVG9rZW46IHRydWVcbiAgICB9LFxuICAgIFwicnN2cFwiOiB7XG4gICAgICB2YWx1ZXM6IFtcIlRSVUVcIiwgXCJGQUxTRVwiXVxuICAgIH0sXG4gICAgXCJzZW50LWJ5XCI6IHtcbiAgICAgIHZhbHVlVHlwZTogXCJjYWwtYWRkcmVzc1wiXG4gICAgfSxcbiAgICBcInR6aWRcIjoge1xuICAgICAgbWF0Y2hlczogL15cXC8vXG4gICAgfSxcbiAgICBcInZhbHVlXCI6IHtcbiAgICAgIC8vIHNpbmNlIHRoZSB2YWx1ZSBoZXJlIGlzIGEgJ3R5cGUnIGxvd2VyY2FzZSBpcyB1c2VkLlxuICAgICAgdmFsdWVzOiBbXCJiaW5hcnlcIiwgXCJib29sZWFuXCIsIFwiY2FsLWFkZHJlc3NcIiwgXCJkYXRlXCIsIFwiZGF0ZS10aW1lXCIsXG4gICAgICAgICAgICAgICBcImR1cmF0aW9uXCIsIFwiZmxvYXRcIiwgXCJpbnRlZ2VyXCIsIFwicGVyaW9kXCIsIFwicmVjdXJcIiwgXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICBcInRpbWVcIiwgXCJ1cmlcIiwgXCJ1dGMtb2Zmc2V0XCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIC8vIFdoZW4gYWRkaW5nIGEgdmFsdWUgaGVyZSwgYmUgc3VyZSB0byBhZGQgaXQgdG8gdGhlIHBhcmFtZXRlciB0eXBlcyFcbiAgdmFyIGljYWxWYWx1ZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblZhbHVlcywge1xuICAgIHRleHQ6IGNyZWF0ZVRleHRUeXBlKEZST01fSUNBTF9ORVdMSU5FLCBUT19JQ0FMX05FV0xJTkUpLFxuXG4gICAgdXJpOiB7XG4gICAgICAvLyBUT0RPXG4gICAgICAvKiAuLi4gKi9cbiAgICB9LFxuXG4gICAgXCJiaW5hcnlcIjoge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuQmluYXJ5LmZyb21TdHJpbmcoYVN0cmluZyk7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhQmluYXJ5KSB7XG4gICAgICAgIHJldHVybiBhQmluYXJ5LnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcImNhbC1hZGRyZXNzXCI6IHtcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGFuIHVyaVxuICAgIH0sXG4gICAgXCJkYXRlXCI6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUsIGFQcm9wKSB7XG4gICAgICAgIGlmIChkZXNpZ24uc3RyaWN0KSB7XG4gICAgICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21TdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogdW5kZWNvcmF0ZXMgYSB0aW1lIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgLy8gZnJvbTogMjAxMjA5MDFcbiAgICAgICAgLy8gdG86IDIwMTItMDktMDFcbiAgICAgICAgaWYgKCFkZXNpZ24uc3RyaWN0ICYmIGFWYWx1ZS5sZW5ndGggPj0gMTUpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgZGF0ZS10aW1lLCBlLmcuIDIwMTIwOTAxVDEzMDAwMFpcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlc1tcImRhdGUtdGltZVwiXS5mcm9tSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhVmFsdWUuc3Vic3RyKDAsIDQpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig0LCAyKSArICctJyArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNiwgMik7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IDIwMTItMDktMDFcbiAgICAgICAgLy8gdG86IDIwMTIwOTAxXG4gICAgICAgIHZhciBsZW4gPSBhVmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW4gPT0gMTApIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA0KSArXG4gICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNSwgMikgK1xuICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDgsIDIpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbiA+PSAxOSkge1xuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzW1wiZGF0ZS10aW1lXCJdLnRvSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vVE9ETzogc2VyaWFsaXplIHdhcm5pbmc/XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSxcbiAgICBcImRhdGUtdGltZVwiOiB7XG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IDIwMTIwOTAxVDEzMDAwMFxuICAgICAgICAvLyB0bzogMjAxMi0wOS0wMVQxMzowMDowMFxuICAgICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgYVZhbHVlLmxlbmd0aCA9PSA4KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIGRhdGUsIGUuZy4gMjAxMjA5MDFcbiAgICAgICAgICByZXR1cm4gaWNhbFZhbHVlcy5kYXRlLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGFWYWx1ZS5zdWJzdHIoMCwgNCkgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDQsIDIpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig2LCAyKSArICdUJyArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoOSwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgICBhVmFsdWUuc3Vic3RyKDExLCAyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMTMsIDIpO1xuXG4gICAgICAgICAgaWYgKGFWYWx1ZVsxNV0gJiYgYVZhbHVlWzE1XSA9PT0gJ1onKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IDIwMTItMDktMDFUMTM6MDA6MDBcbiAgICAgICAgLy8gdG86IDIwMTIwOTAxVDEzMDAwMFxuICAgICAgICB2YXIgbGVuID0gYVZhbHVlLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuID09IDEwICYmICFkZXNpZ24uc3RyaWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwoYVZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW4gPj0gMTkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gYVZhbHVlLnN1YnN0cigwLCA0KSArXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoNSwgMikgK1xuICAgICAgICAgICAgICAgICAgICAgICAvLyBncmFiIHRoZSAoRERUSEgpIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig4LCA1KSArXG4gICAgICAgICAgICAgICAgICAgICAgIC8vIE1NXG4gICAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMTQsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gU1NcbiAgICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cigxNywgMik7XG5cbiAgICAgICAgICBpZiAoYVZhbHVlWzE5XSAmJiBhVmFsdWVbMTldID09PSAnWicpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnWic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVE9ETzogZXJyb3JcbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlLCBhUHJvcCkge1xuICAgICAgICBpZiAoZGVzaWduLnN0cmljdCkge1xuICAgICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGR1cmF0aW9uOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcoYVZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGVyaW9kOiB7XG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCcvJyk7XG4gICAgICAgIHBhcnRzWzBdID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10uZnJvbUlDQUwocGFydHNbMF0pO1xuXG4gICAgICAgIGlmICghSUNBTC5EdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKHBhcnRzWzFdKSkge1xuICAgICAgICAgIHBhcnRzWzFdID0gaWNhbFZhbHVlc1snZGF0ZS10aW1lJ10uZnJvbUlDQUwocGFydHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihwYXJ0cykge1xuICAgICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgcGFydHNbMF0ubGVuZ3RoID09IDEwKSB7XG4gICAgICAgICAgcGFydHNbMF0gPSBpY2FsVmFsdWVzLmRhdGUudG9JQ0FMKHBhcnRzWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0c1swXSA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLnRvSUNBTChwYXJ0c1swXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUlDQUwuRHVyYXRpb24uaXNWYWx1ZVN0cmluZyhwYXJ0c1sxXSkpIHtcbiAgICAgICAgICBpZiAoIWRlc2lnbi5zdHJpY3QgJiYgcGFydHNbMV0ubGVuZ3RoID09IDEwKSB7XG4gICAgICAgICAgICBwYXJ0c1sxXSA9IGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwocGFydHNbMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJ0c1sxXSA9IGljYWxWYWx1ZXNbJ2RhdGUtdGltZSddLnRvSUNBTChwYXJ0c1sxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCIvXCIpO1xuICAgICAgfSxcblxuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSwgYVByb3ApIHtcbiAgICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21KU09OKGFWYWx1ZSwgYVByb3AsICFkZXNpZ24uc3RyaWN0KTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvSlNPTigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVjdXI6IHtcbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuUmVjdXIuX3N0cmluZ1RvRGF0YShzdHJpbmcsIHRydWUpO1xuICAgICAgfSxcblxuICAgICAgdG9JQ0FMOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBzdHIgPSBcIlwiO1xuICAgICAgICBmb3IgKHZhciBrIGluIGRhdGEpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2YWwgPSBkYXRhW2tdO1xuICAgICAgICAgIGlmIChrID09IFwidW50aWxcIikge1xuICAgICAgICAgICAgaWYgKHZhbC5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgICB2YWwgPSBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXS50b0lDQUwodmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbCA9IGljYWxWYWx1ZXMuZGF0ZS50b0lDQUwodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGsgPT0gXCJ3a3N0XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICB2YWwgPSBJQ0FMLlJlY3VyLm51bWVyaWNEYXlUb0ljYWxEYXkodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLmpvaW4oXCIsXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHIgKz0gay50b1VwcGVyQ2FzZSgpICsgXCI9XCIgKyB2YWwgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cigwLCBzdHIubGVuZ3RoIC0gMSk7XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24gZGVjb3JhdGUoYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlJlY3VyLmZyb21EYXRhKGFWYWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhUmVjdXIpIHtcbiAgICAgICAgcmV0dXJuIGFSZWN1ci50b0pTT04oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdGltZToge1xuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICAvLyBmcm9tOiBNTUhIU1MoWik/XG4gICAgICAgIC8vIHRvOiBISDpNTTpTUyhaKT9cbiAgICAgICAgaWYgKGFWYWx1ZS5sZW5ndGggPCA2KSB7XG4gICAgICAgICAgLy8gVE9ETzogcGFyc2VyIGV4Y2VwdGlvbj9cbiAgICAgICAgICByZXR1cm4gYVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSEg6Ok1NOjpTU1o/XG4gICAgICAgIHZhciByZXN1bHQgPSBhVmFsdWUuc3Vic3RyKDAsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMiwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig0LCAyKTtcblxuICAgICAgICBpZiAoYVZhbHVlWzZdID09PSAnWicpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIC8vIGZyb206IEhIOk1NOlNTKFopP1xuICAgICAgICAvLyB0bzogTU1ISFNTKFopP1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA8IDgpIHtcbiAgICAgICAgICAvL1RPRE86IGVycm9yXG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBhVmFsdWUuc3Vic3RyKDAsIDIpICtcbiAgICAgICAgICAgICAgICAgICAgIGFWYWx1ZS5zdWJzdHIoMywgMikgK1xuICAgICAgICAgICAgICAgICAgICAgYVZhbHVlLnN1YnN0cig2LCAyKTtcblxuICAgICAgICBpZiAoYVZhbHVlWzhdID09PSAnWicpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1onO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHZhciBpY2FsUHJvcGVydGllcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uUHJvcGVydGllcywge1xuXG4gICAgXCJhY3Rpb25cIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJhdHRhY2hcIjogeyBkZWZhdWx0VHlwZTogXCJ1cmlcIiB9LFxuICAgIFwiYXR0ZW5kZWVcIjogeyBkZWZhdWx0VHlwZTogXCJjYWwtYWRkcmVzc1wiIH0sXG4gICAgXCJjYWxzY2FsZVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImNsYXNzXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiY29tbWVudFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImNvbXBsZXRlZFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gICAgXCJjb250YWN0XCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwiY3JlYXRlZFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gICAgXCJkZXNjcmlwdGlvblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImR0ZW5kXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwiZHRzdGFtcFwiOiBERUZBVUxUX1RZUEVfREFURVRJTUUsXG4gICAgXCJkdHN0YXJ0XCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwiZHVlXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwiZHVyYXRpb25cIjogeyBkZWZhdWx0VHlwZTogXCJkdXJhdGlvblwiIH0sXG4gICAgXCJleGRhdGVcIjoge1xuICAgICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIl0sXG4gICAgICBtdWx0aVZhbHVlOiAnLCdcbiAgICB9LFxuICAgIFwiZXhydWxlXCI6IERFRkFVTFRfVFlQRV9SRUNVUixcbiAgICBcImZyZWVidXN5XCI6IHsgZGVmYXVsdFR5cGU6IFwicGVyaW9kXCIsIG11bHRpVmFsdWU6IFwiLFwiIH0sXG4gICAgXCJnZW9cIjogeyBkZWZhdWx0VHlwZTogXCJmbG9hdFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH0sXG4gICAgXCJsYXN0LW1vZGlmaWVkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRSxcbiAgICBcImxvY2F0aW9uXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwibWV0aG9kXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwib3JnYW5pemVyXCI6IHsgZGVmYXVsdFR5cGU6IFwiY2FsLWFkZHJlc3NcIiB9LFxuICAgIFwicGVyY2VudC1jb21wbGV0ZVwiOiBERUZBVUxUX1RZUEVfSU5URUdFUixcbiAgICBcInByaW9yaXR5XCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICAgIFwicHJvZGlkXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwicmVsYXRlZC10b1wiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInJlcGVhdFwiOiBERUZBVUxUX1RZUEVfSU5URUdFUixcbiAgICBcInJkYXRlXCI6IHtcbiAgICAgIGRlZmF1bHRUeXBlOiBcImRhdGUtdGltZVwiLFxuICAgICAgYWxsb3dlZFR5cGVzOiBbXCJkYXRlLXRpbWVcIiwgXCJkYXRlXCIsIFwicGVyaW9kXCJdLFxuICAgICAgbXVsdGlWYWx1ZTogJywnLFxuICAgICAgZGV0ZWN0VHlwZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIGlmIChzdHJpbmcuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiAncGVyaW9kJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHN0cmluZy5pbmRleE9mKCdUJykgPT09IC0xKSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJyZWN1cnJlbmNlLWlkXCI6IERFRkFVTFRfVFlQRV9EQVRFVElNRV9EQVRFLFxuICAgIFwicmVzb3VyY2VzXCI6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICAgIFwicmVxdWVzdC1zdGF0dXNcIjogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcbiAgICBcInJydWxlXCI6IERFRkFVTFRfVFlQRV9SRUNVUixcbiAgICBcInNlcXVlbmNlXCI6IERFRkFVTFRfVFlQRV9JTlRFR0VSLFxuICAgIFwic3RhdHVzXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwic3VtbWFyeVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInRyYW5zcFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcInRyaWdnZXJcIjogeyBkZWZhdWx0VHlwZTogXCJkdXJhdGlvblwiLCBhbGxvd2VkVHlwZXM6IFtcImR1cmF0aW9uXCIsIFwiZGF0ZS10aW1lXCJdIH0sXG4gICAgXCJ0em9mZnNldGZyb21cIjogREVGQVVMVF9UWVBFX1VUQ09GRlNFVCxcbiAgICBcInR6b2Zmc2V0dG9cIjogREVGQVVMVF9UWVBFX1VUQ09GRlNFVCxcbiAgICBcInR6dXJsXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJ0emlkXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwidHpuYW1lXCI6IERFRkFVTFRfVFlQRV9URVhUXG4gIH0pO1xuXG4gIC8vIFdoZW4gYWRkaW5nIGEgdmFsdWUgaGVyZSwgYmUgc3VyZSB0byBhZGQgaXQgdG8gdGhlIHBhcmFtZXRlciB0eXBlcyFcbiAgdmFyIHZjYXJkVmFsdWVzID0gSUNBTC5oZWxwZXJzLmV4dGVuZChjb21tb25WYWx1ZXMsIHtcbiAgICB0ZXh0OiBjcmVhdGVUZXh0VHlwZShGUk9NX1ZDQVJEX05FV0xJTkUsIFRPX1ZDQVJEX05FV0xJTkUpLFxuICAgIHVyaTogY3JlYXRlVGV4dFR5cGUoRlJPTV9WQ0FSRF9ORVdMSU5FLCBUT19WQ0FSRF9ORVdMSU5FKSxcblxuICAgIGRhdGU6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVkNhcmRUaW1lLmZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKGFWYWx1ZSwgXCJkYXRlXCIpO1xuICAgICAgfSxcbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA9PSA4KSB7XG4gICAgICAgICAgcmV0dXJuIGljYWxWYWx1ZXMuZGF0ZS5mcm9tSUNBTChhVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGFWYWx1ZVswXSA9PSAnLScgJiYgYVZhbHVlLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgNCkgKyAnLScgKyBhVmFsdWUuc3Vic3RyKDQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBhVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICBpZiAoYVZhbHVlLmxlbmd0aCA9PSAxMCkge1xuICAgICAgICAgIHJldHVybiBpY2FsVmFsdWVzLmRhdGUudG9JQ0FMKGFWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYVZhbHVlWzBdID09ICctJyAmJiBhVmFsdWUubGVuZ3RoID09IDcpIHtcbiAgICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA0KSArIGFWYWx1ZS5zdWJzdHIoNSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGFWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB0aW1lOiB7XG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlZDYXJkVGltZS5mcm9tRGF0ZUFuZE9yVGltZVN0cmluZyhcIlRcIiArIGFWYWx1ZSwgXCJ0aW1lXCIpO1xuICAgICAgfSxcbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuICAgICAgZnJvbUlDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICB2YXIgc3BsaXR6b25lID0gdmNhcmRWYWx1ZXMudGltZS5fc3BsaXRab25lKGFWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciB6b25lID0gc3BsaXR6b25lWzBdLCB2YWx1ZSA9IHNwbGl0em9uZVsxXTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU1BMSVQ6IFwiLHNwbGl0em9uZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSA2KSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMikgKyAnOicgK1xuICAgICAgICAgICAgICAgICAgdmFsdWUuc3Vic3RyKDIsIDIpICsgJzonICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cig0LCAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT0gNCAmJiB2YWx1ZVswXSAhPSAnLScpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAyKSArICc6JyArIHZhbHVlLnN1YnN0cigyLCAyKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggPT0gNSkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDMpICsgJzonICsgdmFsdWUuc3Vic3RyKDMsIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHpvbmUubGVuZ3RoID09IDUgJiYgKHpvbmVbMF0gPT0gJy0nIHx8IHpvbmVbMF0gPT0gJysnKSkge1xuICAgICAgICAgIHpvbmUgPSB6b25lLnN1YnN0cigwLCAzKSArICc6JyArIHpvbmUuc3Vic3RyKDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlICsgem9uZTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHZhciBzcGxpdHpvbmUgPSB2Y2FyZFZhbHVlcy50aW1lLl9zcGxpdFpvbmUoYVZhbHVlKTtcbiAgICAgICAgdmFyIHpvbmUgPSBzcGxpdHpvbmVbMF0sIHZhbHVlID0gc3BsaXR6b25lWzFdO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gOCkge1xuICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDAsIDIpICtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnN1YnN0cigzLCAyKSArXG4gICAgICAgICAgICAgICAgICB2YWx1ZS5zdWJzdHIoNiwgMik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDUgJiYgdmFsdWVbMF0gIT0gJy0nKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMCwgMikgKyB2YWx1ZS5zdWJzdHIoMywgMik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUubGVuZ3RoID09IDYpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCAzKSArIHZhbHVlLnN1YnN0cig0LCAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh6b25lLmxlbmd0aCA9PSA2ICYmICh6b25lWzBdID09ICctJyB8fCB6b25lWzBdID09ICcrJykpIHtcbiAgICAgICAgICB6b25lID0gem9uZS5zdWJzdHIoMCwgMykgKyB6b25lLnN1YnN0cig0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZSArIHpvbmU7XG4gICAgICB9LFxuXG4gICAgICBfc3BsaXRab25lOiBmdW5jdGlvbihhVmFsdWUsIGlzRnJvbUljYWwpIHtcbiAgICAgICAgdmFyIGxhc3RDaGFyID0gYVZhbHVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBzaWduQ2hhciA9IGFWYWx1ZS5sZW5ndGggLSAoaXNGcm9tSWNhbCA/IDUgOiA2KTtcbiAgICAgICAgdmFyIHNpZ24gPSBhVmFsdWVbc2lnbkNoYXJdO1xuICAgICAgICB2YXIgem9uZSwgdmFsdWU7XG5cbiAgICAgICAgaWYgKGFWYWx1ZVtsYXN0Q2hhcl0gPT0gJ1onKSB7XG4gICAgICAgICAgem9uZSA9IGFWYWx1ZVtsYXN0Q2hhcl07XG4gICAgICAgICAgdmFsdWUgPSBhVmFsdWUuc3Vic3RyKDAsIGxhc3RDaGFyKTtcbiAgICAgICAgfSBlbHNlIGlmIChhVmFsdWUubGVuZ3RoID4gNiAmJiAoc2lnbiA9PSAnLScgfHwgc2lnbiA9PSAnKycpKSB7XG4gICAgICAgICAgem9uZSA9IGFWYWx1ZS5zdWJzdHIoc2lnbkNoYXIpO1xuICAgICAgICAgIHZhbHVlID0gYVZhbHVlLnN1YnN0cigwLCBzaWduQ2hhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgem9uZSA9IFwiXCI7XG4gICAgICAgICAgdmFsdWUgPSBhVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3pvbmUsIHZhbHVlXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJkYXRlLXRpbWVcIjoge1xuICAgICAgZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gSUNBTC5WQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcoYVZhbHVlLCBcImRhdGUtdGltZVwiKTtcbiAgICAgIH0sXG5cbiAgICAgIHVuZGVjb3JhdGU6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICB9LFxuXG4gICAgICBmcm9tSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2Y2FyZFZhbHVlc1snZGF0ZS1hbmQtb3ItdGltZSddLmZyb21JQ0FMKGFWYWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gdmNhcmRWYWx1ZXNbJ2RhdGUtYW5kLW9yLXRpbWUnXS50b0lDQUwoYVZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJkYXRlLWFuZC1vci10aW1lXCI6IHtcbiAgICAgIGRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVkNhcmRUaW1lLmZyb21EYXRlQW5kT3JUaW1lU3RyaW5nKGFWYWx1ZSwgXCJkYXRlLWFuZC1vci10aW1lXCIpO1xuICAgICAgfSxcblxuICAgICAgdW5kZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhVmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gYVZhbHVlLnNwbGl0KCdUJyk7XG4gICAgICAgIHJldHVybiAocGFydHNbMF0gPyB2Y2FyZFZhbHVlcy5kYXRlLmZyb21JQ0FMKHBhcnRzWzBdKSA6ICcnKSArXG4gICAgICAgICAgICAgICAocGFydHNbMV0gPyAnVCcgKyB2Y2FyZFZhbHVlcy50aW1lLmZyb21JQ0FMKHBhcnRzWzFdKSA6ICcnKTtcbiAgICAgIH0sXG5cbiAgICAgIHRvSUNBTDogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGFWYWx1ZS5zcGxpdCgnVCcpO1xuICAgICAgICByZXR1cm4gdmNhcmRWYWx1ZXMuZGF0ZS50b0lDQUwocGFydHNbMF0pICtcbiAgICAgICAgICAgICAgIChwYXJ0c1sxXSA/ICdUJyArIHZjYXJkVmFsdWVzLnRpbWUudG9JQ0FMKHBhcnRzWzFdKSA6ICcnKTtcblxuICAgICAgfVxuICAgIH0sXG4gICAgdGltZXN0YW1wOiBpY2FsVmFsdWVzWydkYXRlLXRpbWUnXSxcbiAgICBcImxhbmd1YWdlLXRhZ1wiOiB7XG4gICAgICBtYXRjaGVzOiAvXlthLXpBLVowLTktXSskLyAvLyBDb3VsZCBnbyB3aXRoIGEgbW9yZSBzdHJpY3QgcmVnZXggaGVyZVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHZjYXJkUGFyYW1zID0ge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICB2YWx1ZVR5cGU6IFwidGV4dFwiLFxuICAgICAgbXVsdGlWYWx1ZTogXCIsXCJcbiAgICB9LFxuICAgIFwidmFsdWVcIjoge1xuICAgICAgLy8gc2luY2UgdGhlIHZhbHVlIGhlcmUgaXMgYSAndHlwZScgbG93ZXJjYXNlIGlzIHVzZWQuXG4gICAgICB2YWx1ZXM6IFtcInRleHRcIiwgXCJ1cmlcIiwgXCJkYXRlXCIsIFwidGltZVwiLCBcImRhdGUtdGltZVwiLCBcImRhdGUtYW5kLW9yLXRpbWVcIixcbiAgICAgICAgICAgICAgIFwidGltZXN0YW1wXCIsIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJmbG9hdFwiLCBcInV0Yy1vZmZzZXRcIixcbiAgICAgICAgICAgICAgIFwibGFuZ3VhZ2UtdGFnXCJdLFxuICAgICAgYWxsb3dYTmFtZTogdHJ1ZSxcbiAgICAgIGFsbG93SWFuYVRva2VuOiB0cnVlXG4gICAgfVxuICB9O1xuXG4gIHZhciB2Y2FyZFByb3BlcnRpZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblByb3BlcnRpZXMsIHtcbiAgICBcImFkclwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBcImFubml2ZXJzYXJ5XCI6IERFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUsXG4gICAgXCJiZGF5XCI6IERFRkFVTFRfVFlQRV9EQVRFX0FORE9SX1RJTUUsXG4gICAgXCJjYWxhZHJ1cmlcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImNhbHVyaVwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwiY2xpZW50cGlkbWFwXCI6IERFRkFVTFRfVFlQRV9URVhUX1NUUlVDVFVSRUQsXG4gICAgXCJlbWFpbFwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImZidXJsXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJmblwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcImdlbmRlclwiOiBERUZBVUxUX1RZUEVfVEVYVF9TVFJVQ1RVUkVELFxuICAgIFwiZ2VvXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJpbXBwXCI6IERFRkFVTFRfVFlQRV9VUkksXG4gICAgXCJrZXlcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcImtpbmRcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJsYW5nXCI6IHsgZGVmYXVsdFR5cGU6IFwibGFuZ3VhZ2UtdGFnXCIgfSxcbiAgICBcImxvZ29cIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcIm1lbWJlclwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwiblwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBcIm5pY2tuYW1lXCI6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICAgIFwibm90ZVwiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBcIm9yZ1wiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiB9LFxuICAgIFwicGhvdG9cIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInJlbGF0ZWRcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInJldlwiOiB7IGRlZmF1bHRUeXBlOiBcInRpbWVzdGFtcFwiIH0sXG4gICAgXCJyb2xlXCI6IERFRkFVTFRfVFlQRV9URVhULFxuICAgIFwic291bmRcIjogREVGQVVMVF9UWVBFX1VSSSxcbiAgICBcInNvdXJjZVwiOiBERUZBVUxUX1RZUEVfVVJJLFxuICAgIFwidGVsXCI6IHsgZGVmYXVsdFR5cGU6IFwidXJpXCIsIGFsbG93ZWRUeXBlczogW1widXJpXCIsIFwidGV4dFwiXSB9LFxuICAgIFwidGl0bGVcIjogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgXCJ0elwiOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgYWxsb3dlZFR5cGVzOiBbXCJ0ZXh0XCIsIFwidXRjLW9mZnNldFwiLCBcInVyaVwiXSB9LFxuICAgIFwieG1sXCI6IERFRkFVTFRfVFlQRV9URVhUXG4gIH0pO1xuXG4gIHZhciB2Y2FyZDNWYWx1ZXMgPSBJQ0FMLmhlbHBlcnMuZXh0ZW5kKGNvbW1vblZhbHVlcywge1xuICAgIGJpbmFyeTogaWNhbFZhbHVlcy5iaW5hcnksXG4gICAgZGF0ZTogdmNhcmRWYWx1ZXMuZGF0ZSxcbiAgICBcImRhdGUtdGltZVwiOiB2Y2FyZFZhbHVlc1tcImRhdGUtdGltZVwiXSxcbiAgICBcInBob25lLW51bWJlclwiOiB7XG4gICAgICAvLyBUT0RPXG4gICAgICAvKiAuLi4gKi9cbiAgICB9LFxuICAgIHVyaTogaWNhbFZhbHVlcy51cmksXG4gICAgdGV4dDogaWNhbFZhbHVlcy50ZXh0LFxuICAgIHRpbWU6IGljYWxWYWx1ZXMudGltZSxcbiAgICB2Y2FyZDogaWNhbFZhbHVlcy50ZXh0LFxuICAgIFwidXRjLW9mZnNldFwiOiB7XG4gICAgICB0b0lDQUw6IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgICAgICByZXR1cm4gYVZhbHVlLnN1YnN0cigwLCA3KTtcbiAgICAgIH0sXG5cbiAgICAgIGZyb21JQ0FMOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS5zdWJzdHIoMCwgNyk7XG4gICAgICB9LFxuXG4gICAgICBkZWNvcmF0ZTogZnVuY3Rpb24oYVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlV0Y09mZnNldC5mcm9tU3RyaW5nKGFWYWx1ZSk7XG4gICAgICB9LFxuXG4gICAgICB1bmRlY29yYXRlOiBmdW5jdGlvbihhVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFWYWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHZjYXJkM1BhcmFtcyA9IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgdmFsdWVUeXBlOiBcInRleHRcIixcbiAgICAgIG11bHRpVmFsdWU6IFwiLFwiXG4gICAgfSxcbiAgICBcInZhbHVlXCI6IHtcbiAgICAgIC8vIHNpbmNlIHRoZSB2YWx1ZSBoZXJlIGlzIGEgJ3R5cGUnIGxvd2VyY2FzZSBpcyB1c2VkLlxuICAgICAgdmFsdWVzOiBbXCJ0ZXh0XCIsIFwidXJpXCIsIFwiZGF0ZVwiLCBcImRhdGUtdGltZVwiLCBcInBob25lLW51bWJlclwiLCBcInRpbWVcIixcbiAgICAgICAgICAgICAgIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJmbG9hdFwiLCBcInV0Yy1vZmZzZXRcIiwgXCJ2Y2FyZFwiLCBcImJpbmFyeVwiXSxcbiAgICAgIGFsbG93WE5hbWU6IHRydWUsXG4gICAgICBhbGxvd0lhbmFUb2tlbjogdHJ1ZVxuICAgIH1cbiAgfTtcblxuICB2YXIgdmNhcmQzUHJvcGVydGllcyA9IElDQUwuaGVscGVycy5leHRlbmQoY29tbW9uUHJvcGVydGllcywge1xuICAgIGZuOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBuOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBuaWNrbmFtZTogREVGQVVMVF9UWVBFX1RFWFRfTVVMVEksXG4gICAgcGhvdG86IHsgZGVmYXVsdFR5cGU6IFwiYmluYXJ5XCIsIGFsbG93ZWRUeXBlczogW1wiYmluYXJ5XCIsIFwidXJpXCJdIH0sXG4gICAgYmRheToge1xuICAgICAgZGVmYXVsdFR5cGU6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBhbGxvd2VkVHlwZXM6IFtcImRhdGUtdGltZVwiLCBcImRhdGVcIl0sXG4gICAgICBkZXRlY3RUeXBlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIChzdHJpbmcuaW5kZXhPZignVCcpID09PSAtMSkgPyAnZGF0ZScgOiAnZGF0ZS10aW1lJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRyOiB7IGRlZmF1bHRUeXBlOiBcInRleHRcIiwgc3RydWN0dXJlZFZhbHVlOiBcIjtcIiwgbXVsdGlWYWx1ZTogXCIsXCIgfSxcbiAgICBsYWJlbDogREVGQVVMVF9UWVBFX1RFWFQsXG5cbiAgICB0ZWw6IHsgZGVmYXVsdFR5cGU6IFwicGhvbmUtbnVtYmVyXCIgfSxcbiAgICBlbWFpbDogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgbWFpbGVyOiBERUZBVUxUX1RZUEVfVEVYVCxcblxuICAgIHR6OiB7IGRlZmF1bHRUeXBlOiBcInV0Yy1vZmZzZXRcIiwgYWxsb3dlZFR5cGVzOiBbXCJ1dGMtb2Zmc2V0XCIsIFwidGV4dFwiXSB9LFxuICAgIGdlbzogeyBkZWZhdWx0VHlwZTogXCJmbG9hdFwiLCBzdHJ1Y3R1cmVkVmFsdWU6IFwiO1wiIH0sXG5cbiAgICB0aXRsZTogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgcm9sZTogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgbG9nbzogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ1cmlcIl0gfSxcbiAgICBhZ2VudDogeyBkZWZhdWx0VHlwZTogXCJ2Y2FyZFwiLCBhbGxvd2VkVHlwZXM6IFtcInZjYXJkXCIsIFwidGV4dFwiLCBcInVyaVwiXSB9LFxuICAgIG9yZzogREVGQVVMVF9UWVBFX1RFWFRfU1RSVUNUVVJFRCxcblxuICAgIG5vdGU6IERFRkFVTFRfVFlQRV9URVhUX01VTFRJLFxuICAgIHByb2RpZDogREVGQVVMVF9UWVBFX1RFWFQsXG4gICAgcmV2OiB7XG4gICAgICBkZWZhdWx0VHlwZTogXCJkYXRlLXRpbWVcIixcbiAgICAgIGFsbG93ZWRUeXBlczogW1wiZGF0ZS10aW1lXCIsIFwiZGF0ZVwiXSxcbiAgICAgIGRldGVjdFR5cGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICByZXR1cm4gKHN0cmluZy5pbmRleE9mKCdUJykgPT09IC0xKSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJzb3J0LXN0cmluZ1wiOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBzb3VuZDogeyBkZWZhdWx0VHlwZTogXCJiaW5hcnlcIiwgYWxsb3dlZFR5cGVzOiBbXCJiaW5hcnlcIiwgXCJ1cmlcIl0gfSxcblxuICAgIGNsYXNzOiBERUZBVUxUX1RZUEVfVEVYVCxcbiAgICBrZXk6IHsgZGVmYXVsdFR5cGU6IFwiYmluYXJ5XCIsIGFsbG93ZWRUeXBlczogW1wiYmluYXJ5XCIsIFwidGV4dFwiXSB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBpQ2FsZW5kYXIgZGVzaWduIHNldFxuICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgKi9cbiAgdmFyIGljYWxTZXQgPSB7XG4gICAgdmFsdWU6IGljYWxWYWx1ZXMsXG4gICAgcGFyYW06IGljYWxQYXJhbXMsXG4gICAgcHJvcGVydHk6IGljYWxQcm9wZXJ0aWVzXG4gIH07XG5cbiAgLyoqXG4gICAqIHZDYXJkIDQuMCBkZXNpZ24gc2V0XG4gICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAqL1xuICB2YXIgdmNhcmRTZXQgPSB7XG4gICAgdmFsdWU6IHZjYXJkVmFsdWVzLFxuICAgIHBhcmFtOiB2Y2FyZFBhcmFtcyxcbiAgICBwcm9wZXJ0eTogdmNhcmRQcm9wZXJ0aWVzXG4gIH07XG5cbiAgLyoqXG4gICAqIHZDYXJkIDMuMCBkZXNpZ24gc2V0XG4gICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAqL1xuICB2YXIgdmNhcmQzU2V0ID0ge1xuICAgIHZhbHVlOiB2Y2FyZDNWYWx1ZXMsXG4gICAgcGFyYW06IHZjYXJkM1BhcmFtcyxcbiAgICBwcm9wZXJ0eTogdmNhcmQzUHJvcGVydGllc1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZGVzaWduIGRhdGEsIHVzZWQgYnkgdGhlIHBhcnNlciB0byBkZXRlcm1pbmUgdHlwZXMgZm9yIHByb3BlcnRpZXMgYW5kXG4gICAqIG90aGVyIG1ldGFkYXRhIG5lZWRlZCB0byBwcm9kdWNlIGNvcnJlY3QgakNhcmQvakNhbCBkYXRhLlxuICAgKlxuICAgKiBAYWxpYXMgSUNBTC5kZXNpZ25cbiAgICogQG5hbWVzcGFjZVxuICAgKi9cbiAgdmFyIGRlc2lnbiA9IHtcbiAgICAvKipcbiAgICAgKiBBIGRlc2lnblNldCBkZXNjcmliZXMgdmFsdWUsIHBhcmFtZXRlciBhbmQgcHJvcGVydHkgZGF0YS4gSXQgaXMgdXNlZCBieVxuICAgICAqIHRoZXIgcGFyc2VyIGFuZCBzdHJpbmdpZmllciBpbiBjb21wb25lbnRzIGFuZCBwcm9wZXJ0aWVzIHRvIGRldGVybWluZSB0aGV5XG4gICAgICogc2hvdWxkIGJlIHJlcHJlc2VudGVkLlxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gZGVzaWduU2V0XG4gICAgICogQG1lbWJlck9mIElDQUwuZGVzaWduXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IHZhbHVlICAgICAgIERlZmluaXRpb25zIGZvciB2YWx1ZSB0eXBlcywga2V5cyBhcmUgdHlwZSBuYW1lc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwYXJhbSAgICAgICBEZWZpbml0aW9ucyBmb3IgcGFyYW1zLCBrZXlzIGFyZSBwYXJhbSBuYW1lc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwcm9wZXJ0eSAgICBEZWZpbnRpb25zIGZvciBwcm9wZXJ0aWVzLCBrZXlzIGFyZSBwcm9wZXJ0eSBuYW1lc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHNldCB0byBmYWxzZSB0byBtYWtlIHRoZSBwYXJzZXIgbW9yZSBsZW5pZW50LlxuICAgICAqL1xuICAgIHN0cmljdDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHNldCBmb3IgbmV3IHByb3BlcnRpZXMgYW5kIGNvbXBvbmVudHMgaWYgbm9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKi9cbiAgICBkZWZhdWx0U2V0OiBpY2FsU2V0LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgdHlwZSBmb3IgdW5rbm93biBwcm9wZXJ0aWVzXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBkZWZhdWx0VHlwZTogJ3Vua25vd24nLFxuXG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIGRlc2lnbiBzZXQgZm9yIGtub3duIHRvcC1sZXZlbCBjb21wb25lbnRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2Y2FyZCAgICAgICB2Q2FyZCBWQ0FSRFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2ZXZlbnQgICAgICBpQ2FsZW5kYXIgVkVWRU5UXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IHZ0b2RvICAgICAgIGlDYWxlbmRhciBWVE9ET1xuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2am91cm5hbCAgICBpQ2FsZW5kYXIgVkpPVVJOQUxcbiAgICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gdmFsYXJtICAgICAgaUNhbGVuZGFyIFZBTEFSTVxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSB2dGltZXpvbmUgICBpQ2FsZW5kYXIgVlRJTUVaT05FXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IGRheWxpZ2h0ICAgIGlDYWxlbmRhciBEQVlMSUdIVFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBzdGFuZGFyZCAgICBpQ2FsZW5kYXIgU1RBTkRBUkRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHByb3BlcnR5TmFtZSA9ICdmbic7XG4gICAgICogdmFyIGNvbXBvbmVudERlc2lnbiA9IElDQUwuZGVzaWduLmNvbXBvbmVudHMudmNhcmQ7XG4gICAgICogdmFyIHByb3BlcnR5RGV0YWlscyA9IGNvbXBvbmVudERlc2lnbi5wcm9wZXJ0eVtwcm9wZXJ0eU5hbWVdO1xuICAgICAqIGlmIChwcm9wZXJ0eURldGFpbHMuZGVmYXVsdFR5cGUgPT0gJ3RleHQnKSB7XG4gICAgICogICAvLyBZZXAsIHN1cmUgaXMuLi5cbiAgICAgKiB9XG4gICAgICovXG4gICAgY29tcG9uZW50czoge1xuICAgICAgdmNhcmQ6IHZjYXJkU2V0LFxuICAgICAgdmNhcmQzOiB2Y2FyZDNTZXQsXG4gICAgICB2ZXZlbnQ6IGljYWxTZXQsXG4gICAgICB2dG9kbzogaWNhbFNldCxcbiAgICAgIHZqb3VybmFsOiBpY2FsU2V0LFxuICAgICAgdmFsYXJtOiBpY2FsU2V0LFxuICAgICAgdnRpbWV6b25lOiBpY2FsU2V0LFxuICAgICAgZGF5bGlnaHQ6IGljYWxTZXQsXG4gICAgICBzdGFuZGFyZDogaWNhbFNldFxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciBpQ2FsZW5kYXIgKHJmYzU1NDUvcmZjNzI2NSkgY29tcG9uZW50cy5cbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqL1xuICAgIGljYWxlbmRhcjogaWNhbFNldCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciB2Q2FyZCAocmZjNjM1MC9yZmM3MDk1KSBjb21wb25lbnRzLlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICovXG4gICAgdmNhcmQ6IHZjYXJkU2V0LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2lnbiBzZXQgZm9yIHZDYXJkIChyZmMyNDI1L3JmYzI0MjYvcmZjNzA5NSkgY29tcG9uZW50cy5cbiAgICAgKiBAdHlwZSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fVxuICAgICAqL1xuICAgIHZjYXJkMzogdmNhcmQzU2V0LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGVzaWduIHNldCBmb3IgdGhlIGdpdmVuIGNvbXBvbmVudCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudE5hbWUgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9ICAgICAgVGhlIGRlc2lnbiBzZXQgZm9yIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXREZXNpZ25TZXQ6IGZ1bmN0aW9uKGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHZhciBpc0luRGVzaWduID0gY29tcG9uZW50TmFtZSAmJiBjb21wb25lbnROYW1lIGluIGRlc2lnbi5jb21wb25lbnRzO1xuICAgICAgcmV0dXJuIGlzSW5EZXNpZ24gPyBkZXNpZ24uY29tcG9uZW50c1tjb21wb25lbnROYW1lXSA6IGRlc2lnbi5kZWZhdWx0U2V0O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gZGVzaWduO1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBDb250YWlucyB2YXJpb3VzIGZ1bmN0aW9ucyB0byBjb252ZXJ0IGpDYWwgYW5kIGpDYXJkIGRhdGEgYmFjayBpbnRvXG4gKiBpQ2FsZW5kYXIgYW5kIHZDYXJkLlxuICogQG5hbWVzcGFjZVxuICovXG5JQ0FMLnN0cmluZ2lmeSA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBMSU5FX0VORElORyA9ICdcXHJcXG4nO1xuICB2YXIgREVGQVVMVF9WQUxVRV9UWVBFID0gJ3Vua25vd24nO1xuXG4gIHZhciBkZXNpZ24gPSBJQ0FMLmRlc2lnbjtcbiAgdmFyIGhlbHBlcnMgPSBJQ0FMLmhlbHBlcnM7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBmdWxsIGpDYWwvakNhcmQgYXJyYXkgaW50byBhIGlDYWxlbmRhci92Q2FyZCBzdHJpbmcuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeVxuICAgKiBAdmFyaWF0aW9uIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXl9IGpDYWwgICAgVGhlIGpDYWwvakNhcmQgZG9jdW1lbnRcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBUaGUgc3RyaW5naWZpZWQgaUNhbGVuZGFyL3ZDYXJkIGRvY3VtZW50XG4gICAqL1xuICBmdW5jdGlvbiBzdHJpbmdpZnkoakNhbCkge1xuICAgIGlmICh0eXBlb2YgakNhbFswXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGNvbXBvbmVudFxuICAgICAgakNhbCA9IFtqQ2FsXTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGpDYWwubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkuY29tcG9uZW50KGpDYWxbaV0pICsgTElORV9FTkRJTkc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBqQ2FsIGNvbXBvbmVudCBhcnJheSBpbnRvIGEgSUNBTCBzdHJpbmcuXG4gICAqIFJlY3Vyc2l2ZSB3aWxsIHJlc29sdmUgc3ViLWNvbXBvbmVudHMuXG4gICAqXG4gICAqIEV4YWN0IGNvbXBvbmVudC9wcm9wZXJ0eSBvcmRlciBpcyBub3Qgc2F2ZWQgYWxsXG4gICAqIHByb3BlcnRpZXMgd2lsbCBjb21lIGJlZm9yZSBzdWJjb21wb25lbnRzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5zdHJpbmdpZnkuY29tcG9uZW50XG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudFxuICAgKiAgICAgICAgakNhbC9qQ2FyZCBmcmFnbWVudCBvZiBhIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0XG4gICAqICAgICAgICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIGNvbXBvbmVudFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgIFRoZSBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nXG4gICAqL1xuICBzdHJpbmdpZnkuY29tcG9uZW50ID0gZnVuY3Rpb24oY29tcG9uZW50LCBkZXNpZ25TZXQpIHtcbiAgICB2YXIgbmFtZSA9IGNvbXBvbmVudFswXS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciByZXN1bHQgPSAnQkVHSU46JyArIG5hbWUgKyBMSU5FX0VORElORztcblxuICAgIHZhciBwcm9wcyA9IGNvbXBvbmVudFsxXTtcbiAgICB2YXIgcHJvcElkeCA9IDA7XG4gICAgdmFyIHByb3BMZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB2YXIgZGVzaWduU2V0TmFtZSA9IGNvbXBvbmVudFswXTtcbiAgICAvLyByZmM2MzUwIHJlcXVpcmVzIHRoYXQgaW4gdkNhcmQgNC4wIHRoZSBmaXJzdCBjb21wb25lbnQgaXMgdGhlIFZFUlNJT05cbiAgICAvLyBjb21wb25lbnQgd2l0aCBhcyB2YWx1ZSA0LjAsIG5vdGUgdGhhdCAzLjAgZG9lcyBub3QgaGF2ZSB0aGlzIHJlcXVpcmVtZW50LlxuICAgIGlmIChkZXNpZ25TZXROYW1lID09PSAndmNhcmQnICYmIGNvbXBvbmVudFsxXS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAhKGNvbXBvbmVudFsxXVswXVswXSA9PT0gXCJ2ZXJzaW9uXCIgJiYgY29tcG9uZW50WzFdWzBdWzNdID09PSBcIjQuMFwiKSkge1xuICAgICAgZGVzaWduU2V0TmFtZSA9IFwidmNhcmQzXCI7XG4gICAgfVxuICAgIGRlc2lnblNldCA9IGRlc2lnblNldCB8fCBkZXNpZ24uZ2V0RGVzaWduU2V0KGRlc2lnblNldE5hbWUpO1xuXG4gICAgZm9yICg7IHByb3BJZHggPCBwcm9wTGVuOyBwcm9wSWR4KyspIHtcbiAgICAgIHJlc3VsdCArPSBzdHJpbmdpZnkucHJvcGVydHkocHJvcHNbcHJvcElkeF0sIGRlc2lnblNldCkgKyBMSU5FX0VORElORztcbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgc3ViY29tcG9uZW50cyBpZiBub25lIGV4aXN0LCBlLmcuIGluIHZDYXJkLlxuICAgIHZhciBjb21wcyA9IGNvbXBvbmVudFsyXSB8fCBbXTtcbiAgICB2YXIgY29tcElkeCA9IDA7XG4gICAgdmFyIGNvbXBMZW4gPSBjb21wcy5sZW5ndGg7XG5cbiAgICBmb3IgKDsgY29tcElkeCA8IGNvbXBMZW47IGNvbXBJZHgrKykge1xuICAgICAgcmVzdWx0ICs9IHN0cmluZ2lmeS5jb21wb25lbnQoY29tcHNbY29tcElkeF0sIGRlc2lnblNldCkgKyBMSU5FX0VORElORztcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gJ0VORDonICsgbmFtZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHNpbmdsZSBqQ2FsL2pDYXJkIHByb3BlcnR5IHRvIGEgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5LnByb3BlcnR5XG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BlcnR5XG4gICAqICAgICAgICBqQ2FsL2pDYXJkIHByb3BlcnR5IGFycmF5XG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0fSBkZXNpZ25TZXRcbiAgICogICAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBub0ZvbGRcbiAgICogICAgICAgIElmIHRydWUsIHRoZSBsaW5lIGlzIG5vdCBmb2xkZWRcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICBUaGUgaUNhbGVuZGFyL3ZDYXJkIHN0cmluZ1xuICAgKi9cbiAgc3RyaW5naWZ5LnByb3BlcnR5ID0gZnVuY3Rpb24ocHJvcGVydHksIGRlc2lnblNldCwgbm9Gb2xkKSB7XG4gICAgdmFyIG5hbWUgPSBwcm9wZXJ0eVswXS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBqc05hbWUgPSBwcm9wZXJ0eVswXTtcbiAgICB2YXIgcGFyYW1zID0gcHJvcGVydHlbMV07XG5cbiAgICB2YXIgbGluZSA9IG5hbWU7XG5cbiAgICB2YXIgcGFyYW1OYW1lO1xuICAgIGZvciAocGFyYW1OYW1lIGluIHBhcmFtcykge1xuICAgICAgdmFyIHZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KHBhcmFtTmFtZSkpIHtcbiAgICAgICAgdmFyIG11bHRpVmFsdWUgPSAocGFyYW1OYW1lIGluIGRlc2lnblNldC5wYXJhbSkgJiYgZGVzaWduU2V0LnBhcmFtW3BhcmFtTmFtZV0ubXVsdGlWYWx1ZTtcbiAgICAgICAgaWYgKG11bHRpVmFsdWUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVzaWduU2V0LnBhcmFtW3BhcmFtTmFtZV0ubXVsdGlWYWx1ZVNlcGFyYXRlRFF1b3RlKSB7XG4gICAgICAgICAgICBtdWx0aVZhbHVlID0gJ1wiJyArIG11bHRpVmFsdWUgKyAnXCInO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLm1hcChzdHJpbmdpZnkuX3JmYzY4NjhVbmVzY2FwZSk7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdpZnkubXVsdGlWYWx1ZSh2YWx1ZSwgbXVsdGlWYWx1ZSwgXCJ1bmtub3duXCIsIG51bGwsIGRlc2lnblNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdpZnkuX3JmYzY4NjhVbmVzY2FwZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGxpbmUgKz0gJzsnICsgcGFyYW1OYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGxpbmUgKz0gJz0nICsgc3RyaW5naWZ5LnByb3BlcnR5VmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9wZXJ0eS5sZW5ndGggPT09IDMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSBubyB2YWx1ZXMsIHdlIG11c3QgYXNzdW1lIGEgYmxhbmsgdmFsdWVcbiAgICAgIHJldHVybiBsaW5lICsgJzonO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZVR5cGUgPSBwcm9wZXJ0eVsyXTtcblxuICAgIGlmICghZGVzaWduU2V0KSB7XG4gICAgICBkZXNpZ25TZXQgPSBkZXNpZ24uZGVmYXVsdFNldDtcbiAgICB9XG5cbiAgICB2YXIgcHJvcERldGFpbHM7XG4gICAgdmFyIG11bHRpVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgc3RydWN0dXJlZFZhbHVlID0gZmFsc2U7XG4gICAgdmFyIGlzRGVmYXVsdCA9IGZhbHNlO1xuXG4gICAgaWYgKGpzTmFtZSBpbiBkZXNpZ25TZXQucHJvcGVydHkpIHtcbiAgICAgIHByb3BEZXRhaWxzID0gZGVzaWduU2V0LnByb3BlcnR5W2pzTmFtZV07XG5cbiAgICAgIGlmICgnbXVsdGlWYWx1ZScgaW4gcHJvcERldGFpbHMpIHtcbiAgICAgICAgbXVsdGlWYWx1ZSA9IHByb3BEZXRhaWxzLm11bHRpVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgoJ3N0cnVjdHVyZWRWYWx1ZScgaW4gcHJvcERldGFpbHMpICYmIEFycmF5LmlzQXJyYXkocHJvcGVydHlbM10pKSB7XG4gICAgICAgIHN0cnVjdHVyZWRWYWx1ZSA9IHByb3BEZXRhaWxzLnN0cnVjdHVyZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdkZWZhdWx0VHlwZScgaW4gcHJvcERldGFpbHMpIHtcbiAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gcHJvcERldGFpbHMuZGVmYXVsdFR5cGUpIHtcbiAgICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsdWVUeXBlID09PSBERUZBVUxUX1ZBTFVFX1RZUEUpIHtcbiAgICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZVR5cGUgPT09IERFRkFVTFRfVkFMVUVfVFlQRSkge1xuICAgICAgICBpc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHB1c2ggdGhlIFZBTFVFIHByb3BlcnR5IGlmIHR5cGUgaXMgbm90IHRoZSBkZWZhdWx0XG4gICAgLy8gZm9yIHRoZSBjdXJyZW50IHByb3BlcnR5LlxuICAgIGlmICghaXNEZWZhdWx0KSB7XG4gICAgICAvLyB2YWx1ZSB3aWxsIG5ldmVyIGNvbnRhaW4gOy86Lywgc28gd2UgZG9uJ3QgZXNjYXBlIGl0IGhlcmUuXG4gICAgICBsaW5lICs9ICc7VkFMVUU9JyArIHZhbHVlVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgIH1cblxuICAgIGxpbmUgKz0gJzonO1xuXG4gICAgaWYgKG11bHRpVmFsdWUgJiYgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgICBsaW5lICs9IHN0cmluZ2lmeS5tdWx0aVZhbHVlKFxuICAgICAgICBwcm9wZXJ0eVszXSwgc3RydWN0dXJlZFZhbHVlLCB2YWx1ZVR5cGUsIG11bHRpVmFsdWUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgbGluZSArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZShcbiAgICAgICAgcHJvcGVydHkuc2xpY2UoMyksIG11bHRpVmFsdWUsIHZhbHVlVHlwZSwgbnVsbCwgZGVzaWduU2V0LCBmYWxzZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgICAgbGluZSArPSBzdHJpbmdpZnkubXVsdGlWYWx1ZShcbiAgICAgICAgcHJvcGVydHlbM10sIHN0cnVjdHVyZWRWYWx1ZSwgdmFsdWVUeXBlLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZSArPSBzdHJpbmdpZnkudmFsdWUocHJvcGVydHlbM10sIHZhbHVlVHlwZSwgZGVzaWduU2V0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vRm9sZCA/IGxpbmUgOiBJQ0FMLmhlbHBlcnMuZm9sZGxpbmUobGluZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXNjYXBpbmcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgbWF5IGNvbnRhaW46XG4gICAqXG4gICAqICAgIENPTE9OICg6KSwgU0VNSUNPTE9OICg7KSwgb3IgQ09NTUEgKCwpXG4gICAqXG4gICAqIElmIGFueSBvZiB0aGUgYWJvdmUgYXJlIHByZXNlbnQgdGhlIHJlc3VsdCBpcyB3cmFwcGVkXG4gICAqIGluIGRvdWJsZSBxdW90ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnN0cmluZ2lmeS5wcm9wZXJ0eVZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICAgIFJhdyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBHaXZlbiBvciBlc2NhcGVkIHZhbHVlIHdoZW4gbmVlZGVkXG4gICAqL1xuICBzdHJpbmdpZnkucHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cbiAgICBpZiAoKGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZih2YWx1ZSwgJywnKSA9PT0gLTEpICYmXG4gICAgICAgIChoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YodmFsdWUsICc6JykgPT09IC0xKSAmJlxuICAgICAgICAoaGVscGVycy51bmVzY2FwZWRJbmRleE9mKHZhbHVlLCAnOycpID09PSAtMSkpIHtcblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBhcnJheSBvZiBpY2FsIHZhbHVlcyBpbnRvIGEgc2luZ2xlXG4gICAqIHN0cmluZyBiYXNlZCBvbiBhIHR5cGUgYW5kIGEgZGVsaW1pdGVyIHZhbHVlIChsaWtlIFwiLFwiKS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5Lm11bHRpVmFsdWVcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzICAgICAgTGlzdCBvZiB2YWx1ZXMgdG8gY29udmVydFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGVsaW0gICAgICBVc2VkIHRvIGpvaW4gdGhlIHZhbHVlcyAoXCIsXCIsIFwiO1wiLCBcIjpcIilcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgTG93ZWNhc2UgaWNhbCB2YWx1ZSB0eXBlXG4gICAqICAgICAgICAobGlrZSBib29sZWFuLCBkYXRlLXRpbWUsIGV0Yy4uKVxuICAgKiBAcGFyYW0gez9TdHJpbmd9IGlubmVyTXVsdGkgSWYgc2V0LCBlYWNoIHZhbHVlIHdpbGwgYWdhaW4gYmUgcHJvY2Vzc2VkXG4gICAqICAgICAgICBVc2VkIGZvciBzdHJ1Y3R1cmVkIHZhbHVlc1xuICAgKiBAcGFyYW0ge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0XG4gICAqICAgICAgICBUaGUgZGVzaWduIGRhdGEgdG8gdXNlIGZvciB0aGlzIHByb3BlcnR5XG4gICAqXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIGlDYWxlbmRhci92Q2FyZCBzdHJpbmcgZm9yIHZhbHVlXG4gICAqL1xuICBzdHJpbmdpZnkubXVsdGlWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlcywgZGVsaW0sIHR5cGUsIGlubmVyTXVsdGksIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChpbm5lck11bHRpICYmIEFycmF5LmlzQXJyYXkodmFsdWVzW2ldKSkge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5naWZ5Lm11bHRpVmFsdWUodmFsdWVzW2ldLCBpbm5lck11bHRpLCB0eXBlLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgKz0gc3RyaW5naWZ5LnZhbHVlKHZhbHVlc1tpXSwgdHlwZSwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSAhPT0gKGxlbiAtIDEpKSB7XG4gICAgICAgIHJlc3VsdCArPSBkZWxpbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgYSBzaW5nbGUgaWNhbCB2YWx1ZSBydW5zIHRoZSBhc3NvY2lhdGVkIFwidG9JQ0FMXCIgbWV0aG9kIGZyb20gdGhlXG4gICAqIGRlc2lnbiB2YWx1ZSB0eXBlIGlmIGF2YWlsYWJsZSB0byBjb252ZXJ0IHRoZSB2YWx1ZS5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwuc3RyaW5naWZ5LnZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsdWUgICAgICAgQSBmb3JtYXR0ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgICAgICAgICBMb3dlcmNhc2UgaUNhbGVuZGFyL3ZDYXJkIHZhbHVlIHR5cGVcbiAgICogIChsaWtlIGJvb2xlYW4sIGRhdGUtdGltZSwgZXRjLi4pXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgICAgICAgaUNhbGVuZGFyL3ZDYXJkIHZhbHVlIGZvciBzaW5nbGUgdmFsdWVcbiAgICovXG4gIHN0cmluZ2lmeS52YWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSkge1xuICAgIGlmICh0eXBlIGluIGRlc2lnblNldC52YWx1ZSAmJiAndG9JQ0FMJyBpbiBkZXNpZ25TZXQudmFsdWVbdHlwZV0pIHtcbiAgICAgIHJldHVybiBkZXNpZ25TZXQudmFsdWVbdHlwZV0udG9JQ0FMKHZhbHVlLCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGhlbHBlciBmb3IgcmZjNjg2OC4gRXhwb3NpbmcgdGhpcyBvbiBJQ0FMLnN0cmluZ2lmeSBzbyB0aGF0XG4gICAqIGhhY2tlcnMgY2FuIGRpc2FibGUgdGhlIHJmYzY4NjggcGFyc2luZyBpZiB0aGUgcmVhbGx5IG5lZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgICAgICAgIFRoZSB2YWx1ZSB0byB1bmVzY2FwZVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICBUaGUgZXNjYXBlZCB2YWx1ZVxuICAgKi9cbiAgc3RyaW5naWZ5Ll9yZmM2ODY4VW5lc2NhcGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gdmFsLnJlcGxhY2UoL1tcXG5eXCJdL2csIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBSRkM2ODY4X1JFUExBQ0VfTUFQW3hdO1xuICAgIH0pO1xuICB9O1xuICB2YXIgUkZDNjg2OF9SRVBMQUNFX01BUCA9IHsgJ1wiJzogXCJeJ1wiLCBcIlxcblwiOiBcIl5uXCIsIFwiXlwiOiBcIl5eXCIgfTtcblxuICByZXR1cm4gc3RyaW5naWZ5O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBDb250YWlucyB2YXJpb3VzIGZ1bmN0aW9ucyB0byBwYXJzZSBpQ2FsZW5kYXIgYW5kIHZDYXJkIGRhdGEuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbklDQUwucGFyc2UgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ0hBUiA9IC9bXiBcXHRdLztcbiAgdmFyIE1VTFRJVkFMVUVfREVMSU1JVEVSID0gJywnO1xuICB2YXIgVkFMVUVfREVMSU1JVEVSID0gJzonO1xuICB2YXIgUEFSQU1fREVMSU1JVEVSID0gJzsnO1xuICB2YXIgUEFSQU1fTkFNRV9ERUxJTUlURVIgPSAnPSc7XG4gIHZhciBERUZBVUxUX1ZBTFVFX1RZUEUgPSAndW5rbm93bic7XG4gIHZhciBERUZBVUxUX1BBUkFNX1RZUEUgPSAndGV4dCc7XG5cbiAgdmFyIGRlc2lnbiA9IElDQUwuZGVzaWduO1xuICB2YXIgaGVscGVycyA9IElDQUwuaGVscGVycztcblxuICAvKipcbiAgICogQW4gZXJyb3IgdGhhdCBvY2N1cnJlZCBkdXJpbmcgcGFyc2luZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgICAgICAgIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqIEBtZW1iZXJvZiBJQ0FMLnBhcnNlXG4gICAqIEBleHRlbmRzIHtFcnJvcn1cbiAgICogQGNsYXNzXG4gICAqL1xuICBmdW5jdGlvbiBQYXJzZXJFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSAnUGFyc2VyRXJyb3InO1xuXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLnN0YWNrKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgICBzcGxpdC5zaGlmdCgpO1xuICAgICAgICB0aGlzLnN0YWNrID0gc3BsaXQuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgUGFyc2VyRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgaUNhbGVuZGFyIG9yIHZDYXJkIGRhdGEgaW50byBhIHJhdyBqQ2FsIG9iamVjdC4gQ29uc3VsdFxuICAgKiBkb2N1bWVudGF0aW9uIG9uIHRoZSB7QHR1dG9yaWFsIGxheWVyc3xsYXllcnMgb2YgcGFyc2luZ30gZm9yIG1vcmVcbiAgICogZGV0YWlscy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2VcbiAgICogQHZhcmlhdGlvbiBmdW5jdGlvblxuICAgKiBAdG9kbyBGaXggdGhlIEFQSSB0byBiZSBtb3JlIGNsZWFyIG9uIHRoZSByZXR1cm4gdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgICAgICBUaGUgc3RyaW5nIGRhdGEgdG8gcGFyc2VcbiAgICogQHJldHVybiB7T2JqZWN0fE9iamVjdFtdfSAgQSBzaW5nbGUgakNhbCBvYmplY3QsIG9yIGFuIGFycmF5IHRoZXJlb2ZcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlcihpbnB1dCkge1xuICAgIHZhciBzdGF0ZSA9IHt9O1xuICAgIHZhciByb290ID0gc3RhdGUuY29tcG9uZW50ID0gW107XG5cbiAgICBzdGF0ZS5zdGFjayA9IFtyb290XTtcblxuICAgIHBhcnNlci5fZWFjaExpbmUoaW5wdXQsIGZ1bmN0aW9uKGVyciwgbGluZSkge1xuICAgICAgcGFyc2VyLl9oYW5kbGVDb250ZW50TGluZShsaW5lLCBzdGF0ZSk7XG4gICAgfSk7XG5cblxuICAgIC8vIHdoZW4gdGhlcmUgYXJlIHN0aWxsIGl0ZW1zIG9uIHRoZSBzdGFja1xuICAgIC8vIHRocm93IGEgZmF0YWwgZXJyb3IsIGEgY29tcG9uZW50IHdhcyBub3QgY2xvc2VkXG4gICAgLy8gY29ycmVjdGx5IGluIHRoYXQgY2FzZS5cbiAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFxuICAgICAgICAnaW52YWxpZCBpY2FsIGJvZHkuIGNvbXBvbmVudCBiZWdhbiBidXQgZGlkIG5vdCBlbmQnXG4gICAgICApO1xuICAgIH1cblxuICAgIHN0YXRlID0gbnVsbDtcblxuICAgIHJldHVybiAocm9vdC5sZW5ndGggPT0gMSA/IHJvb3RbMF0gOiByb290KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbiBpQ2FsZW5kYXIgcHJvcGVydHkgdmFsdWUgaW50byB0aGUgakNhbCBmb3IgYSBzaW5nbGUgcHJvcGVydHlcbiAgICpcbiAgICogQGZ1bmN0aW9uIElDQUwucGFyc2UucHJvcGVydHlcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgKiAgIFRoZSBpQ2FsZW5kYXIgcHJvcGVydHkgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7SUNBTC5kZXNpZ24uZGVzaWduU2V0PX0gZGVzaWduU2V0XG4gICAqICAgVGhlIGRlc2lnbiBkYXRhIHRvIHVzZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqICAgVGhlIGpDYWwgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnR5XG4gICAqL1xuICBwYXJzZXIucHJvcGVydHkgPSBmdW5jdGlvbihzdHIsIGRlc2lnblNldCkge1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIGNvbXBvbmVudDogW1tdLCBbXV0sXG4gICAgICBkZXNpZ25TZXQ6IGRlc2lnblNldCB8fCBkZXNpZ24uZGVmYXVsdFNldFxuICAgIH07XG4gICAgcGFyc2VyLl9oYW5kbGVDb250ZW50TGluZShzdHIsIHN0YXRlKTtcbiAgICByZXR1cm4gc3RhdGUuY29tcG9uZW50WzFdWzBdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcGFyc2UgYSBjb21wb25lbnQuIFlvdSBjYW4gdXNlIElDQUwucGFyc2UoKSBkaXJlY3RseVxuICAgKiBpbnN0ZWFkLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5jb21wb25lbnRcbiAgICogQHNlZSBJQ0FMLnBhcnNlKGZ1bmN0aW9uKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgIFRoZSBpQ2FsZW5kYXIgY29tcG9uZW50IHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFRoZSBqQ2FsIE9iamVjdCBjb250YWluaW5nIHRoZSBjb21wb25lbnRcbiAgICovXG4gIHBhcnNlci5jb21wb25lbnQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VyKHN0cik7XG4gIH07XG5cbiAgLy8gY2xhc3NlcyAmIGNvbnN0YW50c1xuICBwYXJzZXIuUGFyc2VyRXJyb3IgPSBQYXJzZXJFcnJvcjtcblxuICAvKipcbiAgICogVGhlIHN0YXRlIGZvciBwYXJzaW5nIGNvbnRlbnQgbGluZXMgZnJvbSBhbiBpQ2FsZW5kYXIvdkNhcmQgc3RyaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2YgSUNBTC5wYXJzZVxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBwYXJzZXJTdGF0ZVxuICAgKiBAcHJvcGVydHkge0lDQUwuZGVzaWduLmRlc2lnblNldH0gZGVzaWduU2V0ICAgIFRoZSBkZXNpZ24gc2V0IHRvIHVzZSBmb3IgcGFyc2luZ1xuICAgKiBAcHJvcGVydHkge0lDQUwuQ29tcG9uZW50W119IHN0YWNrICAgICAgICAgICAgIFRoZSBzdGFjayBvZiBjb21wb25lbnRzIGJlaW5nIHByb2Nlc3NlZFxuICAgKiBAcHJvcGVydHkge0lDQUwuQ29tcG9uZW50fSBjb21wb25lbnQgICAgICAgICAgIFRoZSBjdXJyZW50bHkgYWN0aXZlIGNvbXBvbmVudFxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgc2luZ2xlIGxpbmUgb2YgaUNhbGVuZGFyL3ZDYXJkLCB1cGRhdGluZyB0aGUgc3RhdGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9oYW5kbGVDb250ZW50TGluZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSAgICAgICAgICAgICAgIFRoZSBjb250ZW50IGxpbmUgdG8gcHJvY2Vzc1xuICAgKiBAcGFyYW0ge0lDQUwucGFyc2UucGFyc2VyU3RhdGV9ICAgIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBsaW5lIHBhcnNpbmdcbiAgICovXG4gIHBhcnNlci5faGFuZGxlQ29udGVudExpbmUgPSBmdW5jdGlvbihsaW5lLCBzdGF0ZSkge1xuICAgIC8vIGJyZWFrIHVwIHRoZSBwYXJ0cyBvZiB0aGUgbGluZVxuICAgIHZhciB2YWx1ZVBvcyA9IGxpbmUuaW5kZXhPZihWQUxVRV9ERUxJTUlURVIpO1xuICAgIHZhciBwYXJhbVBvcyA9IGxpbmUuaW5kZXhPZihQQVJBTV9ERUxJTUlURVIpO1xuXG4gICAgdmFyIGxhc3RQYXJhbUluZGV4O1xuICAgIHZhciBsYXN0VmFsdWVQb3M7XG5cbiAgICAvLyBuYW1lIG9mIHByb3BlcnR5IG9yIGJlZ2luL2VuZFxuICAgIHZhciBuYW1lO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBwYXJhbXMgaXMgb25seSBvdmVycmlkZGVuIGlmIHBhcmFtUG9zICE9PSAtMS5cbiAgICAvLyB3ZSBjYW4ndCBkbyBwYXJhbXMgPSBwYXJhbXMgfHwge30gbGF0ZXIgb25cbiAgICAvLyBiZWNhdXNlIGl0IHNhY3JpZmljZXMgb3BzLlxuICAgIHZhciBwYXJhbXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIERpZmZlcmVudCBwcm9wZXJ0eSBjYXNlc1xuICAgICAqXG4gICAgICpcbiAgICAgKiAxLiBSUlVMRTpGUkVRPWZvb1xuICAgICAqICAgIC8vIEZSRVE9IGlzIG5vdCBhIHBhcmFtIGJ1dCB0aGUgdmFsdWVcbiAgICAgKlxuICAgICAqIDIuIEFUVEVOREVFO1JPTEU9UkVRLVBBUlRJQ0lQQU5UO1xuICAgICAqICAgIC8vIFJPTEU9IGlzIGEgcGFyYW0gYmVjYXVzZSA6IGhhcyBub3QgaGFwcGVuZWQgeWV0XG4gICAgICovXG4gICAgICAvLyB3aGVuIHRoZSBwYXJhbWV0ZXIgZGVsaW1pdGVyIGlzIGFmdGVyIHRoZVxuICAgICAgLy8gdmFsdWUgZGVsaW1pdGVyIHRoZW4gaXQgaXMgbm90IGEgcGFyYW1ldGVyLlxuXG4gICAgaWYgKChwYXJhbVBvcyAhPT0gLTEgJiYgdmFsdWVQb3MgIT09IC0xKSkge1xuICAgICAgLy8gd2hlbiB0aGUgcGFyYW1ldGVyIGRlbGltaXRlciBpcyBhZnRlciB0aGVcbiAgICAgIC8vIHZhbHVlIGRlbGltaXRlciB0aGVuIGl0IGlzIG5vdCBhIHBhcmFtZXRlci5cbiAgICAgIGlmIChwYXJhbVBvcyA+IHZhbHVlUG9zKSB7XG4gICAgICAgIHBhcmFtUG9zID0gLTE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhcnNlZFBhcmFtcztcbiAgICBpZiAocGFyYW1Qb3MgIT09IC0xKSB7XG4gICAgICBuYW1lID0gbGluZS5zdWJzdHJpbmcoMCwgcGFyYW1Qb3MpLnRvTG93ZXJDYXNlKCk7XG4gICAgICBwYXJzZWRQYXJhbXMgPSBwYXJzZXIuX3BhcnNlUGFyYW1ldGVycyhsaW5lLnN1YnN0cmluZyhwYXJhbVBvcyksIDAsIHN0YXRlLmRlc2lnblNldCk7XG4gICAgICBpZiAocGFyc2VkUGFyYW1zWzJdID09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcIkludmFsaWQgcGFyYW1ldGVycyBpbiAnXCIgKyBsaW5lICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgcGFyYW1zID0gcGFyc2VkUGFyYW1zWzBdO1xuICAgICAgbGFzdFBhcmFtSW5kZXggPSBwYXJzZWRQYXJhbXNbMV0ubGVuZ3RoICsgcGFyc2VkUGFyYW1zWzJdICsgcGFyYW1Qb3M7XG4gICAgICBpZiAoKGxhc3RWYWx1ZVBvcyA9XG4gICAgICAgIGxpbmUuc3Vic3RyaW5nKGxhc3RQYXJhbUluZGV4KS5pbmRleE9mKFZBTFVFX0RFTElNSVRFUikpICE9PSAtMSkge1xuICAgICAgICB2YWx1ZSA9IGxpbmUuc3Vic3RyaW5nKGxhc3RQYXJhbUluZGV4ICsgbGFzdFZhbHVlUG9zICsgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VyRXJyb3IoXCJNaXNzaW5nIHBhcmFtZXRlciB2YWx1ZSBpbiAnXCIgKyBsaW5lICsgXCInXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsdWVQb3MgIT09IC0xKSB7XG4gICAgICAvLyB3aXRob3V0IHBhcm1ldGVycyAoQkVHSU46VkNBRU5EQVIsIENMQVNTOlBVQkxJQylcbiAgICAgIG5hbWUgPSBsaW5lLnN1YnN0cmluZygwLCB2YWx1ZVBvcykudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhbHVlID0gbGluZS5zdWJzdHJpbmcodmFsdWVQb3MgKyAxKTtcblxuICAgICAgaWYgKG5hbWUgPT09ICdiZWdpbicpIHtcbiAgICAgICAgdmFyIG5ld0NvbXBvbmVudCA9IFt2YWx1ZS50b0xvd2VyQ2FzZSgpLCBbXSwgW11dO1xuICAgICAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgc3RhdGUuY29tcG9uZW50LnB1c2gobmV3Q29tcG9uZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5jb21wb25lbnRbMl0ucHVzaChuZXdDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnN0YWNrLnB1c2goc3RhdGUuY29tcG9uZW50KTtcbiAgICAgICAgc3RhdGUuY29tcG9uZW50ID0gbmV3Q29tcG9uZW50O1xuICAgICAgICBpZiAoIXN0YXRlLmRlc2lnblNldCkge1xuICAgICAgICAgIHN0YXRlLmRlc2lnblNldCA9IGRlc2lnbi5nZXREZXNpZ25TZXQoc3RhdGUuY29tcG9uZW50WzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdlbmQnKSB7XG4gICAgICAgIHN0YXRlLmNvbXBvbmVudCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBJZiBpdCBpcyBub3QgYmVnaW4vZW5kLCB0aGVuIHRoaXMgaXMgYSBwcm9wZXJ0eSB3aXRoIGFuIGVtcHR5IHZhbHVlLFxuICAgICAgLy8gd2hpY2ggc2hvdWxkIGJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogSW52YWxpZCBsaW5lLlxuICAgICAgICogVGhlIHJhdGlvbmFsIHRvIHRocm93IGFuIGVycm9yIGlzIHdlIHdpbGxcbiAgICAgICAqIG5ldmVyIGJlIGNlcnRhaW4gdGhhdCB0aGUgcmVzdCBvZiB0aGUgZmlsZVxuICAgICAgICogaXMgc2FuZSBhbmQgaXQgaXMgdW5saWtlbHkgdGhhdCB3ZSBjYW4gc2VyaWFsaXplXG4gICAgICAgKiB0aGUgcmVzdWx0IGNvcnJlY3RseSBlaXRoZXIuXG4gICAgICAgKi9cbiAgICAgIHRocm93IG5ldyBQYXJzZXJFcnJvcihcbiAgICAgICAgJ2ludmFsaWQgbGluZSAobm8gdG9rZW4gXCI7XCIgb3IgXCI6XCIpIFwiJyArIGxpbmUgKyAnXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZVR5cGU7XG4gICAgdmFyIG11bHRpVmFsdWUgPSBmYWxzZTtcbiAgICB2YXIgc3RydWN0dXJlZFZhbHVlID0gZmFsc2U7XG4gICAgdmFyIHByb3BlcnR5RGV0YWlscztcblxuICAgIGlmIChuYW1lIGluIHN0YXRlLmRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgcHJvcGVydHlEZXRhaWxzID0gc3RhdGUuZGVzaWduU2V0LnByb3BlcnR5W25hbWVdO1xuXG4gICAgICBpZiAoJ211bHRpVmFsdWUnIGluIHByb3BlcnR5RGV0YWlscykge1xuICAgICAgICBtdWx0aVZhbHVlID0gcHJvcGVydHlEZXRhaWxzLm11bHRpVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICgnc3RydWN0dXJlZFZhbHVlJyBpbiBwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgICAgc3RydWN0dXJlZFZhbHVlID0gcHJvcGVydHlEZXRhaWxzLnN0cnVjdHVyZWRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlICYmICdkZXRlY3RUeXBlJyBpbiBwcm9wZXJ0eURldGFpbHMpIHtcbiAgICAgICAgdmFsdWVUeXBlID0gcHJvcGVydHlEZXRhaWxzLmRldGVjdFR5cGUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF0dGVtcHQgdG8gZGV0ZXJtaW5lIHZhbHVlXG4gICAgaWYgKCF2YWx1ZVR5cGUpIHtcbiAgICAgIGlmICghKCd2YWx1ZScgaW4gcGFyYW1zKSkge1xuICAgICAgICBpZiAocHJvcGVydHlEZXRhaWxzKSB7XG4gICAgICAgICAgdmFsdWVUeXBlID0gcHJvcGVydHlEZXRhaWxzLmRlZmF1bHRUeXBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlVHlwZSA9IERFRkFVTFRfVkFMVUVfVFlQRTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcG9zc2libGUgdG8gYXZvaWQgdGhpcz9cbiAgICAgICAgdmFsdWVUeXBlID0gcGFyYW1zLnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlIHBhcmFtcy52YWx1ZTtcblxuICAgIC8qKlxuICAgICAqIE5vdGUgb24gYHZhciByZXN1bHRgIGp1Z2dsaW5nOlxuICAgICAqXG4gICAgICogSSBvYnNlcnZlZCB0aGF0IGJ1aWxkaW5nIHRoZSBhcnJheSBpbiBwaWVjZXMgaGFzIGFkdmVyc2VcbiAgICAgKiBlZmZlY3RzIG9uIHBlcmZvcm1hbmNlLCBzbyB3aGVyZSBwb3NzaWJsZSB3ZSBpbmxpbmUgdGhlIGNyZWF0aW9uLlxuICAgICAqIEl0IGlzIGEgbGl0dGxlIHVnbHkgYnV0IHJlc3VsdGVkIGluIH4yMDAwIGFkZGl0aW9uYWwgb3BzL3NlYy5cbiAgICAgKi9cblxuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKG11bHRpVmFsdWUgJiYgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBzdHJ1Y3R1cmVkVmFsdWUsIHZhbHVlVHlwZSwgW10sIG11bHRpVmFsdWUsIHN0YXRlLmRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICAgIHJlc3VsdCA9IFtuYW1lLCBwYXJhbXMsIHZhbHVlVHlwZSwgdmFsdWVdO1xuICAgIH0gZWxzZSBpZiAobXVsdGlWYWx1ZSkge1xuICAgICAgcmVzdWx0ID0gW25hbWUsIHBhcmFtcywgdmFsdWVUeXBlXTtcbiAgICAgIHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBtdWx0aVZhbHVlLCB2YWx1ZVR5cGUsIHJlc3VsdCwgbnVsbCwgc3RhdGUuZGVzaWduU2V0LCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChzdHJ1Y3R1cmVkVmFsdWUpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIHN0cnVjdHVyZWRWYWx1ZSwgdmFsdWVUeXBlLCBbXSwgbnVsbCwgc3RhdGUuZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgcmVzdWx0ID0gW25hbWUsIHBhcmFtcywgdmFsdWVUeXBlLCB2YWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZVZhbHVlKHZhbHVlLCB2YWx1ZVR5cGUsIHN0YXRlLmRlc2lnblNldCwgZmFsc2UpO1xuICAgICAgcmVzdWx0ID0gW25hbWUsIHBhcmFtcywgdmFsdWVUeXBlLCB2YWx1ZV07XG4gICAgfVxuICAgIC8vIHJmYzYzNTAgcmVxdWlyZXMgdGhhdCBpbiB2Q2FyZCA0LjAgdGhlIGZpcnN0IGNvbXBvbmVudCBpcyB0aGUgVkVSU0lPTlxuICAgIC8vIGNvbXBvbmVudCB3aXRoIGFzIHZhbHVlIDQuMCwgbm90ZSB0aGF0IDMuMCBkb2VzIG5vdCBoYXZlIHRoaXMgcmVxdWlyZW1lbnQuXG4gICAgaWYgKHN0YXRlLmNvbXBvbmVudFswXSA9PT0gJ3ZjYXJkJyAmJiBzdGF0ZS5jb21wb25lbnRbMV0ubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAhKG5hbWUgPT09ICd2ZXJzaW9uJyAmJiB2YWx1ZSA9PT0gJzQuMCcpKSB7XG4gICAgICBzdGF0ZS5kZXNpZ25TZXQgPSBkZXNpZ24uZ2V0RGVzaWduU2V0KFwidmNhcmQzXCIpO1xuICAgIH1cbiAgICBzdGF0ZS5jb21wb25lbnRbMV0ucHVzaChyZXN1bHQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHZhbHVlIGZyb20gdGhlIHJhdyB2YWx1ZSBpbnRvIHRoZSBqQ2FyZC9qQ2FsIHZhbHVlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5fcGFyc2VWYWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgICAgICAgICAgT3JpZ2luYWwgdmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgICAgIFR5cGUgb2YgdmFsdWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2lnblNldCAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgdmFsdWVcbiAgICogQHJldHVybiB7T2JqZWN0fSB2YXJpZXMgb24gdHlwZVxuICAgKi9cbiAgcGFyc2VyLl9wYXJzZVZhbHVlID0gZnVuY3Rpb24odmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgaWYgKHR5cGUgaW4gZGVzaWduU2V0LnZhbHVlICYmICdmcm9tSUNBTCcgaW4gZGVzaWduU2V0LnZhbHVlW3R5cGVdKSB7XG4gICAgICByZXR1cm4gZGVzaWduU2V0LnZhbHVlW3R5cGVdLmZyb21JQ0FMKHZhbHVlLCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlIHBhcmFtZXRlcnMgZnJvbSBhIHN0cmluZyB0byBvYmplY3QuXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9wYXJzZVBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmUgICAgICAgICAgIEEgc2luZ2xlIHVuZm9sZGVkIGxpbmVcbiAgICogQHBhcmFtIHtOdW1lcmljfSBzdGFydCAgICAgICAgIFBvc2l0aW9uIHRvIHN0YXJ0IGxvb2tpbmcgZm9yIHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGRlc2lnblNldCAgICAgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHJldHVybiB7T2JqZWN0fSBrZXkvdmFsdWUgcGFpcnNcbiAgICovXG4gIHBhcnNlci5fcGFyc2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24obGluZSwgc3RhcnQsIGRlc2lnblNldCkge1xuICAgIHZhciBsYXN0UGFyYW0gPSBzdGFydDtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgZGVsaW0gPSBQQVJBTV9OQU1FX0RFTElNSVRFUjtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIG5hbWUsIGxjbmFtZTtcbiAgICB2YXIgdmFsdWUsIHZhbHVlUG9zID0gLTE7XG4gICAgdmFyIHR5cGUsIG11bHRpVmFsdWUsIG12ZGVsaW07XG5cbiAgICAvLyBmaW5kIHRoZSBuZXh0ICc9JyBzaWduXG4gICAgLy8gdXNlIGxhc3RQYXJhbSBhbmQgcG9zIHRvIGZpbmQgbmFtZVxuICAgIC8vIGNoZWNrIGlmIFwiIGlzIHVzZWQgaWYgc28gZ2V0IHZhbHVlIGZyb20gXCItPlwiXG4gICAgLy8gdGhlbiBpbmNyZW1lbnQgcG9zIHRvIGZpbmQgbmV4dCA7XG5cbiAgICB3aGlsZSAoKHBvcyAhPT0gZmFsc2UpICYmXG4gICAgICAgICAgIChwb3MgPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgZGVsaW0sIHBvcyArIDEpKSAhPT0gLTEpIHtcblxuICAgICAgbmFtZSA9IGxpbmUuc3Vic3RyKGxhc3RQYXJhbSArIDEsIHBvcyAtIGxhc3RQYXJhbSAtIDEpO1xuICAgICAgaWYgKG5hbWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFwiRW1wdHkgcGFyYW1ldGVyIG5hbWUgaW4gJ1wiICsgbGluZSArIFwiJ1wiKTtcbiAgICAgIH1cbiAgICAgIGxjbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIG12ZGVsaW0gPSBmYWxzZTtcbiAgICAgIG11bHRpVmFsdWUgPSBmYWxzZTtcblxuICAgICAgaWYgKGxjbmFtZSBpbiBkZXNpZ25TZXQucGFyYW0gJiYgZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0udmFsdWVUeXBlKSB7XG4gICAgICAgIHR5cGUgPSBkZXNpZ25TZXQucGFyYW1bbGNuYW1lXS52YWx1ZVR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gREVGQVVMVF9QQVJBTV9UWVBFO1xuICAgICAgfVxuXG4gICAgICBpZiAobGNuYW1lIGluIGRlc2lnblNldC5wYXJhbSkge1xuICAgICAgICBtdWx0aVZhbHVlID0gZGVzaWduU2V0LnBhcmFtW2xjbmFtZV0ubXVsdGlWYWx1ZTtcbiAgICAgICAgaWYgKGRlc2lnblNldC5wYXJhbVtsY25hbWVdLm11bHRpVmFsdWVTZXBhcmF0ZURRdW90ZSkge1xuICAgICAgICAgIG12ZGVsaW0gPSBwYXJzZXIuX3JmYzY4NjhFc2NhcGUoJ1wiJyArIG11bHRpVmFsdWUgKyAnXCInKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbmV4dENoYXIgPSBsaW5lW3BvcyArIDFdO1xuICAgICAgaWYgKG5leHRDaGFyID09PSAnXCInKSB7XG4gICAgICAgIHZhbHVlUG9zID0gcG9zICsgMjtcbiAgICAgICAgcG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsICdcIicsIHZhbHVlUG9zKTtcbiAgICAgICAgaWYgKG11bHRpVmFsdWUgJiYgcG9zICE9IC0xKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW5kZWRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoZXh0ZW5kZWRWYWx1ZSkge1xuICAgICAgICAgICAgICBpZiAobGluZVtwb3MgKyAxXSA9PSBtdWx0aVZhbHVlICYmIGxpbmVbcG9zICsgMl0gPT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIHBvcyA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihsaW5lLCAnXCInLCBwb3MgKyAzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleHRlbmRlZFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFBhcnNlckVycm9yKFxuICAgICAgICAgICAgJ2ludmFsaWQgbGluZSAobm8gbWF0Y2hpbmcgZG91YmxlIHF1b3RlKSBcIicgKyBsaW5lICsgJ1wiJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBsaW5lLnN1YnN0cih2YWx1ZVBvcywgcG9zIC0gdmFsdWVQb3MpO1xuICAgICAgICBsYXN0UGFyYW0gPSBoZWxwZXJzLnVuZXNjYXBlZEluZGV4T2YobGluZSwgUEFSQU1fREVMSU1JVEVSLCBwb3MpO1xuICAgICAgICBpZiAobGFzdFBhcmFtID09PSAtMSkge1xuICAgICAgICAgIHBvcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZVBvcyA9IHBvcyArIDE7XG5cbiAgICAgICAgLy8gbW92ZSB0byBuZXh0IFwiO1wiXG4gICAgICAgIHZhciBuZXh0UG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsIFBBUkFNX0RFTElNSVRFUiwgdmFsdWVQb3MpO1xuICAgICAgICB2YXIgcHJvcFZhbHVlUG9zID0gaGVscGVycy51bmVzY2FwZWRJbmRleE9mKGxpbmUsIFZBTFVFX0RFTElNSVRFUiwgdmFsdWVQb3MpO1xuICAgICAgICBpZiAocHJvcFZhbHVlUG9zICE9PSAtMSAmJiBuZXh0UG9zID4gcHJvcFZhbHVlUG9zKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyBhIGRlbGltaXRlciBpbiB0aGUgcHJvcGVydHkgdmFsdWUsIGxldCdzIHN0b3AgaGVyZVxuICAgICAgICAgIG5leHRQb3MgPSBwcm9wVmFsdWVQb3M7XG4gICAgICAgICAgcG9zID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAvLyBubyBcIjtcIlxuICAgICAgICAgIGlmIChwcm9wVmFsdWVQb3MgPT09IC0xKSB7XG4gICAgICAgICAgICBuZXh0UG9zID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHRQb3MgPSBwcm9wVmFsdWVQb3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RQYXJhbSA9IG5leHRQb3M7XG4gICAgICAgICAgcG9zID0gbmV4dFBvcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gbGluZS5zdWJzdHIodmFsdWVQb3MsIG5leHRQb3MgLSB2YWx1ZVBvcyk7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gcGFyc2VyLl9yZmM2ODY4RXNjYXBlKHZhbHVlKTtcbiAgICAgIGlmIChtdWx0aVZhbHVlKSB7XG4gICAgICAgIHZhciBkZWxpbWl0ZXIgPSBtdmRlbGltIHx8IG11bHRpVmFsdWU7XG4gICAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIGRlbGltaXRlciwgdHlwZSwgW10sIG51bGwsIGRlc2lnblNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VWYWx1ZSh2YWx1ZSwgdHlwZSwgZGVzaWduU2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG11bHRpVmFsdWUgJiYgKGxjbmFtZSBpbiByZXN1bHQpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdFtsY25hbWVdKSkge1xuICAgICAgICAgIHJlc3VsdFtsY25hbWVdLnB1c2godmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFtsY25hbWVdID0gW1xuICAgICAgICAgICAgcmVzdWx0W2xjbmFtZV0sXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsY25hbWVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbcmVzdWx0LCB2YWx1ZSwgdmFsdWVQb3NdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBoZWxwZXIgZm9yIHJmYzY4NjguIEV4cG9zaW5nIHRoaXMgb24gSUNBTC5wYXJzZSBzbyB0aGF0XG4gICAqIGhhY2tlcnMgY2FuIGRpc2FibGUgdGhlIHJmYzY4NjggcGFyc2luZyBpZiB0aGUgcmVhbGx5IG5lZWQgdG8uXG4gICAqXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9yZmM2ODY4RXNjYXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWwgICAgICAgIFRoZSB2YWx1ZSB0byBlc2NhcGVcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgVGhlIGVzY2FwZWQgdmFsdWVcbiAgICovXG4gIHBhcnNlci5fcmZjNjg2OEVzY2FwZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiB2YWwucmVwbGFjZSgvXFxeWyduXl0vZywgZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFJGQzY4NjhfUkVQTEFDRV9NQVBbeF07XG4gICAgfSk7XG4gIH07XG4gIHZhciBSRkM2ODY4X1JFUExBQ0VfTUFQID0geyBcIl4nXCI6ICdcIicsIFwiXm5cIjogXCJcXG5cIiwgXCJeXlwiOiBcIl5cIiB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZSBhIG11bHRpIHZhbHVlIHN0cmluZy4gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGVpdGhlciBmb3IgcGFyc2luZ1xuICAgKiBhY3R1YWwgbXVsdGktdmFsdWUgcHJvcGVydHkncyB2YWx1ZXMsIG9yIGZvciBoYW5kbGluZyBwYXJhbWV0ZXIgdmFsdWVzLiBJdFxuICAgKiBjYW4gYmUgdXNlZCBmb3IgYm90aCBtdWx0aS12YWx1ZSBwcm9wZXJ0aWVzIGFuZCBzdHJ1Y3R1cmVkIHZhbHVlIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBmdW5jdGlvbiBJQ0FMLnBhcnNlLl9wYXJzZU11bHRpVmFsdWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAgICAgVGhlIGJ1ZmZlciBjb250YWluaW5nIHRoZSBmdWxsIHZhbHVlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBkZWxpbSAgICAgIFRoZSBtdWx0aS12YWx1ZSBkZWxpbWl0ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgICAgICAgVGhlIHZhbHVlIHR5cGUgdG8gYmUgcGFyc2VkXG4gICAqIEBwYXJhbSB7QXJyYXkuPD8+fSByZXN1bHQgICAgICAgIFRoZSBhcnJheSB0byBhcHBlbmQgcmVzdWx0cyB0bywgdmFyaWVzIG9uIHZhbHVlIHR5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlubmVyTXVsdGkgVGhlIGlubmVyIGRlbGltaXRlciB0byBzcGxpdCBlYWNoIHZhbHVlIHdpdGhcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9IGRlc2lnblNldCAgIFRoZSBkZXNpZ24gZGF0YSBmb3IgdGhpcyB2YWx1ZVxuICAgKiBAcmV0dXJuIHs/fEFycmF5Ljw/Pn0gICAgICAgICAgICBFaXRoZXIgYW4gYXJyYXkgb2YgcmVzdWx0cywgb3IgdGhlIGZpcnN0IHJlc3VsdFxuICAgKi9cbiAgcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUgPSBmdW5jdGlvbihidWZmZXIsIGRlbGltLCB0eXBlLCByZXN1bHQsIGlubmVyTXVsdGksIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKSB7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIGxhc3RQb3MgPSAwO1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAoZGVsaW0ubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cblxuICAgIC8vIHNwbGl0IGVhY2ggcGllY2VcbiAgICB3aGlsZSAoKHBvcyA9IGhlbHBlcnMudW5lc2NhcGVkSW5kZXhPZihidWZmZXIsIGRlbGltLCBsYXN0UG9zKSkgIT09IC0xKSB7XG4gICAgICB2YWx1ZSA9IGJ1ZmZlci5zdWJzdHIobGFzdFBvcywgcG9zIC0gbGFzdFBvcyk7XG4gICAgICBpZiAoaW5uZXJNdWx0aSkge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlci5fcGFyc2VNdWx0aVZhbHVlKHZhbHVlLCBpbm5lck11bHRpLCB0eXBlLCBbXSwgbnVsbCwgZGVzaWduU2V0LCBzdHJ1Y3R1cmVkVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBwYXJzZXIuX3BhcnNlVmFsdWUodmFsdWUsIHR5cGUsIGRlc2lnblNldCwgc3RydWN0dXJlZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIGxhc3RQb3MgPSBwb3MgKyBkZWxpbS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gb24gdGhlIGxhc3QgcGllY2UgdGFrZSB0aGUgcmVzdCBvZiBzdHJpbmdcbiAgICB2YWx1ZSA9IGJ1ZmZlci5zdWJzdHIobGFzdFBvcyk7XG4gICAgaWYgKGlubmVyTXVsdGkpIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZU11bHRpVmFsdWUodmFsdWUsIGlubmVyTXVsdGksIHR5cGUsIFtdLCBudWxsLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gcGFyc2VyLl9wYXJzZVZhbHVlKHZhbHVlLCB0eXBlLCBkZXNpZ25TZXQsIHN0cnVjdHVyZWRWYWx1ZSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcblxuICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb2Nlc3MgYSBjb21wbGV0ZSBidWZmZXIgb2YgaUNhbGVuZGFyL3ZDYXJkIGRhdGEgbGluZSBieSBsaW5lLCBjb3JyZWN0bHlcbiAgICogdW5mb2xkaW5nIGNvbnRlbnQuIEVhY2ggbGluZSB3aWxsIGJlIHByb2Nlc3NlZCB3aXRoIHRoZSBnaXZlbiBjYWxsYmFja1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAZnVuY3Rpb24gSUNBTC5wYXJzZS5fZWFjaExpbmVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGJ1ZmZlciAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgYnVmZmVyIHRvIHByb2Nlc3NcbiAgICogQHBhcmFtIHtmdW5jdGlvbig/U3RyaW5nLCBTdHJpbmcpfSBjYWxsYmFjayAgICBUaGUgY2FsbGJhY2sgZm9yIGVhY2ggbGluZVxuICAgKi9cbiAgcGFyc2VyLl9lYWNoTGluZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICB2YXIgbGFzdFBvcyA9IGJ1ZmZlci5zZWFyY2goQ0hBUik7XG4gICAgdmFyIHBvcyA9IGxhc3RQb3M7XG4gICAgdmFyIGxpbmU7XG4gICAgdmFyIGZpcnN0Q2hhcjtcblxuICAgIHZhciBuZXdsaW5lT2Zmc2V0O1xuXG4gICAgZG8ge1xuICAgICAgcG9zID0gYnVmZmVyLmluZGV4T2YoJ1xcbicsIGxhc3RQb3MpICsgMTtcblxuICAgICAgaWYgKHBvcyA+IDEgJiYgYnVmZmVyW3BvcyAtIDJdID09PSAnXFxyJykge1xuICAgICAgICBuZXdsaW5lT2Zmc2V0ID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld2xpbmVPZmZzZXQgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zID09PSAwKSB7XG4gICAgICAgIHBvcyA9IGxlbjtcbiAgICAgICAgbmV3bGluZU9mZnNldCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZpcnN0Q2hhciA9IGJ1ZmZlcltsYXN0UG9zXTtcblxuICAgICAgaWYgKGZpcnN0Q2hhciA9PT0gJyAnIHx8IGZpcnN0Q2hhciA9PT0gJ1xcdCcpIHtcbiAgICAgICAgLy8gYWRkIHRvIGxpbmVcbiAgICAgICAgbGluZSArPSBidWZmZXIuc3Vic3RyKFxuICAgICAgICAgIGxhc3RQb3MgKyAxLFxuICAgICAgICAgIHBvcyAtIGxhc3RQb3MgLSAobmV3bGluZU9mZnNldCArIDEpXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGluZSlcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBsaW5lKTtcbiAgICAgICAgLy8gcHVzaCBsaW5lXG4gICAgICAgIGxpbmUgPSBidWZmZXIuc3Vic3RyKFxuICAgICAgICAgIGxhc3RQb3MsXG4gICAgICAgICAgcG9zIC0gbGFzdFBvcyAtIG5ld2xpbmVPZmZzZXRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICB9IHdoaWxlIChwb3MgIT09IGxlbik7XG5cbiAgICAvLyBleHRyYSBlbmRpbmcgbGluZVxuICAgIGxpbmUgPSBsaW5lLnRyaW0oKTtcblxuICAgIGlmIChsaW5lLmxlbmd0aClcbiAgICAgIGNhbGxiYWNrKG51bGwsIGxpbmUpO1xuICB9O1xuXG4gIHJldHVybiBwYXJzZXI7XG5cbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5Db21wb25lbnQgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgUFJPUEVSVFlfSU5ERVggPSAxO1xuICB2YXIgQ09NUE9ORU5UX0lOREVYID0gMjtcbiAgdmFyIE5BTUVfSU5ERVggPSAwO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFdyYXBzIGEgakNhbCBjb21wb25lbnQsIGFkZGluZyBjb252ZW5pZW5jZSBtZXRob2RzIHRvIGFkZCwgcmVtb3ZlIGFuZFxuICAgKiB1cGRhdGUgc3ViY29tcG9uZW50cyBhbmQgcHJvcGVydGllcy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkNvbXBvbmVudFxuICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gakNhbCAgICAgICAgIFJhdyBqQ2FsIGNvbXBvbmVudCBkYXRhIE9SIG5hbWUgb2YgbmV3XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gcGFyZW50ICAgICBQYXJlbnQgY29tcG9uZW50IHRvIGFzc29jaWF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gQ29tcG9uZW50KGpDYWwsIHBhcmVudCkge1xuICAgIGlmICh0eXBlb2YoakNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBqQ2FsIHNwZWMgKG5hbWUsIHByb3BlcnRpZXMsIGNvbXBvbmVudHMpXG4gICAgICBqQ2FsID0gW2pDYWwsIFtdLCBbXV07XG4gICAgfVxuXG4gICAgLy8gbW9zdGx5IGZvciBsZWdhY3kgcmVhc29ucy5cbiAgICB0aGlzLmpDYWwgPSBqQ2FsO1xuXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcbiAgfVxuXG4gIENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogSHlkcmF0ZWQgcHJvcGVydGllcyBhcmUgaW5zZXJ0ZWQgaW50byB0aGUgX3Byb3BlcnRpZXMgYXJyYXkgYXQgdGhlIHNhbWVcbiAgICAgKiBwb3NpdGlvbiBhcyBpbiB0aGUgakNhbCBhcnJheSwgc28gaXQgaXMgcG9zc2libGUgdGhhdCB0aGUgYXJyYXkgY29udGFpbnNcbiAgICAgKiB1bmRlZmluZWQgdmFsdWVzIGZvciB1bmh5ZHJkYXRlZCBwcm9wZXJ0aWVzLiBUbyBhdm9pZCBpdGVyYXRpbmcgdGhlXG4gICAgICogYXJyYXkgd2hlbiBjaGVja2luZyBpZiBhbGwgcHJvcGVydGllcyBoYXZlIGJlZW4gaHlkcmF0ZWQsIHdlIHNhdmUgdGhlXG4gICAgICogY291bnQgaGVyZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaHlkcmF0ZWRQcm9wZXJ0eUNvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgY291bnQgYXMgZm9yIF9oeWRyYXRlZFByb3BlcnR5Q291bnQsIGJ1dCBmb3Igc3ViY29tcG9uZW50c1xuICAgICAqXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9oeWRyYXRlZENvbXBvbmVudENvdW50OiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWxbTkFNRV9JTkRFWF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciB0aGlzIGNvbXBvbmVudCwgZS5nLiBpY2FsZW5kYXIgdnMgdmNhcmRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXQgX2Rlc2lnblNldCgpIHtcbiAgICAgIHZhciBwYXJlbnREZXNpZ24gPSB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5fZGVzaWduU2V0O1xuICAgICAgcmV0dXJuIHBhcmVudERlc2lnbiB8fCBJQ0FMLmRlc2lnbi5nZXREZXNpZ25TZXQodGhpcy5uYW1lKTtcbiAgICB9LFxuXG4gICAgX2h5ZHJhdGVDb21wb25lbnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbXBvbmVudHMpIHtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnRzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXAgPSBuZXcgQ29tcG9uZW50KFxuICAgICAgICB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXVtpbmRleF0sXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQrKztcbiAgICAgIHJldHVybiAodGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSBjb21wKTtcbiAgICB9LFxuXG4gICAgX2h5ZHJhdGVQcm9wZXJ0eTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllc1tpbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wID0gbmV3IElDQUwuUHJvcGVydHkoXG4gICAgICAgIHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF1baW5kZXhdLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQrKztcbiAgICAgIHJldHVybiAodGhpcy5fcHJvcGVydGllc1tpbmRleF0gPSBwcm9wKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgZmlyc3Qgc3ViIGNvbXBvbmVudCwgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lICAgICAgICBPcHRpb25hbCBuYW1lIHRvIGZpbHRlciBieVxuICAgICAqIEByZXR1cm4gez9JQ0FMLkNvbXBvbmVudH0gICAgIFRoZSBmb3VuZCBzdWJjb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXRGaXJzdFN1YmNvbXBvbmVudDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgY29tcHMgPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXTtcbiAgICAgICAgdmFyIGxlbiA9IGNvbXBzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNvbXBzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5faHlkcmF0ZUNvbXBvbmVudChpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF0ubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2h5ZHJhdGVDb21wb25lbnQoMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZW5zdXJlIHdlIHJldHVybiBhIHZhbHVlIChzdHJpY3QgbW9kZSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhbGwgc3ViIGNvbXBvbmVudHMsIG9wdGlvbmFsbHkgZmlsdGVyaW5nIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgICAgICBPcHRpb25hbCBuYW1lIHRvIGZpbHRlciBieVxuICAgICAqIEByZXR1cm4ge0lDQUwuQ29tcG9uZW50W119ICAgICAgIFRoZSBmb3VuZCBzdWIgY29tcG9uZW50c1xuICAgICAqL1xuICAgIGdldEFsbFN1YmNvbXBvbmVudHM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBqQ2FsTGVuID0gdGhpcy5qQ2FsW0NPTVBPTkVOVF9JTkRFWF0ubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgY29tcHMgPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoOyBpIDwgakNhbExlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IGNvbXBzW2ldW05BTUVfSU5ERVhdKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgdGhpcy5faHlkcmF0ZUNvbXBvbmVudChpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5fY29tcG9uZW50cyB8fFxuICAgICAgICAgICAgKHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQgIT09IGpDYWxMZW4pKSB7XG4gICAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2h5ZHJhdGVDb21wb25lbnQoaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudHMgfHwgW107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSB3aGVuIGEgbmFtZWQgcHJvcGVydHkgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgICAgIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFRydWUsIHdoZW4gcHJvcGVydHkgaXMgZm91bmRcbiAgICAgKi9cbiAgICBoYXNQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXTtcbiAgICAgIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gMCBpcyBwcm9wZXJ0eSBuYW1lXG4gICAgICAgIGlmIChwcm9wc1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGZpcnN0IHByb3BlcnR5LCBvcHRpb25hbGx5IHdpdGggdGhlIGdpdmVuIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgIExvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7P0lDQUwuUHJvcGVydHl9ICAgICBUaGUgZm91bmQgcHJvcGVydHlcbiAgICAgKi9cbiAgICBnZXRGaXJzdFByb3BlcnR5OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF07XG4gICAgICAgIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGlmIChwcm9wc1tpXVtOQU1FX0lOREVYXSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2h5ZHJhdGVQcm9wZXJ0eShpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5qQ2FsW1BST1BFUlRZX0lOREVYXS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faHlkcmF0ZVByb3BlcnR5KDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpcnN0IHByb3BlcnR5J3MgdmFsdWUsIGlmIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICBMb3dlcmNhc2UgcHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4gez9TdHJpbmd9ICAgICAgICBUaGUgZm91bmQgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgcHJvcCA9IHRoaXMuZ2V0Rmlyc3RQcm9wZXJ0eShuYW1lKTtcbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBwcm9wLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcHJvcGVydGllcyBpbiB0aGUgY29tcG9uZW50LCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZz19IG5hbWUgICAgICAgIExvd2VyY2FzZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eVtdfSAgICBMaXN0IG9mIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBnZXRBbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgakNhbExlbiA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF0ubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLmpDYWxbUFJPUEVSVFlfSU5ERVhdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAobmFtZSA9PT0gcHJvcHNbaV1bTkFNRV9JTkRFWF0pIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICB0aGlzLl9oeWRyYXRlUHJvcGVydHkoaSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuX3Byb3BlcnRpZXMgfHxcbiAgICAgICAgICAgICh0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQgIT09IGpDYWxMZW4pKSB7XG4gICAgICAgICAgZm9yICg7IGkgPCBqQ2FsTGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2h5ZHJhdGVQcm9wZXJ0eShpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcGVydGllcyB8fCBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX3JlbW92ZU9iamVjdEJ5SW5kZXg6IGZ1bmN0aW9uKGpDYWxJbmRleCwgY2FjaGUsIGluZGV4KSB7XG4gICAgICBjYWNoZSA9IGNhY2hlIHx8IFtdO1xuICAgICAgLy8gcmVtb3ZlIGNhY2hlZCB2ZXJzaW9uXG4gICAgICBpZiAoY2FjaGVbaW5kZXhdKSB7XG4gICAgICAgIHZhciBvYmogPSBjYWNoZVtpbmRleF07XG4gICAgICAgIGlmIChcInBhcmVudFwiIGluIG9iaikge1xuICAgICAgICAgICAgb2JqLnBhcmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FjaGUuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gdGhlIGpDYWxcbiAgICAgIHRoaXMuakNhbFtqQ2FsSW5kZXhdLnNwbGljZShpbmRleCwgMSk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVPYmplY3Q6IGZ1bmN0aW9uKGpDYWxJbmRleCwgY2FjaGUsIG5hbWVPck9iamVjdCkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLmpDYWxbakNhbEluZGV4XTtcbiAgICAgIHZhciBsZW4gPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgIHZhciBjYWNoZWQgPSB0aGlzW2NhY2hlXTtcblxuICAgICAgaWYgKHR5cGVvZihuYW1lT3JPYmplY3QpID09PSAnc3RyaW5nJykge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgaWYgKG9iamVjdHNbaV1bTkFNRV9JTkRFWF0gPT09IG5hbWVPck9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlT2JqZWN0QnlJbmRleChqQ2FsSW5kZXgsIGNhY2hlZCwgaSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2FjaGVkKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2FjaGVkW2ldICYmIGNhY2hlZFtpXSA9PT0gbmFtZU9yT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVPYmplY3RCeUluZGV4KGpDYWxJbmRleCwgY2FjaGVkLCBpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIF9yZW1vdmVBbGxPYmplY3RzOiBmdW5jdGlvbihqQ2FsSW5kZXgsIGNhY2hlLCBuYW1lKSB7XG4gICAgICB2YXIgY2FjaGVkID0gdGhpc1tjYWNoZV07XG5cbiAgICAgIC8vIFVuZm9ydHVuYXRlbHkgd2UgaGF2ZSB0byBydW4gdGhyb3VnaCBhbGwgY2hpbGRyZW4gdG8gcmVzZXQgdGhlaXJcbiAgICAgIC8vIHBhcmVudCBwcm9wZXJ0eS5cbiAgICAgIHZhciBvYmplY3RzID0gdGhpcy5qQ2FsW2pDYWxJbmRleF07XG4gICAgICB2YXIgaSA9IG9iamVjdHMubGVuZ3RoIC0gMTtcblxuICAgICAgLy8gZGVzY2VuZGluZyBzZWFyY2ggcmVxdWlyZWQgYmVjYXVzZSBzcGxpY2VcbiAgICAgIC8vIGlzIHVzZWQgYW5kIHdpbGwgZWZmZWN0IHRoZSBpbmRpY2VzLlxuICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICghbmFtZSB8fCBvYmplY3RzW2ldW05BTUVfSU5ERVhdID09PSBuYW1lKSB7XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlT2JqZWN0QnlJbmRleChqQ2FsSW5kZXgsIGNhY2hlZCwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHNpbmdsZSBzdWIgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gY29tcG9uZW50ICAgICAgICBUaGUgY29tcG9uZW50IHRvIGFkZFxuICAgICAqIEByZXR1cm4ge0lDQUwuQ29tcG9uZW50fSAgICAgICAgICAgICAgICAgVGhlIHBhc3NlZCBpbiBjb21wb25lbnRcbiAgICAgKi9cbiAgICBhZGRTdWJjb21wb25lbnQ6IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgaWYgKCF0aGlzLl9jb21wb25lbnRzKSB7XG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnQucGFyZW50KSB7XG4gICAgICAgIGNvbXBvbmVudC5wYXJlbnQucmVtb3ZlU3ViY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZHggPSB0aGlzLmpDYWxbQ09NUE9ORU5UX0lOREVYXS5wdXNoKGNvbXBvbmVudC5qQ2FsKTtcbiAgICAgIHRoaXMuX2NvbXBvbmVudHNbaWR4IC0gMV0gPSBjb21wb25lbnQ7XG4gICAgICB0aGlzLl9oeWRyYXRlZENvbXBvbmVudENvdW50Kys7XG4gICAgICBjb21wb25lbnQucGFyZW50ID0gdGhpcztcbiAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzaW5nbGUgY29tcG9uZW50IGJ5IG5hbWUgb3IgdGhlIGluc3RhbmNlIG9mIGEgc3BlY2lmaWNcbiAgICAgKiBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fFN0cmluZ30gbmFtZU9yQ29tcCAgICBOYW1lIG9mIGNvbXBvbmVudCwgb3IgY29tcG9uZW50XG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSB3aGVuIGNvbXAgaXMgcmVtb3ZlZFxuICAgICAqL1xuICAgIHJlbW92ZVN1YmNvbXBvbmVudDogZnVuY3Rpb24obmFtZU9yQ29tcCkge1xuICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLl9yZW1vdmVPYmplY3QoQ09NUE9ORU5UX0lOREVYLCAnX2NvbXBvbmVudHMnLCBuYW1lT3JDb21wKTtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkQ29tcG9uZW50Q291bnQtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjb21wb25lbnRzIG9yIChpZiBnaXZlbikgYWxsIGNvbXBvbmVudHMgYnkgYSBwYXJ0aWN1bGFyXG4gICAgICogbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgICAgIExvd2VyY2FzZSBjb21wb25lbnQgbmFtZVxuICAgICAqL1xuICAgIHJlbW92ZUFsbFN1YmNvbXBvbmVudHM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlQWxsT2JqZWN0cyhDT01QT05FTlRfSU5ERVgsICdfY29tcG9uZW50cycsIG5hbWUpO1xuICAgICAgdGhpcy5faHlkcmF0ZWRDb21wb25lbnRDb3VudCA9IDA7XG4gICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiB7QGxpbmsgSUNBTC5Qcm9wZXJ0eX0gdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Qcm9wZXJ0eX0gcHJvcGVydHkgICAgICBUaGUgcHJvcGVydHkgdG8gYWRkXG4gICAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eX0gICAgICAgICAgICAgIFRoZSBwYXNzZWQgaW4gcHJvcGVydHlcbiAgICAgKi9cbiAgICBhZGRQcm9wZXJ0eTogZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgIGlmICghKHByb3BlcnR5IGluc3RhbmNlb2YgSUNBTC5Qcm9wZXJ0eSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBpbnN0YW5jZSBvZiBJQ0FMLlByb3BlcnR5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fcHJvcGVydGllcykge1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gW107XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0eS5wYXJlbnQpIHtcbiAgICAgICAgcHJvcGVydHkucGFyZW50LnJlbW92ZVByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkeCA9IHRoaXMuakNhbFtQUk9QRVJUWV9JTkRFWF0ucHVzaChwcm9wZXJ0eS5qQ2FsKTtcbiAgICAgIHRoaXMuX3Byb3BlcnRpZXNbaWR4IC0gMV0gPSBwcm9wZXJ0eTtcbiAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudCsrO1xuICAgICAgcHJvcGVydHkucGFyZW50ID0gdGhpcztcbiAgICAgIHJldHVybiBwcm9wZXJ0eTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBhZGQgYSBwcm9wZXJ0eSB3aXRoIGEgdmFsdWUgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICAgIG5hbWUgICAgICAgICBQcm9wZXJ0eSBuYW1lIHRvIGFkZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxPYmplY3R9IHZhbHVlICAgICAgICBQcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0lDQUwuUHJvcGVydHl9ICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIGFkZFByb3BlcnR5V2l0aFZhbHVlOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb3AgPSBuZXcgSUNBTC5Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHByb3Auc2V0VmFsdWUodmFsdWUpO1xuXG4gICAgICB0aGlzLmFkZFByb3BlcnR5KHByb3ApO1xuXG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0aGF0IHdpbGwgdXBkYXRlIG9yIGNyZWF0ZSBhIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBuYW1lXG4gICAgICogYW5kIHNldHMgaXRzIHZhbHVlLiBJZiBtdWx0aXBsZSBwcm9wZXJ0aWVzIHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3QsXG4gICAgICogb25seSB0aGUgZmlyc3QgaXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICAgICAgICAgIG5hbWUgICAgICAgICBQcm9wZXJ0eSBuYW1lIHRvIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxPYmplY3R9IHZhbHVlICAgICAgICBQcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge0lDQUwuUHJvcGVydHl9ICAgICAgICAgICAgICAgICAgICBUaGUgY3JlYXRlZCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHVwZGF0ZVByb3BlcnR5V2l0aFZhbHVlOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb3AgPSB0aGlzLmdldEZpcnN0UHJvcGVydHkobmFtZSk7XG5cbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHByb3Auc2V0VmFsdWUodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcCA9IHRoaXMuYWRkUHJvcGVydHlXaXRoVmFsdWUobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNpbmdsZSBwcm9wZXJ0eSBieSBuYW1lIG9yIHRoZSBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWNcbiAgICAgKiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfElDQUwuUHJvcGVydHl9IG5hbWVPclByb3AgICAgIFByb3BlcnR5IG5hbWUgb3IgaW5zdGFuY2UgdG8gcmVtb3ZlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSwgd2hlbiBkZWxldGVkXG4gICAgICovXG4gICAgcmVtb3ZlUHJvcGVydHk6IGZ1bmN0aW9uKG5hbWVPclByb3ApIHtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlT2JqZWN0KFBST1BFUlRZX0lOREVYLCAnX3Byb3BlcnRpZXMnLCBuYW1lT3JQcm9wKTtcbiAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgIHRoaXMuX2h5ZHJhdGVkUHJvcGVydHlDb3VudC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50LCBvcHRpb25hbGx5XG4gICAgICogZmlsdGVyZWQgYnkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nPX0gbmFtZSAgICAgICAgTG93ZXJjYXNlIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIFRydWUsIHdoZW4gZGVsZXRlZFxuICAgICAqL1xuICAgIHJlbW92ZUFsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciByZW1vdmVkID0gdGhpcy5fcmVtb3ZlQWxsT2JqZWN0cyhQUk9QRVJUWV9JTkRFWCwgJ19wcm9wZXJ0aWVzJywgbmFtZSk7XG4gICAgICB0aGlzLl9oeWRyYXRlZFByb3BlcnR5Q291bnQgPSAwO1xuICAgICAgcmV0dXJuIHJlbW92ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC4gVGhlIHJldHVybmVkIG9iamVjdFxuICAgICAqIGlzIGEgbGl2ZSBqQ2FsIG9iamVjdCBhbmQgc2hvdWxkIGJlIGNsb25lZCBpZiBtb2RpZmllZC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLnN0cmluZ2lmeS5jb21wb25lbnQoXG4gICAgICAgIHRoaXMuakNhbCwgdGhpcy5fZGVzaWduU2V0XG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHtAbGluayBJQ0FMLkNvbXBvbmVudH0gYnkgcGFyc2luZyB0aGUgcGFzc2VkIGlDYWxlbmRhciBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgICAgICAgIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHRvIHBhcnNlXG4gICAqL1xuICBDb21wb25lbnQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgQ29tcG9uZW50KElDQUwucGFyc2UuY29tcG9uZW50KHN0cikpO1xuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59KCkpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG4vKipcbiAqIFRoaXMgc3ltYm9sIGlzIGZ1cnRoZXIgZGVzY3JpYmVkIGxhdGVyIG9uXG4gKiBAaWdub3JlXG4gKi9cbklDQUwuUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgTkFNRV9JTkRFWCA9IDA7XG4gIHZhciBQUk9QX0lOREVYID0gMTtcbiAgdmFyIFRZUEVfSU5ERVggPSAyO1xuICB2YXIgVkFMVUVfSU5ERVggPSAzO1xuXG4gIHZhciBkZXNpZ24gPSBJQ0FMLmRlc2lnbjtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBQcm92aWRlcyBhIGxheWVyIG9uIHRvcCBvZiB0aGUgcmF3IGpDYWwgb2JqZWN0IGZvciBtYW5pcHVsYXRpbmcgYSBzaW5nbGVcbiAgICogcHJvcGVydHksIHdpdGggaXRzIHBhcmFtZXRlcnMgYW5kIHZhbHVlLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCBtdXRhdGlvbnMgZG9uZSBpbiB0aGUgd3JhcHBlclxuICAgKiBkaXJlY3RseSBtdXRhdGUgdGhlIGpDYWwgb2JqZWN0IHVzZWQgdG8gaW5pdGlhbGl6ZS5cbiAgICpcbiAgICogQ2FuIGFsc28gYmUgdXNlZCB0byBjcmVhdGUgbmV3IHByb3BlcnRpZXMgYnkgcGFzc2luZ1xuICAgKiB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgKGFzIGEgU3RyaW5nKS5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLlByb3BlcnR5XG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBqQ2FsICAgICAgICAgUmF3IGpDYWwgcmVwcmVzZW50YXRpb24gT1JcbiAgICogIHRoZSBuZXcgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudD19IHBhcmVudCAgICBQYXJlbnQgY29tcG9uZW50XG4gICAqL1xuICBmdW5jdGlvbiBQcm9wZXJ0eShqQ2FsLCBwYXJlbnQpIHtcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcblxuICAgIGlmICh0eXBlb2YoakNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBXZSBhcmUgY3JlYXRpbmcgdGhlIHByb3BlcnR5IGJ5IG5hbWUgYW5kIG5lZWQgdG8gZGV0ZWN0IHRoZSB0eXBlXG4gICAgICB0aGlzLmpDYWwgPSBbakNhbCwge30sIGRlc2lnbi5kZWZhdWx0VHlwZV07XG4gICAgICB0aGlzLmpDYWxbVFlQRV9JTkRFWF0gPSB0aGlzLmdldERlZmF1bHRUeXBlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuakNhbCA9IGpDYWw7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZVR5cGUoKTtcbiAgfVxuXG4gIFByb3BlcnR5LnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSB0eXBlIGZvciB0aGlzIHByb3BlcnR5XG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmpDYWxbVFlQRV9JTkRFWF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoaXMgcHJvcGVydHksIGluIGxvd2VyY2FzZS5cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbFtOQU1FX0lOREVYXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcmVudCBjb21wb25lbnQgZm9yIHRoaXMgcHJvcGVydHkuXG4gICAgICogQHR5cGUge0lDQUwuQ29tcG9uZW50fVxuICAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xuICAgIH0sXG5cbiAgICBzZXQgcGFyZW50KHApIHtcbiAgICAgIC8vIEJlZm9yZSBzZXR0aW5nIHRoZSBwYXJlbnQsIGNoZWNrIGlmIHRoZSBkZXNpZ24gc2V0IGhhcyBjaGFuZ2VkLiBJZiBpdFxuICAgICAgLy8gaGFzLCB3ZSBsYXRlciBuZWVkIHRvIHVwZGF0ZSB0aGUgdHlwZSBpZiBpdCB3YXMgdW5rbm93biBiZWZvcmUuXG4gICAgICB2YXIgZGVzaWduU2V0Q2hhbmdlZCA9ICF0aGlzLl9wYXJlbnQgfHwgKHAgJiYgcC5fZGVzaWduU2V0ICE9IHRoaXMuX3BhcmVudC5fZGVzaWduU2V0KTtcblxuICAgICAgdGhpcy5fcGFyZW50ID0gcDtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PSBkZXNpZ24uZGVmYXVsdFR5cGUgJiYgZGVzaWduU2V0Q2hhbmdlZCkge1xuICAgICAgICB0aGlzLmpDYWxbVFlQRV9JTkRFWF0gPSB0aGlzLmdldERlZmF1bHRUeXBlKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVR5cGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNpZ24gc2V0IGZvciB0aGlzIHByb3BlcnR5LCBlLmcuIGljYWxlbmRhciB2cyB2Y2FyZFxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuZGVzaWduLmRlc2lnblNldH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldCBfZGVzaWduU2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuX2Rlc2lnblNldCA6IGRlc2lnbi5kZWZhdWx0U2V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0eXBlIG1ldGFkYXRhIGZyb20gdGhlIGN1cnJlbnQgakNhbCB0eXBlIGFuZCBkZXNpZ24gc2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGVzaWduU2V0ID0gdGhpcy5fZGVzaWduU2V0O1xuXG4gICAgICBpZiAodGhpcy50eXBlIGluIGRlc2lnblNldC52YWx1ZSkge1xuICAgICAgICB2YXIgZGVzaWduVHlwZSA9IGRlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdO1xuXG4gICAgICAgIGlmICgnZGVjb3JhdGUnIGluIGRlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdKSB7XG4gICAgICAgICAgdGhpcy5pc0RlY29yYXRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pc0RlY29yYXRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubmFtZSBpbiBkZXNpZ25TZXQucHJvcGVydHkpIHtcbiAgICAgICAgICB0aGlzLmlzTXVsdGlWYWx1ZSA9ICgnbXVsdGlWYWx1ZScgaW4gZGVzaWduU2V0LnByb3BlcnR5W3RoaXMubmFtZV0pO1xuICAgICAgICAgIHRoaXMuaXNTdHJ1Y3R1cmVkVmFsdWUgPSAoJ3N0cnVjdHVyZWRWYWx1ZScgaW4gZGVzaWduU2V0LnByb3BlcnR5W3RoaXMubmFtZV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEh5ZHJhdGUgYSBzaW5nbGUgdmFsdWUuIFRoZSBhY3Qgb2YgaHlkcmF0aW5nIG1lYW5zIHR1cm5pbmcgdGhlIHJhdyBqQ2FsXG4gICAgICogdmFsdWUgaW50byBhIHBvdGVudGlhbGx5IHdyYXBwZWQgb2JqZWN0LCBmb3IgZXhhbXBsZSB7QGxpbmsgSUNBTC5UaW1lfS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4ICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHZhbHVlIHRvIGh5ZHJhdGVcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgIFRoZSBkZWNvcmF0ZWQgdmFsdWUuXG4gICAgICovXG4gICAgX2h5ZHJhdGVWYWx1ZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLl92YWx1ZXMgJiYgdGhpcy5fdmFsdWVzW2luZGV4XSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yIHRoZSBjYXNlIHdoZXJlIHRoZXJlIGlzIG5vIHZhbHVlLlxuICAgICAgaWYgKHRoaXMuakNhbC5sZW5ndGggPD0gKFZBTFVFX0lOREVYICsgaW5kZXgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0RlY29yYXRlZCkge1xuICAgICAgICBpZiAoIXRoaXMuX3ZhbHVlcykge1xuICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5fdmFsdWVzW2luZGV4XSA9IHRoaXMuX2RlY29yYXRlKFxuICAgICAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWCArIGluZGV4XVxuICAgICAgICApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlY29yYXRlIGEgc2luZ2xlIHZhbHVlLCByZXR1cm5pbmcgaXRzIHdyYXBwZWQgb2JqZWN0LiBUaGlzIGlzIHVzZWQgYnlcbiAgICAgKiB0aGUgaHlkcmF0ZSBmdW5jdGlvbiB0byBhY3R1YWxseSB3cmFwIHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHs/fSB2YWx1ZSAgICAgICAgIFRoZSB2YWx1ZSB0byBkZWNvcmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBUaGUgZGVjb3JhdGVkIHZhbHVlXG4gICAgICovXG4gICAgX2RlY29yYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdLmRlY29yYXRlKHZhbHVlLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5kZWNvcmF0ZSBhIHNpbmdsZSB2YWx1ZSwgcmV0dXJuaW5nIGl0cyByYXcgakNhbCBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgICAgICAgICBUaGUgdmFsdWUgdG8gdW5kZWNvcmF0ZVxuICAgICAqIEByZXR1cm4gez99ICAgICAgICAgICAgICAgICAgIFRoZSB1bmRlY29yYXRlZCB2YWx1ZVxuICAgICAqL1xuICAgIF91bmRlY29yYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rlc2lnblNldC52YWx1ZVt0aGlzLnR5cGVdLnVuZGVjb3JhdGUodmFsdWUsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gaW5kZXggd2hpbGUgYWxzbyBoeWRyYXRpbmcgaXQuIFRoZSBwYXNzZWRcbiAgICAgKiB2YWx1ZSBjYW4gZWl0aGVyIGJlIGEgZGVjb3JhdGVkIG9yIHVuZGVjb3JhdGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gez99IHZhbHVlICAgICAgICAgICAgIFRoZSB2YWx1ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggICAgICAgIFRoZSBpbmRleCB0byBzZXQgaXQgYXRcbiAgICAgKi9cbiAgICBfc2V0RGVjb3JhdGVkVmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgaWYgKCF0aGlzLl92YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiAnaWNhbHR5cGUnIGluIHZhbHVlKSB7XG4gICAgICAgIC8vIGRlY29yYXRlZCB2YWx1ZVxuICAgICAgICB0aGlzLmpDYWxbVkFMVUVfSU5ERVggKyBpbmRleF0gPSB0aGlzLl91bmRlY29yYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5kZWNvcmF0ZWQgdmFsdWVcbiAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB0aGlzLl9kZWNvcmF0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBwYXJhbWV0ZXIgb24gdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICBuYW1lICAgUGFyYW1ldGVyIG5hbWUgKGxvd2VyY2FzZSlcbiAgICAgKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd9ICAgICAgICBQYXJhbWV0ZXIgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lIGluIHRoaXMuakNhbFtQUk9QX0lOREVYXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5qQ2FsW1BST1BfSU5ERVhdW25hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBmaXJzdCBwYXJhbWV0ZXIgb24gdGhlIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICBuYW1lICAgUGFyYW1ldGVyIG5hbWUgKGxvd2VyY2FzZSlcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICBQYXJhbWV0ZXIgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRGaXJzdFBhcmFtZXRlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLmdldFBhcmFtZXRlcihuYW1lKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycykpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlcnNbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJhbWV0ZXJzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgcGFyYW1ldGVyIG9uIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgICBuYW1lICAgICBUaGUgcGFyYW1ldGVyIG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gdmFsdWUgICAgVGhlIHBhcmFtZXRlciB2YWx1ZVxuICAgICAqL1xuICAgIHNldFBhcmFtZXRlcjogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgIHZhciBsY25hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgbGNuYW1lIGluIHRoaXMuX2Rlc2lnblNldC5wYXJhbSAmJlxuICAgICAgICAgICdtdWx0aVZhbHVlJyBpbiB0aGlzLl9kZXNpZ25TZXQucGFyYW1bbGNuYW1lXSkge1xuICAgICAgICAgIHZhbHVlID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuakNhbFtQUk9QX0lOREVYXVtuYW1lXSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgICAgVGhlIHBhcmFtZXRlciBuYW1lXG4gICAgICovXG4gICAgcmVtb3ZlUGFyYW1ldGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBkZWxldGUgdGhpcy5qQ2FsW1BST1BfSU5ERVhdW25hbWVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlZmF1bHQgdHlwZSBiYXNlZCBvbiB0aGlzIHByb3BlcnR5J3MgbmFtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gICAgIFRoZSBkZWZhdWx0IHR5cGUgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgKi9cbiAgICBnZXREZWZhdWx0VHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbmFtZSA9IHRoaXMuakNhbFtOQU1FX0lOREVYXTtcbiAgICAgIHZhciBkZXNpZ25TZXQgPSB0aGlzLl9kZXNpZ25TZXQ7XG5cbiAgICAgIGlmIChuYW1lIGluIGRlc2lnblNldC5wcm9wZXJ0eSkge1xuICAgICAgICB2YXIgZGV0YWlscyA9IGRlc2lnblNldC5wcm9wZXJ0eVtuYW1lXTtcbiAgICAgICAgaWYgKCdkZWZhdWx0VHlwZScgaW4gZGV0YWlscykge1xuICAgICAgICAgIHJldHVybiBkZXRhaWxzLmRlZmF1bHRUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzaWduLmRlZmF1bHRUeXBlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHR5cGUgb2YgcHJvcGVydHkgYW5kIGNsZWFycyBvdXQgYW55IGV4aXN0aW5nIHZhbHVlcyBvZiB0aGUgY3VycmVudFxuICAgICAqIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAgICAgTmV3IGlDQUwgdHlwZSAoc2VlIGRlc2lnbi4qLnZhbHVlcylcbiAgICAgKi9cbiAgICByZXNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsVmFsdWVzKCk7XG4gICAgICB0aGlzLmpDYWxbVFlQRV9JTkRFWF0gPSB0eXBlO1xuICAgICAgdGhpcy5fdXBkYXRlVHlwZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZmlyc3QgcHJvcGVydHkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgRmlyc3QgcHJvcGVydHkgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRGaXJzdFZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oeWRyYXRlVmFsdWUoMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIHZhbHVlcyBvbiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBOT1RFOiB0aGlzIGNyZWF0ZXMgYW4gYXJyYXkgZHVyaW5nIGVhY2ggY2FsbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBMaXN0IG9mIHZhbHVlc1xuICAgICAqL1xuICAgIGdldFZhbHVlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5qQ2FsLmxlbmd0aCAtIFZBTFVFX0lOREVYO1xuXG4gICAgICBpZiAobGVuIDwgMSkge1xuICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSBmb3IgYSBwcm9wZXJ0eSB0byBoYXZlIG5vIHZhbHVlLlxuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICByZXN1bHRbaV0gPSB0aGlzLl9oeWRyYXRlVmFsdWUoaSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHZhbHVlcyBmcm9tIHRoaXMgcHJvcGVydHlcbiAgICAgKi9cbiAgICByZW1vdmVBbGxWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX3ZhbHVlcykge1xuICAgICAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuakNhbC5sZW5ndGggPSAzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZXMgb2YgdGhlIHByb3BlcnR5LiAgV2lsbCBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIHZhbHVlcy5cbiAgICAgKiBUaGlzIGNhbiBvbmx5IGJlIHVzZWQgZm9yIG11bHRpLXZhbHVlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgICAgQW4gYXJyYXkgb2YgdmFsdWVzXG4gICAgICovXG4gICAgc2V0VmFsdWVzOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIGlmICghdGhpcy5pc011bHRpVmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIHRoaXMubmFtZSArICc6IGRvZXMgbm90IG5vdCBzdXBwb3J0IG11bGl0VmFsdWUuXFxuJyArXG4gICAgICAgICAgJ292ZXJyaWRlIGlzTXVsdGlWYWx1ZSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB0aGlzLnJlbW92ZUFsbFZhbHVlcygpO1xuXG4gICAgICBpZiAobGVuID4gMCAmJlxuICAgICAgICAgIHR5cGVvZih2YWx1ZXNbMF0pID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICdpY2FsdHlwZScgaW4gdmFsdWVzWzBdKSB7XG4gICAgICAgIHRoaXMucmVzZXRUeXBlKHZhbHVlc1swXS5pY2FsdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRGVjb3JhdGVkKSB7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9zZXREZWNvcmF0ZWRWYWx1ZSh2YWx1ZXNbaV0sIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5qQ2FsW1ZBTFVFX0lOREVYICsgaV0gPSB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuIElmIHRoaXMgaXMgYSBtdWx0aS12YWx1ZVxuICAgICAqIHByb3BlcnR5LCBhbGwgb3RoZXIgdmFsdWVzIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdmFsdWUgICAgIE5ldyBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsVmFsdWVzKCk7XG4gICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gJ29iamVjdCcgJiYgJ2ljYWx0eXBlJyBpbiB2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlc2V0VHlwZSh2YWx1ZS5pY2FsdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzRGVjb3JhdGVkKSB7XG4gICAgICAgIHRoaXMuX3NldERlY29yYXRlZFZhbHVlKHZhbHVlLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuakNhbFtWQUxVRV9JTkRFWF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgT2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgY29tcG9uZW50LiBUaGUgcmV0dXJuZWQgb2JqZWN0XG4gICAgICogaXMgYSBsaXZlIGpDYWwgb2JqZWN0IGFuZCBzaG91bGQgYmUgY2xvbmVkIGlmIG1vZGlmaWVkLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuakNhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLnN0cmluZ2lmeS5wcm9wZXJ0eShcbiAgICAgICAgdGhpcy5qQ2FsLCB0aGlzLl9kZXNpZ25TZXQsIHRydWVcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4ge0BsaW5rIElDQUwuUHJvcGVydHl9IGJ5IHBhcnNpbmcgdGhlIHBhc3NlZCBpQ2FsZW5kYXIgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGlDYWxlbmRhciBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHBhcmFtIHtJQ0FMLmRlc2lnbi5kZXNpZ25TZXQ9fSBkZXNpZ25TZXQgIFRoZSBkZXNpZ24gZGF0YSB0byB1c2UgZm9yIHRoaXMgcHJvcGVydHlcbiAgICogQHJldHVybiB7SUNBTC5Qcm9wZXJ0eX0gICAgICAgICAgICAgICAgICAgIFRoZSBjcmVhdGVkIGlDYWxlbmRhciBwcm9wZXJ0eVxuICAgKi9cbiAgUHJvcGVydHkuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0ciwgZGVzaWduU2V0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9wZXJ0eShJQ0FMLnBhcnNlLnByb3BlcnR5KHN0ciwgZGVzaWduU2V0KSk7XG4gIH07XG5cbiAgcmV0dXJuIFByb3BlcnR5O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlV0Y09mZnNldCA9IChmdW5jdGlvbigpIHtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgdGhlIFwiZHVyYXRpb25cIiB2YWx1ZSB0eXBlLCB3aXRoIHZhcmlvdXMgY2FsY3VsYXRpb25cbiAgICogYW5kIG1hbmlwdWxhdGlvbiBtZXRob2RzLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuVXRjT2Zmc2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91cnMgICBUaGUgaG91cnMgZm9yIHRoZSB1dGMgb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubWludXRlcyBUaGUgbWludXRlcyBpbiB0aGUgdXRjIG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmZhY3RvciAgVGhlIGZhY3RvciBmb3IgdGhlIHV0Yy1vZmZzZXQsIGVpdGhlciAtMSBvciAxXG4gICAqL1xuICBmdW5jdGlvbiBVdGNPZmZzZXQoYURhdGEpIHtcbiAgICB0aGlzLmZyb21EYXRhKGFEYXRhKTtcbiAgfVxuXG4gIFV0Y09mZnNldC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaG91cnMgaW4gdGhlIHV0Yy1vZmZzZXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGhvdXJzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1pbnV0ZXMgaW4gdGhlIHV0Yy1vZmZzZXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIG1pbnV0ZXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2lnbiBvZiB0aGUgdXRjIG9mZnNldCwgMSBmb3IgcG9zaXRpdmUgb2Zmc2V0LCAtMSBmb3IgbmVnYXRpdmVcbiAgICAgKiBvZmZzZXRzLlxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZmFjdG9yOiAxLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcInV0Yy1vZmZzZXRcIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcInV0Yy1vZmZzZXRcIixcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgdXRjIG9mZnNldCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlV0Y09mZnNldH0gICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElDQUwuVXRjT2Zmc2V0LmZyb21TZWNvbmRzKHRoaXMudG9TZWNvbmRzKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHV0YyBvZmZzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmhvdXJzICAgVGhlIGhvdXJzIGZvciB0aGUgdXRjIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEubWludXRlcyBUaGUgbWludXRlcyBpbiB0aGUgdXRjIG9mZnNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuZmFjdG9yICBUaGUgZmFjdG9yIGZvciB0aGUgdXRjLW9mZnNldCwgZWl0aGVyIC0xIG9yIDFcbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24oYURhdGEpIHtcbiAgICAgIGlmIChhRGF0YSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYURhdGEpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChhRGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzW2tleV0gPSBhRGF0YVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbm9ybWFsaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gc2Vjb25kcyB2YWx1ZS4gVGhlIHNlY29uZHNcbiAgICAgKiB2YWx1ZSBpcyB0cnVuY2F0ZWQgdG8gdGhlIG1pbnV0ZS4gT2Zmc2V0cyBhcmUgd3JhcHBlZCB3aGVuIHRoZSB3b3JsZFxuICAgICAqIGVuZHMsIHRoZSBob3VyIGFmdGVyIFVUQysxNDowMCBpcyBVVEMtMTI6MDAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgICAgICBUaGUgc2Vjb25kcyB0byBjb252ZXJ0IGludG8gYW4gb2Zmc2V0XG4gICAgICovXG4gICAgZnJvbVNlY29uZHM6IGZ1bmN0aW9uKGFTZWNvbmRzKSB7XG4gICAgICB2YXIgc2VjcyA9IE1hdGguYWJzKGFTZWNvbmRzKTtcblxuICAgICAgdGhpcy5mYWN0b3IgPSBhU2Vjb25kcyA8IDAgPyAtMSA6IDE7XG4gICAgICB0aGlzLmhvdXJzID0gSUNBTC5oZWxwZXJzLnRydW5jKHNlY3MgLyAzNjAwKTtcblxuICAgICAgc2VjcyAtPSAodGhpcy5ob3VycyAqIDM2MDApO1xuICAgICAgdGhpcy5taW51dGVzID0gSUNBTC5oZWxwZXJzLnRydW5jKHNlY3MgLyA2MCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgY3VycmVudCBvZmZzZXQgdG8gYSB2YWx1ZSBpbiBzZWNvbmRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICBUaGUgb2Zmc2V0IGluIHNlY29uZHNcbiAgICAgKi9cbiAgICB0b1NlY29uZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmFjdG9yICogKDYwICogdGhpcy5taW51dGVzICsgMzYwMCAqIHRoaXMuaG91cnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlIHRoaXMgdXRjIG9mZnNldCB3aXRoIGFub3RoZXIgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlV0Y09mZnNldH0gb3RoZXIgICAgICAgIFRoZSBvdGhlciBvZmZzZXQgdG8gY29tcGFyZSB3aXRoXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgICAgICAgICAgICAgIC0xLCAwIG9yIDEgZm9yIGxlc3MvZXF1YWwvZ3JlYXRlclxuICAgICAqL1xuICAgIGNvbXBhcmU6IGZ1bmN0aW9uIGljYWx0aW1lX2NvbXBhcmUob3RoZXIpIHtcbiAgICAgIHZhciBhID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICAgIHZhciBiID0gb3RoZXIudG9TZWNvbmRzKCk7XG4gICAgICByZXR1cm4gKGEgPiBiKSAtIChiID4gYSk7XG4gICAgfSxcblxuICAgIF9ub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gUmFuZ2U6IDk3MjAwIHNlY29uZHMgKHdpdGggMSBob3VyIGluYmV0d2VlbilcbiAgICAgIHZhciBzZWNzID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICAgIHZhciBmYWN0b3IgPSB0aGlzLmZhY3RvcjtcbiAgICAgIHdoaWxlIChzZWNzIDwgLTQzMjAwKSB7IC8vID0gVVRDLTEyOjAwXG4gICAgICAgIHNlY3MgKz0gOTcyMDA7XG4gICAgICB9XG4gICAgICB3aGlsZSAoc2VjcyA+IDUwNDAwKSB7IC8vID0gVVRDKzE0OjAwXG4gICAgICAgIHNlY3MgLT0gOTcyMDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZnJvbVNlY29uZHMoc2Vjcyk7XG5cbiAgICAgIC8vIEF2b2lkIGNoYW5naW5nIHRoZSBmYWN0b3Igd2hlbiBvbiB6ZXJvIHNlY29uZHNcbiAgICAgIGlmIChzZWNzID09IDApIHtcbiAgICAgICAgdGhpcy5mYWN0b3IgPSBmYWN0b3I7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpQ2FsZW5kYXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdXRjLW9mZnNldC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWVbJ3V0Yy1vZmZzZXQnXS50b0lDQUwodGhpcy50b1N0cmluZygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHV0Yy1vZmZzZXQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAodGhpcy5mYWN0b3IgPT0gMSA/IFwiK1wiIDogXCItXCIpICtcbiAgICAgICAgICAgICAgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5ob3VycykgKyAnOicgK1xuICAgICAgICAgICAgICBJQ0FMLmhlbHBlcnMucGFkMih0aGlzLm1pbnV0ZXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5VdGNPZmZzZXR9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhU3RyaW5nICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHJldHVybiB7SUNBTC5EdXJhdGlvbn0gICAgVGhlIGNyZWF0ZWQgdXRjLW9mZnNldCBpbnN0YW5jZVxuICAgKi9cbiAgVXRjT2Zmc2V0LmZyb21TdHJpbmcgPSBmdW5jdGlvbihhU3RyaW5nKSB7XG4gICAgLy8gLTA1OjAwXG4gICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAvL1RPRE86IHN1cHBvcnQgc2Vjb25kcyBwZXIgcmZjNTU0NSA/XG4gICAgb3B0aW9ucy5mYWN0b3IgPSAoYVN0cmluZ1swXSA9PT0gJysnKSA/IDEgOiAtMTtcbiAgICBvcHRpb25zLmhvdXJzID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFTdHJpbmcuc3Vic3RyKDEsIDIpKTtcbiAgICBvcHRpb25zLm1pbnV0ZXMgPSBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVN0cmluZy5zdWJzdHIoNCwgMikpO1xuXG4gICAgcmV0dXJuIG5ldyBJQ0FMLlV0Y09mZnNldChvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5VdGNPZmZzZXR9IGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBzZWNvbmRzXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gYVNlY29uZHMgICAgICAgVGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIGNvbnZlcnRcbiAgICovXG4gIFV0Y09mZnNldC5mcm9tU2Vjb25kcyA9IGZ1bmN0aW9uKGFTZWNvbmRzKSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IFV0Y09mZnNldCgpO1xuICAgIGluc3RhbmNlLmZyb21TZWNvbmRzKGFTZWNvbmRzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG5cbiAgcmV0dXJuIFV0Y09mZnNldDtcbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5CaW5hcnkgPSAoZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogUmVwcmVzZW50cyB0aGUgQklOQVJZIHZhbHVlIHR5cGUsIHdoaWNoIGNvbnRhaW5zIGV4dHJhIG1ldGhvZHMgZm9yXG4gICAqIGVuY29kaW5nIGFuZCBkZWNvZGluZy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkJpbmFyeVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgYmluYXJ5IGRhdGEgZm9yIHRoaXMgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIEJpbmFyeShhVmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gYVZhbHVlO1xuICB9XG5cbiAgQmluYXJ5LnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAZGVmYXVsdCBcImJpbmFyeVwiXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwiYmluYXJ5XCIsXG5cbiAgICAvKipcbiAgICAgKiBCYXNlNjQgZGVjb2RlIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgVGhlIGJhc2U2NC1kZWNvZGVkIHZhbHVlXG4gICAgICovXG4gICAgZGVjb2RlVmFsdWU6IGZ1bmN0aW9uIGRlY29kZVZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2I2NF9kZWNvZGUodGhpcy52YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgdGhlIHBhc3NlZCBwYXJhbWV0ZXIgd2l0aCBiYXNlNjQgYW5kIHNldHMgdGhlIGludGVybmFsXG4gICAgICogdmFsdWUgdG8gdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhVmFsdWUgICAgICBUaGUgcmF3IGJpbmFyeSB2YWx1ZSB0byBlbmNvZGVcbiAgICAgKi9cbiAgICBzZXRFbmNvZGVkVmFsdWU6IGZ1bmN0aW9uIHNldEVuY29kZWRWYWx1ZShhVmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9iNjRfZW5jb2RlKGFWYWx1ZSk7XG4gICAgfSxcblxuICAgIF9iNjRfZW5jb2RlOiBmdW5jdGlvbiBiYXNlNjRfZW5jb2RlKGRhdGEpIHtcbiAgICAgIC8vIGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0XG4gICAgICAvLyArICAgb3JpZ2luYWwgYnk6IFR5bGVyIEFraW5zIChodHRwOi8vcnVta2luLmNvbSlcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogQmF5cm9uIEd1ZXZhcmFcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogVGh1bmRlci5tXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKyAgIGJ1Z2ZpeGVkIGJ5OiBQZWxsZW50ZXNxdWUgTWFsZXN1YWRhXG4gICAgICAvLyArICAgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBSYWZhXHUwMTQyIEt1a2F3c2tpIChodHRwOi8va3VrYXdza2kucGwpXG4gICAgICAvLyAqICAgICBleGFtcGxlIDE6IGJhc2U2NF9lbmNvZGUoJ0tldmluIHZhbiBab25uZXZlbGQnKTtcbiAgICAgIC8vICogICAgIHJldHVybnMgMTogJ1MyVjJhVzRnZG1GdUlGcHZibTVsZG1Wc1pBPT0nXG4gICAgICAvLyBtb3ppbGxhIGhhcyB0aGlzIG5hdGl2ZVxuICAgICAgLy8gLSBidXQgYnJlYWtzIGluIDIuMC4wLjEyIVxuICAgICAgLy9pZiAodHlwZW9mIHRoaXMud2luZG93WydhdG9iJ10gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gICAgcmV0dXJuIGF0b2IoZGF0YSk7XG4gICAgICAvL31cbiAgICAgIHZhciBiNjQgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCIgK1xuICAgICAgICAgICAgICAgIFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gICAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICBhYyA9IDAsXG4gICAgICAgIGVuYyA9IFwiXCIsXG4gICAgICAgIHRtcF9hcnIgPSBbXTtcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICBkbyB7IC8vIHBhY2sgdGhyZWUgb2N0ZXRzIGludG8gZm91ciBoZXhldHNcbiAgICAgICAgbzEgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzIgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcbiAgICAgICAgbzMgPSBkYXRhLmNoYXJDb2RlQXQoaSsrKTtcblxuICAgICAgICBiaXRzID0gbzEgPDwgMTYgfCBvMiA8PCA4IHwgbzM7XG5cbiAgICAgICAgaDEgPSBiaXRzID4+IDE4ICYgMHgzZjtcbiAgICAgICAgaDIgPSBiaXRzID4+IDEyICYgMHgzZjtcbiAgICAgICAgaDMgPSBiaXRzID4+IDYgJiAweDNmO1xuICAgICAgICBoNCA9IGJpdHMgJiAweDNmO1xuXG4gICAgICAgIC8vIHVzZSBoZXhldHMgdG8gaW5kZXggaW50byBiNjQsIGFuZCBhcHBlbmQgcmVzdWx0IHRvIGVuY29kZWQgc3RyaW5nXG4gICAgICAgIHRtcF9hcnJbYWMrK10gPSBiNjQuY2hhckF0KGgxKSArIGI2NC5jaGFyQXQoaDIpICsgYjY0LmNoYXJBdChoMykgKyBiNjQuY2hhckF0KGg0KTtcbiAgICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICAgIGVuYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICAgIHZhciByID0gZGF0YS5sZW5ndGggJSAzO1xuXG4gICAgICByZXR1cm4gKHIgPyBlbmMuc2xpY2UoMCwgciAtIDMpIDogZW5jKSArICc9PT0nLnNsaWNlKHIgfHwgMyk7XG5cbiAgICB9LFxuXG4gICAgX2I2NF9kZWNvZGU6IGZ1bmN0aW9uIGJhc2U2NF9kZWNvZGUoZGF0YSkge1xuICAgICAgLy8gaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXRcbiAgICAgIC8vICsgICBvcmlnaW5hbCBieTogVHlsZXIgQWtpbnMgKGh0dHA6Ly9ydW1raW4uY29tKVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBUaHVuZGVyLm1cbiAgICAgIC8vICsgICAgICBpbnB1dCBieTogQW1hbiBHdXB0YVxuICAgICAgLy8gKyAgIGltcHJvdmVkIGJ5OiBLZXZpbiB2YW4gWm9ubmV2ZWxkIChodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldClcbiAgICAgIC8vICsgICBidWdmaXhlZCBieTogT25ubyBNYXJzbWFuXG4gICAgICAvLyArICAgYnVnZml4ZWQgYnk6IFBlbGxlbnRlc3F1ZSBNYWxlc3VhZGFcbiAgICAgIC8vICsgICBpbXByb3ZlZCBieTogS2V2aW4gdmFuIFpvbm5ldmVsZCAoaHR0cDovL2tldmluLnZhbnpvbm5ldmVsZC5uZXQpXG4gICAgICAvLyArICAgICAgaW5wdXQgYnk6IEJyZXR0IFphbWlyIChodHRwOi8vYnJldHQtemFtaXIubWUpXG4gICAgICAvLyArICAgYnVnZml4ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxuICAgICAgLy8gKiAgICAgZXhhbXBsZSAxOiBiYXNlNjRfZGVjb2RlKCdTMlYyYVc0Z2RtRnVJRnB2Ym01bGRtVnNaQT09Jyk7XG4gICAgICAvLyAqICAgICByZXR1cm5zIDE6ICdLZXZpbiB2YW4gWm9ubmV2ZWxkJ1xuICAgICAgLy8gbW96aWxsYSBoYXMgdGhpcyBuYXRpdmVcbiAgICAgIC8vIC0gYnV0IGJyZWFrcyBpbiAyLjAuMC4xMiFcbiAgICAgIC8vaWYgKHR5cGVvZiB0aGlzLndpbmRvd1snYnRvYSddID09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vICAgIHJldHVybiBidG9hKGRhdGEpO1xuICAgICAgLy99XG4gICAgICB2YXIgYjY0ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiICtcbiAgICAgICAgICAgICAgICBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICAgICAgdmFyIG8xLCBvMiwgbzMsIGgxLCBoMiwgaDMsIGg0LCBiaXRzLCBpID0gMCxcbiAgICAgICAgYWMgPSAwLFxuICAgICAgICBkZWMgPSBcIlwiLFxuICAgICAgICB0bXBfYXJyID0gW107XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH1cblxuICAgICAgZGF0YSArPSAnJztcblxuICAgICAgZG8geyAvLyB1bnBhY2sgZm91ciBoZXhldHMgaW50byB0aHJlZSBvY3RldHMgdXNpbmcgaW5kZXggcG9pbnRzIGluIGI2NFxuICAgICAgICBoMSA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgICBoMiA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgICBoMyA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuICAgICAgICBoNCA9IGI2NC5pbmRleE9mKGRhdGEuY2hhckF0KGkrKykpO1xuXG4gICAgICAgIGJpdHMgPSBoMSA8PCAxOCB8IGgyIDw8IDEyIHwgaDMgPDwgNiB8IGg0O1xuXG4gICAgICAgIG8xID0gYml0cyA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIG8yID0gYml0cyA+PiA4ICYgMHhmZjtcbiAgICAgICAgbzMgPSBiaXRzICYgMHhmZjtcblxuICAgICAgICBpZiAoaDMgPT0gNjQpIHtcbiAgICAgICAgICB0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaDQgPT0gNjQpIHtcbiAgICAgICAgICB0bXBfYXJyW2FjKytdID0gU3RyaW5nLmZyb21DaGFyQ29kZShvMSwgbzIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRtcF9hcnJbYWMrK10gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG8xLCBvMiwgbzMpO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG4gICAgICBkZWMgPSB0bXBfYXJyLmpvaW4oJycpO1xuXG4gICAgICByZXR1cm4gZGVjO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgYmluYXJ5IHZhbHVlIGZyb20gdGhlIGdpdmVuIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFTdHJpbmcgICAgICAgIFRoZSBiaW5hcnkgdmFsdWUgc3RyaW5nXG4gICAqIEByZXR1cm4ge0lDQUwuQmluYXJ5fSAgICAgICAgICBUaGUgYmluYXJ5IHZhbHVlIGluc3RhbmNlXG4gICAqL1xuICBCaW5hcnkuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKGFTdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IEJpbmFyeShhU3RyaW5nKTtcbiAgfTtcblxuICByZXR1cm4gQmluYXJ5O1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJwZXJpb2RcIiB2YWx1ZSB0eXBlLCB3aXRoIHZhcmlvdXMgY2FsY3VsYXRpb25cbiAgICogYW5kIG1hbmlwdWxhdGlvbiBtZXRob2RzLlxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIHBhc3NlZCBkYXRhIG9iamVjdCBjYW5ub3QgY29udGFpbiBib3RoIGFuZCBlbmQgZGF0ZSBhbmQgYSBkdXJhdGlvbi5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLnN0YXJ0ICAgICAgICBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGFEYXRhLmVuZCAgICAgICAgICBUaGUgZW5kIG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9uPX0gYURhdGEuZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBwZXJpb2RcbiAgICovXG4gIElDQUwuUGVyaW9kID0gZnVuY3Rpb24gaWNhbHBlcmlvZChhRGF0YSkge1xuICAgIHRoaXMud3JhcHBlZEpTT2JqZWN0ID0gdGhpcztcblxuICAgIGlmIChhRGF0YSAmJiAnc3RhcnQnIGluIGFEYXRhKSB7XG4gICAgICBpZiAoYURhdGEuc3RhcnQgJiYgIShhRGF0YS5zdGFydCBpbnN0YW5jZW9mIElDQUwuVGltZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLnN0YXJ0IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSUNBTC5UaW1lJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXJ0ID0gYURhdGEuc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmIGFEYXRhLmVuZCAmJiBhRGF0YS5kdXJhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYWNjZXB0IGJvdGggZW5kIGFuZCBkdXJhdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChhRGF0YSAmJiAnZW5kJyBpbiBhRGF0YSkge1xuICAgICAgaWYgKGFEYXRhLmVuZCAmJiAhKGFEYXRhLmVuZCBpbnN0YW5jZW9mIElDQUwuVGltZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLmVuZCBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIElDQUwuVGltZScpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbmQgPSBhRGF0YS5lbmQ7XG4gICAgfVxuXG4gICAgaWYgKGFEYXRhICYmICdkdXJhdGlvbicgaW4gYURhdGEpIHtcbiAgICAgIGlmIChhRGF0YS5kdXJhdGlvbiAmJiAhKGFEYXRhLmR1cmF0aW9uIGluc3RhbmNlb2YgSUNBTC5EdXJhdGlvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignLmR1cmF0aW9uIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgSUNBTC5EdXJhdGlvbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5kdXJhdGlvbiA9IGFEYXRhLmR1cmF0aW9uO1xuICAgIH1cbiAgfTtcblxuICBJQ0FMLlBlcmlvZC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgb2YgdGhlIHBlcmlvZFxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgc3RhcnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW5kIG9mIHRoZSBwZXJpb2RcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGVuZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgcGVyaW9kXG4gICAgICogQHR5cGUge0lDQUwuRHVyYXRpb259XG4gICAgICovXG4gICAgZHVyYXRpb246IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHBlcmlvZFwiXG4gICAgICovXG4gICAgaWNhbGNsYXNzOiBcImljYWxwZXJpb2RcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG5hbWUsIHRvIGJlIHVzZWQgaW4gdGhlIGpDYWwgb2JqZWN0LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJwZXJpb2RcIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcInBlcmlvZFwiLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBkdXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlBlcmlvZH0gICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJQ0FMLlBlcmlvZC5mcm9tRGF0YSh7XG4gICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ID8gdGhpcy5zdGFydC5jbG9uZSgpIDogbnVsbCxcbiAgICAgICAgZW5kOiB0aGlzLmVuZCA/IHRoaXMuZW5kLmNsb25lKCkgOiBudWxsLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbiA/IHRoaXMuZHVyYXRpb24uY2xvbmUoKSA6IG51bGxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBkdXJhdGlvbiBvZiB0aGUgcGVyaW9kLCBlaXRoZXIgZGlyZWN0bHkgb3IgYnkgc3VidHJhY3RpbmdcbiAgICAgKiBzdGFydCBmcm9tIGVuZCBkYXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5EdXJhdGlvbn0gICAgICBUaGUgY2FsY3VsYXRlZCBkdXJhdGlvblxuICAgICAqL1xuICAgIGdldER1cmF0aW9uOiBmdW5jdGlvbiBkdXJhdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmR1cmF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLnN1YnRyYWN0RGF0ZSh0aGlzLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZW5kIGRhdGUgb2YgdGhlIHBlcmlvZCwgZWl0aGVyIGRpcmVjdGx5IG9yIGJ5IGFkZGluZ1xuICAgICAqIGR1cmF0aW9uIHRvIHN0YXJ0IGRhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgIFRoZSBjYWxjdWxhdGVkIGVuZCBkYXRlXG4gICAgICovXG4gICAgZ2V0RW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5zdGFydC5jbG9uZSgpO1xuICAgICAgICBlbmQuYWRkRHVyYXRpb24odGhpcy5kdXJhdGlvbik7XG4gICAgICAgIHJldHVybiBlbmQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwZXJpb2QuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgXCIvXCIgKyAodGhpcy5lbmQgfHwgdGhpcy5kdXJhdGlvbik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBqQ2FsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcGVyaW9kIHR5cGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3RoaXMuc3RhcnQudG9TdHJpbmcoKSwgKHRoaXMuZW5kIHx8IHRoaXMuZHVyYXRpb24pLnRvU3RyaW5nKCldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaUNhbGVuZGFyIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBlcmlvZC5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICovXG4gICAgdG9JQ0FMU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXJ0LnRvSUNBTFN0cmluZygpICsgXCIvXCIgK1xuICAgICAgICAgICAgICh0aGlzLmVuZCB8fCB0aGlzLmR1cmF0aW9uKS50b0lDQUxTdHJpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcge0BsaW5rIElDQUwuUGVyaW9kfSBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICAgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHl9IHByb3AgICAgVGhlIHByb3BlcnR5IHRoaXMgcGVyaW9kIHdpbGwgYmUgb25cbiAgICogQHJldHVybiB7SUNBTC5QZXJpb2R9ICAgICAgICAgIFRoZSBjcmVhdGVkIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5QZXJpb2QuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyLCBwcm9wKSB7XG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcvJyk7XG5cbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbnZhbGlkIHN0cmluZyB2YWx1ZTogXCInICsgc3RyICsgJ1wiIG11c3QgY29udGFpbiBhIFwiL1wiIGNoYXIuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHN0YXJ0OiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKHBhcnRzWzBdLCBwcm9wKVxuICAgIH07XG5cbiAgICB2YXIgZW5kID0gcGFydHNbMV07XG5cbiAgICBpZiAoSUNBTC5EdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKGVuZCkpIHtcbiAgICAgIG9wdGlvbnMuZHVyYXRpb24gPSBJQ0FMLkR1cmF0aW9uLmZyb21TdHJpbmcoZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucy5lbmQgPSBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGVuZCwgcHJvcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJQ0FMLlBlcmlvZChvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5QZXJpb2R9IGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGRhdGEgb2JqZWN0LlxuICAgKiBUaGUgcGFzc2VkIGRhdGEgb2JqZWN0IGNhbm5vdCBjb250YWluIGJvdGggYW5kIGVuZCBkYXRlIGFuZCBhIGR1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBhRGF0YS5zdGFydCAgICAgICAgVGhlIHN0YXJ0IG9mIHRoZSBwZXJpb2RcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBhRGF0YS5lbmQgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcGVyaW9kXG4gICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbj19IGFEYXRhLmR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgcGVyaW9kXG4gICAqIEByZXR1cm4ge0lDQUwuUGVyaW9kfSAgICAgICAgICAgICAgICAgIFRoZSBwZXJpb2QgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuUGVyaW9kLmZyb21EYXRhID0gZnVuY3Rpb24gZnJvbURhdGEoYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IElDQUwuUGVyaW9kKGFEYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBwZXJpb2QgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gakNhbCBkYXRhIGFycmF5LiBUaGUgZmlyc3RcbiAgICogbWVtYmVyIGlzIGFsd2F5cyB0aGUgc3RhcnQgZGF0ZSBzdHJpbmcsIHRoZSBzZWNvbmQgbWVtYmVyIGlzIGVpdGhlciBhXG4gICAqIGR1cmF0aW9uIG9yIGVuZCBkYXRlIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmcsU3RyaW5nPn0gYURhdGEgICAgVGhlIGpDYWwgZGF0YSBhcnJheVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHl9IGFQcm9wICAgICAgICAgICBUaGUgcHJvcGVydHkgdGhpcyBqQ2FsIGRhdGEgaXMgb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBhTGVuaWVudCAgICAgICAgICAgICAgSWYgdHJ1ZSwgZGF0YSB2YWx1ZSBjYW4gYmUgYm90aCBkYXRlIGFuZCBkYXRlLXRpbWVcbiAgICogQHJldHVybiB7SUNBTC5QZXJpb2R9ICAgICAgICAgICAgICAgICAgVGhlIHBlcmlvZCBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5QZXJpb2QuZnJvbUpTT04gPSBmdW5jdGlvbihhRGF0YSwgYVByb3AsIGFMZW5pZW50KSB7XG4gICAgZnVuY3Rpb24gZnJvbURhdGVPckRhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3ApIHtcbiAgICAgIGlmIChhTGVuaWVudCkge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21TdHJpbmcoYVZhbHVlLCBhUHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLmZyb21EYXRlVGltZVN0cmluZyhhVmFsdWUsIGFQcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoSUNBTC5EdXJhdGlvbi5pc1ZhbHVlU3RyaW5nKGFEYXRhWzFdKSkge1xuICAgICAgcmV0dXJuIElDQUwuUGVyaW9kLmZyb21EYXRhKHtcbiAgICAgICAgc3RhcnQ6IGZyb21EYXRlT3JEYXRlVGltZVN0cmluZyhhRGF0YVswXSwgYVByb3ApLFxuICAgICAgICBkdXJhdGlvbjogSUNBTC5EdXJhdGlvbi5mcm9tU3RyaW5nKGFEYXRhWzFdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBJQ0FMLlBlcmlvZC5mcm9tRGF0YSh7XG4gICAgICAgIHN0YXJ0OiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYURhdGFbMF0sIGFQcm9wKSxcbiAgICAgICAgZW5kOiBmcm9tRGF0ZU9yRGF0ZVRpbWVTdHJpbmcoYURhdGFbMV0sIGFQcm9wKVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBEVVJBVElPTl9MRVRURVJTID0gLyhbUERXSE1UU117MSwxfSkvO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJkdXJhdGlvblwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICAgKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5EdXJhdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLndlZWtzICAgICAgICAgRHVyYXRpb24gaW4gd2Vla3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEuZGF5cyAgICAgICAgICBEdXJhdGlvbiBpbiBkYXlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLmhvdXJzICAgICAgICAgRHVyYXRpb24gaW4gaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEubWludXRlcyAgICAgICBEdXJhdGlvbiBpbiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkYXRhLnNlY29uZHMgICAgICAgRHVyYXRpb24gaW4gc2Vjb25kc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRhdGEuaXNOZWdhdGl2ZSAgIElmIHRydWUsIHRoZSBkdXJhdGlvbiBpcyBuZWdhdGl2ZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbiA9IGZ1bmN0aW9uIGljYWxkdXJhdGlvbihkYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIHRoaXMuZnJvbURhdGEoZGF0YSk7XG4gIH07XG5cbiAgSUNBTC5EdXJhdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIHdlZWtzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB3ZWVrczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXlzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICBkYXlzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRheXMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGhvdXJzOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1pbnV0ZXMgaW4gdGhpcyBkdXJhdGlvblxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIG1pbnV0ZXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2Vjb25kcyBpbiB0aGlzIGR1cmF0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgc2Vjb25kczogMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWNvbmRzIGluIHRoaXMgZHVyYXRpb25cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGlzTmVnYXRpdmU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImljYWxkdXJhdGlvblwiXG4gICAgICovXG4gICAgaWNhbGNsYXNzOiBcImljYWxkdXJhdGlvblwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgbmFtZSwgdG8gYmUgdXNlZCBpbiB0aGUgakNhbCBvYmplY3QuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImR1cmF0aW9uXCJcbiAgICAgKi9cbiAgICBpY2FsdHlwZTogXCJkdXJhdGlvblwiLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSBkdXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIElDQUwuRHVyYXRpb24uZnJvbURhdGEodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkdXJhdGlvbiB2YWx1ZSBleHByZXNzZWQgYXMgYSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgVGhlIGR1cmF0aW9uIHZhbHVlIGluIHNlY29uZHNcbiAgICAgKi9cbiAgICB0b1NlY29uZHM6IGZ1bmN0aW9uIHRvU2Vjb25kcygpIHtcbiAgICAgIHZhciBzZWNvbmRzID0gdGhpcy5zZWNvbmRzICsgNjAgKiB0aGlzLm1pbnV0ZXMgKyAzNjAwICogdGhpcy5ob3VycyArXG4gICAgICAgICAgICAgICAgICAgIDg2NDAwICogdGhpcy5kYXlzICsgNyAqIDg2NDAwICogdGhpcy53ZWVrcztcbiAgICAgIHJldHVybiAodGhpcy5pc05lZ2F0aXZlID8gLXNlY29uZHMgOiBzZWNvbmRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIHBhc3NlZCBzZWNvbmRzIHZhbHVlIGludG8gdGhpcyBkdXJhdGlvbiBvYmplY3QuIEFmdGVyd2FyZHMsXG4gICAgICogbWVtYmVycyBsaWtlIHtAbGluayBJQ0FMLkR1cmF0aW9uI2RheXMgZGF5c30gYW5kIHtAbGluayBJQ0FMLkR1cmF0aW9uI3dlZWtzIHdlZWtzfSB3aWxsIGJlIHNldCB1cFxuICAgICAqIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFTZWNvbmRzICAgICBUaGUgZHVyYXRpb24gdmFsdWUgaW4gc2Vjb25kc1xuICAgICAqIEByZXR1cm4ge0lDQUwuRHVyYXRpb259ICAgICAgUmV0dXJucyB0aGlzIGluc3RhbmNlXG4gICAgICovXG4gICAgZnJvbVNlY29uZHM6IGZ1bmN0aW9uIGZyb21TZWNvbmRzKGFTZWNvbmRzKSB7XG4gICAgICB2YXIgc2VjcyA9IE1hdGguYWJzKGFTZWNvbmRzKTtcblxuICAgICAgdGhpcy5pc05lZ2F0aXZlID0gKGFTZWNvbmRzIDwgMCk7XG4gICAgICB0aGlzLmRheXMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDg2NDAwKTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBhIGZsYXQgbnVtYmVyIG9mIHdlZWtzLCB1c2UgdGhlbS5cbiAgICAgIGlmICh0aGlzLmRheXMgJSA3ID09IDApIHtcbiAgICAgICAgdGhpcy53ZWVrcyA9IHRoaXMuZGF5cyAvIDc7XG4gICAgICAgIHRoaXMuZGF5cyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndlZWtzID0gMDtcbiAgICAgIH1cblxuICAgICAgc2VjcyAtPSAodGhpcy5kYXlzICsgNyAqIHRoaXMud2Vla3MpICogODY0MDA7XG5cbiAgICAgIHRoaXMuaG91cnMgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2VjcyAvIDM2MDApO1xuICAgICAgc2VjcyAtPSB0aGlzLmhvdXJzICogMzYwMDtcblxuICAgICAgdGhpcy5taW51dGVzID0gSUNBTC5oZWxwZXJzLnRydW5jKHNlY3MgLyA2MCk7XG4gICAgICBzZWNzIC09IHRoaXMubWludXRlcyAqIDYwO1xuXG4gICAgICB0aGlzLnNlY29uZHMgPSBzZWNzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWQgZGF0YSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSBkdXJhdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS53ZWVrcyAgICAgICAgIER1cmF0aW9uIGluIHdlZWtzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmRheXMgICAgICAgICAgRHVyYXRpb24gaW4gZGF5c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5ob3VycyAgICAgICAgIER1cmF0aW9uIGluIGhvdXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLm1pbnV0ZXMgICAgICAgRHVyYXRpb24gaW4gbWludXRlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5zZWNvbmRzICAgICAgIER1cmF0aW9uIGluIHNlY29uZHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFEYXRhLmlzTmVnYXRpdmUgICBJZiB0cnVlLCB0aGUgZHVyYXRpb24gaXMgbmVnYXRpdmVcbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24gZnJvbURhdGEoYURhdGEpIHtcbiAgICAgIHZhciBwcm9wc1RvQ29weSA9IFtcIndlZWtzXCIsIFwiZGF5c1wiLCBcImhvdXJzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcImlzTmVnYXRpdmVcIl07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHNUb0NvcHkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghcHJvcHNUb0NvcHkuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNUb0NvcHlba2V5XTtcbiAgICAgICAgaWYgKGFEYXRhICYmIHByb3AgaW4gYURhdGEpIHtcbiAgICAgICAgICB0aGlzW3Byb3BdID0gYURhdGFbcHJvcF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1twcm9wXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBkdXJhdGlvbiBpbnN0YW5jZSB0byB0aGUgZGVmYXVsdCB2YWx1ZXMsIGkuZS4gUFQwU1xuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuaXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy53ZWVrcyA9IDA7XG4gICAgICB0aGlzLmRheXMgPSAwO1xuICAgICAgdGhpcy5ob3VycyA9IDA7XG4gICAgICB0aGlzLm1pbnV0ZXMgPSAwO1xuICAgICAgdGhpcy5zZWNvbmRzID0gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhlIGR1cmF0aW9uIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb259IGFPdGhlciAgICAgICAgVGhlIGluc3RhbmNlIHRvIGNvbXBhcmUgd2l0aFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICAgKi9cbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKGFPdGhlcikge1xuICAgICAgdmFyIHRoaXNTZWNvbmRzID0gdGhpcy50b1NlY29uZHMoKTtcbiAgICAgIHZhciBvdGhlclNlY29uZHMgPSBhT3RoZXIudG9TZWNvbmRzKCk7XG4gICAgICByZXR1cm4gKHRoaXNTZWNvbmRzID4gb3RoZXJTZWNvbmRzKSAtICh0aGlzU2Vjb25kcyA8IG90aGVyU2Vjb25kcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgdGhlIGR1cmF0aW9uIGluc3RhbmNlLiBGb3IgZXhhbXBsZSwgYSBkdXJhdGlvbiB3aXRoIGEgdmFsdWVcbiAgICAgKiBvZiA2MSBzZWNvbmRzIHdpbGwgYmUgbm9ybWFsaXplZCB0byAxIG1pbnV0ZSBhbmQgMSBzZWNvbmQuXG4gICAgICovXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gICAgICB0aGlzLmZyb21TZWNvbmRzKHRoaXMudG9TZWNvbmRzKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZHVyYXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIGlmICh0aGlzLnRvU2Vjb25kcygpID09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiUFQwU1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUpIHN0ciArPSBcIi1cIjtcbiAgICAgICAgc3RyICs9IFwiUFwiO1xuICAgICAgICBpZiAodGhpcy53ZWVrcykgc3RyICs9IHRoaXMud2Vla3MgKyBcIldcIjtcbiAgICAgICAgaWYgKHRoaXMuZGF5cykgc3RyICs9IHRoaXMuZGF5cyArIFwiRFwiO1xuXG4gICAgICAgIGlmICh0aGlzLmhvdXJzIHx8IHRoaXMubWludXRlcyB8fCB0aGlzLnNlY29uZHMpIHtcbiAgICAgICAgICBzdHIgKz0gXCJUXCI7XG4gICAgICAgICAgaWYgKHRoaXMuaG91cnMpIHN0ciArPSB0aGlzLmhvdXJzICsgXCJIXCI7XG4gICAgICAgICAgaWYgKHRoaXMubWludXRlcykgc3RyICs9IHRoaXMubWludXRlcyArIFwiTVwiO1xuICAgICAgICAgIGlmICh0aGlzLnNlY29uZHMpIHN0ciArPSB0aGlzLnNlY29uZHMgKyBcIlNcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaUNhbGVuZGFyIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGR1cmF0aW9uLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b0lDQUxTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5EdXJhdGlvbiBpbnN0YW5jZSBmcm9tIHRoZSBwYXNzZWQgc2Vjb25kcyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFTZWNvbmRzICAgICAgIFRoZSBzZWNvbmRzIHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2UgZnJvbVxuICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgICAgVGhlIG5ld2x5IGNyZWF0ZWQgZHVyYXRpb24gaW5zdGFuY2VcbiAgICovXG4gIElDQUwuRHVyYXRpb24uZnJvbVNlY29uZHMgPSBmdW5jdGlvbiBpY2FsZHVyYXRpb25fZnJvbV9zZWNvbmRzKGFTZWNvbmRzKSB7XG4gICAgcmV0dXJuIChuZXcgSUNBTC5EdXJhdGlvbigpKS5mcm9tU2Vjb25kcyhhU2Vjb25kcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiB0byBoYW5kbGUgYSBjaHVuayBvZiBhIGR1cmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGV0dGVyIHR5cGUgb2YgZHVyYXRpb24gY2h1bmtcbiAgICogQHBhcmFtIHtTdHJpbmd9IG51bWJlciBudW1lcmljIHZhbHVlIG9yIC0vK1xuICAgKiBAcGFyYW0ge09iamVjdH0gZGljdCB0YXJnZXQgdG8gYXNzaWduIHZhbHVlcyB0b1xuICAgKi9cbiAgZnVuY3Rpb24gcGFyc2VEdXJhdGlvbkNodW5rKGxldHRlciwgbnVtYmVyLCBvYmplY3QpIHtcbiAgICB2YXIgdHlwZTtcbiAgICBzd2l0Y2ggKGxldHRlcikge1xuICAgICAgY2FzZSAnUCc6XG4gICAgICAgIGlmIChudW1iZXIgJiYgbnVtYmVyID09PSAnLScpIHtcbiAgICAgICAgICBvYmplY3QuaXNOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqZWN0LmlzTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJpb2RcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdEJzpcbiAgICAgICAgdHlwZSA9ICdkYXlzJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdXJzpcbiAgICAgICAgdHlwZSA9ICd3ZWVrcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnSCc6XG4gICAgICAgIHR5cGUgPSAnaG91cnMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ00nOlxuICAgICAgICB0eXBlID0gJ21pbnV0ZXMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1MnOlxuICAgICAgICB0eXBlID0gJ3NlY29uZHMnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIE5vdCBhIHZhbGlkIGNodW5rXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICh0eXBlKSB7XG4gICAgICBpZiAoIW51bWJlciAmJiBudW1iZXIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdpbnZhbGlkIGR1cmF0aW9uIHZhbHVlOiBNaXNzaW5nIG51bWJlciBiZWZvcmUgXCInICsgbGV0dGVyICsgJ1wiJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIG51bSA9IHBhcnNlSW50KG51bWJlciwgMTApO1xuICAgICAgaWYgKElDQUwuaGVscGVycy5pc1N0cmljdGx5TmFOKG51bSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdpbnZhbGlkIGR1cmF0aW9uIHZhbHVlOiBJbnZhbGlkIG51bWJlciBcIicgKyBudW1iZXIgKyAnXCIgYmVmb3JlIFwiJyArIGxldHRlciArICdcIidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG9iamVjdFt0eXBlXSA9IG51bTtcbiAgICB9XG5cbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhbiBpQ2FsZW5kYXIgZHVyYXRpb24gdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAgICAgIFRoZSByYXcgaWNhbCB2YWx1ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBUcnVlLCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgb2YgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gaWNhbCB0eXBlXG4gICAqL1xuICBJQ0FMLkR1cmF0aW9uLmlzVmFsdWVTdHJpbmcgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICByZXR1cm4gKHN0cmluZ1swXSA9PT0gJ1AnIHx8IHN0cmluZ1sxXSA9PT0gJ1AnKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5EdXJhdGlvbn0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFTdHIgICAgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICBUaGUgY3JlYXRlZCBkdXJhdGlvbiBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5EdXJhdGlvbi5mcm9tU3RyaW5nID0gZnVuY3Rpb24gaWNhbGR1cmF0aW9uX2Zyb21fc3RyaW5nKGFTdHIpIHtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgZGljdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGNodW5rcyA9IDA7XG5cbiAgICB3aGlsZSAoKHBvcyA9IGFTdHIuc2VhcmNoKERVUkFUSU9OX0xFVFRFUlMpKSAhPT0gLTEpIHtcbiAgICAgIHZhciB0eXBlID0gYVN0cltwb3NdO1xuICAgICAgdmFyIG51bWVyaWMgPSBhU3RyLnN1YnN0cigwLCBwb3MpO1xuICAgICAgYVN0ciA9IGFTdHIuc3Vic3RyKHBvcyArIDEpO1xuXG4gICAgICBjaHVua3MgKz0gcGFyc2VEdXJhdGlvbkNodW5rKHR5cGUsIG51bWVyaWMsIGRpY3QpO1xuICAgIH1cblxuICAgIGlmIChjaHVua3MgPCAyKSB7XG4gICAgICAvLyBUaGVyZSBtdXN0IGJlIGF0IGxlYXN0IGEgY2h1bmsgd2l0aCBcIlBcIiBhbmQgc29tZSB1bml0IGNodW5rXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdpbnZhbGlkIGR1cmF0aW9uIHZhbHVlOiBOb3QgZW5vdWdoIGR1cmF0aW9uIGNvbXBvbmVudHMgaW4gXCInICsgYVN0ciArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBJQ0FMLkR1cmF0aW9uKGRpY3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuRHVyYXRpb24gaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIGR1cmF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS53ZWVrcyAgICAgICAgIER1cmF0aW9uIGluIHdlZWtzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5kYXlzICAgICAgICAgIER1cmF0aW9uIGluIGRheXNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmhvdXJzICAgICAgICAgRHVyYXRpb24gaW4gaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLm1pbnV0ZXMgICAgICAgRHVyYXRpb24gaW4gbWludXRlc1xuICAgKiBAcGFyYW0ge051bWJlcn0gYURhdGEuc2Vjb25kcyAgICAgICBEdXJhdGlvbiBpbiBzZWNvbmRzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYURhdGEuaXNOZWdhdGl2ZSAgIElmIHRydWUsIHRoZSBkdXJhdGlvbiBpcyBuZWdhdGl2ZVxuICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgICAgICAgICBUaGUgY3JlYXRlYWQgZHVyYXRpb24gaW5zdGFuY2VcbiAgICovXG4gIElDQUwuRHVyYXRpb24uZnJvbURhdGEgPSBmdW5jdGlvbiBpY2FsZHVyYXRpb25fZnJvbV9kYXRhKGFEYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBJQ0FMLkR1cmF0aW9uKGFEYXRhKTtcbiAgfTtcbn0pKCk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxMiAqL1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgT1BUSU9OUyA9IFtcInR6aWRcIiwgXCJsb2NhdGlvblwiLCBcInR6bmFtZXNcIixcbiAgICAgICAgICAgICAgICAgXCJsYXRpdHVkZVwiLCBcImxvbmdpdHVkZVwiXTtcblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBUaW1lem9uZSByZXByZXNlbnRhdGlvbiwgY3JlYXRlZCBieSBwYXNzaW5nIGluIGEgdHppZCBhbmQgY29tcG9uZW50LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdmNhbGVuZGFyO1xuICAgKiB2YXIgdGltZXpvbmVDb21wID0gdmNhbGVuZGFyLmdldEZpcnN0U3ViY29tcG9uZW50KCd2dGltZXpvbmUnKTtcbiAgICogdmFyIHR6aWQgPSB0aW1lem9uZUNvbXAuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKCd0emlkJyk7XG4gICAqXG4gICAqIHZhciB0aW1lem9uZSA9IG5ldyBJQ0FMLlRpbWV6b25lKHtcbiAgICogICBjb21wb25lbnQ6IHRpbWV6b25lQ29tcCxcbiAgICogICB0emlkXG4gICAqIH0pO1xuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxPYmplY3R9IGRhdGEgb3B0aW9ucyBmb3IgY2xhc3NcbiAgICogQHBhcmFtIHtTdHJpbmd8SUNBTC5Db21wb25lbnR9IGRhdGEuY29tcG9uZW50XG4gICAqICAgICAgICBJZiBkYXRhIGlzIGEgc2ltcGxlIG9iamVjdCwgdGhlbiB0aGlzIG1lbWJlciBjYW4gYmUgc2V0IHRvIGVpdGhlciBhXG4gICAqICAgICAgICBzdHJpbmcgY29udGFpbmluZyB0aGUgY29tcG9uZW50IGRhdGEsIG9yIGFuIGFscmVhZHkgcGFyc2VkXG4gICAqICAgICAgICBJQ0FMLkNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS50emlkICAgICAgVGhlIHRpbWV6b25lIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEubG9jYXRpb24gIFRoZSB0aW1lem9uZSBsb2NhdGlvbndcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEudHpuYW1lcyAgIEFuIGFsdGVybmF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEubGF0aXR1ZGUgIFRoZSBsYXRpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhdGEubG9uZ2l0dWRlIFRoZSBsb25naXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAqL1xuICBJQ0FMLlRpbWV6b25lID0gZnVuY3Rpb24gaWNhbHRpbWV6b25lKGRhdGEpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdGhpcy5mcm9tRGF0YShkYXRhKTtcbiAgfTtcblxuICBJQ0FMLlRpbWV6b25lLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFRpbWV6b25lIGlkZW50aWZpZXJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIHR6aWQ6IFwiXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaW1lem9uZSBsb2NhdGlvblxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgbG9jYXRpb246IFwiXCIsXG5cbiAgICAvKipcbiAgICAgKiBBbHRlcm5hdGl2ZSB0aW1lem9uZSBuYW1lLCBmb3IgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdHpuYW1lczogXCJcIixcblxuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IGxhdGl0dWRlIGZvciB0aGUgdGltZXpvbmUuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBsYXRpdHVkZTogMC4wLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgbG9uZ2l0dWRlIGZvciB0aGUgdGltZXpvbmUuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICBsb25naXR1ZGU6IDAuMCxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2dGltZXpvbmUgY29tcG9uZW50IGZvciB0aGlzIHRpbWV6b25lLlxuICAgICAqIEB0eXBlIHtJQ0FMLkNvbXBvbmVudH1cbiAgICAgKi9cbiAgICBjb21wb25lbnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgeWVhciB0aGlzIHRpbWV6b25lIGhhcyBiZWVuIGV4cGFuZGVkIHRvLiBBbGwgdGltZXpvbmUgdHJhbnNpdGlvblxuICAgICAqIGRhdGVzIHVudGlsIHRoaXMgeWVhciBhcmUga25vd24gYW5kIGNhbiBiZSB1c2VkIGZvciBjYWxjdWxhdGlvblxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGV4cGFuZGVkVW50aWxZZWFyOiAwLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImljYWx0aW1lem9uZVwiXG4gICAgICovXG4gICAgaWNhbGNsYXNzOiBcImljYWx0aW1lem9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR8T2JqZWN0fSBhRGF0YSBvcHRpb25zIGZvciBjbGFzc1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfElDQUwuQ29tcG9uZW50fSBhRGF0YS5jb21wb25lbnRcbiAgICAgKiAgICAgICAgSWYgYURhdGEgaXMgYSBzaW1wbGUgb2JqZWN0LCB0aGVuIHRoaXMgbWVtYmVyIGNhbiBiZSBzZXQgdG8gZWl0aGVyIGFcbiAgICAgKiAgICAgICAgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGNvbXBvbmVudCBkYXRhLCBvciBhbiBhbHJlYWR5IHBhcnNlZFxuICAgICAqICAgICAgICBJQ0FMLkNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS50emlkICAgICAgVGhlIHRpbWV6b25lIGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEubG9jYXRpb24gIFRoZSB0aW1lem9uZSBsb2NhdGlvbndcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEudHpuYW1lcyAgIEFuIGFsdGVybmF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lem9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5sYXRpdHVkZSAgVGhlIGxhdGl0dWRlIG9mIHRoZSB0aW1lem9uZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5sb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24gZnJvbURhdGEoYURhdGEpIHtcbiAgICAgIHRoaXMuZXhwYW5kZWRVbnRpbFllYXIgPSAwO1xuICAgICAgdGhpcy5jaGFuZ2VzID0gW107XG5cbiAgICAgIGlmIChhRGF0YSBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIEVpdGhlciBhIGNvbXBvbmVudCBpcyBwYXNzZWQgZGlyZWN0bHlcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBhRGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSB0aGUgY29tcG9uZW50IG1heSBiZSBpbiB0aGUgZGF0YSBvYmplY3RcbiAgICAgICAgaWYgKGFEYXRhICYmIFwiY29tcG9uZW50XCIgaW4gYURhdGEpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFEYXRhLmNvbXBvbmVudCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHN0cmluZyB3YXMgcGFzc2VkLCBwYXJzZSBpdCBhcyBhIGNvbXBvbmVudFxuICAgICAgICAgICAgdmFyIGpDYWwgPSBJQ0FMLnBhcnNlKGFEYXRhLmNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IG5ldyBJQ0FMLkNvbXBvbmVudChqQ2FsKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFEYXRhLmNvbXBvbmVudCBpbnN0YW5jZW9mIElDQUwuQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBJZiBpdCB3YXMgYSBjb21wb25lbnQgYWxyZWFkeSwgdGhlbiBqdXN0IHNldCBpdFxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBhRGF0YS5jb21wb25lbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IG51bGwgb3V0IHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb3B5IHJlbWFpbmluZyBwYXNzZWQgcHJvcGVydGllc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gT1BUSU9OUykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKE9QVElPTlMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBPUFRJT05TW2tleV07XG4gICAgICAgICAgICBpZiAoYURhdGEgJiYgcHJvcCBpbiBhRGF0YSkge1xuICAgICAgICAgICAgICB0aGlzW3Byb3BdID0gYURhdGFbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgYSBjb21wb25lbnQgYnV0IG5vIFRaSUQsIGF0dGVtcHQgdG8gZ2V0IGl0IGZyb20gdGhlXG4gICAgICAvLyBjb21wb25lbnQncyBwcm9wZXJ0aWVzLlxuICAgICAgaWYgKHRoaXMuY29tcG9uZW50IGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQgJiYgIXRoaXMudHppZCkge1xuICAgICAgICB0aGlzLnR6aWQgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ3R6aWQnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSB1dGNPZmZzZXQgdGhlIGdpdmVuIHRpbWUgd291bGQgb2NjdXIgaW4gdGhpcyB0aW1lem9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSB0dCAgICAgICAgVGhlIHRpbWUgdG8gY2hlY2sgZm9yXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB1dGMgb2Zmc2V0IGluIHNlY29uZHNcbiAgICAgKi9cbiAgICB1dGNPZmZzZXQ6IGZ1bmN0aW9uIHV0Y09mZnNldCh0dCkge1xuICAgICAgaWYgKHRoaXMgPT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSB8fCB0aGlzID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZW5zdXJlQ292ZXJhZ2UodHQueWVhcik7XG5cbiAgICAgIGlmICghdGhpcy5jaGFuZ2VzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIHR0X2NoYW5nZSA9IHtcbiAgICAgICAgeWVhcjogdHQueWVhcixcbiAgICAgICAgbW9udGg6IHR0Lm1vbnRoLFxuICAgICAgICBkYXk6IHR0LmRheSxcbiAgICAgICAgaG91cjogdHQuaG91cixcbiAgICAgICAgbWludXRlOiB0dC5taW51dGUsXG4gICAgICAgIHNlY29uZDogdHQuc2Vjb25kXG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hhbmdlX251bSA9IHRoaXMuX2ZpbmROZWFyYnlDaGFuZ2UodHRfY2hhbmdlKTtcbiAgICAgIHZhciBjaGFuZ2VfbnVtX3RvX3VzZSA9IC0xO1xuICAgICAgdmFyIHN0ZXAgPSAxO1xuXG4gICAgICAvLyBUT0RPOiByZXBsYWNlIHdpdGggYmluIHNlYXJjaD9cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgdmFyIGNoYW5nZSA9IElDQUwuaGVscGVycy5jbG9uZSh0aGlzLmNoYW5nZXNbY2hhbmdlX251bV0sIHRydWUpO1xuICAgICAgICBpZiAoY2hhbmdlLnV0Y09mZnNldCA8IGNoYW5nZS5wcmV2VXRjT2Zmc2V0KSB7XG4gICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCwgY2hhbmdlLnV0Y09mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjbXAgPSBJQ0FMLlRpbWV6b25lLl9jb21wYXJlX2NoYW5nZV9mbih0dF9jaGFuZ2UsIGNoYW5nZSk7XG5cbiAgICAgICAgaWYgKGNtcCA+PSAwKSB7XG4gICAgICAgICAgY2hhbmdlX251bV90b191c2UgPSBjaGFuZ2VfbnVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ZXAgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGVwID09IC0xICYmIGNoYW5nZV9udW1fdG9fdXNlICE9IC0xKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VfbnVtICs9IHN0ZXA7XG5cbiAgICAgICAgaWYgKGNoYW5nZV9udW0gPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlX251bSA+PSB0aGlzLmNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHpvbmVfY2hhbmdlID0gdGhpcy5jaGFuZ2VzW2NoYW5nZV9udW1fdG9fdXNlXTtcbiAgICAgIHZhciB1dGNPZmZzZXRfY2hhbmdlID0gem9uZV9jaGFuZ2UudXRjT2Zmc2V0IC0gem9uZV9jaGFuZ2UucHJldlV0Y09mZnNldDtcblxuICAgICAgaWYgKHV0Y09mZnNldF9jaGFuZ2UgPCAwICYmIGNoYW5nZV9udW1fdG9fdXNlID4gMCkge1xuICAgICAgICB2YXIgdG1wX2NoYW5nZSA9IElDQUwuaGVscGVycy5jbG9uZSh6b25lX2NoYW5nZSwgdHJ1ZSk7XG4gICAgICAgIElDQUwuVGltZXpvbmUuYWRqdXN0X2NoYW5nZSh0bXBfY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcF9jaGFuZ2UucHJldlV0Y09mZnNldCk7XG5cbiAgICAgICAgaWYgKElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuKHR0X2NoYW5nZSwgdG1wX2NoYW5nZSkgPCAwKSB7XG4gICAgICAgICAgdmFyIHByZXZfem9uZV9jaGFuZ2UgPSB0aGlzLmNoYW5nZXNbY2hhbmdlX251bV90b191c2UgLSAxXTtcblxuICAgICAgICAgIHZhciB3YW50X2RheWxpZ2h0ID0gZmFsc2U7IC8vIFRPRE9cblxuICAgICAgICAgIGlmICh6b25lX2NoYW5nZS5pc19kYXlsaWdodCAhPSB3YW50X2RheWxpZ2h0ICYmXG4gICAgICAgICAgICAgIHByZXZfem9uZV9jaGFuZ2UuaXNfZGF5bGlnaHQgPT0gd2FudF9kYXlsaWdodCkge1xuICAgICAgICAgICAgem9uZV9jaGFuZ2UgPSBwcmV2X3pvbmVfY2hhbmdlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPIHJldHVybiBpc19kYXlsaWdodD9cbiAgICAgIHJldHVybiB6b25lX2NoYW5nZS51dGNPZmZzZXQ7XG4gICAgfSxcblxuICAgIF9maW5kTmVhcmJ5Q2hhbmdlOiBmdW5jdGlvbiBpY2FsdGltZXpvbmVfZmluZF9uZWFyYnlfY2hhbmdlKGNoYW5nZSkge1xuICAgICAgLy8gZmluZCB0aGUgY2xvc2VzdCBtYXRjaFxuICAgICAgdmFyIGlkeCA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgIHRoaXMuY2hhbmdlcyxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICBJQ0FMLlRpbWV6b25lLl9jb21wYXJlX2NoYW5nZV9mblxuICAgICAgKTtcblxuICAgICAgaWYgKGlkeCA+PSB0aGlzLmNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9LFxuXG4gICAgX2Vuc3VyZUNvdmVyYWdlOiBmdW5jdGlvbihhWWVhcikge1xuICAgICAgaWYgKElDQUwuVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyID09IC0xKSB7XG4gICAgICAgIHZhciB0b2RheSA9IElDQUwuVGltZS5ub3coKTtcbiAgICAgICAgSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXIgPSB0b2RheS55ZWFyO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlc0VuZFllYXIgPSBhWWVhcjtcbiAgICAgIGlmIChjaGFuZ2VzRW5kWWVhciA8IElDQUwuVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyKSB7XG4gICAgICAgIGNoYW5nZXNFbmRZZWFyID0gSUNBTC5UaW1lem9uZS5fbWluaW11bUV4cGFuc2lvblllYXI7XG4gICAgICB9XG5cbiAgICAgIGNoYW5nZXNFbmRZZWFyICs9IElDQUwuVGltZXpvbmUuRVhUUkFfQ09WRVJBR0U7XG5cbiAgICAgIGlmIChjaGFuZ2VzRW5kWWVhciA+IElDQUwuVGltZXpvbmUuTUFYX1lFQVIpIHtcbiAgICAgICAgY2hhbmdlc0VuZFllYXIgPSBJQ0FMLlRpbWV6b25lLk1BWF9ZRUFSO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuY2hhbmdlcy5sZW5ndGggfHwgdGhpcy5leHBhbmRlZFVudGlsWWVhciA8IGFZZWFyKSB7XG4gICAgICAgIHZhciBzdWJjb21wcyA9IHRoaXMuY29tcG9uZW50LmdldEFsbFN1YmNvbXBvbmVudHMoKTtcbiAgICAgICAgdmFyIGNvbXBMZW4gPSBzdWJjb21wcy5sZW5ndGg7XG4gICAgICAgIHZhciBjb21wSWR4ID0gMDtcblxuICAgICAgICBmb3IgKDsgY29tcElkeCA8IGNvbXBMZW47IGNvbXBJZHgrKykge1xuICAgICAgICAgIHRoaXMuX2V4cGFuZENvbXBvbmVudChcbiAgICAgICAgICAgIHN1YmNvbXBzW2NvbXBJZHhdLCBjaGFuZ2VzRW5kWWVhciwgdGhpcy5jaGFuZ2VzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2hhbmdlcy5zb3J0KElDQUwuVGltZXpvbmUuX2NvbXBhcmVfY2hhbmdlX2ZuKTtcbiAgICAgICAgdGhpcy5leHBhbmRlZFVudGlsWWVhciA9IGNoYW5nZXNFbmRZZWFyO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZXhwYW5kQ29tcG9uZW50OiBmdW5jdGlvbihhQ29tcG9uZW50LCBhWWVhciwgY2hhbmdlcykge1xuICAgICAgaWYgKCFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwiZHRzdGFydFwiKSB8fFxuICAgICAgICAgICFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwidHpvZmZzZXR0b1wiKSB8fFxuICAgICAgICAgICFhQ29tcG9uZW50Lmhhc1Byb3BlcnR5KFwidHpvZmZzZXRmcm9tXCIpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgZHRzdGFydCA9IGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcImR0c3RhcnRcIikuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgdmFyIGNoYW5nZTtcblxuICAgICAgZnVuY3Rpb24gY29udmVydF90em9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldC5mYWN0b3IgKiAob2Zmc2V0LmhvdXJzICogMzYwMCArIG9mZnNldC5taW51dGVzICogNjApO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbml0X2NoYW5nZXMoKSB7XG4gICAgICAgIHZhciBjaGFuZ2ViYXNlID0ge307XG4gICAgICAgIGNoYW5nZWJhc2UuaXNfZGF5bGlnaHQgPSAoYUNvbXBvbmVudC5uYW1lID09IFwiZGF5bGlnaHRcIik7XG4gICAgICAgIGNoYW5nZWJhc2UudXRjT2Zmc2V0ID0gY29udmVydF90em9mZnNldChcbiAgICAgICAgICBhQ29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoXCJ0em9mZnNldHRvXCIpLmdldEZpcnN0VmFsdWUoKVxuICAgICAgICApO1xuXG4gICAgICAgIGNoYW5nZWJhc2UucHJldlV0Y09mZnNldCA9IGNvbnZlcnRfdHpvZmZzZXQoXG4gICAgICAgICAgYUNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KFwidHpvZmZzZXRmcm9tXCIpLmdldEZpcnN0VmFsdWUoKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBjaGFuZ2ViYXNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFDb21wb25lbnQuaGFzUHJvcGVydHkoXCJycnVsZVwiKSAmJiAhYUNvbXBvbmVudC5oYXNQcm9wZXJ0eShcInJkYXRlXCIpKSB7XG4gICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuICAgICAgICBjaGFuZ2UueWVhciA9IGR0c3RhcnQueWVhcjtcbiAgICAgICAgY2hhbmdlLm1vbnRoID0gZHRzdGFydC5tb250aDtcbiAgICAgICAgY2hhbmdlLmRheSA9IGR0c3RhcnQuZGF5O1xuICAgICAgICBjaGFuZ2UuaG91ciA9IGR0c3RhcnQuaG91cjtcbiAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IGR0c3RhcnQubWludXRlO1xuICAgICAgICBjaGFuZ2Uuc2Vjb25kID0gZHRzdGFydC5zZWNvbmQ7XG5cbiAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGFDb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcyhcInJkYXRlXCIpO1xuICAgICAgICBmb3IgKHZhciByZGF0ZWtleSBpbiBwcm9wcykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocmRhdGVrZXkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJkYXRlID0gcHJvcHNbcmRhdGVrZXldO1xuICAgICAgICAgIHZhciB0aW1lID0gcmRhdGUuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuXG4gICAgICAgICAgY2hhbmdlLnllYXIgPSB0aW1lLnllYXI7XG4gICAgICAgICAgY2hhbmdlLm1vbnRoID0gdGltZS5tb250aDtcbiAgICAgICAgICBjaGFuZ2UuZGF5ID0gdGltZS5kYXk7XG5cbiAgICAgICAgICBpZiAodGltZS5pc0RhdGUpIHtcbiAgICAgICAgICAgIGNoYW5nZS5ob3VyID0gZHRzdGFydC5ob3VyO1xuICAgICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IGR0c3RhcnQubWludXRlO1xuICAgICAgICAgICAgY2hhbmdlLnNlY29uZCA9IGR0c3RhcnQuc2Vjb25kO1xuXG4gICAgICAgICAgICBpZiAoZHRzdGFydC56b25lICE9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgICAgICAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlKGNoYW5nZSwgMCwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFuZ2UuaG91ciA9IHRpbWUuaG91cjtcbiAgICAgICAgICAgIGNoYW5nZS5taW51dGUgPSB0aW1lLm1pbnV0ZTtcbiAgICAgICAgICAgIGNoYW5nZS5zZWNvbmQgPSB0aW1lLnNlY29uZDtcblxuICAgICAgICAgICAgaWYgKHRpbWUuem9uZSAhPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgICAgICAgIElDQUwuVGltZXpvbmUuYWRqdXN0X2NoYW5nZShjaGFuZ2UsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLWNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBycnVsZSA9IGFDb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShcInJydWxlXCIpO1xuXG4gICAgICAgIGlmIChycnVsZSkge1xuICAgICAgICAgIHJydWxlID0gcnJ1bGUuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICAgIGNoYW5nZSA9IGluaXRfY2hhbmdlcygpO1xuXG4gICAgICAgICAgaWYgKHJydWxlLnVudGlsICYmIHJydWxlLnVudGlsLnpvbmUgPT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICAgICAgcnJ1bGUudW50aWwuYWRqdXN0KDAsIDAsIDAsIGNoYW5nZS5wcmV2VXRjT2Zmc2V0KTtcbiAgICAgICAgICAgIHJydWxlLnVudGlsLnpvbmUgPSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gcnJ1bGUuaXRlcmF0b3IoZHRzdGFydCk7XG5cbiAgICAgICAgICB2YXIgb2NjO1xuICAgICAgICAgIHdoaWxlICgob2NjID0gaXRlcmF0b3IubmV4dCgpKSkge1xuICAgICAgICAgICAgY2hhbmdlID0gaW5pdF9jaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAob2NjLnllYXIgPiBhWWVhciB8fCAhb2NjKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGFuZ2UueWVhciA9IG9jYy55ZWFyO1xuICAgICAgICAgICAgY2hhbmdlLm1vbnRoID0gb2NjLm1vbnRoO1xuICAgICAgICAgICAgY2hhbmdlLmRheSA9IG9jYy5kYXk7XG4gICAgICAgICAgICBjaGFuZ2UuaG91ciA9IG9jYy5ob3VyO1xuICAgICAgICAgICAgY2hhbmdlLm1pbnV0ZSA9IG9jYy5taW51dGU7XG4gICAgICAgICAgICBjaGFuZ2Uuc2Vjb25kID0gb2NjLnNlY29uZDtcbiAgICAgICAgICAgIGNoYW5nZS5pc0RhdGUgPSBvY2MuaXNEYXRlO1xuXG4gICAgICAgICAgICBJQ0FMLlRpbWV6b25lLmFkanVzdF9jaGFuZ2UoY2hhbmdlLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtY2hhbmdlLnByZXZVdGNPZmZzZXQpO1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdGltZXpvbmUuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAodGhpcy50em5hbWVzID8gdGhpcy50em5hbWVzIDogdGhpcy50emlkKTtcbiAgICB9XG4gIH07XG5cbiAgSUNBTC5UaW1lem9uZS5fY29tcGFyZV9jaGFuZ2VfZm4gPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfY29tcGFyZV9jaGFuZ2VfZm4oYSwgYikge1xuICAgIGlmIChhLnllYXIgPCBiLnllYXIpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLnllYXIgPiBiLnllYXIpIHJldHVybiAxO1xuXG4gICAgaWYgKGEubW9udGggPCBiLm1vbnRoKSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS5tb250aCA+IGIubW9udGgpIHJldHVybiAxO1xuXG4gICAgaWYgKGEuZGF5IDwgYi5kYXkpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLmRheSA+IGIuZGF5KSByZXR1cm4gMTtcblxuICAgIGlmIChhLmhvdXIgPCBiLmhvdXIpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLmhvdXIgPiBiLmhvdXIpIHJldHVybiAxO1xuXG4gICAgaWYgKGEubWludXRlIDwgYi5taW51dGUpIHJldHVybiAtMTtcbiAgICBlbHNlIGlmIChhLm1pbnV0ZSA+IGIubWludXRlKSByZXR1cm4gMTtcblxuICAgIGlmIChhLnNlY29uZCA8IGIuc2Vjb25kKSByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYS5zZWNvbmQgPiBiLnNlY29uZCkgcmV0dXJuIDE7XG5cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgZGF0ZS90aW1lIGZyb20gb25lIHpvbmUgdG8gdGhlIG5leHQuXG4gICAqXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lfSB0dCAgICAgICAgICAgICAgICAgIFRoZSB0aW1lIHRvIGNvbnZlcnRcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lfSBmcm9tX3pvbmUgICAgICAgVGhlIHNvdXJjZSB6b25lIHRvIGNvbnZlcnQgZnJvbVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHRvX3pvbmUgICAgICAgICBUaGUgdGFyZ2V0IHpvbmUgdG8gY29udmVydCB0b1xuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICAgICAgICBUaGUgY29udmVydGVkIGRhdGUvdGltZSBvYmplY3RcbiAgICovXG4gIElDQUwuVGltZXpvbmUuY29udmVydF90aW1lID0gZnVuY3Rpb24gaWNhbHRpbWV6b25lX2NvbnZlcnRfdGltZSh0dCwgZnJvbV96b25lLCB0b196b25lKSB7XG4gICAgaWYgKHR0LmlzRGF0ZSB8fFxuICAgICAgICBmcm9tX3pvbmUudHppZCA9PSB0b196b25lLnR6aWQgfHxcbiAgICAgICAgZnJvbV96b25lID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSB8fFxuICAgICAgICB0b196b25lID09IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSkge1xuICAgICAgdHQuem9uZSA9IHRvX3pvbmU7XG4gICAgICByZXR1cm4gdHQ7XG4gICAgfVxuXG4gICAgdmFyIHV0Y09mZnNldCA9IGZyb21fem9uZS51dGNPZmZzZXQodHQpO1xuICAgIHR0LmFkanVzdCgwLCAwLCAwLCAtIHV0Y09mZnNldCk7XG5cbiAgICB1dGNPZmZzZXQgPSB0b196b25lLnV0Y09mZnNldCh0dCk7XG4gICAgdHQuYWRqdXN0KDAsIDAsIDAsIHV0Y09mZnNldCk7XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWV6b25lIGluc3RhbmNlIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxPYmplY3R9IGFEYXRhIG9wdGlvbnMgZm9yIGNsYXNzXG4gICAqIEBwYXJhbSB7U3RyaW5nfElDQUwuQ29tcG9uZW50fSBhRGF0YS5jb21wb25lbnRcbiAgICogICAgICAgIElmIGFEYXRhIGlzIGEgc2ltcGxlIG9iamVjdCwgdGhlbiB0aGlzIG1lbWJlciBjYW4gYmUgc2V0IHRvIGVpdGhlciBhXG4gICAqICAgICAgICBzdHJpbmcgY29udGFpbmluZyB0aGUgY29tcG9uZW50IGRhdGEsIG9yIGFuIGFscmVhZHkgcGFyc2VkXG4gICAqICAgICAgICBJQ0FMLkNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEudHppZCAgICAgIFRoZSB0aW1lem9uZSBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhRGF0YS5sb2NhdGlvbiAgVGhlIHRpbWV6b25lIGxvY2F0aW9ud1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYURhdGEudHpuYW1lcyAgIEFuIGFsdGVybmF0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXpvbmVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFEYXRhLmxhdGl0dWRlICBUaGUgbGF0aXR1ZGUgb2YgdGhlIHRpbWV6b25lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF0YS5sb25naXR1ZGUgVGhlIGxvbmdpdHVkZSBvZiB0aGUgdGltZXpvbmVcbiAgICovXG4gIElDQUwuVGltZXpvbmUuZnJvbURhdGEgPSBmdW5jdGlvbiBpY2FsdGltZXpvbmVfZnJvbURhdGEoYURhdGEpIHtcbiAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lem9uZSgpO1xuICAgIHJldHVybiB0dC5mcm9tRGF0YShhRGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBpbnN0YW5jZSBkZXNjcmliaW5nIHRoZSBVVEMgdGltZXpvbmVcbiAgICogQHR5cGUge0lDQUwuVGltZXpvbmV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUgPSBJQ0FMLlRpbWV6b25lLmZyb21EYXRhKHtcbiAgICB0emlkOiBcIlVUQ1wiXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBUaGUgaW5zdGFuY2UgZGVzY3JpYmluZyB0aGUgbG9jYWwgdGltZXpvbmVcbiAgICogQHR5cGUge0lDQUwuVGltZXpvbmV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZSA9IElDQUwuVGltZXpvbmUuZnJvbURhdGEoe1xuICAgIHR6aWQ6IFwiZmxvYXRpbmdcIlxuICB9KTtcblxuICAvKipcbiAgICogQWRqdXN0IGEgdGltZXpvbmUgY2hhbmdlIG9iamVjdC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZSAgICAgVGhlIHRpbWV6b25lIGNoYW5nZSBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRheXMgICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBkYXlzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBob3VycyAgICAgIFRoZSBleHRyYSBhbW91bnQgb2YgaG91cnNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZXMgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBtaW51dGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmRzICAgIFRoZSBleHRyYSBhbW91bnQgb2Ygc2Vjb25kc1xuICAgKi9cbiAgSUNBTC5UaW1lem9uZS5hZGp1c3RfY2hhbmdlID0gZnVuY3Rpb24gaWNhbHRpbWV6b25lX2FkanVzdF9jaGFuZ2UoY2hhbmdlLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcykge1xuICAgIHJldHVybiBJQ0FMLlRpbWUucHJvdG90eXBlLmFkanVzdC5jYWxsKFxuICAgICAgY2hhbmdlLFxuICAgICAgZGF5cyxcbiAgICAgIGhvdXJzLFxuICAgICAgbWludXRlcyxcbiAgICAgIHNlY29uZHMsXG4gICAgICBjaGFuZ2VcbiAgICApO1xuICB9O1xuXG4gIElDQUwuVGltZXpvbmUuX21pbmltdW1FeHBhbnNpb25ZZWFyID0gLTE7XG4gIElDQUwuVGltZXpvbmUuTUFYX1lFQVIgPSAyMDM1OyAvLyBUT0RPIHRoaXMgaXMgYmVjYXVzZSBvZiB0aW1lX3QsIHdoaWNoIHdlIGRvbid0IG5lZWQuIFN0aWxsIHVzZWZ1bGw/XG4gIElDQUwuVGltZXpvbmUuRVhUUkFfQ09WRVJBR0UgPSA1O1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlRpbWV6b25lU2VydmljZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHpvbmVzO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFNpbmdsZXRvbiBjbGFzcyB0byBjb250YWluIHRpbWV6b25lcy4gIFJpZ2h0IG5vdyBpdCBpcyBhbGwgbWFudWFsIHJlZ2lzdHJ5IGluXG4gICAqIHRoZSBmdXR1cmUgd2UgbWF5IHVzZSB0aGlzIGNsYXNzIHRvIGRvd25sb2FkIHRpbWV6b25lIGluZm9ybWF0aW9uIG9yIGhhbmRsZVxuICAgKiBsb2FkaW5nIHByZS1leHBhbmRlZCB0aW1lem9uZXMuXG4gICAqXG4gICAqIEBuYW1lc3BhY2VcbiAgICogQGFsaWFzIElDQUwuVGltZXpvbmVTZXJ2aWNlXG4gICAqL1xuICB2YXIgVGltZXpvbmVTZXJ2aWNlID0ge1xuICAgIGdldCBjb3VudCgpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh6b25lcykubGVuZ3RoO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB6b25lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgdXRjID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcblxuICAgICAgem9uZXMuWiA9IHV0YztcbiAgICAgIHpvbmVzLlVUQyA9IHV0YztcbiAgICAgIHpvbmVzLkdNVCA9IHV0YztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRpbWV6b25lIGlkIGhhcyBiZWVuIHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHppZCAgICAgVGltZXpvbmUgaWRlbnRpZmllciAoZS5nLiBBbWVyaWNhL0xvc19BbmdlbGVzKVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBGYWxzZSwgd2hlbiBub3QgcHJlc2VudFxuICAgICAqL1xuICAgIGhhczogZnVuY3Rpb24odHppZCkge1xuICAgICAgcmV0dXJuICEhem9uZXNbdHppZF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB0aW1lem9uZSBieSBpdHMgdHppZCBpZiBwcmVzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR6aWQgICAgIFRpbWV6b25lIGlkZW50aWZpZXIgKGUuZy4gQW1lcmljYS9Mb3NfQW5nZWxlcylcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5UaW1lem9uZX0gVGhlIHRpbWV6b25lLCBvciBudWxsIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24odHppZCkge1xuICAgICAgcmV0dXJuIHpvbmVzW3R6aWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSB0aW1lem9uZSBvYmplY3Qgb3IgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmc9fSBuYW1lXG4gICAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSB0aW1lem9uZS4gRGVmYXVsdHMgdG8gdGhlIGNvbXBvbmVudCdzIFRaSUQgaWYgbm90XG4gICAgICogICAgICAgIHBhc3NlZC5cbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fElDQUwuVGltZXpvbmV9IHpvbmVcbiAgICAgKiAgICAgICAgVGhlIGluaXRpYWxpemVkIHpvbmUgb3IgdnRpbWV6b25lLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbihuYW1lLCB0aW1lem9uZSkge1xuICAgICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkge1xuICAgICAgICBpZiAobmFtZS5uYW1lID09PSAndnRpbWV6b25lJykge1xuICAgICAgICAgIHRpbWV6b25lID0gbmV3IElDQUwuVGltZXpvbmUobmFtZSk7XG4gICAgICAgICAgbmFtZSA9IHRpbWV6b25lLnR6aWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWV6b25lIGluc3RhbmNlb2YgSUNBTC5UaW1lem9uZSkge1xuICAgICAgICB6b25lc1tuYW1lXSA9IHRpbWV6b25lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGltZXpvbmUgbXVzdCBiZSBJQ0FMLlRpbWV6b25lIG9yIElDQUwuQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB0aW1lem9uZSBieSBpdHMgdHppZCBmcm9tIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR6aWQgICAgIFRpbWV6b25lIGlkZW50aWZpZXIgKGUuZy4gQW1lcmljYS9Mb3NfQW5nZWxlcylcbiAgICAgKiBAcmV0dXJuIHs/SUNBTC5UaW1lem9uZX0gVGhlIHJlbW92ZWQgdGltZXpvbmUsIG9yIG51bGwgaWYgbm90IHJlZ2lzdGVyZWRcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHR6aWQpIHtcbiAgICAgIHJldHVybiAoZGVsZXRlIHpvbmVzW3R6aWRdKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaW5pdGlhbGl6ZSBkZWZhdWx0c1xuICBUaW1lem9uZVNlcnZpY2UucmVzZXQoKTtcblxuICByZXR1cm4gVGltZXpvbmVTZXJ2aWNlO1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc2Rlc2NcbiAgICogaUNhbGVuZGFyIFRpbWUgcmVwcmVzZW50YXRpb24gKHNpbWlsYXIgdG8gSlMgRGF0ZSBvYmplY3QpLiAgRnVsbHlcbiAgICogaW5kZXBlbmRlbnQgb2Ygc3lzdGVtIChPUykgdGltZXpvbmUgLyB0aW1lLiAgVW5saWtlIEpTIERhdGUsIHRoZSBtb250aFxuICAgKiBKYW51YXJ5IGlzIDEsIG5vdCB6ZXJvLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgdGltZSA9IG5ldyBJQ0FMLlRpbWUoe1xuICAgKiAgIHllYXI6IDIwMTIsXG4gICAqICAgbW9udGg6IDEwLFxuICAgKiAgIGRheTogMTFcbiAgICogICBtaW51dGU6IDAsXG4gICAqICAgc2Vjb25kOiAwLFxuICAgKiAgIGlzRGF0ZTogZmFsc2VcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIEBhbGlhcyBJQ0FMLlRpbWVcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICBUaW1lIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS55ZWFyICAgICBUaGUgeWVhciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5tb250aCAgICBUaGUgbW9udGggZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuZGF5ICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5ob3VyICAgICBUaGUgaG91ciBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5taW51dGUgICBUaGUgbWludXRlIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLnNlY29uZCAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBkYXRhLmlzRGF0ZSAgSWYgdHJ1ZSwgdGhlIGluc3RhbmNlIHJlcHJlc2VudHMgYSBkYXRlIChhc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHBvc2VkIHRvIGEgZGF0ZS10aW1lKVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHpvbmUgdGltZXpvbmUgdGhpcyBwb3NpdGlvbiBvY2N1cnMgaW5cbiAgICovXG4gIElDQUwuVGltZSA9IGZ1bmN0aW9uIGljYWx0aW1lKGRhdGEsIHpvbmUpIHtcbiAgICB0aGlzLndyYXBwZWRKU09iamVjdCA9IHRoaXM7XG4gICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8qIHRpbWUgZGVmYXVsdHMgKi9cbiAgICB0aW1lLnllYXIgPSAwO1xuICAgIHRpbWUubW9udGggPSAxO1xuICAgIHRpbWUuZGF5ID0gMTtcbiAgICB0aW1lLmhvdXIgPSAwO1xuICAgIHRpbWUubWludXRlID0gMDtcbiAgICB0aW1lLnNlY29uZCA9IDA7XG4gICAgdGltZS5pc0RhdGUgPSBmYWxzZTtcblxuICAgIHRoaXMuZnJvbURhdGEoZGF0YSwgem9uZSk7XG4gIH07XG5cbiAgSUNBTC5UaW1lLl9kb3dDYWNoZSA9IHt9O1xuICBJQ0FMLlRpbWUuX3duQ2FjaGUgPSB7fTtcblxuICBJQ0FMLlRpbWUucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIGlkZW50aWZpZXIuXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCBcImljYWx0aW1lXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHRpbWVcIixcbiAgICBfY2FjaGVkVW5peFRpbWU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC4gVGhpcyB2YWx1ZSBtYXkgY2hhbmdlIGFuZFxuICAgICAqIGlzIHN0cmljdGx5IGRlZmluZWQgYnkgdGhlIHtAbGluayBJQ0FMLlRpbWUjaXNEYXRlIGlzRGF0ZX0gbWVtYmVyLlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgXCJkYXRlLXRpbWVcIlxuICAgICAqL1xuICAgIGdldCBpY2FsdHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRGF0ZSA/ICdkYXRlJyA6ICdkYXRlLXRpbWUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGltZXpvbmUgZm9yIHRoaXMgdGltZS5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZX1cbiAgICAgKi9cbiAgICB6b25lOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgdXNlcyB0byBpbmRpY2F0ZSB0aGF0IGEgY2hhbmdlIGhhcyBiZWVuIG1hZGUgYW5kIHRoZSBuZXh0IHJlYWRcbiAgICAgKiBvcGVyYXRpb24gbXVzdCBhdHRlbXB0IHRvIG5vcm1hbGl6ZSB0aGUgdmFsdWUgKGZvciBleGFtcGxlIGNoYW5naW5nIHRoZVxuICAgICAqIGRheSB0byAzMykuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wZW5kaW5nTm9ybWFsaXphdGlvbjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIHRpbWUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgICAgVGhlIGNsb25lZCBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuVGltZSh0aGlzLl90aW1lLCB0aGlzLnpvbmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgdGltZSBpbnN0YW5jZSB0byBlcG9jaCB0aW1lXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIGljYWx0aW1lX3Jlc2V0KCkge1xuICAgICAgdGhpcy5mcm9tRGF0YShJQ0FMLlRpbWUuZXBvY2hUaW1lKTtcbiAgICAgIHRoaXMuem9uZSA9IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSB0aW1lIGluc3RhbmNlIHRvIHRoZSBnaXZlbiBkYXRlL3RpbWUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHllYXIgICAgICAgICAgICAgVGhlIHllYXIgdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoICAgICAgICAgICAgVGhlIG1vbnRoIHRvIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkYXkgICAgICAgICAgICAgIFRoZSBkYXkgdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhvdXIgICAgICAgICAgICAgVGhlIGhvdXIgdG8gc2V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbnV0ZSAgICAgICAgICAgVGhlIG1pbnV0ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kICAgICAgICAgICBUaGUgc2Vjb25kIHRvIHNldFxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZX0gdGltZXpvbmUgIFRoZSB0aW1lem9uZSB0byBzZXRcbiAgICAgKi9cbiAgICByZXNldFRvOiBmdW5jdGlvbiBpY2FsdGltZV9yZXNldFRvKHllYXIsIG1vbnRoLCBkYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyLCBtaW51dGUsIHNlY29uZCwgdGltZXpvbmUpIHtcbiAgICAgIHRoaXMuZnJvbURhdGEoe1xuICAgICAgICB5ZWFyOiB5ZWFyLFxuICAgICAgICBtb250aDogbW9udGgsXG4gICAgICAgIGRheTogZGF5LFxuICAgICAgICBob3VyOiBob3VyLFxuICAgICAgICBtaW51dGU6IG1pbnV0ZSxcbiAgICAgICAgc2Vjb25kOiBzZWNvbmQsXG4gICAgICAgIHpvbmU6IHRpbWV6b25lXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIGZyb20gdGhlIEphdmFzY3JpcHQgZGF0ZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P0RhdGV9IGFEYXRlICAgICBUaGUgSmF2YXNjcmlwdCBEYXRlIHRvIHJlYWQsIG9yIG51bGwgdG8gcmVzZXRcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVzZVVUQyAgSWYgdHJ1ZSwgdGhlIFVUQyB2YWx1ZXMgb2YgdGhlIGRhdGUgd2lsbCBiZSB1c2VkXG4gICAgICovXG4gICAgZnJvbUpTRGF0ZTogZnVuY3Rpb24gaWNhbHRpbWVfZnJvbUpTRGF0ZShhRGF0ZSwgdXNlVVRDKSB7XG4gICAgICBpZiAoIWFEYXRlKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh1c2VVVEMpIHtcbiAgICAgICAgICB0aGlzLnpvbmUgPSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lO1xuICAgICAgICAgIHRoaXMueWVhciA9IGFEYXRlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgdGhpcy5tb250aCA9IGFEYXRlLmdldFVUQ01vbnRoKCkgKyAxO1xuICAgICAgICAgIHRoaXMuZGF5ID0gYURhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgIHRoaXMuaG91ciA9IGFEYXRlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgdGhpcy5taW51dGUgPSBhRGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgdGhpcy5zZWNvbmQgPSBhRGF0ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lO1xuICAgICAgICAgIHRoaXMueWVhciA9IGFEYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgdGhpcy5tb250aCA9IGFEYXRlLmdldE1vbnRoKCkgKyAxO1xuICAgICAgICAgIHRoaXMuZGF5ID0gYURhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICAgIHRoaXMuaG91ciA9IGFEYXRlLmdldEhvdXJzKCk7XG4gICAgICAgICAgdGhpcy5taW51dGUgPSBhRGF0ZS5nZXRNaW51dGVzKCk7XG4gICAgICAgICAgdGhpcy5zZWNvbmQgPSBhRGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIHVzaW5nIG1lbWJlcnMgZnJvbSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFEYXRhICAgICAgICAgICAgVGltZSBpbml0aWFsaXphdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEueWVhciAgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1vbnRoICAgICBUaGUgbW9udGggZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuZGF5ICAgICAgIFRoZSBkYXkgZm9yIHRoaXMgZGF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91ciAgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLm1pbnV0ZSAgICBUaGUgbWludXRlIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLnNlY29uZCAgICBUaGUgc2Vjb25kIGZvciB0aGlzIGRhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGF0YS5pc0RhdGUgICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcyBvcHBvc2VkIHRvIGEgZGF0ZS10aW1lKVxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lem9uZT19IGFab25lICAgIFRpbWV6b25lIHRoaXMgcG9zaXRpb24gb2NjdXJzIGluXG4gICAgICovXG4gICAgZnJvbURhdGE6IGZ1bmN0aW9uIGZyb21EYXRhKGFEYXRhLCBhWm9uZSkge1xuICAgICAgaWYgKGFEYXRhKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBhRGF0YSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhRGF0YSwga2V5KSkge1xuICAgICAgICAgICAgLy8gaWNhbCB0eXBlIGNhbm5vdCBiZSBzZXRcbiAgICAgICAgICAgIGlmIChrZXkgPT09ICdpY2FsdHlwZScpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpc1trZXldID0gYURhdGFba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFab25lKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IGFab25lO1xuICAgICAgfVxuXG4gICAgICBpZiAoYURhdGEgJiYgIShcImlzRGF0ZVwiIGluIGFEYXRhKSkge1xuICAgICAgICB0aGlzLmlzRGF0ZSA9ICEoXCJob3VyXCIgaW4gYURhdGEpO1xuICAgICAgfSBlbHNlIGlmIChhRGF0YSAmJiAoXCJpc0RhdGVcIiBpbiBhRGF0YSkpIHtcbiAgICAgICAgdGhpcy5pc0RhdGUgPSBhRGF0YS5pc0RhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhRGF0YSAmJiBcInRpbWV6b25lXCIgaW4gYURhdGEpIHtcbiAgICAgICAgdmFyIHpvbmUgPSBJQ0FMLlRpbWV6b25lU2VydmljZS5nZXQoXG4gICAgICAgICAgYURhdGEudGltZXpvbmVcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLnpvbmUgPSB6b25lIHx8IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFEYXRhICYmIFwiem9uZVwiIGluIGFEYXRhKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IGFEYXRhLnpvbmU7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy56b25lKSB7XG4gICAgICAgIHRoaXMuem9uZSA9IElDQUwuVGltZXpvbmUubG9jYWxUaW1lem9uZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FjaGVkVW5peFRpbWUgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGF5IG9mIHdlZWsuXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lLndlZWtEYXl9XG4gICAgICovXG4gICAgZGF5T2ZXZWVrOiBmdW5jdGlvbiBpY2FsdGltZV9kYXlPZldlZWsoYVdlZWtTdGFydCkge1xuICAgICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgICAgdmFyIGRvd0NhY2hlS2V5ID0gKHRoaXMueWVhciA8PCAxMikgKyAodGhpcy5tb250aCA8PCA4KSArICh0aGlzLmRheSA8PCAzKSArIGZpcnN0RG93O1xuICAgICAgaWYgKGRvd0NhY2hlS2V5IGluIElDQUwuVGltZS5fZG93Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVGltZS5fZG93Q2FjaGVbZG93Q2FjaGVLZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2luZyBaZWxsZXIncyBhbGdvcml0aG1cbiAgICAgIHZhciBxID0gdGhpcy5kYXk7XG4gICAgICB2YXIgbSA9IHRoaXMubW9udGggKyAodGhpcy5tb250aCA8IDMgPyAxMiA6IDApO1xuICAgICAgdmFyIFkgPSB0aGlzLnllYXIgLSAodGhpcy5tb250aCA8IDMgPyAxIDogMCk7XG5cbiAgICAgIHZhciBoID0gKHEgKyBZICsgSUNBTC5oZWxwZXJzLnRydW5jKCgobSArIDEpICogMjYpIC8gMTApICsgSUNBTC5oZWxwZXJzLnRydW5jKFkgLyA0KSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHRydWUgLyogZ3JlZ29yaWFuICovKSB7XG4gICAgICAgIGggKz0gSUNBTC5oZWxwZXJzLnRydW5jKFkgLyAxMDApICogNiArIElDQUwuaGVscGVycy50cnVuYyhZIC8gNDAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggKz0gNTtcbiAgICAgIH1cblxuICAgICAgLy8gTm9ybWFsaXplIHRvIDEgPSB3a3N0XG4gICAgICBoID0gKChoICsgNyAtIGZpcnN0RG93KSAlIDcpICsgMTtcbiAgICAgIElDQUwuVGltZS5fZG93Q2FjaGVbZG93Q2FjaGVLZXldID0gaDtcbiAgICAgIHJldHVybiBoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGRheSBvZiB5ZWFyLlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBkYXlPZlllYXI6IGZ1bmN0aW9uIGRheU9mWWVhcigpIHtcbiAgICAgIHZhciBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHRoaXMueWVhcikgPyAxIDogMCk7XG4gICAgICB2YXIgZGl5cG0gPSBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoO1xuICAgICAgcmV0dXJuIGRpeXBtW2lzX2xlYXBdW3RoaXMubW9udGggLSAxXSArIHRoaXMuZGF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIHdlZWsuIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWYgdGhpc1xuICAgICAqIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBzdGFydCBvZiB0aGUgd2VlayAoY2xvbmVkKVxuICAgICAqL1xuICAgIHN0YXJ0T2ZXZWVrOiBmdW5jdGlvbiBzdGFydE9mV2VlayhhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5TVU5EQVk7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSAtPSAoKHRoaXMuZGF5T2ZXZWVrKCkgKyA3IC0gZmlyc3REb3cpICUgNyk7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGUgd2Vlay5cbiAgICAgKiBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmIHRoaXMgaXMgYVxuICAgICAqIGRhdGUtdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0XG4gICAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICBUaGUgZW5kIG9mIHRoZSB3ZWVrIChjbG9uZWQpXG4gICAgICovXG4gICAgZW5kT2ZXZWVrOiBmdW5jdGlvbiBlbmRPZldlZWsoYVdlZWtTdGFydCkge1xuICAgICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIHJlc3VsdC5kYXkgKz0gKDcgLSB0aGlzLmRheU9mV2VlaygpICsgZmlyc3REb3cgLSBJQ0FMLlRpbWUuU1VOREFZKSAlIDc7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHJld291bmQgdG8gdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAqIG1vbnRoLiBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmXG4gICAgICogdGhpcyBpcyBhIGRhdGUtdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICBUaGUgc3RhcnQgb2YgdGhlIG1vbnRoIChjbG9uZWQpXG4gICAgICovXG4gICAgc3RhcnRPZk1vbnRoOiBmdW5jdGlvbiBzdGFydE9mTW9udGgoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSA9IDE7XG4gICAgICByZXN1bHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHJlc3VsdC5ob3VyID0gMDtcbiAgICAgIHJlc3VsdC5taW51dGUgPSAwO1xuICAgICAgcmVzdWx0LnNlY29uZCA9IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBkYXRlL3RpbWUsIHNoaWZ0ZWQgdG8gdGhlIGVuZCBvZiB0aGVcbiAgICAgKiBtb250aC4gIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBlbmQgb2YgdGhlIG1vbnRoIChjbG9uZWQpXG4gICAgICovXG4gICAgZW5kT2ZNb250aDogZnVuY3Rpb24gZW5kT2ZNb250aCgpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHJlc3VsdC5tb250aCwgcmVzdWx0LnllYXIpO1xuICAgICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgICByZXN1bHQubWludXRlID0gMDtcbiAgICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lLCByZXdvdW5kIHRvIHRoZSBzdGFydCBvZiB0aGVcbiAgICAgKiB5ZWFyLiBUaGUgcmVzdWx0aW5nIElDQUwuVGltZSBpbnN0YW5jZSBpcyBvZiBpY2FsdHlwZSBkYXRlLCBldmVuIGlmXG4gICAgICogdGhpcyBpcyBhIGRhdGUtdGltZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICBUaGUgc3RhcnQgb2YgdGhlIHllYXIgKGNsb25lZClcbiAgICAgKi9cbiAgICBzdGFydE9mWWVhcjogZnVuY3Rpb24gc3RhcnRPZlllYXIoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgcmVzdWx0LmRheSA9IDE7XG4gICAgICByZXN1bHQubW9udGggPSAxO1xuICAgICAgcmVzdWx0LmlzRGF0ZSA9IHRydWU7XG4gICAgICByZXN1bHQuaG91ciA9IDA7XG4gICAgICByZXN1bHQubWludXRlID0gMDtcbiAgICAgIHJlc3VsdC5zZWNvbmQgPSAwO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIGN1cnJlbnQgZGF0ZS90aW1lLCBzaGlmdGVkIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgICogeWVhci4gIFRoZSByZXN1bHRpbmcgSUNBTC5UaW1lIGluc3RhbmNlIGlzIG9mIGljYWx0eXBlIGRhdGUsIGV2ZW4gaWZcbiAgICAgKiB0aGlzIGlzIGEgZGF0ZS10aW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgIFRoZSBlbmQgb2YgdGhlIHllYXIgKGNsb25lZClcbiAgICAgKi9cbiAgICBlbmRPZlllYXI6IGZ1bmN0aW9uIGVuZE9mWWVhcigpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG4gICAgICByZXN1bHQuZGF5ID0gMzE7XG4gICAgICByZXN1bHQubW9udGggPSAxMjtcbiAgICAgIHJlc3VsdC5pc0RhdGUgPSB0cnVlO1xuICAgICAgcmVzdWx0LmhvdXIgPSAwO1xuICAgICAgcmVzdWx0Lm1pbnV0ZSA9IDA7XG4gICAgICByZXN1bHQuc2Vjb25kID0gMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpcnN0IGNhbGN1bGF0ZXMgdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrLCB0aGVuIHJldHVybnMgdGhlIGRheSBvZiB5ZWFyIGZvclxuICAgICAqIHRoaXMgZGF0ZS4gSWYgdGhlIGRheSBmYWxscyBpbnRvIHRoZSBwcmV2aW91cyB5ZWFyLCB0aGUgZGF5IGlzIHplcm8gb3IgbmVnYXRpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYUZpcnN0RGF5T2ZXZWVrXG4gICAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgIFRoZSBjYWxjdWxhdGVkIGRheSBvZiB5ZWFyXG4gICAgICovXG4gICAgc3RhcnREb3lXZWVrOiBmdW5jdGlvbiBzdGFydERveVdlZWsoYUZpcnN0RGF5T2ZXZWVrKSB7XG4gICAgICB2YXIgZmlyc3REb3cgPSBhRmlyc3REYXlPZldlZWsgfHwgSUNBTC5UaW1lLlNVTkRBWTtcbiAgICAgIHZhciBkZWx0YSA9IHRoaXMuZGF5T2ZXZWVrKCkgLSBmaXJzdERvdztcbiAgICAgIGlmIChkZWx0YSA8IDApIGRlbHRhICs9IDc7XG4gICAgICByZXR1cm4gdGhpcy5kYXlPZlllYXIoKSAtIGRlbHRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRvbWluaWNhbCBsZXR0ZXIgZm9yIHRoZSBjdXJyZW50IHllYXIuIExldHRlcnMgcmFuZ2UgZnJvbSBBIC0gR1xuICAgICAqIGZvciBjb21tb24geWVhcnMsIGFuZCBBRyB0byBHRiBmb3IgbGVhcCB5ZWFycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ciAgICAgICAgICAgVGhlIHllYXIgdG8gcmV0cmlldmUgdGhlIGxldHRlciBmb3JcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgIFRoZSBkb21pbmljYWwgbGV0dGVyLlxuICAgICAqL1xuICAgIGdldERvbWluaWNhbExldHRlcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSUNBTC5UaW1lLmdldERvbWluaWNhbExldHRlcih0aGlzLnllYXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbnRoV2Vla0RheSByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBtb250aCAobm90IGRheSkuICBUaGVcbiAgICAgKiByZXR1cm5lZCB2YWx1ZSBpcyBhIGRheSByZWxhdGl2ZSB0aGUgbW9udGggdGhhdCB0aGlzIG1vbnRoIGJlbG9uZ3MgdG8gc29cbiAgICAgKiAxIHdvdWxkIGluZGljYXRlIHRoZSBmaXJzdCBvZiB0aGUgbW9udGggYW5kIDQwIHdvdWxkIGluZGljYXRlIGEgZGF5IGluXG4gICAgICogdGhlIGZvbGxvd2luZyBtb250aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF5T2ZXZWVrICAgRGF5IG9mIHRoZSB3ZWVrIHNlZSB0aGUgZGF5IG5hbWUgY29uc3RhbnRzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFQb3MgICAgICAgICBOdGggb2NjdXJyZW5jZSBvZiBhIGdpdmVuIHdlZWsgZGF5IHZhbHVlc1xuICAgICAqICAgICAgICBvZiAxIGFuZCAwIGJvdGggaW5kaWNhdGUgdGhlIGZpcnN0IHdlZWtkYXkgb2YgdGhhdCB0eXBlLiBhUG9zIG1heVxuICAgICAqICAgICAgICBiZSBlaXRoZXIgcG9zaXRpdmUgb3IgbmVnYXRpdmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gbnVtZXJpYyB2YWx1ZSBpbmRpY2F0aW5nIGEgZGF5IHJlbGF0aXZlXG4gICAgICogICAgICAgICAgICAgICAgICAgdG8gdGhlIGN1cnJlbnQgbW9udGggb2YgdGhpcyB0aW1lIG9iamVjdFxuICAgICAqL1xuICAgIG50aFdlZWtEYXk6IGZ1bmN0aW9uIGljYWx0aW1lX250aFdlZWtEYXkoYURheU9mV2VlaywgYVBvcykge1xuICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubW9udGgsIHRoaXMueWVhcik7XG4gICAgICB2YXIgd2Vla2RheTtcbiAgICAgIHZhciBwb3MgPSBhUG9zO1xuXG4gICAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgICB2YXIgb3RoZXJEYXkgPSB0aGlzLmNsb25lKCk7XG5cbiAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICBvdGhlckRheS5kYXkgPSAxO1xuXG4gICAgICAgIC8vIGJlY2F1c2UgMCBtZWFucyBubyBwb3NpdGlvbiBoYXMgYmVlbiBnaXZlblxuICAgICAgICAvLyAxIGFuZCAwIGluZGljYXRlIHRoZSBzYW1lIGRheS5cbiAgICAgICAgaWYgKHBvcyAhPSAwKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHRoZSBleHRyYSBudW1lcmljIHZhbHVlXG4gICAgICAgICAgcG9zLS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgY3VycmVudCBzdGFydCBvZmZzZXQgdG8gY3VycmVudCBkYXkuXG4gICAgICAgIHN0YXJ0ID0gb3RoZXJEYXkuZGF5O1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnQgZGF5IG9mIHdlZWtcbiAgICAgICAgdmFyIHN0YXJ0RG93ID0gb3RoZXJEYXkuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudFxuICAgICAgICAvLyBkYXkgb2YgdGhlIHdlZWsgYW5kIGRlc2lyZWQgZGF5IG9mIHRoZSB3ZWVrXG4gICAgICAgIHZhciBvZmZzZXQgPSBhRGF5T2ZXZWVrIC0gc3RhcnREb3c7XG5cblxuICAgICAgICAvLyBpZiB0aGUgb2Zmc2V0IGdvZXMgaW50byB0aGUgcGFzdFxuICAgICAgICAvLyB3ZWVrIHdlIGFkZCA3IHNvIGl0IGdvZXMgaW50byB0aGUgbmV4dFxuICAgICAgICAvLyB3ZWVrLiBXZSBvbmx5IHdhbnQgdG8gZ28gZm9yd2FyZCBpbiB0aW1lIGhlcmUuXG4gICAgICAgIGlmIChvZmZzZXQgPCAwKVxuICAgICAgICAgIC8vIHRoaXMgaXMgcmVhbGx5IGltcG9ydGFudCBvdGhlcndpc2Ugd2Ugd291bGRcbiAgICAgICAgICAvLyBlbmQgdXAgd2l0aCBkYXRlcyBmcm9tIGluIHRoZSBwYXN0LlxuICAgICAgICAgIG9mZnNldCArPSA3O1xuXG4gICAgICAgIC8vIGFkZCBvZmZzZXQgdG8gc3RhcnQgc28gc3RhcnQgaXMgdGhlIHNhbWVcbiAgICAgICAgLy8gZGF5IG9mIHRoZSB3ZWVrIGFzIHRoZSBkZXNpcmVkIGRheSBvZiB3ZWVrLlxuICAgICAgICBzdGFydCArPSBvZmZzZXQ7XG5cbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gYWRkIChhbmQgbXVsdGlwbHkpXG4gICAgICAgIC8vIHRoZSBudW1lcmljIHZhbHVlIG9mIHRoZSBkYXkgd2Ugc3VidHJhY3QgaXRcbiAgICAgICAgLy8gZnJvbSB0aGUgc3RhcnQgcG9zaXRpb24gc28gbm90IHRvIGFkZCBpdCB0d2ljZS5cbiAgICAgICAgc3RhcnQgLT0gYURheU9mV2VlaztcblxuICAgICAgICAvLyBzZXQgd2VlayBkYXlcbiAgICAgICAgd2Vla2RheSA9IGFEYXlPZldlZWs7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHRoZW4gd2Ugc2V0IGl0IHRvIHRoZSBsYXN0IGRheSBpbiB0aGUgY3VycmVudCBtb250aFxuICAgICAgICBvdGhlckRheS5kYXkgPSBkYXlzSW5Nb250aDtcblxuICAgICAgICAvLyBmaW5kIHRoZSBlbmRzIHdlZWtkYXlcbiAgICAgICAgdmFyIGVuZERvdyA9IG90aGVyRGF5LmRheU9mV2VlaygpO1xuXG4gICAgICAgIHBvcysrO1xuXG4gICAgICAgIHdlZWtkYXkgPSAoZW5kRG93IC0gYURheU9mV2Vlayk7XG5cbiAgICAgICAgaWYgKHdlZWtkYXkgPCAwKSB7XG4gICAgICAgICAgd2Vla2RheSArPSA3O1xuICAgICAgICB9XG5cbiAgICAgICAgd2Vla2RheSA9IGRheXNJbk1vbnRoIC0gd2Vla2RheTtcbiAgICAgIH1cblxuICAgICAgd2Vla2RheSArPSBwb3MgKiA3O1xuXG4gICAgICByZXR1cm4gc3RhcnQgKyB3ZWVrZGF5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgY3VycmVudCB0aW1lIGlzIHRoZSBudGggd2Vla2RheSwgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnRcbiAgICAgKiBtb250aC4gIFdpbGwgYWx3YXlzIHJldHVybiBmYWxzZSB3aGVuIHJ1bGUgcmVzb2x2ZXMgb3V0c2lkZSBvZiBjdXJyZW50XG4gICAgICogbW9udGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5fSBhRGF5T2ZXZWVrICAgICAgIERheSBvZiB3ZWVrIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFQb3MgICAgICAgICAgICAgICAgICAgICAgICBSZWxhdGl2ZSBwb3NpdGlvblxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJ1ZSwgaWYgaXQgaXMgdGhlIG50aCB3ZWVrZGF5XG4gICAgICovXG4gICAgaXNOdGhXZWVrRGF5OiBmdW5jdGlvbihhRGF5T2ZXZWVrLCBhUG9zKSB7XG4gICAgICB2YXIgZG93ID0gdGhpcy5kYXlPZldlZWsoKTtcblxuICAgICAgaWYgKGFQb3MgPT09IDAgJiYgZG93ID09PSBhRGF5T2ZXZWVrKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgcG9zXG4gICAgICB2YXIgZGF5ID0gdGhpcy5udGhXZWVrRGF5KGFEYXlPZldlZWssIGFQb3MpO1xuXG4gICAgICBpZiAoZGF5ID09PSB0aGlzLmRheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBJU08gODYwMSB3ZWVrIG51bWJlci4gVGhlIGZpcnN0IHdlZWsgb2YgYSB5ZWFyIGlzIHRoZVxuICAgICAqIHdlZWsgdGhhdCBjb250YWlucyB0aGUgZmlyc3QgVGh1cnNkYXkuIFRoZSB5ZWFyIGNhbiBoYXZlIDUzIHdlZWtzLCBpZlxuICAgICAqIEphbnVhcnkgMXN0IGlzIGEgRnJpZGF5LlxuICAgICAqXG4gICAgICogTm90ZSB0aGVyZSBhcmUgcmVnaW9ucyB3aGVyZSB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhciBpcyB0aGUgb25lIHRoYXRcbiAgICAgKiBzdGFydHMgb24gSmFudWFyeSAxc3QsIHdoaWNoIG1heSBvZmZzZXQgdGhlIHdlZWsgbnVtYmVyLiBBbHNvLCBpZiBhXG4gICAgICogZGlmZmVyZW50IHdlZWsgc3RhcnQgaXMgc3BlY2lmaWVkLCB0aGlzIHdpbGwgYWxzbyBhZmZlY3QgdGhlIHdlZWtcbiAgICAgKiBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc2VlIElDQUwuVGltZS53ZWVrT25lU3RhcnRzXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheX0gYVdlZWtTdGFydCAgICAgICAgVGhlIHdlZWtkYXkgdGhlIHdlZWsgc3RhcnRzIHdpdGhcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgSVNPIHdlZWsgbnVtYmVyXG4gICAgICovXG4gICAgd2Vla051bWJlcjogZnVuY3Rpb24gd2Vla051bWJlcihhV2Vla1N0YXJ0KSB7XG4gICAgICB2YXIgd25DYWNoZUtleSA9ICh0aGlzLnllYXIgPDwgMTIpICsgKHRoaXMubW9udGggPDwgOCkgKyAodGhpcy5kYXkgPDwgMykgKyBhV2Vla1N0YXJ0O1xuICAgICAgaWYgKHduQ2FjaGVLZXkgaW4gSUNBTC5UaW1lLl93bkNhY2hlKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLlRpbWUuX3duQ2FjaGVbd25DYWNoZUtleV07XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGNvdXJ0ZXN0eSBvZiBKdWxpYW4gQnVja25hbGwsIHB1Ymxpc2hlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAgICAgIC8vIGh0dHA6Ly93d3cuYm95ZXQuY29tL2FydGljbGVzL3B1Ymxpc2hlZGFydGljbGVzL2NhbGN1bGF0aW5ndGhlaXNvd2Vla251bWIuaHRtbFxuICAgICAgLy8gcGx1cyBzb21lIGZpeGVzIHRvIGJlIGFibGUgdG8gdXNlIGRpZmZlcmVudCB3ZWVrIHN0YXJ0cy5cbiAgICAgIHZhciB3ZWVrMTtcblxuICAgICAgdmFyIGR0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgZHQuaXNEYXRlID0gdHJ1ZTtcbiAgICAgIHZhciBpc295ZWFyID0gdGhpcy55ZWFyO1xuXG4gICAgICBpZiAoZHQubW9udGggPT0gMTIgJiYgZHQuZGF5ID4gMjUpIHtcbiAgICAgICAgd2VlazEgPSBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cyhpc295ZWFyICsgMSwgYVdlZWtTdGFydCk7XG4gICAgICAgIGlmIChkdC5jb21wYXJlKHdlZWsxKSA8IDApIHtcbiAgICAgICAgICB3ZWVrMSA9IElDQUwuVGltZS53ZWVrT25lU3RhcnRzKGlzb3llYXIsIGFXZWVrU3RhcnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzb3llYXIrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2VlazEgPSBJQ0FMLlRpbWUud2Vla09uZVN0YXJ0cyhpc295ZWFyLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgaWYgKGR0LmNvbXBhcmUod2VlazEpIDwgMCkge1xuICAgICAgICAgIHdlZWsxID0gSUNBTC5UaW1lLndlZWtPbmVTdGFydHMoLS1pc295ZWFyLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGF5c0JldHdlZW4gPSAoZHQuc3VidHJhY3REYXRlKHdlZWsxKS50b1NlY29uZHMoKSAvIDg2NDAwKTtcbiAgICAgIHZhciBhbnN3ZXIgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoZGF5c0JldHdlZW4gLyA3KSArIDE7XG4gICAgICBJQ0FMLlRpbWUuX3duQ2FjaGVbd25DYWNoZUtleV0gPSBhbnN3ZXI7XG4gICAgICByZXR1cm4gYW5zd2VyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBkdXJhdGlvbiB0byB0aGUgY3VycmVudCB0aW1lLiBUaGUgaW5zdGFuY2UgaXMgbW9kaWZpZWQgaW5cbiAgICAgKiBwbGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5EdXJhdGlvbn0gYUR1cmF0aW9uICAgICAgICAgVGhlIGR1cmF0aW9uIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZER1cmF0aW9uOiBmdW5jdGlvbiBpY2FsdGltZV9hZGQoYUR1cmF0aW9uKSB7XG4gICAgICB2YXIgbXVsdCA9IChhRHVyYXRpb24uaXNOZWdhdGl2ZSA/IC0xIDogMSk7XG5cbiAgICAgIC8vIGJlY2F1c2Ugb2YgdGhlIGR1cmF0aW9uIG9wdGltaXphdGlvbnMgaXQgaXMgbXVjaFxuICAgICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gZ3JhYiBhbGwgdGhlIHZhbHVlcyB1cCBmcm9udFxuICAgICAgLy8gdGhlbiBzZXQgdGhlbSBkaXJlY3RseSAod2hpY2ggd2lsbCBhdm9pZCBhIG5vcm1hbGl6YXRpb24gY2FsbCkuXG4gICAgICAvLyBTbyB3ZSBkb24ndCBhY3R1YWxseSBub3JtYWxpemUgdW50aWwgd2UgbmVlZCBpdC5cbiAgICAgIHZhciBzZWNvbmQgPSB0aGlzLnNlY29uZDtcbiAgICAgIHZhciBtaW51dGUgPSB0aGlzLm1pbnV0ZTtcbiAgICAgIHZhciBob3VyID0gdGhpcy5ob3VyO1xuICAgICAgdmFyIGRheSA9IHRoaXMuZGF5O1xuXG4gICAgICBzZWNvbmQgKz0gbXVsdCAqIGFEdXJhdGlvbi5zZWNvbmRzO1xuICAgICAgbWludXRlICs9IG11bHQgKiBhRHVyYXRpb24ubWludXRlcztcbiAgICAgIGhvdXIgKz0gbXVsdCAqIGFEdXJhdGlvbi5ob3VycztcbiAgICAgIGRheSArPSBtdWx0ICogYUR1cmF0aW9uLmRheXM7XG4gICAgICBkYXkgKz0gbXVsdCAqIDcgKiBhRHVyYXRpb24ud2Vla3M7XG5cbiAgICAgIHRoaXMuc2Vjb25kID0gc2Vjb25kO1xuICAgICAgdGhpcy5taW51dGUgPSBtaW51dGU7XG4gICAgICB0aGlzLmhvdXIgPSBob3VyO1xuICAgICAgdGhpcy5kYXkgPSBkYXk7XG5cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3VidHJhY3QgdGhlIGRhdGUgZGV0YWlscyAoX2V4Y2x1ZGluZ18gdGltZXpvbmUpLiAgVXNlZnVsIGZvciBmaW5kaW5nXG4gICAgICogdGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gdGltZSBvYmplY3RzIGV4Y2x1ZGluZyB0aGVpclxuICAgICAqIHRpbWV6b25lIGRpZmZlcmVuY2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFEYXRlICAgICBUaGUgZGF0ZSB0byBzdWJzdHJhY3RcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgICAgIFRoZSBkaWZmZXJlbmNlIGFzIGEgZHVyYXRpb25cbiAgICAgKi9cbiAgICBzdWJ0cmFjdERhdGU6IGZ1bmN0aW9uIGljYWx0aW1lX3N1YnRyYWN0KGFEYXRlKSB7XG4gICAgICB2YXIgdW5peFRpbWUgPSB0aGlzLnRvVW5peFRpbWUoKSArIHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICB2YXIgb3RoZXIgPSBhRGF0ZS50b1VuaXhUaW1lKCkgKyBhRGF0ZS51dGNPZmZzZXQoKTtcbiAgICAgIHJldHVybiBJQ0FMLkR1cmF0aW9uLmZyb21TZWNvbmRzKHVuaXhUaW1lIC0gb3RoZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0aGUgZGF0ZSBkZXRhaWxzLCB0YWtpbmcgdGltZXpvbmVzIGludG8gYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBhRGF0ZSAgVGhlIGRhdGUgdG8gc3VidHJhY3RcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLkR1cmF0aW9ufSAgVGhlIGRpZmZlcmVuY2UgaW4gZHVyYXRpb25cbiAgICAgKi9cbiAgICBzdWJ0cmFjdERhdGVUejogZnVuY3Rpb24gaWNhbHRpbWVfc3VidHJhY3RfYWJzKGFEYXRlKSB7XG4gICAgICB2YXIgdW5peFRpbWUgPSB0aGlzLnRvVW5peFRpbWUoKTtcbiAgICAgIHZhciBvdGhlciA9IGFEYXRlLnRvVW5peFRpbWUoKTtcbiAgICAgIHJldHVybiBJQ0FMLkR1cmF0aW9uLmZyb21TZWNvbmRzKHVuaXhUaW1lIC0gb3RoZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB0aGUgSUNBTC5UaW1lIGluc3RhbmNlIHdpdGggYW5vdGhlciBvbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuRHVyYXRpb259IGFPdGhlciAgICAgICAgVGhlIGluc3RhbmNlIHRvIGNvbXBhcmUgd2l0aFxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgICAtMSwgMCBvciAxIGZvciBsZXNzL2VxdWFsL2dyZWF0ZXJcbiAgICAgKi9cbiAgICBjb21wYXJlOiBmdW5jdGlvbiBpY2FsdGltZV9jb21wYXJlKG90aGVyKSB7XG4gICAgICB2YXIgYSA9IHRoaXMudG9Vbml4VGltZSgpO1xuICAgICAgdmFyIGIgPSBvdGhlci50b1VuaXhUaW1lKCk7XG5cbiAgICAgIGlmIChhID4gYikgcmV0dXJuIDE7XG4gICAgICBpZiAoYiA+IGEpIHJldHVybiAtMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyBvbmx5IHRoZSBkYXRlIHBhcnQgb2YgdGhpcyBpbnN0YW5jZSB3aXRoIGFub3RoZXIgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkR1cmF0aW9ufSBvdGhlciAgICAgICAgIFRoZSBpbnN0YW5jZSB0byBjb21wYXJlIHdpdGhcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHR6ICAgICAgICAgICAgVGhlIHRpbWV6b25lIHRvIGNvbXBhcmUgaW5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgLTEsIDAgb3IgMSBmb3IgbGVzcy9lcXVhbC9ncmVhdGVyXG4gICAgICovXG4gICAgY29tcGFyZURhdGVPbmx5VHo6IGZ1bmN0aW9uIGljYWx0aW1lX2NvbXBhcmVEYXRlT25seVR6KG90aGVyLCB0eikge1xuICAgICAgZnVuY3Rpb24gY21wKGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIElDQUwuVGltZS5fY21wX2F0dHIoYSwgYiwgYXR0cik7XG4gICAgICB9XG4gICAgICB2YXIgYSA9IHRoaXMuY29udmVydFRvWm9uZSh0eik7XG4gICAgICB2YXIgYiA9IG90aGVyLmNvbnZlcnRUb1pvbmUodHopO1xuICAgICAgdmFyIHJjID0gMDtcblxuICAgICAgaWYgKChyYyA9IGNtcChcInllYXJcIikpICE9IDApIHJldHVybiByYztcbiAgICAgIGlmICgocmMgPSBjbXAoXCJtb250aFwiKSkgIT0gMCkgcmV0dXJuIHJjO1xuICAgICAgaWYgKChyYyA9IGNtcChcImRheVwiKSkgIT0gMCkgcmV0dXJuIHJjO1xuXG4gICAgICByZXR1cm4gcmM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGluc3RhbmNlIGludG8gYW5vdGhlciB0aW1lem9uZS4gVGhlIHJldHVybmVkIElDQUwuVGltZVxuICAgICAqIGluc3RhbmNlIGlzIGFsd2F5cyBhIGNvcHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV9IHpvbmUgICAgICBUaGUgem9uZSB0byBjb252ZXJ0IHRvXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgICAgVGhlIGNvcHksIGNvbnZlcnRlZCB0byB0aGUgem9uZVxuICAgICAqL1xuICAgIGNvbnZlcnRUb1pvbmU6IGZ1bmN0aW9uIGNvbnZlcnRUb1pvbmUoem9uZSkge1xuICAgICAgdmFyIGNvcHkgPSB0aGlzLmNsb25lKCk7XG4gICAgICB2YXIgem9uZV9lcXVhbHMgPSAodGhpcy56b25lLnR6aWQgPT0gem9uZS50emlkKTtcblxuICAgICAgaWYgKCF0aGlzLmlzRGF0ZSAmJiAhem9uZV9lcXVhbHMpIHtcbiAgICAgICAgSUNBTC5UaW1lem9uZS5jb252ZXJ0X3RpbWUoY29weSwgdGhpcy56b25lLCB6b25lKTtcbiAgICAgIH1cblxuICAgICAgY29weS56b25lID0gem9uZTtcbiAgICAgIHJldHVybiBjb3B5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBVVEMgb2Zmc2V0IG9mIHRoZSBjdXJyZW50IGRhdGUvdGltZSBpbiB0aGUgdGltZXpvbmUgaXQgaXNcbiAgICAgKiBpbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gICAgIFVUQyBvZmZzZXQgaW4gc2Vjb25kc1xuICAgICAqL1xuICAgIHV0Y09mZnNldDogZnVuY3Rpb24gdXRjX29mZnNldCgpIHtcbiAgICAgIGlmICh0aGlzLnpvbmUgPT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lIHx8XG4gICAgICAgICAgdGhpcy56b25lID09IElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy56b25lLnV0Y09mZnNldCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBSRkMgNTU0NSBjb21wbGlhbnQgaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gaWNhbCBkYXRlL2RhdGUtdGltZVxuICAgICAqL1xuICAgIHRvSUNBTFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RyaW5nID0gdGhpcy50b1N0cmluZygpO1xuXG4gICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgIHJldHVybiBJQ0FMLmRlc2lnbi5pY2FsZW5kYXIudmFsdWVbJ2RhdGUtdGltZSddLnRvSUNBTChzdHJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIElDQUwuZGVzaWduLmljYWxlbmRhci52YWx1ZS5kYXRlLnRvSUNBTChzdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZGF0ZS90aW1lLCBpbiBqQ2FsIGZvcm1cbiAgICAgKiAoaW5jbHVkaW5nIDogYW5kIC0gc2VwYXJhdG9ycykuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLnllYXIgKyAnLScgK1xuICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMubW9udGgpICsgJy0nICtcbiAgICAgICAgICAgICAgICAgICBJQ0FMLmhlbHBlcnMucGFkMih0aGlzLmRheSk7XG5cbiAgICAgIGlmICghdGhpcy5pc0RhdGUpIHtcbiAgICAgICAgICByZXN1bHQgKz0gJ1QnICsgSUNBTC5oZWxwZXJzLnBhZDIodGhpcy5ob3VyKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMubWludXRlKSArICc6JyArXG4gICAgICAgICAgICAgICAgICAgIElDQUwuaGVscGVycy5wYWQyKHRoaXMuc2Vjb25kKTtcblxuICAgICAgICBpZiAodGhpcy56b25lID09PSBJQ0FMLlRpbWV6b25lLnV0Y1RpbWV6b25lKSB7XG4gICAgICAgICAgcmVzdWx0ICs9ICdaJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgY3VycmVudCBpbnN0YW5jZSB0byBhIEphdmFzY3JpcHQgZGF0ZVxuICAgICAqIEByZXR1cm4ge0RhdGV9XG4gICAgICovXG4gICAgdG9KU0RhdGU6IGZ1bmN0aW9uIHRvSlNEYXRlKCkge1xuICAgICAgaWYgKHRoaXMuem9uZSA9PSBJQ0FMLlRpbWV6b25lLmxvY2FsVGltZXpvbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCAtIDEsIHRoaXMuZGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy55ZWFyLCB0aGlzLm1vbnRoIC0gMSwgdGhpcy5kYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaG91ciwgdGhpcy5taW51dGUsIHRoaXMuc2Vjb25kLCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudG9Vbml4VGltZSgpICogMTAwMCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9ub3JtYWxpemU6IGZ1bmN0aW9uIGljYWx0aW1lX25vcm1hbGl6ZSgpIHtcbiAgICAgIHZhciBpc0RhdGUgPSB0aGlzLl90aW1lLmlzRGF0ZTtcbiAgICAgIGlmICh0aGlzLl90aW1lLmlzRGF0ZSkge1xuICAgICAgICB0aGlzLl90aW1lLmhvdXIgPSAwO1xuICAgICAgICB0aGlzLl90aW1lLm1pbnV0ZSA9IDA7XG4gICAgICAgIHRoaXMuX3RpbWUuc2Vjb25kID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRqdXN0KDAsIDAsIDAsIDApO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSBkYXRlL3RpbWUgYnkgdGhlIGdpdmVuIG9mZnNldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYURheXMgICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBkYXlzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFFeHRyYUhvdXJzICAgICAgVGhlIGV4dHJhIGFtb3VudCBvZiBob3Vyc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRXh0cmFNaW51dGVzICAgIFRoZSBleHRyYSBhbW91bnQgb2YgbWludXRlc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhRXh0cmFTZWNvbmRzICAgIFRoZSBleHRyYSBhbW91bnQgb2Ygc2Vjb25kc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gYVRpbWUgICAgICAgICAgIFRoZSB0aW1lIHRvIGFkanVzdCwgZGVmYXVsdHMgdG8gdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFkanVzdDogZnVuY3Rpb24gaWNhbHRpbWVfYWRqdXN0KGFFeHRyYURheXMsIGFFeHRyYUhvdXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFFeHRyYU1pbnV0ZXMsIGFFeHRyYVNlY29uZHMsIGFUaW1lKSB7XG5cbiAgICAgIHZhciBtaW51dGVzT3ZlcmZsb3csIGhvdXJzT3ZlcmZsb3csXG4gICAgICAgICAgZGF5c092ZXJmbG93ID0gMCwgeWVhcnNPdmVyZmxvdyA9IDA7XG5cbiAgICAgIHZhciBzZWNvbmQsIG1pbnV0ZSwgaG91ciwgZGF5O1xuICAgICAgdmFyIGRheXNJbk1vbnRoO1xuXG4gICAgICB2YXIgdGltZSA9IGFUaW1lIHx8IHRoaXMuX3RpbWU7XG5cbiAgICAgIGlmICghdGltZS5pc0RhdGUpIHtcbiAgICAgICAgc2Vjb25kID0gdGltZS5zZWNvbmQgKyBhRXh0cmFTZWNvbmRzO1xuICAgICAgICB0aW1lLnNlY29uZCA9IHNlY29uZCAlIDYwO1xuICAgICAgICBtaW51dGVzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmMoc2Vjb25kIC8gNjApO1xuICAgICAgICBpZiAodGltZS5zZWNvbmQgPCAwKSB7XG4gICAgICAgICAgdGltZS5zZWNvbmQgKz0gNjA7XG4gICAgICAgICAgbWludXRlc092ZXJmbG93LS07XG4gICAgICAgIH1cblxuICAgICAgICBtaW51dGUgPSB0aW1lLm1pbnV0ZSArIGFFeHRyYU1pbnV0ZXMgKyBtaW51dGVzT3ZlcmZsb3c7XG4gICAgICAgIHRpbWUubWludXRlID0gbWludXRlICUgNjA7XG4gICAgICAgIGhvdXJzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmMobWludXRlIC8gNjApO1xuICAgICAgICBpZiAodGltZS5taW51dGUgPCAwKSB7XG4gICAgICAgICAgdGltZS5taW51dGUgKz0gNjA7XG4gICAgICAgICAgaG91cnNPdmVyZmxvdy0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaG91ciA9IHRpbWUuaG91ciArIGFFeHRyYUhvdXJzICsgaG91cnNPdmVyZmxvdztcblxuICAgICAgICB0aW1lLmhvdXIgPSBob3VyICUgMjQ7XG4gICAgICAgIGRheXNPdmVyZmxvdyA9IElDQUwuaGVscGVycy50cnVuYyhob3VyIC8gMjQpO1xuICAgICAgICBpZiAodGltZS5ob3VyIDwgMCkge1xuICAgICAgICAgIHRpbWUuaG91ciArPSAyNDtcbiAgICAgICAgICBkYXlzT3ZlcmZsb3ctLTtcbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgICAgIC8vIEFkanVzdCBtb250aCBhbmQgeWVhciBmaXJzdCwgYmVjYXVzZSB3ZSBuZWVkIHRvIGtub3cgd2hhdCBtb250aCB0aGUgZGF5XG4gICAgICAvLyBpcyBpbiBiZWZvcmUgYWRqdXN0aW5nIGl0LlxuICAgICAgaWYgKHRpbWUubW9udGggPiAxMikge1xuICAgICAgICB5ZWFyc092ZXJmbG93ID0gSUNBTC5oZWxwZXJzLnRydW5jKCh0aW1lLm1vbnRoIC0gMSkgLyAxMik7XG4gICAgICB9IGVsc2UgaWYgKHRpbWUubW9udGggPCAxKSB7XG4gICAgICAgIHllYXJzT3ZlcmZsb3cgPSBJQ0FMLmhlbHBlcnMudHJ1bmModGltZS5tb250aCAvIDEyKSAtIDE7XG4gICAgICB9XG5cbiAgICAgIHRpbWUueWVhciArPSB5ZWFyc092ZXJmbG93O1xuICAgICAgdGltZS5tb250aCAtPSAxMiAqIHllYXJzT3ZlcmZsb3c7XG5cbiAgICAgIC8vIE5vdyB0YWtlIGNhcmUgb2YgdGhlIGRheXMgKGFuZCBhZGp1c3QgbW9udGggaWYgbmVlZGVkKVxuICAgICAgZGF5ID0gdGltZS5kYXkgKyBhRXh0cmFEYXlzICsgZGF5c092ZXJmbG93O1xuXG4gICAgICBpZiAoZGF5ID4gMCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGltZS5tb250aCwgdGltZS55ZWFyKTtcbiAgICAgICAgICBpZiAoZGF5IDw9IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aW1lLm1vbnRoKys7XG4gICAgICAgICAgaWYgKHRpbWUubW9udGggPiAxMikge1xuICAgICAgICAgICAgdGltZS55ZWFyKys7XG4gICAgICAgICAgICB0aW1lLm1vbnRoID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXkgLT0gZGF5c0luTW9udGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlIChkYXkgPD0gMCkge1xuICAgICAgICAgIGlmICh0aW1lLm1vbnRoID09IDEpIHtcbiAgICAgICAgICAgIHRpbWUueWVhci0tO1xuICAgICAgICAgICAgdGltZS5tb250aCA9IDEyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aW1lLm1vbnRoLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF5ICs9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aW1lLm1vbnRoLCB0aW1lLnllYXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRpbWUuZGF5ID0gZGF5O1xuXG4gICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSBmcm9tIHVuaXggdGltZSwgdGhlIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlXG4gICAgICogSmFudWFyeSAxc3QsIDE5NzAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kcyAgICAgIFRoZSBzZWNvbmRzIHRvIHNldCB1cCB3aXRoXG4gICAgICovXG4gICAgZnJvbVVuaXhUaW1lOiBmdW5jdGlvbiBmcm9tVW5peFRpbWUoc2Vjb25kcykge1xuICAgICAgdGhpcy56b25lID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcbiAgICAgIHZhciBlcG9jaCA9IElDQUwuVGltZS5lcG9jaFRpbWUuY2xvbmUoKTtcbiAgICAgIGVwb2NoLmFkanVzdCgwLCAwLCAwLCBzZWNvbmRzKTtcblxuICAgICAgdGhpcy55ZWFyID0gZXBvY2gueWVhcjtcbiAgICAgIHRoaXMubW9udGggPSBlcG9jaC5tb250aDtcbiAgICAgIHRoaXMuZGF5ID0gZXBvY2guZGF5O1xuICAgICAgdGhpcy5ob3VyID0gZXBvY2guaG91cjtcbiAgICAgIHRoaXMubWludXRlID0gZXBvY2gubWludXRlO1xuICAgICAgdGhpcy5zZWNvbmQgPSBNYXRoLmZsb29yKGVwb2NoLnNlY29uZCk7XG5cbiAgICAgIHRoaXMuX2NhY2hlZFVuaXhUaW1lID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGN1cnJlbnQgaW5zdGFuY2UgdG8gc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDFzdCAxOTcwLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICAgIFNlY29uZHMgc2luY2UgMTk3MFxuICAgICAqL1xuICAgIHRvVW5peFRpbWU6IGZ1bmN0aW9uIHRvVW5peFRpbWUoKSB7XG4gICAgICBpZiAodGhpcy5fY2FjaGVkVW5peFRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFVuaXhUaW1lO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG5cbiAgICAgIC8vIHdlIHVzZSB0aGUgb2Zmc2V0IHRyaWNrIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBhcmUgZ2V0dGluZyB0aGUgYWN0dWFsIFVUQyB0aW1lXG4gICAgICB2YXIgbXMgPSBEYXRlLlVUQyhcbiAgICAgICAgdGhpcy55ZWFyLFxuICAgICAgICB0aGlzLm1vbnRoIC0gMSxcbiAgICAgICAgdGhpcy5kYXksXG4gICAgICAgIHRoaXMuaG91cixcbiAgICAgICAgdGhpcy5taW51dGUsXG4gICAgICAgIHRoaXMuc2Vjb25kIC0gb2Zmc2V0XG4gICAgICApO1xuXG4gICAgICAvLyBzZWNvbmRzXG4gICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG1zIC8gMTAwMDtcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRVbml4VGltZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGltZSB0byBpbnRvIE9iamVjdCB3aGljaCBjYW4gYmUgc2VyaWFsaXplZCB0aGVuIHJlLWNyZWF0ZWRcbiAgICAgKiB1c2luZyB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHRvSlNPTiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgY2FsbGVkXG4gICAgICogdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShteXRpbWUpO1xuICAgICAqXG4gICAgICogdmFyIGRlc2VyaWFsaXplZCA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgICpcbiAgICAgKiB2YXIgdGltZSA9IG5ldyBJQ0FMLlRpbWUoZGVzZXJpYWxpemVkKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvcHkgPSBbXG4gICAgICAgICd5ZWFyJyxcbiAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgJ2RheScsXG4gICAgICAgICdob3VyJyxcbiAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICdzZWNvbmQnLFxuICAgICAgICAnaXNEYXRlJ1xuICAgICAgXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSBjb3B5Lmxlbmd0aDtcbiAgICAgIHZhciBwcm9wO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHByb3AgPSBjb3B5W2ldO1xuICAgICAgICByZXN1bHRbcHJvcF0gPSB0aGlzW3Byb3BdO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy56b25lKSB7XG4gICAgICAgIHJlc3VsdC50aW1lem9uZSA9IHRoaXMuem9uZS50emlkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICB9O1xuXG4gIChmdW5jdGlvbiBzZXR1cE5vcm1hbGl6ZUF0dHJpYnV0ZXMoKSB7XG4gICAgLy8gVGhpcyBuZWVkcyB0byBydW4gYmVmb3JlIGFueSBpbnN0YW5jZXMgYXJlIGNyZWF0ZWQhXG4gICAgZnVuY3Rpb24gZGVmaW5lQXR0cihhdHRyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSUNBTC5UaW1lLnByb3RvdHlwZSwgYXR0ciwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldFRpbWVBdHRyKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nTm9ybWFsaXphdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nTm9ybWFsaXphdGlvbiA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lW2F0dHJdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldFRpbWVBdHRyKHZhbCkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIGlzRGF0ZSB3aWxsIGJlIHNldCBhbmQgaWYgd2FzIG5vdCBzZXQgdG8gbm9ybWFsaXplIGRhdGUuXG4gICAgICAgICAgLy8gVGhpcyBhdm9pZHMgbG9zaW5nIGRheXMgd2hlbiBzZWNvbmRzLCBtaW51dGVzIGFuZCBob3VycyBhcmUgemVyb2VkXG4gICAgICAgICAgLy8gd2hhdCBub3JtYWxpemUgd2lsbCBkbyB3aGVuIHRpbWUgaXMgYSBkYXRlLlxuICAgICAgICAgIGlmIChhdHRyID09PSBcImlzRGF0ZVwiICYmIHZhbCAmJiAhdGhpcy5fdGltZS5pc0RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0KDAsIDAsIDAsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9jYWNoZWRVbml4VGltZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fcGVuZGluZ05vcm1hbGl6YXRpb24gPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX3RpbWVbYXR0cl0gPSB2YWw7XG5cbiAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKFwiZGVmaW5lUHJvcGVydHlcIiBpbiBPYmplY3QpIHtcbiAgICAgIGRlZmluZUF0dHIoXCJ5ZWFyXCIpO1xuICAgICAgZGVmaW5lQXR0cihcIm1vbnRoXCIpO1xuICAgICAgZGVmaW5lQXR0cihcImRheVwiKTtcbiAgICAgIGRlZmluZUF0dHIoXCJob3VyXCIpO1xuICAgICAgZGVmaW5lQXR0cihcIm1pbnV0ZVwiKTtcbiAgICAgIGRlZmluZUF0dHIoXCJzZWNvbmRcIik7XG4gICAgICBkZWZpbmVBdHRyKFwiaXNEYXRlXCIpO1xuICAgIH1cbiAgfSkoKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF5cyBpbiB0aGUgZ2l2ZW4gbW9udGhcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vbnRoICAgICAgVGhlIG1vbnRoIHRvIGNoZWNrXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgIFRoZSB5ZWFyIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgIFRoZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGhcbiAgICovXG4gIElDQUwuVGltZS5kYXlzSW5Nb250aCA9IGZ1bmN0aW9uIGljYWx0aW1lX2RheXNJbk1vbnRoKG1vbnRoLCB5ZWFyKSB7XG4gICAgdmFyIF9kYXlzSW5Nb250aCA9IFswLCAzMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXTtcbiAgICB2YXIgZGF5cyA9IDMwO1xuXG4gICAgaWYgKG1vbnRoIDwgMSB8fCBtb250aCA+IDEyKSByZXR1cm4gZGF5cztcblxuICAgIGRheXMgPSBfZGF5c0luTW9udGhbbW9udGhdO1xuXG4gICAgaWYgKG1vbnRoID09IDIpIHtcbiAgICAgIGRheXMgKz0gSUNBTC5UaW1lLmlzTGVhcFllYXIoeWVhcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRheXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgeWVhciBpcyBhIGxlYXAgeWVhclxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0geWVhciAgICAgICBUaGUgeWVhciB0byBjaGVja1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICBUcnVlLCBpZiB0aGUgeWVhciBpcyBhIGxlYXAgeWVhclxuICAgKi9cbiAgSUNBTC5UaW1lLmlzTGVhcFllYXIgPSBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICBpZiAoeWVhciA8PSAxNzUyKSB7XG4gICAgICByZXR1cm4gKCh5ZWFyICUgNCkgPT0gMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoKCh5ZWFyICUgNCA9PSAwKSAmJiAoeWVhciAlIDEwMCAhPSAwKSkgfHwgKHllYXIgJSA0MDAgPT0gMCkpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IElDQUwuVGltZSBmcm9tIHRoZSBkYXkgb2YgeWVhciBhbmQgeWVhci4gVGhlIGRhdGUgaXMgcmV0dXJuZWRcbiAgICogaW4gZmxvYXRpbmcgdGltZXpvbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhRGF5T2ZZZWFyICAgICBUaGUgZGF5IG9mIHllYXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFZZWFyICAgICAgICAgIFRoZSB5ZWFyIHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2UgaW5cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgIFRoZSBjcmVhdGVkIGluc3RhbmNlIHdpdGggdGhlIGNhbGN1bGF0ZWQgZGF0ZVxuICAgKi9cbiAgSUNBTC5UaW1lLmZyb21EYXlPZlllYXIgPSBmdW5jdGlvbiBpY2FsdGltZV9mcm9tRGF5T2ZZZWFyKGFEYXlPZlllYXIsIGFZZWFyKSB7XG4gICAgdmFyIHllYXIgPSBhWWVhcjtcbiAgICB2YXIgZG95ID0gYURheU9mWWVhcjtcbiAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgdHQuYXV0b19ub3JtYWxpemUgPSBmYWxzZTtcbiAgICB2YXIgaXNfbGVhcCA9IChJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKSA/IDEgOiAwKTtcblxuICAgIGlmIChkb3kgPCAxKSB7XG4gICAgICB5ZWFyLS07XG4gICAgICBpc19sZWFwID0gKElDQUwuVGltZS5pc0xlYXBZZWFyKHllYXIpID8gMSA6IDApO1xuICAgICAgZG95ICs9IElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bMTJdO1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKGRveSwgeWVhcik7XG4gICAgfSBlbHNlIGlmIChkb3kgPiBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdWzEyXSkge1xuICAgICAgaXNfbGVhcCA9IChJQ0FMLlRpbWUuaXNMZWFwWWVhcih5ZWFyKSA/IDEgOiAwKTtcbiAgICAgIGRveSAtPSBJQ0FMLlRpbWUuZGF5c0luWWVhclBhc3NlZE1vbnRoW2lzX2xlYXBdWzEyXTtcbiAgICAgIHllYXIrKztcbiAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkb3ksIHllYXIpO1xuICAgIH1cblxuICAgIHR0LnllYXIgPSB5ZWFyO1xuICAgIHR0LmlzRGF0ZSA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBtb250aCA9IDExOyBtb250aCA+PSAwOyBtb250aC0tKSB7XG4gICAgICBpZiAoZG95ID4gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc19sZWFwXVttb250aF0pIHtcbiAgICAgICAgdHQubW9udGggPSBtb250aCArIDE7XG4gICAgICAgIHR0LmRheSA9IGRveSAtIElDQUwuVGltZS5kYXlzSW5ZZWFyUGFzc2VkTW9udGhbaXNfbGVhcF1bbW9udGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0dC5hdXRvX25vcm1hbGl6ZSA9IHRydWU7XG4gICAgcmV0dXJuIHR0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBzdHJpbmcsIGUuZyAyMDE1LTAxLTAyLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCAgICAgICAgICAgICAgICBVc2Uge0BsaW5rIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZ30gaW5zdGVhZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tU3RyaW5ndjIgPSBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0cikge1xuICAgIHJldHVybiBuZXcgSUNBTC5UaW1lKHtcbiAgICAgIHllYXI6IHBhcnNlSW50KHN0ci5zdWJzdHIoMCwgNCksIDEwKSxcbiAgICAgIG1vbnRoOiBwYXJzZUludChzdHIuc3Vic3RyKDUsIDIpLCAxMCksXG4gICAgICBkYXk6IHBhcnNlSW50KHN0ci5zdWJzdHIoOCwgMiksIDEwKSxcbiAgICAgIGlzRGF0ZTogdHJ1ZVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBzdHJpbmcsIGUuZyAyMDE1LTAxLTAyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZyA9IGZ1bmN0aW9uKGFWYWx1ZSkge1xuICAgIC8vIERhdGVzIHNob3VsZCBoYXZlIG5vIHRpbWV6b25lLlxuICAgIC8vIEdvb2dsZSBsaWtlcyB0byBzb21ldGltZXMgc3BlY2lmeSBaIG9uIGRhdGVzXG4gICAgLy8gd2Ugc3BlY2lmaWNhbGx5IGlnbm9yZSB0aGF0IHRvIGF2b2lkIGlzc3Vlcy5cblxuICAgIC8vIFlZWVktTU0tRERcbiAgICAvLyAyMDEyLTEwLTEwXG4gICAgcmV0dXJuIG5ldyBJQ0FMLlRpbWUoe1xuICAgICAgeWVhcjogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoMCwgNCkpLFxuICAgICAgbW9udGg6IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChhVmFsdWUuc3Vic3RyKDUsIDIpKSxcbiAgICAgIGRheTogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoOCwgMikpLFxuICAgICAgaXNEYXRlOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gYSBkYXRlLXRpbWUgc3RyaW5nLCBlLmdcbiAgICogMjAxNS0wMS0wMlQwMzowNDowNS4gSWYgYSBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQsIHRoZSB0aW1lem9uZSBpcyBzZXQgdXBcbiAgICogZnJvbSB0aGUgcHJvcGVydHkncyBUWklEIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFWYWx1ZSAgICAgICAgIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGZyb21cbiAgICogQHBhcmFtIHtJQ0FMLlByb3BlcnR5PX0gcHJvcCAgIFRoZSBwcm9wZXJ0eSB0aGUgZGF0ZSBiZWxvbmdzIHRvXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX0gICAgICAgICAgICBUaGUgZGF0ZS90aW1lIGluc3RhbmNlXG4gICAqL1xuICBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nID0gZnVuY3Rpb24oYVZhbHVlLCBwcm9wKSB7XG4gICAgaWYgKGFWYWx1ZS5sZW5ndGggPCAxOSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnaW52YWxpZCBkYXRlLXRpbWUgdmFsdWU6IFwiJyArIGFWYWx1ZSArICdcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHpvbmU7XG5cbiAgICBpZiAoYVZhbHVlWzE5XSAmJiBhVmFsdWVbMTldID09PSAnWicpIHtcbiAgICAgIHpvbmUgPSAnWic7XG4gICAgfSBlbHNlIGlmIChwcm9wKSB7XG4gICAgICB6b25lID0gcHJvcC5nZXRQYXJhbWV0ZXIoJ3R6aWQnKTtcbiAgICB9XG5cbiAgICAvLyAyMDEyLTEwLTEwVDEwOjEwOjEwKFopP1xuICAgIHZhciB0aW1lID0gbmV3IElDQUwuVGltZSh7XG4gICAgICB5ZWFyOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigwLCA0KSksXG4gICAgICBtb250aDogSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50KGFWYWx1ZS5zdWJzdHIoNSwgMikpLFxuICAgICAgZGF5OiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cig4LCAyKSksXG4gICAgICBob3VyOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigxMSwgMikpLFxuICAgICAgbWludXRlOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigxNCwgMikpLFxuICAgICAgc2Vjb25kOiBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQoYVZhbHVlLnN1YnN0cigxNywgMikpLFxuICAgICAgdGltZXpvbmU6IHpvbmVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIGEgZGF0ZSBvciBkYXRlLXRpbWUgc3RyaW5nLFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICAgICAgVGhlIHN0cmluZyB0byBjcmVhdGUgZnJvbVxuICAgKiBAcGFyYW0ge0lDQUwuUHJvcGVydHk9fSBwcm9wICAgVGhlIHByb3BlcnR5IHRoZSBkYXRlIGJlbG9uZ3MgdG9cbiAgICogQHJldHVybiB7SUNBTC5UaW1lfSAgICAgICAgICAgIFRoZSBkYXRlL3RpbWUgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gZnJvbVN0cmluZyhhVmFsdWUsIGFQcm9wZXJ0eSkge1xuICAgIGlmIChhVmFsdWUubGVuZ3RoID4gMTApIHtcbiAgICAgIHJldHVybiBJQ0FMLlRpbWUuZnJvbURhdGVUaW1lU3RyaW5nKGFWYWx1ZSwgYVByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIElDQUwuVGltZS5mcm9tRGF0ZVN0cmluZyhhVmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBJQ0FMLlRpbWUgaW5zdGFuY2UgZnJvbSB0aGUgZ2l2ZW4gSmF2YXNjcmlwdCBEYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gez9EYXRlfSBhRGF0ZSAgICAgVGhlIEphdmFzY3JpcHQgRGF0ZSB0byByZWFkLCBvciBudWxsIHRvIHJlc2V0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlVVRDICBJZiB0cnVlLCB0aGUgVVRDIHZhbHVlcyBvZiB0aGUgZGF0ZSB3aWxsIGJlIHVzZWRcbiAgICovXG4gIElDQUwuVGltZS5mcm9tSlNEYXRlID0gZnVuY3Rpb24gZnJvbUpTRGF0ZShhRGF0ZSwgdXNlVVRDKSB7XG4gICAgdmFyIHR0ID0gbmV3IElDQUwuVGltZSgpO1xuICAgIHJldHVybiB0dC5mcm9tSlNEYXRlKGFEYXRlLCB1c2VVVEMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IElDQUwuVGltZSBpbnN0YW5jZSBmcm9tIHRoZSB0aGUgcGFzc2VkIGRhdGEgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYURhdGEgICAgICAgICAgICBUaW1lIGluaXRpYWxpemF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEueWVhciAgICAgIFRoZSB5ZWFyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5tb250aCAgICAgVGhlIG1vbnRoIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5kYXkgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuaG91ciAgICAgIFRoZSBob3VyIGZvciB0aGlzIGRhdGVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5taW51dGUgICAgVGhlIG1pbnV0ZSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gYURhdGEuc2Vjb25kICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBhRGF0YS5pc0RhdGUgICBJZiB0cnVlLCB0aGUgaW5zdGFuY2UgcmVwcmVzZW50cyBhIGRhdGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXMgb3Bwb3NlZCB0byBhIGRhdGUtdGltZSlcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lPX0gYVpvbmUgICAgVGltZXpvbmUgdGhpcyBwb3NpdGlvbiBvY2N1cnMgaW5cbiAgICovXG4gIElDQUwuVGltZS5mcm9tRGF0YSA9IGZ1bmN0aW9uIGZyb21EYXRhKGFEYXRhLCBhWm9uZSkge1xuICAgIHZhciB0ID0gbmV3IElDQUwuVGltZSgpO1xuICAgIHJldHVybiB0LmZyb21EYXRhKGFEYXRhLCBhWm9uZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSUNBTC5UaW1lIGluc3RhbmNlIGZyb20gdGhlIGN1cnJlbnQgbW9tZW50LlxuICAgKiBUaGUgaW5zdGFuY2UgaXMgXHUyMDFDZmxvYXRpbmdcdTIwMUQgLSBoYXMgbm8gdGltZXpvbmUgcmVsYXRpb24uXG4gICAqIFRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBjb25zaWRlcmluZyB0aGUgdGltZSB6b25lLCBjYWxsXG4gICAqIElDQUwuVGltZS5mcm9tSlNEYXRlKG5ldyBEYXRlKCksIHRydWUpXG4gICAqIEByZXR1cm4ge0lDQUwuVGltZX1cbiAgICovXG4gIElDQUwuVGltZS5ub3cgPSBmdW5jdGlvbiBpY2FsdGltZV9ub3coKSB7XG4gICAgcmV0dXJuIElDQUwuVGltZS5mcm9tSlNEYXRlKG5ldyBEYXRlKCksIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGF0ZSBvbiB3aGljaCBJU08gd2VlayBudW1iZXIgMSBzdGFydHMuXG4gICAqXG4gICAqIEBzZWUgSUNBTC5UaW1lI3dlZWtOdW1iZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFZZWFyICAgICAgICAgICAgICAgICAgVGhlIHllYXIgdG8gc2VhcmNoIGluXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0IFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIHVzZWQgZm9yIGNhbGN1bGF0aW9uLlxuICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICAgICAgICBUaGUgZGF0ZSBvbiB3aGljaCB3ZWVrIG51bWJlciAxIHN0YXJ0c1xuICAgKi9cbiAgSUNBTC5UaW1lLndlZWtPbmVTdGFydHMgPSBmdW5jdGlvbiB3ZWVrT25lU3RhcnRzKGFZZWFyLCBhV2Vla1N0YXJ0KSB7XG4gICAgdmFyIHQgPSBJQ0FMLlRpbWUuZnJvbURhdGEoe1xuICAgICAgeWVhcjogYVllYXIsXG4gICAgICBtb250aDogMSxcbiAgICAgIGRheTogMSxcbiAgICAgIGlzRGF0ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdmFyIGRvdyA9IHQuZGF5T2ZXZWVrKCk7XG4gICAgdmFyIHdrc3QgPSBhV2Vla1N0YXJ0IHx8IElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQ7XG4gICAgaWYgKGRvdyA+IElDQUwuVGltZS5USFVSU0RBWSkge1xuICAgICAgdC5kYXkgKz0gNztcbiAgICB9XG4gICAgaWYgKHdrc3QgPiBJQ0FMLlRpbWUuVEhVUlNEQVkpIHtcbiAgICAgIHQuZGF5IC09IDc7XG4gICAgfVxuXG4gICAgdC5kYXkgLT0gZG93IC0gd2tzdDtcblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGRvbWluaWNhbCBsZXR0ZXIgZm9yIHRoZSBnaXZlbiB5ZWFyLiBMZXR0ZXJzIHJhbmdlIGZyb20gQSAtIEcgZm9yXG4gICAqIGNvbW1vbiB5ZWFycywgYW5kIEFHIHRvIEdGIGZvciBsZWFwIHllYXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0geXIgICAgICAgICAgIFRoZSB5ZWFyIHRvIHJldHJpZXZlIHRoZSBsZXR0ZXIgZm9yXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgICAgVGhlIGRvbWluaWNhbCBsZXR0ZXIuXG4gICAqL1xuICBJQ0FMLlRpbWUuZ2V0RG9taW5pY2FsTGV0dGVyID0gZnVuY3Rpb24oeXIpIHtcbiAgICB2YXIgTFRSUyA9IFwiR0ZFRENCQVwiO1xuICAgIHZhciBkb20gPSAoeXIgKyAoeXIgLyA0IHwgMCkgKyAoeXIgLyA0MDAgfCAwKSAtICh5ciAvIDEwMCB8IDApIC0gMSkgJSA3O1xuICAgIHZhciBpc0xlYXAgPSBJQ0FMLlRpbWUuaXNMZWFwWWVhcih5cik7XG4gICAgaWYgKGlzTGVhcCkge1xuICAgICAgcmV0dXJuIExUUlNbKGRvbSArIDYpICUgN10gKyBMVFJTW2RvbV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBMVFJTW2RvbV07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBKYW51YXJ5IDFzdCwgMTk3MCBhcyBhbiBJQ0FMLlRpbWUuXG4gICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAqIEBjb25zdGFudFxuICAgKiBAaW5zdGFuY2VcbiAgICovXG4gIElDQUwuVGltZS5lcG9jaFRpbWUgPSBJQ0FMLlRpbWUuZnJvbURhdGEoe1xuICAgIHllYXI6IDE5NzAsXG4gICAgbW9udGg6IDEsXG4gICAgZGF5OiAxLFxuICAgIGhvdXI6IDAsXG4gICAgbWludXRlOiAwLFxuICAgIHNlY29uZDogMCxcbiAgICBpc0RhdGU6IGZhbHNlLFxuICAgIHRpbWV6b25lOiBcIlpcIlxuICB9KTtcblxuICBJQ0FMLlRpbWUuX2NtcF9hdHRyID0gZnVuY3Rpb24gX2NtcF9hdHRyKGEsIGIsIGF0dHIpIHtcbiAgICBpZiAoYVthdHRyXSA+IGJbYXR0cl0pIHJldHVybiAxO1xuICAgIGlmIChhW2F0dHJdIDwgYlthdHRyXSkgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGUgZGF5cyB0aGF0IGhhdmUgcGFzc2VkIGluIHRoZSB5ZWFyIGFmdGVyIGEgZ2l2ZW4gbW9udGguIFRoZSBhcnJheSBoYXNcbiAgICogdHdvIG1lbWJlcnMsIG9uZSBiZWluZyBhbiBhcnJheSBvZiBwYXNzZWQgZGF5cyBmb3Igbm9uLWxlYXAgeWVhcnMsIHRoZVxuICAgKiBvdGhlciBhbmFsb2cgZm9yIGxlYXAgeWVhcnMuXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBpc0xlYXBZZWFyID0gSUNBTC5UaW1lLmlzTGVhcFllYXIoeWVhcik7XG4gICAqIHZhciBwYXNzZWREYXlzID0gSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aFtpc0xlYXBZZWFyXVttb250aF07XG4gICAqIEB0eXBlIHtBcnJheS48QXJyYXkuPE51bWJlcj4+fVxuICAgKi9cbiAgSUNBTC5UaW1lLmRheXNJblllYXJQYXNzZWRNb250aCA9IFtcbiAgICBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzQsIDM2NV0sXG4gICAgWzAsIDMxLCA2MCwgOTEsIDEyMSwgMTUyLCAxODIsIDIxMywgMjQ0LCAyNzQsIDMwNSwgMzM1LCAzNjZdXG4gIF07XG5cbiAgLyoqXG4gICAqIFRoZSB3ZWVrZGF5LCAxID0gU1VOREFZLCA3ID0gU0FUVVJEQVkuIEFjY2VzcyB2aWFcbiAgICogSUNBTC5UaW1lLk1PTkRBWSwgSUNBTC5UaW1lLlRVRVNEQVksIC4uLlxuICAgKlxuICAgKiBAdHlwZWRlZiB7TnVtYmVyfSB3ZWVrRGF5XG4gICAqIEBtZW1iZXJvZiBJQ0FMLlRpbWVcbiAgICovXG5cbiAgSUNBTC5UaW1lLlNVTkRBWSA9IDE7XG4gIElDQUwuVGltZS5NT05EQVkgPSAyO1xuICBJQ0FMLlRpbWUuVFVFU0RBWSA9IDM7XG4gIElDQUwuVGltZS5XRURORVNEQVkgPSA0O1xuICBJQ0FMLlRpbWUuVEhVUlNEQVkgPSA1O1xuICBJQ0FMLlRpbWUuRlJJREFZID0gNjtcbiAgSUNBTC5UaW1lLlNBVFVSREFZID0gNztcblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgd2Vla2RheSBmb3IgdGhlIFdLU1QgcGFydC5cbiAgICogQGNvbnN0YW50XG4gICAqIEBkZWZhdWx0IElDQUwuVGltZS5NT05EQVlcbiAgICovXG4gIElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQgPSBJQ0FMLlRpbWUuTU9OREFZO1xufSkoKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxNSAqL1xuXG5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBEZXNjcmliZXMgYSB2Q2FyZCB0aW1lLCB3aGljaCBoYXMgc2xpZ2h0IGRpZmZlcmVuY2VzIHRvIHRoZSBJQ0FMLlRpbWUuXG4gICAqIFByb3BlcnRpZXMgY2FuIGJlIG51bGwgaWYgbm90IHNwZWNpZmllZCwgZm9yIGV4YW1wbGUgZm9yIGRhdGVzIHdpdGhcbiAgICogcmVkdWNlZCBhY2N1cmFjeSBvciB0cnVuY2F0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgY3VycmVudGx5IG5vdCBhbGwgbWV0aG9kcyBhcmUgY29ycmVjdGx5IHJlLWltcGxlbWVudGVkIGZvclxuICAgKiBWQ2FyZFRpbWUuIEZvciBleGFtcGxlLCBjb21wYXJpc29uIHdpbGwgaGF2ZSB1bmRlZmluZWQgcmVzdWx0cyB3aGVuIHNvbWVcbiAgICogbWVtYmVycyBhcmUgbnVsbC5cbiAgICpcbiAgICogQWxzbywgbm9ybWFsaXphdGlvbiBpcyBub3QgeWV0IGltcGxlbWVudGVkIGZvciB0aGlzIGNsYXNzIVxuICAgKlxuICAgKiBAYWxpYXMgSUNBTC5WQ2FyZFRpbWVcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIHtJQ0FMLlRpbWV9XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGRhdGEgZm9yIHRoZSB0aW1lIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS55ZWFyICAgICAgICAgICAgICAgICAgICAgVGhlIHllYXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEubW9udGggICAgICAgICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5kYXkgICAgICAgICAgICAgICAgICAgICAgVGhlIGRheSBmb3IgdGhpcyBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5ob3VyICAgICAgICAgICAgICAgICAgICAgVGhlIGhvdXIgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEubWludXRlICAgICAgICAgICAgICAgICAgIFRoZSBtaW51dGUgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGRhdGEuc2Vjb25kICAgICAgICAgICAgICAgICAgIFRoZSBzZWNvbmQgZm9yIHRoaXMgZGF0ZVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZXpvbmV8SUNBTC5VdGNPZmZzZXR9IHpvbmUgICAgIFRoZSB0aW1lem9uZSB0byB1c2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IGljYWx0eXBlICAgICAgICAgICAgICAgICAgICAgICBUaGUgdHlwZSBmb3IgdGhpcyBkYXRlL3RpbWUgb2JqZWN0XG4gICAqL1xuICBJQ0FMLlZDYXJkVGltZSA9IGZ1bmN0aW9uKGRhdGEsIHpvbmUsIGljYWx0eXBlKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIHZhciB0aW1lID0gdGhpcy5fdGltZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aW1lLnllYXIgPSBudWxsO1xuICAgIHRpbWUubW9udGggPSBudWxsO1xuICAgIHRpbWUuZGF5ID0gbnVsbDtcbiAgICB0aW1lLmhvdXIgPSBudWxsO1xuICAgIHRpbWUubWludXRlID0gbnVsbDtcbiAgICB0aW1lLnNlY29uZCA9IG51bGw7XG5cbiAgICB0aGlzLmljYWx0eXBlID0gaWNhbHR5cGUgfHwgXCJkYXRlLWFuZC1vci10aW1lXCI7XG5cbiAgICB0aGlzLmZyb21EYXRhKGRhdGEsIHpvbmUpO1xuICB9O1xuICBJQ0FMLmhlbHBlcnMuaW5oZXJpdHMoSUNBTC5UaW1lLCBJQ0FMLlZDYXJkVGltZSwgLyoqIEBsZW5kcyBJQ0FMLlZDYXJkVGltZSAqLyB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwidmNhcmR0aW1lXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwidmNhcmR0aW1lXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiZGF0ZS1hbmQtb3ItdGltZVwiXG4gICAgICovXG4gICAgaWNhbHR5cGU6IFwiZGF0ZS1hbmQtb3ItdGltZVwiLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWV6b25lLiBUaGlzIGNhbiBlaXRoZXIgYmUgZmxvYXRpbmcsIFVUQywgb3IgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgKiBJQ0FMLlV0Y09mZnNldC5cbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lem9uZXxJQ0FMLlV0Y09GZnNldH1cbiAgICAgKi9cbiAgICB6b25lOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoZSB2Y2FyZCBkYXRlL3RpbWUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7SUNBTC5WQ2FyZFRpbWV9ICAgICBUaGUgY2xvbmVkIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgSUNBTC5WQ2FyZFRpbWUodGhpcy5fdGltZSwgdGhpcy56b25lLCB0aGlzLmljYWx0eXBlKTtcbiAgICB9LFxuXG4gICAgX25vcm1hbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICB1dGNPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuem9uZSBpbnN0YW5jZW9mIElDQUwuVXRjT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvbmUudG9TZWNvbmRzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gSUNBTC5UaW1lLnByb3RvdHlwZS51dGNPZmZzZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBSRkMgNjM1MCBjb21wbGlhbnQgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgdmNhcmQgZGF0ZS90aW1lIHN0cmluZ1xuICAgICAqL1xuICAgIHRvSUNBTFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSUNBTC5kZXNpZ24udmNhcmQudmFsdWVbdGhpcy5pY2FsdHlwZV0udG9JQ0FMKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBkYXRlL3RpbWUsIGluIGpDYXJkIGZvcm1cbiAgICAgKiAoaW5jbHVkaW5nIDogYW5kIC0gc2VwYXJhdG9ycykuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHZhciBwMiA9IElDQUwuaGVscGVycy5wYWQyO1xuICAgICAgdmFyIHkgPSB0aGlzLnllYXIsIG0gPSB0aGlzLm1vbnRoLCBkID0gdGhpcy5kYXk7XG4gICAgICB2YXIgaCA9IHRoaXMuaG91ciwgbW0gPSB0aGlzLm1pbnV0ZSwgcyA9IHRoaXMuc2Vjb25kO1xuXG4gICAgICB2YXIgaGFzWWVhciA9IHkgIT09IG51bGwsIGhhc01vbnRoID0gbSAhPT0gbnVsbCwgaGFzRGF5ID0gZCAhPT0gbnVsbDtcbiAgICAgIHZhciBoYXNIb3VyID0gaCAhPT0gbnVsbCwgaGFzTWludXRlID0gbW0gIT09IG51bGwsIGhhc1NlY29uZCA9IHMgIT09IG51bGw7XG5cbiAgICAgIHZhciBkYXRlcGFydCA9IChoYXNZZWFyID8gcDIoeSkgKyAoaGFzTW9udGggfHwgaGFzRGF5ID8gJy0nIDogJycpIDogKGhhc01vbnRoIHx8IGhhc0RheSA/ICctLScgOiAnJykpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNNb250aCA/IHAyKG0pIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNEYXkgPyAnLScgKyBwMihkKSA6ICcnKTtcbiAgICAgIHZhciB0aW1lcGFydCA9IChoYXNIb3VyID8gcDIoaCkgOiAnLScpICsgKGhhc0hvdXIgJiYgaGFzTWludXRlID8gJzonIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgIChoYXNNaW51dGUgPyBwMihtbSkgOiAnJykgKyAoIWhhc0hvdXIgJiYgIWhhc01pbnV0ZSA/ICctJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAoaGFzTWludXRlICYmIGhhc1NlY29uZCA/ICc6JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAoaGFzU2Vjb25kID8gcDIocykgOiAnJyk7XG5cbiAgICAgIHZhciB6b25lO1xuICAgICAgaWYgKHRoaXMuem9uZSA9PT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZSkge1xuICAgICAgICB6b25lID0gJ1onO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnpvbmUgaW5zdGFuY2VvZiBJQ0FMLlV0Y09mZnNldCkge1xuICAgICAgICB6b25lID0gdGhpcy56b25lLnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuem9uZSA9PT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lKSB7XG4gICAgICAgIHpvbmUgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy56b25lIGluc3RhbmNlb2YgSUNBTC5UaW1lem9uZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gSUNBTC5VdGNPZmZzZXQuZnJvbVNlY29uZHModGhpcy56b25lLnV0Y09mZnNldCh0aGlzKSk7XG4gICAgICAgIHpvbmUgPSBvZmZzZXQudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHpvbmUgPSAnJztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0aGlzLmljYWx0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgICAgcmV0dXJuIHRpbWVwYXJ0ICsgem9uZTtcbiAgICAgICAgY2FzZSBcImRhdGUtYW5kLW9yLXRpbWVcIjpcbiAgICAgICAgY2FzZSBcImRhdGUtdGltZVwiOlxuICAgICAgICAgIHJldHVybiBkYXRlcGFydCArICh0aW1lcGFydCA9PSAnLS0nID8gJycgOiAnVCcgKyB0aW1lcGFydCArIHpvbmUpO1xuICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgIHJldHVybiBkYXRlcGFydDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgSUNBTC5WQ2FyZFRpbWUgaW5zdGFuY2UgZnJvbSBhIGRhdGUgYW5kL29yIHRpbWUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYVZhbHVlICAgICBUaGUgc3RyaW5nIHRvIGNyZWF0ZSBmcm9tXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhSWNhbFR5cGUgIFRoZSB0eXBlIGZvciB0aGlzIGluc3RhbmNlLCBlLmcuIGRhdGUtYW5kLW9yLXRpbWVcbiAgICogQHJldHVybiB7SUNBTC5WQ2FyZFRpbWV9ICAgVGhlIGRhdGUvdGltZSBpbnN0YW5jZVxuICAgKi9cbiAgSUNBTC5WQ2FyZFRpbWUuZnJvbURhdGVBbmRPclRpbWVTdHJpbmcgPSBmdW5jdGlvbihhVmFsdWUsIGFJY2FsVHlwZSkge1xuICAgIGZ1bmN0aW9uIHBhcnQodiwgcywgZSkge1xuICAgICAgcmV0dXJuIHYgPyBJQ0FMLmhlbHBlcnMuc3RyaWN0UGFyc2VJbnQodi5zdWJzdHIocywgZSkpIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIHBhcnRzID0gYVZhbHVlLnNwbGl0KCdUJyk7XG4gICAgdmFyIGR0ID0gcGFydHNbMF0sIHRteiA9IHBhcnRzWzFdO1xuICAgIHZhciBzcGxpdHpvbmUgPSB0bXogPyBJQ0FMLmRlc2lnbi52Y2FyZC52YWx1ZS50aW1lLl9zcGxpdFpvbmUodG16KSA6IFtdO1xuICAgIHZhciB6b25lID0gc3BsaXR6b25lWzBdLCB0bSA9IHNwbGl0em9uZVsxXTtcblxuICAgIHZhciBzdG9pID0gSUNBTC5oZWxwZXJzLnN0cmljdFBhcnNlSW50O1xuICAgIHZhciBkdGxlbiA9IGR0ID8gZHQubGVuZ3RoIDogMDtcbiAgICB2YXIgdG1sZW4gPSB0bSA/IHRtLmxlbmd0aCA6IDA7XG5cbiAgICB2YXIgaGFzRGFzaERhdGUgPSBkdCAmJiBkdFswXSA9PSAnLScgJiYgZHRbMV0gPT0gJy0nO1xuICAgIHZhciBoYXNEYXNoVGltZSA9IHRtICYmIHRtWzBdID09ICctJztcblxuICAgIHZhciBvID0ge1xuICAgICAgeWVhcjogaGFzRGFzaERhdGUgPyBudWxsIDogcGFydChkdCwgMCwgNCksXG4gICAgICBtb250aDogaGFzRGFzaERhdGUgJiYgKGR0bGVuID09IDQgfHwgZHRsZW4gPT0gNykgPyBwYXJ0KGR0LCAyLCAyKSA6IGR0bGVuID09IDcgPyBwYXJ0KGR0LCA1LCAyKSA6IGR0bGVuID09IDEwID8gcGFydChkdCwgNSwgMikgOiBudWxsLFxuICAgICAgZGF5OiBkdGxlbiA9PSA1ID8gcGFydChkdCwgMywgMikgOiBkdGxlbiA9PSA3ICYmIGhhc0Rhc2hEYXRlID8gcGFydChkdCwgNSwgMikgOiBkdGxlbiA9PSAxMCA/IHBhcnQoZHQsIDgsIDIpIDogbnVsbCxcblxuICAgICAgaG91cjogaGFzRGFzaFRpbWUgPyBudWxsIDogcGFydCh0bSwgMCwgMiksXG4gICAgICBtaW51dGU6IGhhc0Rhc2hUaW1lICYmIHRtbGVuID09IDMgPyBwYXJ0KHRtLCAxLCAyKSA6IHRtbGVuID4gNCA/IGhhc0Rhc2hUaW1lID8gcGFydCh0bSwgMSwgMikgOiBwYXJ0KHRtLCAzLCAyKSA6IG51bGwsXG4gICAgICBzZWNvbmQ6IHRtbGVuID09IDQgPyBwYXJ0KHRtLCAyLCAyKSA6IHRtbGVuID09IDYgPyBwYXJ0KHRtLCA0LCAyKSA6IHRtbGVuID09IDggPyBwYXJ0KHRtLCA2LCAyKSA6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHpvbmUgPT0gJ1onKSB7XG4gICAgICB6b25lID0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZTtcbiAgICB9IGVsc2UgaWYgKHpvbmUgJiYgem9uZVszXSA9PSAnOicpIHtcbiAgICAgIHpvbmUgPSBJQ0FMLlV0Y09mZnNldC5mcm9tU3RyaW5nKHpvbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB6b25lID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IElDQUwuVkNhcmRUaW1lKG8sIHpvbmUsIGFJY2FsVHlwZSk7XG4gIH07XG59KSgpO1xuLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy5cbiAqIFBvcnRpb25zIENvcHlyaWdodCAoQykgUGhpbGlwcCBLZXdpc2NoLCAyMDExLTIwMTUgKi9cblxuXG5cbihmdW5jdGlvbigpIHtcbiAgdmFyIERPV19NQVAgPSB7XG4gICAgU1U6IElDQUwuVGltZS5TVU5EQVksXG4gICAgTU86IElDQUwuVGltZS5NT05EQVksXG4gICAgVFU6IElDQUwuVGltZS5UVUVTREFZLFxuICAgIFdFOiBJQ0FMLlRpbWUuV0VETkVTREFZLFxuICAgIFRIOiBJQ0FMLlRpbWUuVEhVUlNEQVksXG4gICAgRlI6IElDQUwuVGltZS5GUklEQVksXG4gICAgU0E6IElDQUwuVGltZS5TQVRVUkRBWVxuICB9O1xuXG4gIHZhciBSRVZFUlNFX0RPV19NQVAgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIERPV19NQVApIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChET1dfTUFQLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIFJFVkVSU0VfRE9XX01BUFtET1dfTUFQW2tleV1dID0ga2V5O1xuICAgIH1cbiAgfVxuXG4gIHZhciBDT1BZX1BBUlRTID0gW1wiQllTRUNPTkRcIiwgXCJCWU1JTlVURVwiLCBcIkJZSE9VUlwiLCBcIkJZREFZXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQllNT05USERBWVwiLCBcIkJZWUVBUkRBWVwiLCBcIkJZV0VFS05PXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiQllNT05USFwiLCBcIkJZU0VUUE9TXCJdO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoaXMgY2xhc3MgcmVwcmVzZW50cyB0aGUgXCJyZWN1clwiIHZhbHVlIHR5cGUsIHdpdGggdmFyaW91cyBjYWxjdWxhdGlvblxuICAgKiBhbmQgbWFuaXB1bGF0aW9uIG1ldGhvZHMuXG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAYWxpYXMgSUNBTC5SZWN1clxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBtZW1iZXJzIG9mIHRoZSByZWN1cnJlbmNlXG4gICAqIEBwYXJhbSB7SUNBTC5SZWN1ci5mcmVxdWVuY3lWYWx1ZXM9fSBkYXRhLmZyZXEgICAgIFRoZSBmcmVxdWVuY3kgdmFsdWVcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICAgVGhlIElOVEVSVkFMIHZhbHVlXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBkYXRhLndrc3QgICAgICAgICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHZhbHVlXG4gICAqIEBwYXJhbSB7SUNBTC5UaW1lPX0gZGF0YS51bnRpbCAgICAgICAgICAgICAgICAgICAgIFRoZSBlbmQgb2YgdGhlIHJlY3VycmVuY2Ugc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZWNvbmQgICAgICAgICAgICAgVGhlIHNlY29uZHMgZm9yIHRoZSBCWVNFQ09ORCBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bWludXRlICAgICAgICAgICAgIFRoZSBtaW51dGVzIGZvciB0aGUgQllNSU5VVEUgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieWhvdXIgICAgICAgICAgICAgICBUaGUgaG91cnMgZm9yIHRoZSBCWUhPVVIgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+PX0gZGF0YS5ieWRheSAgICAgICAgICAgICAgICBUaGUgQllEQVkgdmFsdWVzXG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5bW9udGhkYXkgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllNT05USERBWSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5eWVhcmRheSAgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllZRUFSREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnl3ZWVrbm8gICAgICAgICAgICAgVGhlIHdlZWtzIGZvciB0aGUgQllXRUVLTk8gcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1vbnRoICAgICAgICAgICAgICBUaGUgbW9udGggZm9yIHRoZSBCWU1PTlRIIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZXRwb3MgICAgICAgICAgICAgVGhlIHBvc2l0aW9uYWxzIGZvciB0aGUgQllTRVRQT1MgcGFydFxuICAgKi9cbiAgSUNBTC5SZWN1ciA9IGZ1bmN0aW9uIGljYWxyZWN1cihkYXRhKSB7XG4gICAgdGhpcy53cmFwcGVkSlNPYmplY3QgPSB0aGlzO1xuICAgIHRoaXMucGFydHMgPSB7fTtcblxuICAgIGlmIChkYXRhICYmIHR5cGVvZihkYXRhKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuZnJvbURhdGEoZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIElDQUwuUmVjdXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBob2xkaW5nIHRoZSBCWS1wYXJ0cyBvZiB0aGUgcmVjdXJyZW5jZSBydWxlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBwYXJ0czogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcnZhbCB2YWx1ZSBmb3IgdGhlIHJlY3VycmVuY2UgcnVsZS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGludGVydmFsOiAxLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHdlZWsgc3RhcnQgZGF5XG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lLndlZWtEYXl9XG4gICAgICogQGRlZmF1bHQgSUNBTC5UaW1lLk1PTkRBWVxuICAgICAqL1xuICAgIHdrc3Q6IElDQUwuVGltZS5NT05EQVksXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZW5kIG9mIHRoZSByZWN1cnJlbmNlXG4gICAgICogQHR5cGUgez9JQ0FMLlRpbWV9XG4gICAgICovXG4gICAgdW50aWw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICAgKiBAdHlwZSB7P051bWJlcn1cbiAgICAgKi9cbiAgICBjb3VudDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmVxdWVuY3kgdmFsdWUuXG4gICAgICogQHR5cGUge0lDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzfVxuICAgICAqL1xuICAgIGZyZXE6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgaWRlbnRpZmllci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwiaWNhbHJlY3VyXCJcbiAgICAgKi9cbiAgICBpY2FsY2xhc3M6IFwiaWNhbHJlY3VyXCIsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBuYW1lLCB0byBiZSB1c2VkIGluIHRoZSBqQ2FsIG9iamVjdC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0IFwicmVjdXJcIlxuICAgICAqL1xuICAgIGljYWx0eXBlOiBcInJlY3VyXCIsXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaXRlcmF0b3IgZm9yIHRoaXMgcmVjdXJyZW5jZSBydWxlLiBUaGUgcGFzc2VkIHN0YXJ0IGRhdGVcbiAgICAgKiBtdXN0IGJlIHRoZSBzdGFydCBkYXRlIG9mIHRoZSBldmVudCwgbm90IHRoZSBzdGFydCBvZiB0aGUgcmFuZ2UgdG9cbiAgICAgKiBzZWFyY2ggaW4uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciByZWN1ciA9IGNvbXAuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKCdycnVsZScpO1xuICAgICAqIHZhciBkdHN0YXJ0ID0gY29tcC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ2R0c3RhcnQnKTtcbiAgICAgKiB2YXIgaXRlciA9IHJlY3VyLml0ZXJhdG9yKGR0c3RhcnQpO1xuICAgICAqIGZvciAodmFyIG5leHQgPSBpdGVyLm5leHQoKTsgbmV4dDsgbmV4dCA9IGl0ZXIubmV4dCgpKSB7XG4gICAgICogICBpZiAobmV4dC5jb21wYXJlKHJhbmdlU3RhcnQpIDwgMCkge1xuICAgICAqICAgICBjb250aW51ZTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIGNvbnNvbGUubG9nKG5leHQudG9TdHJpbmcoKSk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFTdGFydCAgICAgICAgVGhlIGl0ZW0ncyBzdGFydCBkYXRlXG4gICAgICogQHJldHVybiB7SUNBTC5SZWN1ckl0ZXJhdG9yfSAgICAgVGhlIHJlY3VycmVuY2UgaXRlcmF0b3JcbiAgICAgKi9cbiAgICBpdGVyYXRvcjogZnVuY3Rpb24oYVN0YXJ0KSB7XG4gICAgICByZXR1cm4gbmV3IElDQUwuUmVjdXJJdGVyYXRvcih7XG4gICAgICAgIHJ1bGU6IHRoaXMsXG4gICAgICAgIGR0c3RhcnQ6IGFTdGFydFxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgcmVjdXJyZW5jZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyfSAgICAgIFRoZSBjbG9uZWQgb2JqZWN0XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyBJQ0FMLlJlY3VyKHRoaXMudG9KU09OKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgcnVsZSBpcyBmaW5pdGUsIGkuZS4gaGFzIGEgY291bnQgb3IgdW50aWwgcGFydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiB0aGUgcnVsZSBpcyBmaW5pdGVcbiAgICAgKi9cbiAgICBpc0Zpbml0ZTogZnVuY3Rpb24gaXNmaW5pdGUoKSB7XG4gICAgICByZXR1cm4gISEodGhpcy5jb3VudCB8fCB0aGlzLnVudGlsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHJ1bGUgaGFzIGEgY291bnQgcGFydCwgYW5kIG5vdCBsaW1pdGVkIGJ5IGFuIHVudGlsXG4gICAgICogcGFydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiB0aGUgcnVsZSBpcyBieSBjb3VudFxuICAgICAqL1xuICAgIGlzQnlDb3VudDogZnVuY3Rpb24gaXNieWNvdW50KCkge1xuICAgICAgcmV0dXJuICEhKHRoaXMuY291bnQgJiYgIXRoaXMudW50aWwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29tcG9uZW50IChwYXJ0KSB0byB0aGUgcmVjdXJyZW5jZSBydWxlLiBUaGlzIGlzIG5vdCBhIGNvbXBvbmVudFxuICAgICAqIGluIHRoZSBzZW5zZSBvZiB7QGxpbmsgSUNBTC5Db21wb25lbnR9LCBidXQgYSBwYXJ0IG9mIHRoZSByZWN1cnJlbmNlXG4gICAgICogcnVsZSwgaS5lLiBCWU1PTlRILlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFUeXBlICAgICAgICAgICAgVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudCBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGFWYWx1ZSAgICAgVGhlIGNvbXBvbmVudCB2YWx1ZVxuICAgICAqL1xuICAgIGFkZENvbXBvbmVudDogZnVuY3Rpb24gYWRkUGFydChhVHlwZSwgYVZhbHVlKSB7XG4gICAgICB2YXIgdWNuYW1lID0gYVR5cGUudG9VcHBlckNhc2UoKTtcbiAgICAgIGlmICh1Y25hbWUgaW4gdGhpcy5wYXJ0cykge1xuICAgICAgICB0aGlzLnBhcnRzW3VjbmFtZV0ucHVzaChhVmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJ0c1t1Y25hbWVdID0gW2FWYWx1ZV07XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXBvbmVudCB2YWx1ZSBmb3IgdGhlIGdpdmVuIGJ5LXBhcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYVR5cGUgICAgICAgIFRoZSBjb21wb25lbnQgcGFydCBuYW1lXG4gICAgICogQHBhcmFtIHtBcnJheX0gYVZhbHVlcyAgICAgICBUaGUgY29tcG9uZW50IHZhbHVlc1xuICAgICAqL1xuICAgIHNldENvbXBvbmVudDogZnVuY3Rpb24gc2V0Q29tcG9uZW50KGFUeXBlLCBhVmFsdWVzKSB7XG4gICAgICB0aGlzLnBhcnRzW2FUeXBlLnRvVXBwZXJDYXNlKCldID0gYVZhbHVlcy5zbGljZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIChhIGNvcHkpIG9mIHRoZSByZXF1ZXN0ZWQgY29tcG9uZW50IHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFUeXBlICAgICAgICBUaGUgY29tcG9uZW50IHBhcnQgbmFtZVxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgVGhlIGNvbXBvbmVudCBwYXJ0IHZhbHVlXG4gICAgICovXG4gICAgZ2V0Q29tcG9uZW50OiBmdW5jdGlvbiBnZXRDb21wb25lbnQoYVR5cGUpIHtcbiAgICAgIHZhciB1Y25hbWUgPSBhVHlwZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgcmV0dXJuICh1Y25hbWUgaW4gdGhpcy5wYXJ0cyA/IHRoaXMucGFydHNbdWNuYW1lXS5zbGljZSgpIDogW10pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIG5leHQgb2NjdXJyZW5jZSBhZnRlciB0aGUgZ2l2ZW4gcmVjdXJyZW5jZSBpZC4gU2VlIHRoZVxuICAgICAqIGd1aWRlIG9uIHtAdHV0b3JpYWwgdGVybWlub2xvZ3l9IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBOT1RFOiBDdXJyZW50bHksIHRoaXMgbWV0aG9kIGl0ZXJhdGVzIGFsbCBvY2N1cnJlbmNlcyBmcm9tIHRoZSBzdGFydFxuICAgICAqIGRhdGUuIEl0IHNob3VsZCBub3QgYmUgY2FsbGVkIGluIGEgbG9vcCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91XG4gICAgICogd291bGQgbGlrZSB0byBnZXQgbW9yZSB0aGFuIG9uZSBvY2N1cnJlbmNlLCB5b3UgY2FuIGl0ZXJhdGUgdGhlXG4gICAgICogb2NjdXJyZW5jZXMgbWFudWFsbHksIHNlZSB0aGUgZXhhbXBsZSBvbiB0aGVcbiAgICAgKiB7QGxpbmsgSUNBTC5SZWN1ciNpdGVyYXRvciBpdGVyYXRvcn0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFTdGFydFRpbWUgICAgICAgIFRoZSBzdGFydCBvZiB0aGUgZXZlbnQgc2VyaWVzXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IGFSZWN1cnJlbmNlSWQgICAgIFRoZSBkYXRlIG9mIHRoZSBsYXN0IG9jY3VycmVuY2VcbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9ICAgICAgICAgICAgICAgICAgVGhlIG5leHQgb2NjdXJyZW5jZSBhZnRlclxuICAgICAqL1xuICAgIGdldE5leHRPY2N1cnJlbmNlOiBmdW5jdGlvbiBnZXROZXh0T2NjdXJyZW5jZShhU3RhcnRUaW1lLCBhUmVjdXJyZW5jZUlkKSB7XG4gICAgICB2YXIgaXRlciA9IHRoaXMuaXRlcmF0b3IoYVN0YXJ0VGltZSk7XG4gICAgICB2YXIgbmV4dCwgY2R0O1xuXG4gICAgICBkbyB7XG4gICAgICAgIG5leHQgPSBpdGVyLm5leHQoKTtcbiAgICAgIH0gd2hpbGUgKG5leHQgJiYgbmV4dC5jb21wYXJlKGFSZWN1cnJlbmNlSWQpIDw9IDApO1xuXG4gICAgICBpZiAobmV4dCAmJiBhUmVjdXJyZW5jZUlkLnpvbmUpIHtcbiAgICAgICAgbmV4dC56b25lID0gYVJlY3VycmVuY2VJZC56b25lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY3VycmVudCBpbnN0YW5jZSB1c2luZyBtZW1iZXJzIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBAcGFyYW0ge0lDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzPX0gZGF0YS5mcmVxICAgICBUaGUgZnJlcXVlbmN5IHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXI9fSBkYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICAgVGhlIElOVEVSVkFMIHZhbHVlXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGRhdGEud2tzdCAgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZT19IGRhdGEudW50aWwgICAgICAgICAgICAgICAgICAgICBUaGUgZW5kIG9mIHRoZSByZWN1cnJlbmNlIHNldFxuICAgICAqIEBwYXJhbSB7TnVtYmVyPX0gZGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXNlY29uZCAgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1pbnV0ZSAgICAgICAgICAgICBUaGUgbWludXRlcyBmb3IgdGhlIEJZTUlOVVRFIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieWhvdXIgICAgICAgICAgICAgICBUaGUgaG91cnMgZm9yIHRoZSBCWUhPVVIgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBkYXRhLmJ5ZGF5ICAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieW1vbnRoZGF5ICAgICAgICAgICBUaGUgZGF5cyBmb3IgdGhlIEJZTU9OVEhEQVkgcGFydFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBkYXRhLmJ5eWVhcmRheSAgICAgICAgICAgIFRoZSBkYXlzIGZvciB0aGUgQllZRUFSREFZIHBhcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gZGF0YS5ieXdlZWtubyAgICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnltb250aCAgICAgICAgICAgICAgVGhlIG1vbnRoIGZvciB0aGUgQllNT05USCBwYXJ0XG4gICAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGRhdGEuYnlzZXRwb3MgICAgICAgICAgICAgVGhlIHBvc2l0aW9uYWxzIGZvciB0aGUgQllTRVRQT1MgcGFydFxuICAgICAqL1xuICAgIGZyb21EYXRhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICB2YXIgdWNrZXkgPSBrZXkudG9VcHBlckNhc2UoKTtcblxuICAgICAgICBpZiAodWNrZXkgaW4gcGFydERlc2lnbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgIHRoaXMucGFydHNbdWNrZXldID0gZGF0YVtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnRzW3Vja2V5XSA9IFtkYXRhW2tleV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwgJiYgdHlwZW9mIHRoaXMuaW50ZXJ2YWwgIT0gXCJudW1iZXJcIikge1xuICAgICAgICBvcHRpb25EZXNpZ24uSU5URVJWQUwodGhpcy5pbnRlcnZhbCwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndrc3QgJiYgdHlwZW9mIHRoaXMud2tzdCAhPSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRoaXMud2tzdCA9IElDQUwuUmVjdXIuaWNhbERheVRvTnVtZXJpY0RheSh0aGlzLndrc3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51bnRpbCAmJiAhKHRoaXMudW50aWwgaW5zdGFuY2VvZiBJQ0FMLlRpbWUpKSB7XG4gICAgICAgIHRoaXMudW50aWwgPSBJQ0FMLlRpbWUuZnJvbVN0cmluZyh0aGlzLnVudGlsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGpDYWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyByZWN1cnJlbmNlIHR5cGUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJlcy5mcmVxID0gdGhpcy5mcmVxO1xuXG4gICAgICBpZiAodGhpcy5jb3VudCkge1xuICAgICAgICByZXMuY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbnRlcnZhbCA+IDEpIHtcbiAgICAgICAgcmVzLmludGVydmFsID0gdGhpcy5pbnRlcnZhbDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgayBpbiB0aGlzLnBhcnRzKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMucGFydHMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga3BhcnRzID0gdGhpcy5wYXJ0c1trXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa3BhcnRzKSAmJiBrcGFydHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICByZXNbay50b0xvd2VyQ2FzZSgpXSA9IGtwYXJ0c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNbay50b0xvd2VyQ2FzZSgpXSA9IElDQUwuaGVscGVycy5jbG9uZSh0aGlzLnBhcnRzW2tdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy51bnRpbCkge1xuICAgICAgICByZXMudW50aWwgPSB0aGlzLnVudGlsLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAoJ3drc3QnIGluIHRoaXMgJiYgdGhpcy53a3N0ICE9PSBJQ0FMLlRpbWUuREVGQVVMVF9XRUVLX1NUQVJUKSB7XG4gICAgICAgIHJlcy53a3N0ID0gSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHRoaXMud2tzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcmVjdXJyZW5jZSBydWxlLlxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gaWNhbHJlY3VyX3RvU3RyaW5nKCkge1xuICAgICAgLy8gVE9ETyByZXRhaW4gb3JkZXJcbiAgICAgIHZhciBzdHIgPSBcIkZSRVE9XCIgKyB0aGlzLmZyZXE7XG4gICAgICBpZiAodGhpcy5jb3VudCkge1xuICAgICAgICBzdHIgKz0gXCI7Q09VTlQ9XCIgKyB0aGlzLmNvdW50O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaW50ZXJ2YWwgPiAxKSB7XG4gICAgICAgIHN0ciArPSBcIjtJTlRFUlZBTD1cIiArIHRoaXMuaW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMucGFydHMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHRoaXMucGFydHMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICBzdHIgKz0gXCI7XCIgKyBrICsgXCI9XCIgKyB0aGlzLnBhcnRzW2tdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy51bnRpbCkge1xuICAgICAgICBzdHIgKz0gJztVTlRJTD0nICsgdGhpcy51bnRpbC50b0lDQUxTdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICgnd2tzdCcgaW4gdGhpcyAmJiB0aGlzLndrc3QgIT09IElDQUwuVGltZS5ERUZBVUxUX1dFRUtfU1RBUlQpIHtcbiAgICAgICAgc3RyICs9ICc7V0tTVD0nICsgSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHRoaXMud2tzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZU51bWVyaWNWYWx1ZSh0eXBlLCBtaW4sIG1heCwgdmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG5cbiAgICBpZiAodmFsdWVbMF0gPT09ICcrJykge1xuICAgICAgcmVzdWx0ID0gdmFsdWUuc3Vic3RyKDEpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludChyZXN1bHQpO1xuXG4gICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgbWluKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIHR5cGUgKyAnOiBpbnZhbGlkIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIG11c3QgYmUgPiAnICsgbWluXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICB0eXBlICsgJzogaW52YWxpZCB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBtdXN0IGJlIDwgJyArIG1pblxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gaWNhbCByZXByZXNlbnRhdGlvbiBvZiBhIGRheSAoU1UsIE1PLCBldGMuLilcbiAgICogaW50byBhIG51bWVyaWMgdmFsdWUgb2YgdGhhdCBkYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgICAgIFRoZSBpQ2FsZW5kYXIgZGF5IG5hbWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFXZWVrU3RhcnRcbiAgICogICAgICAgIFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXksIGRlZmF1bHRzIHRvIFNVTkRBWVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgICAgICBOdW1lcmljIHZhbHVlIG9mIGdpdmVuIGRheVxuICAgKi9cbiAgSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5ID0gZnVuY3Rpb24gdG9OdW1lcmljRGF5KHN0cmluZywgYVdlZWtTdGFydCkge1xuICAgIC8vWFhYOiB0aGlzIGlzIGhlcmUgc28gd2UgY2FuIGRlYWxcbiAgICAvLyAgICAgd2l0aCBwb3NzaWJseSBpbnZhbGlkIHN0cmluZyB2YWx1ZXMuXG4gICAgdmFyIGZpcnN0RG93ID0gYVdlZWtTdGFydCB8fCBJQ0FMLlRpbWUuU1VOREFZO1xuICAgIHJldHVybiAoKERPV19NQVBbc3RyaW5nXSAtIGZpcnN0RG93ICsgNykgJSA3KSArIDE7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBudW1lcmljIGRheSB2YWx1ZSBpbnRvIGl0cyBpY2FsIHJlcHJlc2VudGF0aW9uIChTVSwgTU8sIGV0Yy4uKVxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbnVtICAgICAgICBOdW1lcmljIHZhbHVlIG9mIGdpdmVuIGRheVxuICAgKiBAcGFyYW0ge0lDQUwuVGltZS53ZWVrRGF5PX0gYVdlZWtTdGFydFxuICAgKiAgICAgICAgVGhlIHdlZWsgc3RhcnQgd2Vla2RheSwgZGVmYXVsdHMgdG8gU1VOREFZXG4gICAqIEByZXR1cm4ge1N0cmluZ30gICAgICAgICAgIFRoZSBJQ0FMIGRheSB2YWx1ZSwgZS5nIFNVLE1PLC4uLlxuICAgKi9cbiAgSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5ID0gZnVuY3Rpb24gdG9JY2FsRGF5KG51bSwgYVdlZWtTdGFydCkge1xuICAgIC8vWFhYOiB0aGlzIGlzIGhlcmUgc28gd2UgY2FuIGRlYWwgd2l0aCBwb3NzaWJseSBpbnZhbGlkIG51bWJlciB2YWx1ZXMuXG4gICAgLy8gICAgIEFsc28sIHRoaXMgYWxsb3dzIGNvbnNpc3RlbnQgbWFwcGluZyBiZXR3ZWVuIGRheSBudW1iZXJzIGFuZCBkYXlcbiAgICAvLyAgICAgbmFtZXMgZm9yIGV4dGVybmFsIHVzZXJzLlxuICAgIHZhciBmaXJzdERvdyA9IGFXZWVrU3RhcnQgfHwgSUNBTC5UaW1lLlNVTkRBWTtcbiAgICB2YXIgZG93ID0gKG51bSArIGZpcnN0RG93IC0gSUNBTC5UaW1lLlNVTkRBWSk7XG4gICAgaWYgKGRvdyA+IDcpIHtcbiAgICAgIGRvdyAtPSA3O1xuICAgIH1cbiAgICByZXR1cm4gUkVWRVJTRV9ET1dfTUFQW2Rvd107XG4gIH07XG5cbiAgdmFyIFZBTElEX0RBWV9OQU1FUyA9IC9eKFNVfE1PfFRVfFdFfFRIfEZSfFNBKSQvO1xuICB2YXIgVkFMSURfQllEQVlfUEFSVCA9IC9eKFsrLV0pPyg1WzAtM118WzEtNF1bMC05XXxbMS05XSk/KFNVfE1PfFRVfFdFfFRIfEZSfFNBKSQvO1xuXG4gIC8qKlxuICAgKiBQb3NzaWJsZSBmcmVxdWVuY3kgdmFsdWVzIGZvciB0aGUgRlJFUSBwYXJ0XG4gICAqIChZRUFSTFksIE1PTlRITFksIFdFRUtMWSwgREFJTFksIEhPVVJMWSwgTUlOVVRFTFksIFNFQ09ORExZKVxuICAgKlxuICAgKiBAdHlwZWRlZiB7U3RyaW5nfSBmcmVxdWVuY3lWYWx1ZXNcbiAgICogQG1lbWJlcm9mIElDQUwuUmVjdXJcbiAgICovXG5cbiAgdmFyIEFMTE9XRURfRlJFUSA9IFsnU0VDT05ETFknLCAnTUlOVVRFTFknLCAnSE9VUkxZJyxcbiAgICAgICAgICAgICAgICAgICAgICAnREFJTFknLCAnV0VFS0xZJywgJ01PTlRITFknLCAnWUVBUkxZJ107XG5cbiAgdmFyIG9wdGlvbkRlc2lnbiA9IHtcbiAgICBGUkVROiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgLy8geWVzIHRoaXMgaXMgYWN0dWFsbHkgZXF1YWwgb3IgZmFzdGVyIHRoZW4gcmVnZXguXG4gICAgICAvLyB1cHNpZGUgaGVyZSBpcyB3ZSBjYW4gZW51bWVyYXRlIHRoZSB2YWxpZCB2YWx1ZXMuXG4gICAgICBpZiAoQUxMT1dFRF9GUkVRLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICBkaWN0LmZyZXEgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnaW52YWxpZCBmcmVxdWVuY3kgXCInICsgdmFsdWUgKyAnXCIgZXhwZWN0ZWQ6IFwiJyArXG4gICAgICAgICAgQUxMT1dFRF9GUkVRLmpvaW4oJywgJykgKyAnXCInXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIENPVU5UOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgZGljdC5jb3VudCA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludCh2YWx1ZSk7XG4gICAgfSxcblxuICAgIElOVEVSVkFMOiBmdW5jdGlvbih2YWx1ZSwgZGljdCwgZm10SWNhbCkge1xuICAgICAgZGljdC5pbnRlcnZhbCA9IElDQUwuaGVscGVycy5zdHJpY3RQYXJzZUludCh2YWx1ZSk7XG4gICAgICBpZiAoZGljdC5pbnRlcnZhbCA8IDEpIHtcbiAgICAgICAgLy8gMCBvciBuZWdhdGl2ZSB2YWx1ZXMgYXJlIG5vdCBhbGxvd2VkLCBzb21lIGVuZ2luZXMgc2VlbSB0byBnZW5lcmF0ZVxuICAgICAgICAvLyBpdCB0aG91Z2guIEFzc3VtZSAxIGluc3RlYWQuXG4gICAgICAgIGRpY3QuaW50ZXJ2YWwgPSAxO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBVTlRJTDogZnVuY3Rpb24odmFsdWUsIGRpY3QsIGZtdEljYWwpIHtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxMCkge1xuICAgICAgICBkaWN0LnVudGlsID0gSUNBTC5kZXNpZ24uaWNhbGVuZGFyLnZhbHVlWydkYXRlLXRpbWUnXS5mcm9tSUNBTCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWN0LnVudGlsID0gSUNBTC5kZXNpZ24uaWNhbGVuZGFyLnZhbHVlLmRhdGUuZnJvbUlDQUwodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKCFmbXRJY2FsKSB7XG4gICAgICAgIGRpY3QudW50aWwgPSBJQ0FMLlRpbWUuZnJvbVN0cmluZyhkaWN0LnVudGlsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgV0tTVDogZnVuY3Rpb24odmFsdWUsIGRpY3QsIGZtdEljYWwpIHtcbiAgICAgIGlmIChWQUxJRF9EQVlfTkFNRVMudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgZGljdC53a3N0ID0gSUNBTC5SZWN1ci5pY2FsRGF5VG9OdW1lcmljRGF5KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBXS1NUIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBwYXJ0RGVzaWduID0ge1xuICAgIEJZU0VDT05EOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWVNFQ09ORCcsIDAsIDYwKSxcbiAgICBCWU1JTlVURTogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllNSU5VVEUnLCAwLCA1OSksXG4gICAgQllIT1VSOiBwYXJzZU51bWVyaWNWYWx1ZS5iaW5kKHRoaXMsICdCWUhPVVInLCAwLCAyMyksXG4gICAgQllEQVk6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoVkFMSURfQllEQVlfUEFSVC50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgQllEQVkgdmFsdWUgXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIEJZTU9OVEhEQVk6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZTU9OVEhEQVknLCAtMzEsIDMxKSxcbiAgICBCWVlFQVJEQVk6IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZWUVBUkRBWScsIC0zNjYsIDM2NiksXG4gICAgQllXRUVLTk86IHBhcnNlTnVtZXJpY1ZhbHVlLmJpbmQodGhpcywgJ0JZV0VFS05PJywgLTUzLCA1MyksXG4gICAgQllNT05USDogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllNT05USCcsIDEsIDEyKSxcbiAgICBCWVNFVFBPUzogcGFyc2VOdW1lcmljVmFsdWUuYmluZCh0aGlzLCAnQllTRVRQT1MnLCAtMzY2LCAzNjYpXG4gIH07XG5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5SZWN1cn0gaW5zdGFuY2UgZnJvbSB0aGUgcGFzc2VkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAgICAgICAgIFRoZSBzdHJpbmcgdG8gcGFyc2VcbiAgICogQHJldHVybiB7SUNBTC5SZWN1cn0gICAgICAgICAgIFRoZSBjcmVhdGVkIHJlY3VycmVuY2UgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuUmVjdXIuZnJvbVN0cmluZyA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBkYXRhID0gSUNBTC5SZWN1ci5fc3RyaW5nVG9EYXRhKHN0cmluZywgZmFsc2UpO1xuICAgIHJldHVybiBuZXcgSUNBTC5SZWN1cihkYXRhKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgSUNBTC5SZWN1cn0gaW5zdGFuY2UgdXNpbmcgbWVtYmVycyBmcm9tIHRoZSBwYXNzZWRcbiAgICogZGF0YSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhRGF0YSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFuIG9iamVjdCB3aXRoIG1lbWJlcnMgb2YgdGhlIHJlY3VycmVuY2VcbiAgICogQHBhcmFtIHtJQ0FMLlJlY3VyLmZyZXF1ZW5jeVZhbHVlcz19IGFEYXRhLmZyZXEgICAgVGhlIGZyZXF1ZW5jeSB2YWx1ZVxuICAgKiBAcGFyYW0ge051bWJlcj19IGFEYXRhLmludGVydmFsICAgICAgICAgICAgICAgICAgICBUaGUgSU5URVJWQUwgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWUud2Vla0RheT19IGFEYXRhLndrc3QgICAgICAgICAgICAgVGhlIHdlZWsgc3RhcnQgdmFsdWVcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWU9fSBhRGF0YS51bnRpbCAgICAgICAgICAgICAgICAgICAgVGhlIGVuZCBvZiB0aGUgcmVjdXJyZW5jZSBzZXRcbiAgICogQHBhcmFtIHtOdW1iZXI9fSBhRGF0YS5jb3VudCAgICAgICAgICAgICAgICAgICAgICAgVGhlIG51bWJlciBvZiBvY2N1cnJlbmNlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnlzZWNvbmQgICAgICAgICAgICBUaGUgc2Vjb25kcyBmb3IgdGhlIEJZU0VDT05EIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5bWludXRlICAgICAgICAgICAgVGhlIG1pbnV0ZXMgZm9yIHRoZSBCWU1JTlVURSBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieWhvdXIgICAgICAgICAgICAgIFRoZSBob3VycyBmb3IgdGhlIEJZSE9VUiBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz49fSBhRGF0YS5ieWRheSAgICAgICAgICAgICAgIFRoZSBCWURBWSB2YWx1ZXNcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5bW9udGhkYXkgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWU1PTlRIREFZIHBhcnRcbiAgICogQHBhcmFtIHtBcnJheS48TnVtYmVyPj19IGFEYXRhLmJ5eWVhcmRheSAgICAgICAgICAgVGhlIGRheXMgZm9yIHRoZSBCWVlFQVJEQVkgcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnl3ZWVrbm8gICAgICAgICAgICBUaGUgd2Vla3MgZm9yIHRoZSBCWVdFRUtOTyBwYXJ0XG4gICAqIEBwYXJhbSB7QXJyYXkuPE51bWJlcj49fSBhRGF0YS5ieW1vbnRoICAgICAgICAgICAgIFRoZSBtb250aCBmb3IgdGhlIEJZTU9OVEggcGFydFxuICAgKiBAcGFyYW0ge0FycmF5LjxOdW1iZXI+PX0gYURhdGEuYnlzZXRwb3MgICAgICAgICAgICBUaGUgcG9zaXRpb25hbHMgZm9yIHRoZSBCWVNFVFBPUyBwYXJ0XG4gICAqL1xuICBJQ0FMLlJlY3VyLmZyb21EYXRhID0gZnVuY3Rpb24oYURhdGEpIHtcbiAgICByZXR1cm4gbmV3IElDQUwuUmVjdXIoYURhdGEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHJlY3VycmVuY2Ugc3RyaW5nIHRvIGEgZGF0YSBvYmplY3QsIHN1aXRhYmxlIGZvciB0aGUgZnJvbURhdGFcbiAgICogbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nICAgICBUaGUgc3RyaW5nIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm10SWNhbCAgIElmIHRydWUsIHRoZSBzdHJpbmcgaXMgY29uc2lkZXJlZCB0byBiZSBhblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlDYWxlbmRhciBzdHJpbmdcbiAgICogQHJldHVybiB7SUNBTC5SZWN1cn0gICAgICAgVGhlIHJlY3VycmVuY2UgaW5zdGFuY2VcbiAgICovXG4gIElDQUwuUmVjdXIuX3N0cmluZ1RvRGF0YSA9IGZ1bmN0aW9uKHN0cmluZywgZm10SWNhbCkge1xuICAgIHZhciBkaWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIC8vIHNwbGl0IGlzIHNsb3dlciBpbiBGRiBidXQgZmFzdCBlbm91Z2guXG4gICAgLy8gdjggaG93ZXZlciB0aGlzIGlzIGZhc3RlciB0aGVuIG1hbnVhbCBzcGxpdD9cbiAgICB2YXIgdmFsdWVzID0gc3RyaW5nLnNwbGl0KCc7Jyk7XG4gICAgdmFyIGxlbiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcGFydHMgPSB2YWx1ZXNbaV0uc3BsaXQoJz0nKTtcbiAgICAgIHZhciB1Y25hbWUgPSBwYXJ0c1swXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgdmFyIGxjbmFtZSA9IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgbmFtZSA9IChmbXRJY2FsID8gbGNuYW1lIDogdWNuYW1lKTtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcnRzWzFdO1xuXG4gICAgICBpZiAodWNuYW1lIGluIHBhcnREZXNpZ24pIHtcbiAgICAgICAgdmFyIHBhcnRBcnIgPSB2YWx1ZS5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgcGFydEFycklkeCA9IDA7XG4gICAgICAgIHZhciBwYXJ0QXJyTGVuID0gcGFydEFyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yICg7IHBhcnRBcnJJZHggPCBwYXJ0QXJyTGVuOyBwYXJ0QXJySWR4KyspIHtcbiAgICAgICAgICBwYXJ0QXJyW3BhcnRBcnJJZHhdID0gcGFydERlc2lnblt1Y25hbWVdKHBhcnRBcnJbcGFydEFycklkeF0pO1xuICAgICAgICB9XG4gICAgICAgIGRpY3RbbmFtZV0gPSAocGFydEFyci5sZW5ndGggPT0gMSA/IHBhcnRBcnJbMF0gOiBwYXJ0QXJyKTtcbiAgICAgIH0gZWxzZSBpZiAodWNuYW1lIGluIG9wdGlvbkRlc2lnbikge1xuICAgICAgICBvcHRpb25EZXNpZ25bdWNuYW1lXSh2YWx1ZSwgZGljdCwgZm10SWNhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEb24ndCBzd2FsbG93IHVua25vd24gdmFsdWVzLiBKdXN0IHNldCB0aGVtIGFzIHRoZXkgYXJlLlxuICAgICAgICBkaWN0W2xjbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGljdDtcbiAgfTtcbn0pKCk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5SZWN1ckl0ZXJhdG9yID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIEFuIGl0ZXJhdG9yIGZvciBhIHNpbmdsZSByZWN1cnJlbmNlIHJ1bGUuIFRoaXMgY2xhc3MgdXN1YWxseSBkb2Vzbid0IGhhdmVcbiAgICogdG8gYmUgaW5zdGFuY2lhdGVkIGRpcmVjdGx5LCB0aGUgY29udmVuaWVuY2UgbWV0aG9kXG4gICAqIHtAbGluayBJQ0FMLlJlY3VyI2l0ZXJhdG9yfSBjYW4gYmUgdXNlZC5cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBvcHRpb25zIG9iamVjdCBtYXkgY29udGFpbiBhZGRpdGlvbmFsIG1lbWJlcnMgd2hlbiByZXN1bWluZyBpdGVyYXRpb24gZnJvbSBhIHByZXZpb3VzIHJ1blxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIG9wdGlvbnMgb2JqZWN0IG1heSBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycyB3aGVuIHJlc3VtaW5nIGl0ZXJhdGlvblxuICAgKiBmcm9tIGEgcHJldmlvdXMgcnVuLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuUmVjdXJJdGVyYXRvclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAgICAgICAgICAgICAgICBUaGUgaXRlcmF0b3Igb3B0aW9uc1xuICAgKiBAcGFyYW0ge0lDQUwuUmVjdXJ9IG9wdGlvbnMucnVsZSAgICAgICBUaGUgcnVsZSB0byBpdGVyYXRlLlxuICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb3B0aW9ucy5kdHN0YXJ0ICAgICBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IG9wdGlvbnMuaW5pdGlhbGl6ZWQgIFdoZW4gdHJ1ZSwgYXNzdW1lIHRoYXQgb3B0aW9ucyBhcmVcbiAgICogICAgICAgIGZyb20gYSBwcmV2aW91c2x5IGNvbnN0cnVjdGVkIGl0ZXJhdG9yLiBJbml0aWFsaXphdGlvbiB3aWxsIG5vdCBiZVxuICAgKiAgICAgICAgcmVwZWF0ZWQuXG4gICAqL1xuICBmdW5jdGlvbiBpY2FscmVjdXJfaXRlcmF0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuZnJvbURhdGEob3B0aW9ucyk7XG4gIH1cblxuICBpY2FscmVjdXJfaXRlcmF0b3IucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aGVuIGl0ZXJhdGlvbiBpcyBmaW5pc2hlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjb21wbGV0ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHJ1bGUgdGhhdCBpcyBiZWluZyBpdGVyYXRlZFxuICAgICAqIEB0eXBlIHtJQ0FMLlJlY3VyfVxuICAgICAqL1xuICAgIHJ1bGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQgYmVpbmcgaXRlcmF0ZWQuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBkdHN0YXJ0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGxhc3Qgb2NjdXJyZW5jZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHRoZVxuICAgICAqIHtAbGluayBJQ0FMLlJlY3VySXRlcmF0b3IjbmV4dH0gbWV0aG9kLlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbGFzdDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXF1ZW5jZSBudW1iZXIgZnJvbSB0aGUgb2NjdXJyZW5jZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgb2NjdXJyZW5jZV9udW1iZXI6IDAsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kaWNlcyB1c2VkIGZvciB0aGUge0BsaW5rIElDQUwuUmVjdXJJdGVyYXRvciNieV9kYXRhfSBvYmplY3QuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ5X2luZGljZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgaXRlcmF0b3IgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXplZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWxpemQgYnktZGF0YS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnlfZGF0YTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFRoZSBleHBhbmRlZCB5ZWFyZGF5c1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRheXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggaW4gdGhlIHtAbGluayBJQ0FMLlJlY3VySXRlcmF0b3IjZGF5c30gYXJyYXkuXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRheXNfaW5kZXg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSByZWN1cnJlbmNlIGl0ZXJhdG9yIGZyb20gdGhlIHBhc3NlZCBkYXRhIG9iamVjdC4gVGhpc1xuICAgICAqIG1ldGhvZCBpcyB1c3VhbGx5IG5vdCBjYWxsZWQgZGlyZWN0bHksIHlvdSBjYW4gaW5pdGlhbGl6ZSB0aGUgaXRlcmF0b3JcbiAgICAgKiB0aHJvdWdoIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgIFRoZSBpdGVyYXRvciBvcHRpb25zXG4gICAgICogQHBhcmFtIHtJQ0FMLlJlY3VyfSBvcHRpb25zLnJ1bGUgICAgICAgVGhlIHJ1bGUgdG8gaXRlcmF0ZS5cbiAgICAgKiBAcGFyYW0ge0lDQUwuVGltZX0gb3B0aW9ucy5kdHN0YXJ0ICAgICBUaGUgc3RhcnQgZGF0ZSBvZiB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtCb29sZWFuPX0gb3B0aW9ucy5pbml0aWFsaXplZCAgV2hlbiB0cnVlLCBhc3N1bWUgdGhhdCBvcHRpb25zIGFyZVxuICAgICAqICAgICAgICBmcm9tIGEgcHJldmlvdXNseSBjb25zdHJ1Y3RlZCBpdGVyYXRvci4gSW5pdGlhbGl6YXRpb24gd2lsbCBub3QgYmVcbiAgICAgKiAgICAgICAgcmVwZWF0ZWQuXG4gICAgICovXG4gICAgZnJvbURhdGE6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMucnVsZSA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUob3B0aW9ucy5ydWxlLCBJQ0FMLlJlY3VyKTtcblxuICAgICAgaWYgKCF0aGlzLnJ1bGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdGVyYXRvciByZXF1aXJlcyBhIChJQ0FMLlJlY3VyKSBydWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZHRzdGFydCA9IElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUob3B0aW9ucy5kdHN0YXJ0LCBJQ0FMLlRpbWUpO1xuXG4gICAgICBpZiAoIXRoaXMuZHRzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZXJhdG9yIHJlcXVpcmVzIGEgKElDQUwuVGltZSkgZHRzdGFydCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5ieV9kYXRhKSB7XG4gICAgICAgIHRoaXMuYnlfZGF0YSA9IG9wdGlvbnMuYnlfZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYnlfZGF0YSA9IElDQUwuaGVscGVycy5jbG9uZSh0aGlzLnJ1bGUucGFydHMsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5vY2N1cnJlbmNlX251bWJlcilcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlX251bWJlciA9IG9wdGlvbnMub2NjdXJyZW5jZV9udW1iZXI7XG5cbiAgICAgIHRoaXMuZGF5cyA9IG9wdGlvbnMuZGF5cyB8fCBbXTtcbiAgICAgIGlmIChvcHRpb25zLmxhc3QpIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLmxhc3QsIElDQUwuVGltZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnlfaW5kaWNlcyA9IG9wdGlvbnMuYnlfaW5kaWNlcztcblxuICAgICAgaWYgKCF0aGlzLmJ5X2luZGljZXMpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzID0ge1xuICAgICAgICAgIFwiQllTRUNPTkRcIjogMCxcbiAgICAgICAgICBcIkJZTUlOVVRFXCI6IDAsXG4gICAgICAgICAgXCJCWUhPVVJcIjogMCxcbiAgICAgICAgICBcIkJZREFZXCI6IDAsXG4gICAgICAgICAgXCJCWU1PTlRIXCI6IDAsXG4gICAgICAgICAgXCJCWVdFRUtOT1wiOiAwLFxuICAgICAgICAgIFwiQllNT05USERBWVwiOiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBvcHRpb25zLmluaXRpYWxpemVkIHx8IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludGlhbGl6ZSB0aGUgaXRlcmF0b3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXQ6IGZ1bmN0aW9uIGljYWxyZWN1cl9pdGVyYXRvcl9pbml0KCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLmxhc3QgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgIHZhciBwYXJ0cyA9IHRoaXMuYnlfZGF0YTtcblxuICAgICAgaWYgKFwiQllEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICAvLyBsaWJpY2FsIGRvZXMgdGhpcyBlYXJsaWVyIHdoZW4gdGhlIHJ1bGUgaXMgbG9hZGVkLCBidXQgd2UgcG9zdHBvbmUgdG9cbiAgICAgICAgLy8gbm93IHNvIHdlIGNhbiBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgb3JkZXIuXG4gICAgICAgIHRoaXMuc29ydF9ieWRheV9ydWxlcyhwYXJ0cy5CWURBWSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBCWVlFQVJEQVkgYXBwYXJlcywgbm8gb3RoZXIgZGF0ZSBydWxlIHBhcnQgbWF5IGFwcGVhclxuICAgICAgaWYgKFwiQllZRUFSREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgaWYgKFwiQllNT05USFwiIGluIHBhcnRzIHx8IFwiQllXRUVLTk9cIiBpbiBwYXJ0cyB8fFxuICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgfHwgXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBCWVlFQVJEQVkgcnVsZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCWVdFRUtOTyBhbmQgQllNT05USERBWSBydWxlIHBhcnRzIG1heSBub3QgYm90aCBhcHBlYXJcbiAgICAgIGlmIChcIkJZV0VFS05PXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQllXRUVLTk8gZG9lcyBub3QgZml0IHRvIEJZTU9OVEhEQVlcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBNT05USExZIHJlY3VycmVuY2VzIChGUkVRPU1PTlRITFkpIG5laXRoZXIgQllZRUFSREFZIG5vclxuICAgICAgLy8gQllXRUVLTk8gbWF5IGFwcGVhci5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIiAmJlxuICAgICAgICAgIChcIkJZWUVBUkRBWVwiIGluIHBhcnRzIHx8IFwiQllXRUVLTk9cIiBpbiBwYXJ0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9yIE1PTlRITFkgcmVjdXJyZW5jZXMgbmVpdGhlciBCWVlFQVJEQVkgbm9yIEJZV0VFS05PIG1heSBhcHBlYXJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBXRUVLTFkgcmVjdXJyZW5jZXMgKEZSRVE9V0VFS0xZKSBuZWl0aGVyIEJZTU9OVEhEQVkgbm9yXG4gICAgICAvLyBCWVlFQVJEQVkgbWF5IGFwcGVhci5cbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSA9PSBcIldFRUtMWVwiICYmXG4gICAgICAgICAgKFwiQllZRUFSREFZXCIgaW4gcGFydHMgfHwgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvciBXRUVLTFkgcmVjdXJyZW5jZXMgbmVpdGhlciBCWU1PTlRIREFZIG5vciBCWVlFQVJEQVkgbWF5IGFwcGVhclwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gQllZRUFSREFZIG1heSBvbmx5IGFwcGVhciBpbiBZRUFSTFkgcnVsZXNcbiAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSAhPSBcIllFQVJMWVwiICYmIFwiQllZRUFSREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQllZRUFSREFZIG1heSBvbmx5IGFwcGVhciBpbiBZRUFSTFkgcnVsZXNcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdC5zZWNvbmQgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllTRUNPTkRcIiwgXCJTRUNPTkRMWVwiLCB0aGlzLmR0c3RhcnQuc2Vjb25kKTtcbiAgICAgIHRoaXMubGFzdC5taW51dGUgPSB0aGlzLnNldHVwX2RlZmF1bHRzKFwiQllNSU5VVEVcIiwgXCJNSU5VVEVMWVwiLCB0aGlzLmR0c3RhcnQubWludXRlKTtcbiAgICAgIHRoaXMubGFzdC5ob3VyID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZSE9VUlwiLCBcIkhPVVJMWVwiLCB0aGlzLmR0c3RhcnQuaG91cik7XG4gICAgICB0aGlzLmxhc3QuZGF5ID0gdGhpcy5zZXR1cF9kZWZhdWx0cyhcIkJZTU9OVEhEQVlcIiwgXCJEQUlMWVwiLCB0aGlzLmR0c3RhcnQuZGF5KTtcbiAgICAgIHRoaXMubGFzdC5tb250aCA9IHRoaXMuc2V0dXBfZGVmYXVsdHMoXCJCWU1PTlRIXCIsIFwiTU9OVEhMWVwiLCB0aGlzLmR0c3RhcnQubW9udGgpO1xuXG4gICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJXRUVLTFlcIikge1xuICAgICAgICBpZiAoXCJCWURBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgICAgdmFyIGJ5ZGF5UGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsocGFydHMuQllEQVlbMF0sIHRoaXMucnVsZS53a3N0KTtcbiAgICAgICAgICB2YXIgcG9zID0gYnlkYXlQYXJ0c1swXTtcbiAgICAgICAgICB2YXIgZG93ID0gYnlkYXlQYXJ0c1sxXTtcbiAgICAgICAgICB2YXIgd2tkeSA9IGRvdyAtIHRoaXMubGFzdC5kYXlPZldlZWsodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIGlmICgodGhpcy5sYXN0LmRheU9mV2Vlayh0aGlzLnJ1bGUud2tzdCkgPCBkb3cgJiYgd2tkeSA+PSAwKSB8fCB3a2R5IDwgMCkge1xuICAgICAgICAgICAgLy8gSW5pdGlhbCB0aW1lIGlzIGFmdGVyIGZpcnN0IGRheSBvZiBCWURBWSBkYXRhXG4gICAgICAgICAgICB0aGlzLmxhc3QuZGF5ICs9IHdrZHk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBkYXlOYW1lID0gSUNBTC5SZWN1ci5udW1lcmljRGF5VG9JY2FsRGF5KHRoaXMuZHRzdGFydC5kYXlPZldlZWsoKSk7XG4gICAgICAgICAgcGFydHMuQllEQVkgPSBbZGF5TmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucnVsZS5mcmVxID09IFwiWUVBUkxZXCIpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIHRoaXMuZXhwYW5kX3llYXJfZGF5cyh0aGlzLmxhc3QueWVhcik7XG4gICAgICAgICAgaWYgKHRoaXMuZGF5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5pbmNyZW1lbnRfeWVhcih0aGlzLnJ1bGUuaW50ZXJ2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbmV4dEJ5WWVhckRheSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJNT05USExZXCIgJiYgdGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICAgIHZhciB0ZW1wTGFzdCA9IG51bGw7XG4gICAgICAgIHZhciBpbml0TGFzdCA9IHRoaXMubGFzdC5jbG9uZSgpO1xuICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG5cbiAgICAgICAgLy8gQ2hlY2sgZXZlcnkgd2Vla2RheSBpbiBCWURBWSB3aXRoIHJlbGF0aXZlIGRvdyBhbmQgcG9zLlxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuYnlfZGF0YS5CWURBWSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sYXN0ID0gaW5pdExhc3QuY2xvbmUoKTtcbiAgICAgICAgICB2YXIgYnlkYXlQYXJ0cyA9IHRoaXMucnVsZURheU9mV2Vlayh0aGlzLmJ5X2RhdGEuQllEQVlbaV0pO1xuICAgICAgICAgIHZhciBwb3MgPSBieWRheVBhcnRzWzBdO1xuICAgICAgICAgIHZhciBkb3cgPSBieWRheVBhcnRzWzFdO1xuICAgICAgICAgIHZhciBkYXlPZk1vbnRoID0gdGhpcy5sYXN0Lm50aFdlZWtEYXkoZG93LCBwb3MpO1xuXG4gICAgICAgICAgLy8gSWYgfHBvc3wgPj0gNiwgdGhlIGJ5ZGF5IGlzIGludmFsaWQgZm9yIGEgbW9udGhseSBydWxlLlxuICAgICAgICAgIGlmIChwb3MgPj0gNiB8fCBwb3MgPD0gLTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCB2YWx1ZXMgaW4gQllEQVkgcGFydFwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiBhIEJ5ZGF5IHdpdGggcG9zPSsvLTUgaXMgbm90IGluIHRoZSBjdXJyZW50IG1vbnRoIGl0XG4gICAgICAgICAgLy8gbXVzdCBiZSBzZWFyY2hlZCBpbiB0aGUgbmV4dCBtb250aHMuXG4gICAgICAgICAgaWYgKGRheU9mTW9udGggPiBkYXlzSW5Nb250aCB8fCBkYXlPZk1vbnRoIDw9IDApIHtcbiAgICAgICAgICAgIC8vIFNraXAgaWYgd2UgaGF2ZSBhbHJlYWR5IGZvdW5kIGEgXCJsYXN0XCIgaW4gdGhpcyBtb250aC5cbiAgICAgICAgICAgIGlmICh0ZW1wTGFzdCAmJiB0ZW1wTGFzdC5tb250aCA9PSBpbml0TGFzdC5tb250aCkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChkYXlPZk1vbnRoID4gZGF5c0luTW9udGggfHwgZGF5T2ZNb250aCA8PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgICAgICAgIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICAgICAgICBkYXlPZk1vbnRoID0gdGhpcy5sYXN0Lm50aFdlZWtEYXkoZG93LCBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXlPZk1vbnRoO1xuICAgICAgICAgIGlmICghdGVtcExhc3QgfHwgdGhpcy5sYXN0LmNvbXBhcmUodGVtcExhc3QpIDwgMCkge1xuICAgICAgICAgICAgdGVtcExhc3QgPSB0aGlzLmxhc3QuY2xvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0ID0gdGVtcExhc3QuY2xvbmUoKTtcblxuICAgICAgICAvL1hYWDogVGhpcyBmZWVscyBsaWtlIGEgaGFjaywgYnV0IHdlIG5lZWQgdG8gaW5pdGlhbGl6ZVxuICAgICAgICAvLyAgICAgdGhlIEJZTU9OVEhEQVkgY2FzZSBjb3JyZWN0bHkgYW5kIGJ5RGF5QW5kTW9udGhEYXkgaGFuZGxlc1xuICAgICAgICAvLyAgICAgdGhpcyBjYXNlLiBJdCBhY2NlcHRzIGEgc3BlY2lhbCBmbGFnIHdoaWNoIHdpbGwgYXZvaWQgaW5jcmVtZW50aW5nXG4gICAgICAgIC8vICAgICB0aGUgaW5pdGlhbCB2YWx1ZSB3aXRob3V0IHRoZSBmbGFnIGRheXMgdGhhdCBtYXRjaCB0aGUgc3RhcnQgdGltZVxuICAgICAgICAvLyAgICAgd291bGQgYmUgbWlzc2VkLlxuICAgICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YSgnQllNT05USERBWScpKSB7XG4gICAgICAgICAgdGhpcy5fYnlEYXlBbmRNb250aERheSh0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxhc3QuZGF5ID4gZGF5c0luTW9udGggfHwgdGhpcy5sYXN0LmRheSA9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHZhbHVlcyBpbiBCWURBWSBwYXJ0XCIpO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhEQVlcIikpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdC5kYXkgPCAwKSB7XG4gICAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHRoaXMubGFzdC5tb250aCwgdGhpcy5sYXN0LnllYXIpO1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXlzSW5Nb250aCArIHRoaXMubGFzdC5kYXkgKyAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIG5leHQgb2NjdXJyZW5jZSBmcm9tIHRoZSBpdGVyYXRvci5cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbmV4dDogZnVuY3Rpb24gaWNhbHJlY3VyX2l0ZXJhdG9yX25leHQoKSB7XG4gICAgICB2YXIgYmVmb3JlID0gKHRoaXMubGFzdCA/IHRoaXMubGFzdC5jbG9uZSgpIDogbnVsbCk7XG5cbiAgICAgIGlmICgodGhpcy5ydWxlLmNvdW50ICYmIHRoaXMub2NjdXJyZW5jZV9udW1iZXIgPj0gdGhpcy5ydWxlLmNvdW50KSB8fFxuICAgICAgICAgICh0aGlzLnJ1bGUudW50aWwgJiYgdGhpcy5sYXN0LmNvbXBhcmUodGhpcy5ydWxlLnVudGlsKSA+IDApKSB7XG5cbiAgICAgICAgLy9YWFg6IHJpZ2h0IG5vdyB0aGlzIGlzIGp1c3QgYSBmbGFnIGFuZCBoYXMgbm8gaW1wYWN0XG4gICAgICAgIC8vICAgICB3ZSBjYW4gc2ltcGxpZnkgdGhlIGFib3ZlIGNhc2UgdG8gY2hlY2sgZm9yIGNvbXBsZXRlZCBsYXRlci5cbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vY2N1cnJlbmNlX251bWJlciA9PSAwICYmIHRoaXMubGFzdC5jb21wYXJlKHRoaXMuZHRzdGFydCkgPj0gMCkge1xuICAgICAgICAvLyBGaXJzdCBvZiBhbGwsIGdpdmUgdGhlIGluc3RhbmNlIHRoYXQgd2FzIGluaXRpYWxpemVkXG4gICAgICAgIHRoaXMub2NjdXJyZW5jZV9udW1iZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdDtcbiAgICAgIH1cblxuXG4gICAgICB2YXIgdmFsaWQ7XG4gICAgICBkbyB7XG4gICAgICAgIHZhbGlkID0gMTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMucnVsZS5mcmVxKSB7XG4gICAgICAgIGNhc2UgXCJTRUNPTkRMWVwiOlxuICAgICAgICAgIHRoaXMubmV4dF9zZWNvbmQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1JTlVURUxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X21pbnV0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiSE9VUkxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X2hvdXIoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRBSUxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X2RheSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiV0VFS0xZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X3dlZWsoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1PTlRITFlcIjpcbiAgICAgICAgICB2YWxpZCA9IHRoaXMubmV4dF9tb250aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiWUVBUkxZXCI6XG4gICAgICAgICAgdGhpcy5uZXh0X3llYXIoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICghdGhpcy5jaGVja19jb250cmFjdGluZ19ydWxlcygpIHx8XG4gICAgICAgICAgICAgICB0aGlzLmxhc3QuY29tcGFyZSh0aGlzLmR0c3RhcnQpIDwgMCB8fFxuICAgICAgICAgICAgICAgIXZhbGlkKTtcblxuICAgICAgLy8gVE9ETyBpcyB0aGlzIHZhbGlkP1xuICAgICAgaWYgKHRoaXMubGFzdC5jb21wYXJlKGJlZm9yZSkgPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTYW1lIG9jY3VycmVuY2UgZm91bmQgdHdpY2UsIHByb3RlY3RpbmcgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ5b3UgZnJvbSBkZWF0aCBieSByZWN1cnNpb25cIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJ1bGUudW50aWwgJiYgdGhpcy5sYXN0LmNvbXBhcmUodGhpcy5ydWxlLnVudGlsKSA+IDApIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub2NjdXJyZW5jZV9udW1iZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmV4dF9zZWNvbmQ6IGZ1bmN0aW9uIG5leHRfc2Vjb25kKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dF9nZW5lcmljKFwiQllTRUNPTkRcIiwgXCJTRUNPTkRMWVwiLCBcInNlY29uZFwiLCBcIm1pbnV0ZVwiKTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X3NlY29uZDogZnVuY3Rpb24gaW5jcmVtZW50X3NlY29uZChpbmMpIHtcbiAgICAgIHJldHVybiB0aGlzLmluY3JlbWVudF9nZW5lcmljKGluYywgXCJzZWNvbmRcIiwgNjAsIFwibWludXRlXCIpO1xuICAgIH0sXG5cbiAgICBuZXh0X21pbnV0ZTogZnVuY3Rpb24gbmV4dF9taW51dGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXh0X2dlbmVyaWMoXCJCWU1JTlVURVwiLCBcIk1JTlVURUxZXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW51dGVcIiwgXCJob3VyXCIsIFwibmV4dF9zZWNvbmRcIik7XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9taW51dGU6IGZ1bmN0aW9uIGluY3JlbWVudF9taW51dGUoaW5jKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIFwibWludXRlXCIsIDYwLCBcImhvdXJcIik7XG4gICAgfSxcblxuICAgIG5leHRfaG91cjogZnVuY3Rpb24gbmV4dF9ob3VyKCkge1xuICAgICAgcmV0dXJuIHRoaXMubmV4dF9nZW5lcmljKFwiQllIT1VSXCIsIFwiSE9VUkxZXCIsIFwiaG91clwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibW9udGhkYXlcIiwgXCJuZXh0X21pbnV0ZVwiKTtcbiAgICB9LFxuXG4gICAgaW5jcmVtZW50X2hvdXI6IGZ1bmN0aW9uIGluY3JlbWVudF9ob3VyKGluYykge1xuICAgICAgdGhpcy5pbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIFwiaG91clwiLCAyNCwgXCJtb250aGRheVwiKTtcbiAgICB9LFxuXG4gICAgbmV4dF9kYXk6IGZ1bmN0aW9uIG5leHRfZGF5KCkge1xuICAgICAgdmFyIGhhc19ieV9kYXkgPSAoXCJCWURBWVwiIGluIHRoaXMuYnlfZGF0YSk7XG4gICAgICB2YXIgdGhpc19mcmVxID0gKHRoaXMucnVsZS5mcmVxID09IFwiREFJTFlcIik7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzX2ZyZXEpIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGhkYXkodGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoZGF5KDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgbmV4dF93ZWVrOiBmdW5jdGlvbiBuZXh0X3dlZWsoKSB7XG4gICAgICB2YXIgZW5kX29mX2RhdGEgPSAwO1xuXG4gICAgICBpZiAodGhpcy5uZXh0X3dlZWtkYXlfYnlfd2VlaygpID09IDApIHtcbiAgICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZV0VFS05PXCIpKSB7XG4gICAgICAgIHZhciBpZHggPSArK3RoaXMuYnlfaW5kaWNlcy5CWVdFRUtOTztcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzLkJZV0VFS05PID09IHRoaXMuYnlfZGF0YS5CWVdFRUtOTy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllXRUVLTk8gPSAwO1xuICAgICAgICAgIGVuZF9vZl9kYXRhID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhBQ0sgc2hvdWxkIGJlIGZpcnN0IG1vbnRoIG9mIHRoZSB5ZWFyXG4gICAgICAgIHRoaXMubGFzdC5tb250aCA9IDE7XG4gICAgICAgIHRoaXMubGFzdC5kYXkgPSAxO1xuXG4gICAgICAgIHZhciB3ZWVrX25vID0gdGhpcy5ieV9kYXRhLkJZV0VFS05PW3RoaXMuYnlfaW5kaWNlcy5CWVdFRUtOT107XG5cbiAgICAgICAgdGhpcy5sYXN0LmRheSArPSA3ICogd2Vla19ubztcblxuICAgICAgICBpZiAoZW5kX29mX2RhdGEpIHtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBKdW1wIHRvIHRoZSBuZXh0IHdlZWtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRfbW9udGhkYXkoNyAqIHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIGVhY2ggYnkgZGF5IHJ1bGUgZm9yIGEgZ2l2ZW4geWVhci9tb250aC5cbiAgICAgKiBUYWtlcyBpbnRvIGFjY291bnQgb3JkZXJpbmcgYW5kIG5lZ2F0aXZlIHJ1bGVzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5ZWFyICAgICAgICAgQ3VycmVudCB5ZWFyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtb250aCAgICAgICAgQ3VycmVudCBtb250aC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgcnVsZXMgICAgICAgIEFycmF5IG9mIHJ1bGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IHNvcnRlZCBhbmQgbm9ybWFsaXplZCBydWxlcy5cbiAgICAgKiAgICAgICAgICAgICAgICAgTmVnYXRpdmUgcnVsZXMgd2lsbCBiZSBleHBhbmRlZCB0byB0aGVpclxuICAgICAqICAgICAgICAgICAgICAgICBjb3JyZWN0IHBvc2l0aXZlIHZhbHVlcyBmb3IgZWFzaWVyIHByb2Nlc3NpbmcuXG4gICAgICovXG4gICAgbm9ybWFsaXplQnlNb250aERheVJ1bGVzOiBmdW5jdGlvbih5ZWFyLCBtb250aCwgcnVsZXMpIHtcbiAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aChtb250aCwgeWVhcik7XG5cbiAgICAgIC8vIFhYWDogVGhpcyBpcyBwcm9iYWJseSBiYWQgZm9yIHBlcmZvcm1hbmNlIHRvIGFsbG9jYXRlXG4gICAgICAvLyAgICAgIGEgbmV3IGFycmF5IGZvciBlYWNoIG1vbnRoIHdlIHNjYW4sIGlmIHBvc3NpYmxlXG4gICAgICAvLyAgICAgIHdlIHNob3VsZCB0cnkgdG8gb3B0aW1pemUgdGhpcy4uLlxuICAgICAgdmFyIG5ld1J1bGVzID0gW107XG5cbiAgICAgIHZhciBydWxlSWR4ID0gMDtcbiAgICAgIHZhciBsZW4gPSBydWxlcy5sZW5ndGg7XG4gICAgICB2YXIgcnVsZTtcblxuICAgICAgZm9yICg7IHJ1bGVJZHggPCBsZW47IHJ1bGVJZHgrKykge1xuICAgICAgICBydWxlID0gcnVsZXNbcnVsZUlkeF07XG5cbiAgICAgICAgLy8gaWYgdGhpcyBydWxlIGZhbGxzIG91dHNpZGUgb2YgZ2l2ZW5cbiAgICAgICAgLy8gbW9udGggZGlzY2FyZCBpdC5cbiAgICAgICAgaWYgKE1hdGguYWJzKHJ1bGUpID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5lZ2F0aXZlIGNhc2VcbiAgICAgICAgaWYgKHJ1bGUgPCAwKSB7XG4gICAgICAgICAgLy8gd2UgYWRkIChub3Qgc3VidHJhY3QgaXQgaXMgYSBuZWdhdGl2ZSBudW1iZXIpXG4gICAgICAgICAgLy8gb25lIGZyb20gdGhlIHJ1bGUgYmVjYXVzZSAxID09PSBsYXN0IGRheSBvZiBtb250aFxuICAgICAgICAgIHJ1bGUgPSBkYXlzSW5Nb250aCArIChydWxlICsgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAocnVsZSA9PT0gMCkge1xuICAgICAgICAgIC8vIHNraXAgemVybzogaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG9ubHkgYWRkIHVuaXF1ZSBpdGVtcy4uLlxuICAgICAgICBpZiAobmV3UnVsZXMuaW5kZXhPZihydWxlKSA9PT0gLTEpIHtcbiAgICAgICAgICBuZXdSdWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gdW5pcXVlIGFuZCBzb3J0XG4gICAgICByZXR1cm4gbmV3UnVsZXMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5PVEVTOlxuICAgICAqIFdlIGFyZSBnaXZlbiBhIGxpc3Qgb2YgZGF0ZXMgaW4gdGhlIG1vbnRoIChCWU1PTlRIREFZKSAoMjMsIGV0Yy4uKVxuICAgICAqIEFsc28gd2UgYXJlIGdpdmVuIGEgbGlzdCBvZiBkYXlzIChCWURBWSkgKE1PLCAyU1UsIGV0Yy4uKSB3aGVuXG4gICAgICogYm90aCBjb25kaXRpb25zIG1hdGNoIGEgZ2l2ZW4gZGF0ZSAodGhpcy5sYXN0LmRheSkgaXRlcmF0aW9uIHN0b3BzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW49fSBpc0luaXQgICAgIFdoZW4gZ2l2ZW4gdHJ1ZSB3aWxsIG5vdCBpbmNyZW1lbnQgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgZGF5ICh0aGlzLmxhc3QpLlxuICAgICAqL1xuICAgIF9ieURheUFuZE1vbnRoRGF5OiBmdW5jdGlvbihpc0luaXQpIHtcbiAgICAgIHZhciBieU1vbnRoRGF5OyAvLyBzZXR1cCBpbiBpbml0TW9udGhcbiAgICAgIHZhciBieURheSA9IHRoaXMuYnlfZGF0YS5CWURBWTtcblxuICAgICAgdmFyIGRhdGU7XG4gICAgICB2YXIgZGF0ZUlkeCA9IDA7XG4gICAgICB2YXIgZGF0ZUxlbjsgLy8gc2V0dXAgaW4gaW5pdE1vbnRoXG4gICAgICB2YXIgZGF5TGVuID0gYnlEYXkubGVuZ3RoO1xuXG4gICAgICAvLyB3ZSBhcmUgbm90IHZhbGlkIGJ5IGRlZmF1bHRcbiAgICAgIHZhciBkYXRhSXNWYWxpZCA9IDA7XG5cbiAgICAgIHZhciBkYXlzSW5Nb250aDtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIC8vIHdlIG5lZWQgYSBjb3B5IG9mIHRoaXMsIGJlY2F1c2UgYSBEYXRlVGltZSBnZXRzIG5vcm1hbGl6ZWRcbiAgICAgIC8vIGF1dG9tYXRpY2FsbHkgaWYgdGhlIGRheSBpcyBvdXQgb2YgcmFuZ2UuIEF0IHNvbWUgcG9pbnRzIHdlXG4gICAgICAvLyBzZXQgdGhlIGxhc3QgZGF5IHRvIDAgdG8gc3RhcnQgY291bnRpbmcuXG4gICAgICB2YXIgbGFzdERheSA9IHRoaXMubGFzdC5kYXk7XG5cbiAgICAgIGZ1bmN0aW9uIGluaXRNb250aCgpIHtcbiAgICAgICAgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgoXG4gICAgICAgICAgc2VsZi5sYXN0Lm1vbnRoLCBzZWxmLmxhc3QueWVhclxuICAgICAgICApO1xuXG4gICAgICAgIGJ5TW9udGhEYXkgPSBzZWxmLm5vcm1hbGl6ZUJ5TW9udGhEYXlSdWxlcyhcbiAgICAgICAgICBzZWxmLmxhc3QueWVhcixcbiAgICAgICAgICBzZWxmLmxhc3QubW9udGgsXG4gICAgICAgICAgc2VsZi5ieV9kYXRhLkJZTU9OVEhEQVlcbiAgICAgICAgKTtcblxuICAgICAgICBkYXRlTGVuID0gYnlNb250aERheS5sZW5ndGg7XG5cbiAgICAgICAgLy8gRm9yIHRoZSBjYXNlIG9mIG1vcmUgdGhhbiBvbmUgb2NjdXJyZW5jZSBpbiBvbmUgbW9udGhcbiAgICAgICAgLy8gd2UgaGF2ZSB0byBiZSBzdXJlIHRvIHN0YXJ0IHNlYXJjaGluZyBhZnRlciB0aGUgbGFzdFxuICAgICAgICAvLyBmb3VuZCBkYXRlIG9yIGF0IHRoZSBsYXN0IEJZTU9OVEhEQVksIHVubGVzcyB3ZSBhcmVcbiAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHRoZSBpdGVyYXRvciBiZWNhdXNlIGluIHRoaXMgY2FzZSB3ZSBoYXZlXG4gICAgICAgIC8vIHRvIGNvbnNpZGVyIHRoZSBsYXN0IGZvdW5kIGRhdGUgdG9vLlxuICAgICAgICB3aGlsZSAoYnlNb250aERheVtkYXRlSWR4XSA8PSBsYXN0RGF5ICYmXG4gICAgICAgICAgICAgICAhKGlzSW5pdCAmJiBieU1vbnRoRGF5W2RhdGVJZHhdID09IGxhc3REYXkpICYmXG4gICAgICAgICAgICAgICBkYXRlSWR4IDwgZGF0ZUxlbiAtIDEpIHtcbiAgICAgICAgICBkYXRlSWR4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbmV4dE1vbnRoKCkge1xuICAgICAgICAvLyBzaW5jZSB0aGUgZGF5IGlzIGluY3JlbWVudGVkIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyBvZiB0aGUgbG9vcCBiZWxvdywgd2UgbmVlZCB0byBzdGFydCBhdCAwXG4gICAgICAgIGxhc3REYXkgPSAwO1xuICAgICAgICBzZWxmLmluY3JlbWVudF9tb250aCgpO1xuICAgICAgICBkYXRlSWR4ID0gMDtcbiAgICAgICAgaW5pdE1vbnRoKCk7XG4gICAgICB9XG5cbiAgICAgIGluaXRNb250aCgpO1xuXG4gICAgICAvLyBzaG91bGQgY29tZSBhZnRlciBpbml0TW9udGhcbiAgICAgIGlmIChpc0luaXQpIHtcbiAgICAgICAgbGFzdERheSAtPSAxO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2UgYSBjb3VudGVyIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3Agd2l0aCBtYWxmb3JtZWQgcnVsZXMuXG4gICAgICAvLyBTdG9wIGNoZWNraW5nIGFmdGVyIDQgeWVhcnMgc28gd2UgY29uc2lkZXIgYWxzbyBhIGxlYXAgeWVhci5cbiAgICAgIHZhciBtb250aHNDb3VudGVyID0gNDg7XG5cbiAgICAgIHdoaWxlICghZGF0YUlzVmFsaWQgJiYgbW9udGhzQ291bnRlcikge1xuICAgICAgICBtb250aHNDb3VudGVyLS07XG4gICAgICAgIC8vIGluY3JlbWVudCB0aGUgY3VycmVudCBkYXRlLiBUaGlzIGlzIHJlYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgb3RoZXJ3aXNlIHdlIG1heSBmYWxsIGludG8gdGhlIGluZmluaXRlXG4gICAgICAgIC8vIGxvb3AgdHJhcC4gVGhlIGluaXRpYWwgZGF0ZSB0YWtlcyBjYXJlIG9mIHRoZSBjYXNlXG4gICAgICAgIC8vIHdoZXJlIHRoZSBjdXJyZW50IGRhdGUgaXMgdGhlIGRhdGUgd2UgYXJlIGxvb2tpbmdcbiAgICAgICAgLy8gZm9yLlxuICAgICAgICBkYXRlID0gbGFzdERheSArIDE7XG5cbiAgICAgICAgaWYgKGRhdGUgPiBkYXlzSW5Nb250aCkge1xuICAgICAgICAgIG5leHRNb250aCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBuZXh0IGRhdGVcbiAgICAgICAgdmFyIG5leHQgPSBieU1vbnRoRGF5W2RhdGVJZHgrK107XG5cbiAgICAgICAgLy8gdGhpcyBsb2dpYyBpcyBkZXBlbmRhbnQgb24gdGhlIEJZTU9OVEhEQVlTXG4gICAgICAgIC8vIGJlaW5nIGluIG9yZGVyICh3aGljaCBpcyBkb25lIGJ5ICNub3JtYWxpemVCeU1vbnRoRGF5UnVsZXMpXG4gICAgICAgIGlmIChuZXh0ID49IGRhdGUpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgbmV4dCBtb250aCBkYXkgaXMgaW4gdGhlIGZ1dHVyZSBqdW1wIHRvIGl0LlxuICAgICAgICAgIGxhc3REYXkgPSBuZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgJ25leHQnIG1vbnRoZGF5IGhhcyBwYXN0XG4gICAgICAgICAgLy8gd2UgbXVzdCBtb3ZlIHRvIHRoZSBtb250aC5cbiAgICAgICAgICBuZXh0TW9udGgoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyB3ZSBjYW4gbG9vcCB0aHJvdWdoIHRoZSBkYXkgcnVsZXMgdG8gc2VlXG4gICAgICAgIC8vIGlmIG9uZSBtYXRjaGVzIHRoZSBjdXJyZW50IG1vbnRoIGRhdGUuXG4gICAgICAgIGZvciAodmFyIGRheUlkeCA9IDA7IGRheUlkeCA8IGRheUxlbjsgZGF5SWR4KyspIHtcbiAgICAgICAgICB2YXIgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoYnlEYXlbZGF5SWR4XSk7XG4gICAgICAgICAgdmFyIHBvcyA9IHBhcnRzWzBdO1xuICAgICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBsYXN0RGF5O1xuICAgICAgICAgIGlmICh0aGlzLmxhc3QuaXNOdGhXZWVrRGF5KGRvdywgcG9zKSkge1xuICAgICAgICAgICAgLy8gd2hlbiB3ZSBmaW5kIHRoZSB2YWxpZCBvbmUgd2UgY2FuIG1hcmtcbiAgICAgICAgICAgIC8vIHRoZSBjb25kaXRpb25zIGFzIG1ldCBhbmQgYnJlYWsgdGhlIGxvb3AuXG4gICAgICAgICAgICAvLyAoQmVjYXVzZSB3ZSBoYXZlIHRoaXMgY29uZGl0aW9uIGFib3ZlXG4gICAgICAgICAgICAvLyAgaXQgd2lsbCBhbHNvIGJyZWFrIHRoZSBwYXJlbnQgbG9vcCkuXG4gICAgICAgICAgICBkYXRhSXNWYWxpZCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdCBpcyBjb21wbGV0ZWx5IHBvc3NpYmxlIHRoYXQgdGhlIGNvbWJpbmF0aW9uXG4gICAgICAgIC8vIGNhbm5vdCBiZSBtYXRjaGVkIGluIHRoZSBjdXJyZW50IG1vbnRoLlxuICAgICAgICAvLyBXaGVuIHdlIHJlYWNoIHRoZSBlbmQgb2YgcG9zc2libGUgY29tYmluYXRpb25zXG4gICAgICAgIC8vIGluIHRoZSBjdXJyZW50IG1vbnRoIHdlIGl0ZXJhdGUgdG8gdGhlIG5leHQgb25lLlxuICAgICAgICAvLyBzaW5jZSBkYXRlSWR4IGlzIGluY3JlbWVudGVkIHJpZ2h0IGFmdGVyIGdldHRpbmdcbiAgICAgICAgLy8gXCJuZXh0XCIsIHdlIGRvbid0IG5lZWQgZGF0ZUxlbiAtMSBoZXJlLlxuICAgICAgICBpZiAoIWRhdGFJc1ZhbGlkICYmIGRhdGVJZHggPT09IGRhdGVMZW4pIHtcbiAgICAgICAgICBuZXh0TW9udGgoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobW9udGhzQ291bnRlciA8PSAwKSB7XG4gICAgICAgIC8vIENoZWNrZWQgNCB5ZWFycyB3aXRob3V0IGZpbmRpbmcgYSBCeWRheSB0aGF0IG1hdGNoZXNcbiAgICAgICAgLy8gYSBCeW1vbnRoZGF5LiBNYXliZSB0aGUgcnVsZSBpcyBub3QgY29ycmVjdC5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHZhbHVlcyBpbiBCWURBWSBjb21iaW5lZCB3aXRoIEJZTU9OVEhEQVkgcGFydHNcIik7XG4gICAgICB9XG5cblxuICAgICAgcmV0dXJuIGRhdGFJc1ZhbGlkO1xuICAgIH0sXG5cbiAgICBuZXh0X21vbnRoOiBmdW5jdGlvbiBuZXh0X21vbnRoKCkge1xuICAgICAgdmFyIHRoaXNfZnJlcSA9ICh0aGlzLnJ1bGUuZnJlcSA9PSBcIk1PTlRITFlcIik7XG4gICAgICB2YXIgZGF0YV92YWxpZCA9IDE7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIGRhdGFfdmFsaWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllEQVlcIikgJiYgdGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhEQVlcIikpIHtcbiAgICAgICAgZGF0YV92YWxpZCA9IHRoaXMuX2J5RGF5QW5kTW9udGhEYXkoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZREFZXCIpKSB7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgdmFyIHNldHBvcyA9IDA7XG4gICAgICAgIHZhciBzZXRwb3NfdG90YWwgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikpIHtcbiAgICAgICAgICB2YXIgbGFzdF9kYXkgPSB0aGlzLmxhc3QuZGF5O1xuICAgICAgICAgIGZvciAodmFyIGRheSA9IDE7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5KyspIHtcbiAgICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KSkge1xuICAgICAgICAgICAgICBzZXRwb3NfdG90YWwrKztcbiAgICAgICAgICAgICAgaWYgKGRheSA8PSBsYXN0X2RheSkge1xuICAgICAgICAgICAgICAgIHNldHBvcysrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBsYXN0X2RheTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFfdmFsaWQgPSAwO1xuICAgICAgICBmb3IgKHZhciBkYXkgPSB0aGlzLmxhc3QuZGF5ICsgMTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkrKykge1xuICAgICAgICAgIHRoaXMubGFzdC5kYXkgPSBkYXk7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc19ieV9kYXRhKFwiQllTRVRQT1NcIikgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbigrK3NldHBvcykgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrX3NldF9wb3NpdGlvbihzZXRwb3MgLSBzZXRwb3NfdG90YWwgLSAxKSkge1xuXG4gICAgICAgICAgICAgIGRhdGFfdmFsaWQgPSAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gMTtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNfZGF5X2luX2J5ZGF5KHRoaXMubGFzdCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNfYnlfZGF0YShcIkJZU0VUUE9TXCIpIHx8IHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKDEpKSB7XG4gICAgICAgICAgICAgIGRhdGFfdmFsaWQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhX3ZhbGlkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhEQVlcIikpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkrKztcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkgPj0gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEhEQVkgPSAwO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVt0aGlzLmJ5X2luZGljZXMuQllNT05USERBWV07XG5cbiAgICAgICAgaWYgKGRheSA8IDApIHtcbiAgICAgICAgICBkYXkgPSBkYXlzSW5Nb250aCArIGRheSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5ID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gMTtcbiAgICAgICAgICBkYXRhX3ZhbGlkID0gdGhpcy5pc19kYXlfaW5fYnlkYXkodGhpcy5sYXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gZGF5O1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50X21vbnRoKCk7XG4gICAgICAgIHZhciBkYXlzSW5Nb250aCA9IElDQUwuVGltZS5kYXlzSW5Nb250aCh0aGlzLmxhc3QubW9udGgsIHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgaWYgKHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZWzBdID4gZGF5c0luTW9udGgpIHtcbiAgICAgICAgICBkYXRhX3ZhbGlkID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxhc3QuZGF5ID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVlbMF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGFfdmFsaWQ7XG4gICAgfSxcblxuICAgIG5leHRfd2Vla2RheV9ieV93ZWVrOiBmdW5jdGlvbiBuZXh0X3dlZWtkYXlfYnlfd2VlaygpIHtcbiAgICAgIHZhciBlbmRfb2ZfZGF0YSA9IDA7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIGVuZF9vZl9kYXRhO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGFzX2J5X2RhdGEoXCJCWURBWVwiKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICB2YXIgdHQgPSBuZXcgSUNBTC5UaW1lKCk7XG4gICAgICAgIHRoaXMuYnlfaW5kaWNlcy5CWURBWSsrO1xuXG4gICAgICAgIGlmICh0aGlzLmJ5X2luZGljZXMuQllEQVkgPT0gT2JqZWN0LmtleXModGhpcy5ieV9kYXRhLkJZREFZKS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmJ5X2luZGljZXMuQllEQVkgPSAwO1xuICAgICAgICAgIGVuZF9vZl9kYXRhID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2RlZF9kYXkgPSB0aGlzLmJ5X2RhdGEuQllEQVlbdGhpcy5ieV9pbmRpY2VzLkJZREFZXTtcbiAgICAgICAgdmFyIHBhcnRzID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGNvZGVkX2RheSk7XG4gICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcblxuICAgICAgICBkb3cgLT0gdGhpcy5ydWxlLndrc3Q7XG5cbiAgICAgICAgaWYgKGRvdyA8IDApIHtcbiAgICAgICAgICBkb3cgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIHR0LnllYXIgPSB0aGlzLmxhc3QueWVhcjtcbiAgICAgICAgdHQubW9udGggPSB0aGlzLmxhc3QubW9udGg7XG4gICAgICAgIHR0LmRheSA9IHRoaXMubGFzdC5kYXk7XG5cbiAgICAgICAgdmFyIHN0YXJ0T2ZXZWVrID0gdHQuc3RhcnREb3lXZWVrKHRoaXMucnVsZS53a3N0KTtcblxuICAgICAgICBpZiAoZG93ICsgc3RhcnRPZldlZWsgPCAxKSB7XG4gICAgICAgICAgLy8gVGhlIHNlbGVjdGVkIGRhdGUgaXMgaW4gdGhlIHByZXZpb3VzIHllYXJcbiAgICAgICAgICBpZiAoIWVuZF9vZl9kYXRhKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dCA9IElDQUwuVGltZS5mcm9tRGF5T2ZZZWFyKHN0YXJ0T2ZXZWVrICsgZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3QueWVhcik7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBub3JtYWxpemF0aW9uIGhvcnJvcnMgYmVsb3cgYXJlIGR1ZSB0b1xuICAgICAgICAgKiB0aGUgZmFjdCB0aGF0IHdoZW4gdGhlIHllYXIvbW9udGgvZGF5IGNoYW5nZXNcbiAgICAgICAgICogaXQgY2FuIGVmZmVjdCB0aGUgb3RoZXIgb3BlcmF0aW9ucyB0aGF0IGNvbWUgYWZ0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3QueWVhciA9IG5leHQueWVhcjtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoID0gbmV4dC5tb250aDtcbiAgICAgICAgdGhpcy5sYXN0LmRheSA9IG5leHQuZGF5O1xuXG4gICAgICAgIHJldHVybiBlbmRfb2ZfZGF0YTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbmV4dF95ZWFyOiBmdW5jdGlvbiBuZXh0X3llYXIoKSB7XG5cbiAgICAgIGlmICh0aGlzLm5leHRfaG91cigpID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmICgrK3RoaXMuZGF5c19pbmRleCA9PSB0aGlzLmRheXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZGF5c19pbmRleCA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKHRoaXMucnVsZS5pbnRlcnZhbCk7XG4gICAgICAgICAgdGhpcy5leHBhbmRfeWVhcl9kYXlzKHRoaXMubGFzdC55ZWFyKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5kYXlzLmxlbmd0aCA9PSAwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbmV4dEJ5WWVhckRheSgpO1xuXG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgX25leHRCeVllYXJEYXk6IGZ1bmN0aW9uIF9uZXh0QnlZZWFyRGF5KCkge1xuICAgICAgICB2YXIgZG95ID0gdGhpcy5kYXlzW3RoaXMuZGF5c19pbmRleF07XG4gICAgICAgIHZhciB5ZWFyID0gdGhpcy5sYXN0LnllYXI7XG4gICAgICAgIGlmIChkb3kgPCAxKSB7XG4gICAgICAgICAgICAvLyBUaW1lLmZyb21EYXlPZlllYXIoZG95LCB5ZWFyKSBpbmRleGVzIHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGdpdmVuIHllYXIuIFRoYXQgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgICAgICAgICAvLyBzZW1hbnRpY3Mgb2YgQllZRUFSREFZIHdoZXJlIG5lZ2F0aXZlIGluZGV4ZXMgYXJlIGFuXG4gICAgICAgICAgICAvLyBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIHRoZSBnaXZlbiB5ZWFyLlxuICAgICAgICAgICAgZG95ICs9IDE7XG4gICAgICAgICAgICB5ZWFyICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkb3ksIHllYXIpO1xuICAgICAgICB0aGlzLmxhc3QuZGF5ID0gbmV4dC5kYXk7XG4gICAgICAgIHRoaXMubGFzdC5tb250aCA9IG5leHQubW9udGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkb3cgKGVnOiAnMVRVJywgJy0xTU8nKVxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lLndlZWtEYXk9fSBhV2Vla1N0YXJ0IFRoZSB3ZWVrIHN0YXJ0IHdlZWtkYXlcbiAgICAgKiBAcmV0dXJuIFtwb3MsIG51bWVyaWNEb3ddIChlZzogWzEsIDNdKSBudW1lcmljRG93IGlzIHJlbGF0aXZlIHRvIGFXZWVrU3RhcnRcbiAgICAgKi9cbiAgICBydWxlRGF5T2ZXZWVrOiBmdW5jdGlvbiBydWxlRGF5T2ZXZWVrKGRvdywgYVdlZWtTdGFydCkge1xuICAgICAgdmFyIG1hdGNoZXMgPSBkb3cubWF0Y2goLyhbKy1dP1swLTldKT8oTU98VFV8V0V8VEh8RlJ8U0F8U1UpLyk7XG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICB2YXIgcG9zID0gcGFyc2VJbnQobWF0Y2hlc1sxXSB8fCAwLCAxMCk7XG4gICAgICAgIGRvdyA9IElDQUwuUmVjdXIuaWNhbERheVRvTnVtZXJpY0RheShtYXRjaGVzWzJdLCBhV2Vla1N0YXJ0KTtcbiAgICAgICAgcmV0dXJuIFtwb3MsIGRvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBuZXh0X2dlbmVyaWM6IGZ1bmN0aW9uIG5leHRfZ2VuZXJpYyhhUnVsZVR5cGUsIGFJbnRlcnZhbCwgYURhdGVBdHRyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFGb2xsb3dpbmdBdHRyLCBhUHJldmlvdXNJbmNyKSB7XG4gICAgICB2YXIgaGFzX2J5X3J1bGUgPSAoYVJ1bGVUeXBlIGluIHRoaXMuYnlfZGF0YSk7XG4gICAgICB2YXIgdGhpc19mcmVxID0gKHRoaXMucnVsZS5mcmVxID09IGFJbnRlcnZhbCk7XG4gICAgICB2YXIgZW5kX29mX2RhdGEgPSAwO1xuXG4gICAgICBpZiAoYVByZXZpb3VzSW5jciAmJiB0aGlzW2FQcmV2aW91c0luY3JdKCkgPT0gMCkge1xuICAgICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNfYnlfcnVsZSkge1xuICAgICAgICB0aGlzLmJ5X2luZGljZXNbYVJ1bGVUeXBlXSsrO1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV07XG4gICAgICAgIHZhciBkdGEgPSB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXTtcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV0gPT0gZHRhLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYnlfaW5kaWNlc1thUnVsZVR5cGVdID0gMDtcbiAgICAgICAgICBlbmRfb2ZfZGF0YSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0W2FEYXRlQXR0cl0gPSBkdGFbdGhpcy5ieV9pbmRpY2VzW2FSdWxlVHlwZV1dO1xuICAgICAgfSBlbHNlIGlmICh0aGlzX2ZyZXEpIHtcbiAgICAgICAgdGhpc1tcImluY3JlbWVudF9cIiArIGFEYXRlQXR0cl0odGhpcy5ydWxlLmludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc19ieV9ydWxlICYmIGVuZF9vZl9kYXRhICYmIHRoaXNfZnJlcSkge1xuICAgICAgICB0aGlzW1wiaW5jcmVtZW50X1wiICsgYUZvbGxvd2luZ0F0dHJdKDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZW5kX29mX2RhdGE7XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9tb250aGRheTogZnVuY3Rpb24gaW5jcmVtZW50X21vbnRoZGF5KGluYykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmM7IGkrKykge1xuICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgodGhpcy5sYXN0Lm1vbnRoLCB0aGlzLmxhc3QueWVhcik7XG4gICAgICAgIHRoaXMubGFzdC5kYXkrKztcblxuICAgICAgICBpZiAodGhpcy5sYXN0LmRheSA+IGRheXNJbk1vbnRoKSB7XG4gICAgICAgICAgdGhpcy5sYXN0LmRheSAtPSBkYXlzSW5Nb250aDtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF9tb250aCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9tb250aDogZnVuY3Rpb24gaW5jcmVtZW50X21vbnRoKCkge1xuICAgICAgdGhpcy5sYXN0LmRheSA9IDE7XG4gICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZTU9OVEhcIikpIHtcbiAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEgrKztcblxuICAgICAgICBpZiAodGhpcy5ieV9pbmRpY2VzLkJZTU9OVEggPT0gdGhpcy5ieV9kYXRhLkJZTU9OVEgubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5ieV9pbmRpY2VzLkJZTU9OVEggPSAwO1xuICAgICAgICAgIHRoaXMuaW5jcmVtZW50X3llYXIoMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3QubW9udGggPSB0aGlzLmJ5X2RhdGEuQllNT05USFt0aGlzLmJ5X2luZGljZXMuQllNT05USF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5ydWxlLmZyZXEgPT0gXCJNT05USExZXCIpIHtcbiAgICAgICAgICB0aGlzLmxhc3QubW9udGggKz0gdGhpcy5ydWxlLmludGVydmFsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubGFzdC5tb250aCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoLS07XG4gICAgICAgIHZhciB5ZWFycyA9IElDQUwuaGVscGVycy50cnVuYyh0aGlzLmxhc3QubW9udGggLyAxMik7XG4gICAgICAgIHRoaXMubGFzdC5tb250aCAlPSAxMjtcbiAgICAgICAgdGhpcy5sYXN0Lm1vbnRoKys7XG5cbiAgICAgICAgaWYgKHllYXJzICE9IDApIHtcbiAgICAgICAgICB0aGlzLmluY3JlbWVudF95ZWFyKHllYXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbmNyZW1lbnRfeWVhcjogZnVuY3Rpb24gaW5jcmVtZW50X3llYXIoaW5jKSB7XG4gICAgICB0aGlzLmxhc3QueWVhciArPSBpbmM7XG4gICAgfSxcblxuICAgIGluY3JlbWVudF9nZW5lcmljOiBmdW5jdGlvbiBpbmNyZW1lbnRfZ2VuZXJpYyhpbmMsIGFEYXRlQXR0cixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUZhY3RvciwgYU5leHRJbmNyZW1lbnQpIHtcbiAgICAgIHRoaXMubGFzdFthRGF0ZUF0dHJdICs9IGluYztcbiAgICAgIHZhciBuZXh0dW5pdCA9IElDQUwuaGVscGVycy50cnVuYyh0aGlzLmxhc3RbYURhdGVBdHRyXSAvIGFGYWN0b3IpO1xuICAgICAgdGhpcy5sYXN0W2FEYXRlQXR0cl0gJT0gYUZhY3RvcjtcbiAgICAgIGlmIChuZXh0dW5pdCAhPSAwKSB7XG4gICAgICAgIHRoaXNbXCJpbmNyZW1lbnRfXCIgKyBhTmV4dEluY3JlbWVudF0obmV4dHVuaXQpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBoYXNfYnlfZGF0YTogZnVuY3Rpb24gaGFzX2J5X2RhdGEoYVJ1bGVUeXBlKSB7XG4gICAgICByZXR1cm4gKGFSdWxlVHlwZSBpbiB0aGlzLnJ1bGUucGFydHMpO1xuICAgIH0sXG5cbiAgICBleHBhbmRfeWVhcl9kYXlzOiBmdW5jdGlvbiBleHBhbmRfeWVhcl9kYXlzKGFZZWFyKSB7XG4gICAgICB2YXIgdCA9IG5ldyBJQ0FMLlRpbWUoKTtcbiAgICAgIHRoaXMuZGF5cyA9IFtdO1xuXG4gICAgICAvLyBXZSBuZWVkIG91ciBvd24gY29weSB3aXRoIGEgZmV3IGtleXMgc2V0XG4gICAgICB2YXIgcGFydHMgPSB7fTtcbiAgICAgIHZhciBydWxlcyA9IFtcIkJZREFZXCIsIFwiQllXRUVLTk9cIiwgXCJCWU1PTlRIREFZXCIsIFwiQllNT05USFwiLCBcIkJZWUVBUkRBWVwiXTtcbiAgICAgIGZvciAodmFyIHAgaW4gcnVsZXMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHJ1bGVzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgdmFyIHBhcnQgPSBydWxlc1twXTtcbiAgICAgICAgICBpZiAocGFydCBpbiB0aGlzLnJ1bGUucGFydHMpIHtcbiAgICAgICAgICAgIHBhcnRzW3BhcnRdID0gdGhpcy5ydWxlLnBhcnRzW3BhcnRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoXCJCWU1PTlRIXCIgaW4gcGFydHMgJiYgXCJCWVdFRUtOT1wiIGluIHBhcnRzKSB7XG4gICAgICAgIHZhciB2YWxpZCA9IDE7XG4gICAgICAgIHZhciB2YWxpZFdlZWtzID0ge307XG4gICAgICAgIHQueWVhciA9IGFZZWFyO1xuICAgICAgICB0LmlzRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgbW9udGhJZHggPSAwOyBtb250aElkeCA8IHRoaXMuYnlfZGF0YS5CWU1PTlRILmxlbmd0aDsgbW9udGhJZHgrKykge1xuICAgICAgICAgIHZhciBtb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoSWR4XTtcbiAgICAgICAgICB0Lm1vbnRoID0gbW9udGg7XG4gICAgICAgICAgdC5kYXkgPSAxO1xuICAgICAgICAgIHZhciBmaXJzdF93ZWVrID0gdC53ZWVrTnVtYmVyKHRoaXMucnVsZS53a3N0KTtcbiAgICAgICAgICB0LmRheSA9IElDQUwuVGltZS5kYXlzSW5Nb250aChtb250aCwgYVllYXIpO1xuICAgICAgICAgIHZhciBsYXN0X3dlZWsgPSB0LndlZWtOdW1iZXIodGhpcy5ydWxlLndrc3QpO1xuICAgICAgICAgIGZvciAobW9udGhJZHggPSBmaXJzdF93ZWVrOyBtb250aElkeCA8IGxhc3Rfd2VlazsgbW9udGhJZHgrKykge1xuICAgICAgICAgICAgdmFsaWRXZWVrc1ttb250aElkeF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHdlZWtJZHggPSAwOyB3ZWVrSWR4IDwgdGhpcy5ieV9kYXRhLkJZV0VFS05PLmxlbmd0aCAmJiB2YWxpZDsgd2Vla0lkeCsrKSB7XG4gICAgICAgICAgdmFyIHdlZWtubyA9IHRoaXMuYnlfZGF0YS5CWVdFRUtOT1t3ZWVrSWR4XTtcbiAgICAgICAgICBpZiAod2Vla25vIDwgNTIpIHtcbiAgICAgICAgICAgIHZhbGlkICY9IHZhbGlkV2Vla3Nbd2Vla0lkeF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICBkZWxldGUgcGFydHMuQllNT05USDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgcGFydHMuQllXRUVLTk87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcnRDb3VudCA9IE9iamVjdC5rZXlzKHBhcnRzKS5sZW5ndGg7XG5cbiAgICAgIGlmIChwYXJ0Q291bnQgPT0gMCkge1xuICAgICAgICB2YXIgdDEgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgICAgdDEueWVhciA9IHRoaXMubGFzdC55ZWFyO1xuICAgICAgICB0aGlzLmRheXMucHVzaCh0MS5kYXlPZlllYXIoKSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllNT05USFwiIGluIHBhcnRzKSB7XG4gICAgICAgIGZvciAodmFyIG1vbnRoa2V5IGluIHRoaXMuYnlfZGF0YS5CWU1PTlRIKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCF0aGlzLmJ5X2RhdGEuQllNT05USC5oYXNPd25Qcm9wZXJ0eShtb250aGtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdDIgPSB0aGlzLmR0c3RhcnQuY2xvbmUoKTtcbiAgICAgICAgICB0Mi55ZWFyID0gYVllYXI7XG4gICAgICAgICAgdDIubW9udGggPSB0aGlzLmJ5X2RhdGEuQllNT05USFttb250aGtleV07XG4gICAgICAgICAgdDIuaXNEYXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRheXMucHVzaCh0Mi5kYXlPZlllYXIoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhkYXlrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmhhc093blByb3BlcnR5KG1vbnRoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0MyA9IHRoaXMuZHRzdGFydC5jbG9uZSgpO1xuICAgICAgICAgIHZhciBkYXlfID0gdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVlbbW9udGhkYXlrZXldO1xuICAgICAgICAgIGlmIChkYXlfIDwgMCkge1xuICAgICAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKHQzLm1vbnRoLCBhWWVhcik7XG4gICAgICAgICAgICBkYXlfID0gZGF5XyArIGRheXNJbk1vbnRoICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdDMuZGF5ID0gZGF5XztcbiAgICAgICAgICB0My55ZWFyID0gYVllYXI7XG4gICAgICAgICAgdDMuaXNEYXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmRheXMucHVzaCh0My5kYXlPZlllYXIoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDIgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRILmhhc093blByb3BlcnR5KG1vbnRoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtb250aF8gPSB0aGlzLmJ5X2RhdGEuQllNT05USFttb250aGtleV07XG4gICAgICAgICAgdmFyIGRheXNJbk1vbnRoID0gSUNBTC5UaW1lLmRheXNJbk1vbnRoKG1vbnRoXywgYVllYXIpO1xuICAgICAgICAgIGZvciAodmFyIG1vbnRoZGF5a2V5IGluIHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZTU9OVEhEQVkuaGFzT3duUHJvcGVydHkobW9udGhkYXlrZXkpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRheV8gPSB0aGlzLmJ5X2RhdGEuQllNT05USERBWVttb250aGRheWtleV07XG4gICAgICAgICAgICBpZiAoZGF5XyA8IDApIHtcbiAgICAgICAgICAgICAgZGF5XyA9IGRheV8gKyBkYXlzSW5Nb250aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0LmRheSA9IGRheV87XG4gICAgICAgICAgICB0Lm1vbnRoID0gbW9udGhfO1xuICAgICAgICAgICAgdC55ZWFyID0gYVllYXI7XG4gICAgICAgICAgICB0LmlzRGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIHRoaXMuZGF5cy5wdXNoKHQuZGF5T2ZZZWFyKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMSAmJiBcIkJZV0VFS05PXCIgaW4gcGFydHMpIHtcbiAgICAgICAgLy8gVE9ETyB1bmltcGxlbWVudGVkIGluIGxpYmljYWxcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDIgJiZcbiAgICAgICAgICAgICAgICAgXCJCWVdFRUtOT1wiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICAgIFwiQllNT05USERBWVwiIGluIHBhcnRzKSB7XG4gICAgICAgIC8vIFRPRE8gdW5pbXBsZW1lbnRlZCBpbiBsaWJpY2FsXG4gICAgICB9IGVsc2UgaWYgKHBhcnRDb3VudCA9PSAxICYmIFwiQllEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aGlzLmRheXMgPSB0aGlzLmRheXMuY29uY2F0KHRoaXMuZXhwYW5kX2J5X2RheShhWWVhcikpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgZm9yICh2YXIgbW9udGhrZXkgaW4gdGhpcy5ieV9kYXRhLkJZTU9OVEgpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWU1PTlRILmhhc093blByb3BlcnR5KG1vbnRoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtb250aCA9IHRoaXMuYnlfZGF0YS5CWU1PTlRIW21vbnRoa2V5XTtcbiAgICAgICAgICB2YXIgZGF5c0luTW9udGggPSBJQ0FMLlRpbWUuZGF5c0luTW9udGgobW9udGgsIGFZZWFyKTtcblxuICAgICAgICAgIHQueWVhciA9IGFZZWFyO1xuICAgICAgICAgIHQubW9udGggPSB0aGlzLmJ5X2RhdGEuQllNT05USFttb250aGtleV07XG4gICAgICAgICAgdC5kYXkgPSAxO1xuICAgICAgICAgIHQuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBmaXJzdF9kb3cgPSB0LmRheU9mV2VlaygpO1xuICAgICAgICAgIHZhciBkb3lfb2Zmc2V0ID0gdC5kYXlPZlllYXIoKSAtIDE7XG5cbiAgICAgICAgICB0LmRheSA9IGRheXNJbk1vbnRoO1xuICAgICAgICAgIHZhciBsYXN0X2RvdyA9IHQuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5oYXNfYnlfZGF0YShcIkJZU0VUUE9TXCIpKSB7XG4gICAgICAgICAgICB2YXIgc2V0X3Bvc19jb3VudGVyID0gMDtcbiAgICAgICAgICAgIHZhciBieV9tb250aF9kYXkgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGRheSA9IDE7IGRheSA8PSBkYXlzSW5Nb250aDsgZGF5KyspIHtcbiAgICAgICAgICAgICAgdC5kYXkgPSBkYXk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlzX2RheV9pbl9ieWRheSh0KSkge1xuICAgICAgICAgICAgICAgIGJ5X21vbnRoX2RheS5wdXNoKGRheSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgc3BJbmRleCA9IDA7IHNwSW5kZXggPCBieV9tb250aF9kYXkubGVuZ3RoOyBzcEluZGV4KyspIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tfc2V0X3Bvc2l0aW9uKHNwSW5kZXggKyAxKSB8fFxuICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja19zZXRfcG9zaXRpb24oc3BJbmRleCAtIGJ5X21vbnRoX2RheS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZG95X29mZnNldCArIGJ5X21vbnRoX2RheVtzcEluZGV4XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgZGF5Y29kZWRrZXkgaW4gdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWURBWS5oYXNPd25Qcm9wZXJ0eShkYXljb2RlZGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgY29kZWRfZGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZW2RheWNvZGVka2V5XTtcbiAgICAgICAgICAgICAgdmFyIGJ5ZGF5UGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoY29kZWRfZGF5KTtcbiAgICAgICAgICAgICAgdmFyIHBvcyA9IGJ5ZGF5UGFydHNbMF07XG4gICAgICAgICAgICAgIHZhciBkb3cgPSBieWRheVBhcnRzWzFdO1xuICAgICAgICAgICAgICB2YXIgbW9udGhfZGF5O1xuXG4gICAgICAgICAgICAgIHZhciBmaXJzdF9tYXRjaGluZ19kYXkgPSAoKGRvdyArIDcgLSBmaXJzdF9kb3cpICUgNykgKyAxO1xuICAgICAgICAgICAgICB2YXIgbGFzdF9tYXRjaGluZ19kYXkgPSBkYXlzSW5Nb250aCAtICgobGFzdF9kb3cgKyA3IC0gZG93KSAlIDcpO1xuXG4gICAgICAgICAgICAgIGlmIChwb3MgPT0gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGRheSA9IGZpcnN0X21hdGNoaW5nX2RheTsgZGF5IDw9IGRheXNJbk1vbnRoOyBkYXkgKz0gNykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZG95X29mZnNldCArIGRheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvcyA+IDApIHtcbiAgICAgICAgICAgICAgICBtb250aF9kYXkgPSBmaXJzdF9tYXRjaGluZ19kYXkgKyAocG9zIC0gMSkgKiA3O1xuXG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoX2RheSA8PSBkYXlzSW5Nb250aCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZG95X29mZnNldCArIG1vbnRoX2RheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbnRoX2RheSA9IGxhc3RfbWF0Y2hpbmdfZGF5ICsgKHBvcyArIDEpICogNztcblxuICAgICAgICAgICAgICAgIGlmIChtb250aF9kYXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmRheXMucHVzaChkb3lfb2Zmc2V0ICsgbW9udGhfZGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGRhdGVzIGluIG9yZGVyIG9mIG9jY3VycmVuY2UgKDEsMiwzLC4uLikgaW5zdGVhZFxuICAgICAgICAvLyBvZiBieSBncm91cHMgb2Ygd2Vla2RheXMgKDEsOCwxNSwuLi4sMiw5LDE2LC4uLikuXG4gICAgICAgIHRoaXMuZGF5cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTsgLy8gQ29tcGFyYXRvciBmdW5jdGlvbiBhbGxvd3MgdG8gc29ydCBudW1iZXJzLlxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMiAmJiBcIkJZREFZXCIgaW4gcGFydHMgJiYgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkRGF5cyA9IHRoaXMuZXhwYW5kX2J5X2RheShhWWVhcik7XG5cbiAgICAgICAgZm9yICh2YXIgZGF5a2V5IGluIGV4cGFuZGVkRGF5cykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghZXhwYW5kZWREYXlzLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF5ID0gZXhwYW5kZWREYXlzW2RheWtleV07XG4gICAgICAgICAgdmFyIHR0ID0gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoZGF5LCBhWWVhcik7XG4gICAgICAgICAgaWYgKHRoaXMuYnlfZGF0YS5CWU1PTlRIREFZLmluZGV4T2YodHQuZGF5KSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRheXMucHVzaChkYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJ0Q291bnQgPT0gMyAmJlxuICAgICAgICAgICAgICAgICBcIkJZREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIREFZXCIgaW4gcGFydHMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWU1PTlRIXCIgaW4gcGFydHMpIHtcbiAgICAgICAgdmFyIGV4cGFuZGVkRGF5cyA9IHRoaXMuZXhwYW5kX2J5X2RheShhWWVhcik7XG5cbiAgICAgICAgZm9yICh2YXIgZGF5a2V5IGluIGV4cGFuZGVkRGF5cykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmICghZXhwYW5kZWREYXlzLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF5ID0gZXhwYW5kZWREYXlzW2RheWtleV07XG4gICAgICAgICAgdmFyIHR0ID0gSUNBTC5UaW1lLmZyb21EYXlPZlllYXIoZGF5LCBhWWVhcik7XG5cbiAgICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZTU9OVEguaW5kZXhPZih0dC5tb250aCkgPj0gMCAmJlxuICAgICAgICAgICAgICB0aGlzLmJ5X2RhdGEuQllNT05USERBWS5pbmRleE9mKHR0LmRheSkgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDIgJiYgXCJCWURBWVwiIGluIHBhcnRzICYmIFwiQllXRUVLTk9cIiBpbiBwYXJ0cykge1xuICAgICAgICB2YXIgZXhwYW5kZWREYXlzID0gdGhpcy5leHBhbmRfYnlfZGF5KGFZZWFyKTtcblxuICAgICAgICBmb3IgKHZhciBkYXlrZXkgaW4gZXhwYW5kZWREYXlzKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKCFleHBhbmRlZERheXMuaGFzT3duUHJvcGVydHkoZGF5a2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXkgPSBleHBhbmRlZERheXNbZGF5a2V5XTtcbiAgICAgICAgICB2YXIgdHQgPSBJQ0FMLlRpbWUuZnJvbURheU9mWWVhcihkYXksIGFZZWFyKTtcbiAgICAgICAgICB2YXIgd2Vla25vID0gdHQud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5ieV9kYXRhLkJZV0VFS05PLmluZGV4T2Yod2Vla25vKSkge1xuICAgICAgICAgICAgdGhpcy5kYXlzLnB1c2goZGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDMgJiZcbiAgICAgICAgICAgICAgICAgXCJCWURBWVwiIGluIHBhcnRzICYmXG4gICAgICAgICAgICAgICAgIFwiQllXRUVLTk9cIiBpbiBwYXJ0cyAmJlxuICAgICAgICAgICAgICAgICBcIkJZTU9OVEhEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICAvLyBUT0RPIHVuaW1wbGVtdGVkIGluIGxpYmljYWxcbiAgICAgIH0gZWxzZSBpZiAocGFydENvdW50ID09IDEgJiYgXCJCWVlFQVJEQVlcIiBpbiBwYXJ0cykge1xuICAgICAgICB0aGlzLmRheXMgPSB0aGlzLmRheXMuY29uY2F0KHRoaXMuYnlfZGF0YS5CWVlFQVJEQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXlzID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgZXhwYW5kX2J5X2RheTogZnVuY3Rpb24gZXhwYW5kX2J5X2RheShhWWVhcikge1xuXG4gICAgICB2YXIgZGF5c19saXN0ID0gW107XG4gICAgICB2YXIgdG1wID0gdGhpcy5sYXN0LmNsb25lKCk7XG5cbiAgICAgIHRtcC55ZWFyID0gYVllYXI7XG4gICAgICB0bXAubW9udGggPSAxO1xuICAgICAgdG1wLmRheSA9IDE7XG4gICAgICB0bXAuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgdmFyIHN0YXJ0X2RvdyA9IHRtcC5kYXlPZldlZWsoKTtcblxuICAgICAgdG1wLm1vbnRoID0gMTI7XG4gICAgICB0bXAuZGF5ID0gMzE7XG4gICAgICB0bXAuaXNEYXRlID0gdHJ1ZTtcblxuICAgICAgdmFyIGVuZF9kb3cgPSB0bXAuZGF5T2ZXZWVrKCk7XG4gICAgICB2YXIgZW5kX3llYXJfZGF5ID0gdG1wLmRheU9mWWVhcigpO1xuXG4gICAgICBmb3IgKHZhciBkYXlrZXkgaW4gdGhpcy5ieV9kYXRhLkJZREFZKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMuYnlfZGF0YS5CWURBWS5oYXNPd25Qcm9wZXJ0eShkYXlrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuYnlfZGF0YS5CWURBWVtkYXlrZXldO1xuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLnJ1bGVEYXlPZldlZWsoZGF5KTtcbiAgICAgICAgdmFyIHBvcyA9IHBhcnRzWzBdO1xuICAgICAgICB2YXIgZG93ID0gcGFydHNbMV07XG5cbiAgICAgICAgaWYgKHBvcyA9PSAwKSB7XG4gICAgICAgICAgdmFyIHRtcF9zdGFydF9kb3kgPSAoKGRvdyArIDcgLSBzdGFydF9kb3cpICUgNykgKyAxO1xuXG4gICAgICAgICAgZm9yICh2YXIgZG95ID0gdG1wX3N0YXJ0X2RveTsgZG95IDw9IGVuZF95ZWFyX2RheTsgZG95ICs9IDcpIHtcbiAgICAgICAgICAgIGRheXNfbGlzdC5wdXNoKGRveSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAocG9zID4gMCkge1xuICAgICAgICAgIHZhciBmaXJzdDtcbiAgICAgICAgICBpZiAoZG93ID49IHN0YXJ0X2Rvdykge1xuICAgICAgICAgICAgZmlyc3QgPSBkb3cgLSBzdGFydF9kb3cgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaXJzdCA9IGRvdyAtIHN0YXJ0X2RvdyArIDg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF5c19saXN0LnB1c2goZmlyc3QgKyAocG9zIC0gMSkgKiA3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGFzdDtcbiAgICAgICAgICBwb3MgPSAtcG9zO1xuXG4gICAgICAgICAgaWYgKGRvdyA8PSBlbmRfZG93KSB7XG4gICAgICAgICAgICBsYXN0ID0gZW5kX3llYXJfZGF5IC0gZW5kX2RvdyArIGRvdztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdCA9IGVuZF95ZWFyX2RheSAtIGVuZF9kb3cgKyBkb3cgLSA3O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRheXNfbGlzdC5wdXNoKGxhc3QgLSAocG9zIC0gMSkgKiA3KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRheXNfbGlzdDtcbiAgICB9LFxuXG4gICAgaXNfZGF5X2luX2J5ZGF5OiBmdW5jdGlvbiBpc19kYXlfaW5fYnlkYXkodHQpIHtcbiAgICAgIGZvciAodmFyIGRheWtleSBpbiB0aGlzLmJ5X2RhdGEuQllEQVkpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdGhpcy5ieV9kYXRhLkJZREFZLmhhc093blByb3BlcnR5KGRheWtleSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5ID0gdGhpcy5ieV9kYXRhLkJZREFZW2RheWtleV07XG4gICAgICAgIHZhciBwYXJ0cyA9IHRoaXMucnVsZURheU9mV2VlayhkYXkpO1xuICAgICAgICB2YXIgcG9zID0gcGFydHNbMF07XG4gICAgICAgIHZhciBkb3cgPSBwYXJ0c1sxXTtcbiAgICAgICAgdmFyIHRoaXNfZG93ID0gdHQuZGF5T2ZXZWVrKCk7XG5cbiAgICAgICAgaWYgKChwb3MgPT0gMCAmJiBkb3cgPT0gdGhpc19kb3cpIHx8XG4gICAgICAgICAgICAodHQubnRoV2Vla0RheShkb3csIHBvcykgPT0gdHQuZGF5KSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgZ2l2ZW4gdmFsdWUgaXMgaW4gQllTRVRQT1MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TnVtZXJpY30gYVBvcyBwb3NpdGlvbiB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gZmFsc2UgdW5sZXNzIEJZU0VUUE9TIHJ1bGVzIGV4aXN0XG4gICAgICogICAgICAgICAgICAgICAgICAgYW5kIHRoZSBnaXZlbiB2YWx1ZSBpcyBwcmVzZW50IGluIHJ1bGVzLlxuICAgICAqL1xuICAgIGNoZWNrX3NldF9wb3NpdGlvbjogZnVuY3Rpb24gY2hlY2tfc2V0X3Bvc2l0aW9uKGFQb3MpIHtcbiAgICAgIGlmICh0aGlzLmhhc19ieV9kYXRhKCdCWVNFVFBPUycpKSB7XG4gICAgICAgIHZhciBpZHggPSB0aGlzLmJ5X2RhdGEuQllTRVRQT1MuaW5kZXhPZihhUG9zKTtcbiAgICAgICAgLy8gbmVnYXRpdmUgbnVtYmVycyBhcmUgbm90IGZhbHNlLXlcbiAgICAgICAgcmV0dXJuIGlkeCAhPT0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIHNvcnRfYnlkYXlfcnVsZXM6IGZ1bmN0aW9uIGljYWxyZWN1cl9zb3J0X2J5ZGF5X3J1bGVzKGFSdWxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhUnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpOyBqKyspIHtcbiAgICAgICAgICB2YXIgb25lID0gdGhpcy5ydWxlRGF5T2ZXZWVrKGFSdWxlc1tqXSwgdGhpcy5ydWxlLndrc3QpWzFdO1xuICAgICAgICAgIHZhciB0d28gPSB0aGlzLnJ1bGVEYXlPZldlZWsoYVJ1bGVzW2ldLCB0aGlzLnJ1bGUud2tzdClbMV07XG5cbiAgICAgICAgICBpZiAob25lID4gdHdvKSB7XG4gICAgICAgICAgICB2YXIgdG1wID0gYVJ1bGVzW2ldO1xuICAgICAgICAgICAgYVJ1bGVzW2ldID0gYVJ1bGVzW2pdO1xuICAgICAgICAgICAgYVJ1bGVzW2pdID0gdG1wO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjaGVja19jb250cmFjdF9yZXN0cmljdGlvbjogZnVuY3Rpb24gY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oYVJ1bGVUeXBlLCB2KSB7XG4gICAgICB2YXIgaW5kZXhNYXBWYWx1ZSA9IGljYWxyZWN1cl9pdGVyYXRvci5faW5kZXhNYXBbYVJ1bGVUeXBlXTtcbiAgICAgIHZhciBydWxlTWFwVmFsdWUgPSBpY2FscmVjdXJfaXRlcmF0b3IuX2V4cGFuZE1hcFt0aGlzLnJ1bGUuZnJlcV1baW5kZXhNYXBWYWx1ZV07XG4gICAgICB2YXIgcGFzcyA9IGZhbHNlO1xuXG4gICAgICBpZiAoYVJ1bGVUeXBlIGluIHRoaXMuYnlfZGF0YSAmJlxuICAgICAgICAgIHJ1bGVNYXBWYWx1ZSA9PSBpY2FscmVjdXJfaXRlcmF0b3IuQ09OVFJBQ1QpIHtcblxuICAgICAgICB2YXIgcnVsZVR5cGUgPSB0aGlzLmJ5X2RhdGFbYVJ1bGVUeXBlXTtcblxuICAgICAgICBmb3IgKHZhciBieWRhdGFrZXkgaW4gcnVsZVR5cGUpIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgIGlmIChydWxlVHlwZS5oYXNPd25Qcm9wZXJ0eShieWRhdGFrZXkpKSB7XG4gICAgICAgICAgICBpZiAocnVsZVR5cGVbYnlkYXRha2V5XSA9PSB2KSB7XG4gICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vdCBhIGNvbnRyYWN0aW5nIGJ5cnVsZSBvciBoYXMgbm8gZGF0YSwgdGVzdCBwYXNzZXNcbiAgICAgICAgcGFzcyA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFzcztcbiAgICB9LFxuXG4gICAgY2hlY2tfY29udHJhY3RpbmdfcnVsZXM6IGZ1bmN0aW9uIGNoZWNrX2NvbnRyYWN0aW5nX3J1bGVzKCkge1xuICAgICAgdmFyIGRvdyA9IHRoaXMubGFzdC5kYXlPZldlZWsoKTtcbiAgICAgIHZhciB3ZWVrTm8gPSB0aGlzLmxhc3Qud2Vla051bWJlcih0aGlzLnJ1bGUud2tzdCk7XG4gICAgICB2YXIgZG95ID0gdGhpcy5sYXN0LmRheU9mWWVhcigpO1xuXG4gICAgICByZXR1cm4gKHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWVNFQ09ORFwiLCB0aGlzLmxhc3Quc2Vjb25kKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllNSU5VVEVcIiwgdGhpcy5sYXN0Lm1pbnV0ZSkgJiZcbiAgICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZSE9VUlwiLCB0aGlzLmxhc3QuaG91cikgJiZcbiAgICAgICAgICAgICAgdGhpcy5jaGVja19jb250cmFjdF9yZXN0cmljdGlvbihcIkJZREFZXCIsIElDQUwuUmVjdXIubnVtZXJpY0RheVRvSWNhbERheShkb3cpKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllXRUVLTk9cIiwgd2Vla05vKSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllNT05USERBWVwiLCB0aGlzLmxhc3QuZGF5KSAmJlxuICAgICAgICAgICAgICB0aGlzLmNoZWNrX2NvbnRyYWN0X3Jlc3RyaWN0aW9uKFwiQllNT05USFwiLCB0aGlzLmxhc3QubW9udGgpICYmXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tfY29udHJhY3RfcmVzdHJpY3Rpb24oXCJCWVlFQVJEQVlcIiwgZG95KSk7XG4gICAgfSxcblxuICAgIHNldHVwX2RlZmF1bHRzOiBmdW5jdGlvbiBzZXR1cF9kZWZhdWx0cyhhUnVsZVR5cGUsIHJlcSwgZGVmdGltZSkge1xuICAgICAgdmFyIGluZGV4TWFwVmFsdWUgPSBpY2FscmVjdXJfaXRlcmF0b3IuX2luZGV4TWFwW2FSdWxlVHlwZV07XG4gICAgICB2YXIgcnVsZU1hcFZhbHVlID0gaWNhbHJlY3VyX2l0ZXJhdG9yLl9leHBhbmRNYXBbdGhpcy5ydWxlLmZyZXFdW2luZGV4TWFwVmFsdWVdO1xuXG4gICAgICBpZiAocnVsZU1hcFZhbHVlICE9IGljYWxyZWN1cl9pdGVyYXRvci5DT05UUkFDVCkge1xuICAgICAgICBpZiAoIShhUnVsZVR5cGUgaW4gdGhpcy5ieV9kYXRhKSkge1xuICAgICAgICAgIHRoaXMuYnlfZGF0YVthUnVsZVR5cGVdID0gW2RlZnRpbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJ1bGUuZnJlcSAhPSByZXEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ieV9kYXRhW2FSdWxlVHlwZV1bMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZ0aW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGl0ZXJhdG9yIGludG8gYSBzZXJpYWxpemUtYWJsZSBvYmplY3QuICBXaWxsIHByZXNlcnZlIGN1cnJlbnRcbiAgICAgKiBpdGVyYXRpb24gc2VxdWVuY2UgdG8gZW5zdXJlIHRoZSBzZWFtbGVzcyBjb250aW51YXRpb24gb2YgdGhlIHJlY3VycmVuY2VcbiAgICAgKiBydWxlLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHJlc3VsdC5pbml0aWFsaXplZCA9IHRoaXMuaW5pdGlhbGl6ZWQ7XG4gICAgICByZXN1bHQucnVsZSA9IHRoaXMucnVsZS50b0pTT04oKTtcbiAgICAgIHJlc3VsdC5kdHN0YXJ0ID0gdGhpcy5kdHN0YXJ0LnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmJ5X2RhdGEgPSB0aGlzLmJ5X2RhdGE7XG4gICAgICByZXN1bHQuZGF5cyA9IHRoaXMuZGF5cztcbiAgICAgIHJlc3VsdC5sYXN0ID0gdGhpcy5sYXN0LnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmJ5X2luZGljZXMgPSB0aGlzLmJ5X2luZGljZXM7XG4gICAgICByZXN1bHQub2NjdXJyZW5jZV9udW1iZXIgPSB0aGlzLm9jY3VycmVuY2VfbnVtYmVyO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICBpY2FscmVjdXJfaXRlcmF0b3IuX2luZGV4TWFwID0ge1xuICAgIFwiQllTRUNPTkRcIjogMCxcbiAgICBcIkJZTUlOVVRFXCI6IDEsXG4gICAgXCJCWUhPVVJcIjogMixcbiAgICBcIkJZREFZXCI6IDMsXG4gICAgXCJCWU1PTlRIREFZXCI6IDQsXG4gICAgXCJCWVlFQVJEQVlcIjogNSxcbiAgICBcIkJZV0VFS05PXCI6IDYsXG4gICAgXCJCWU1PTlRIXCI6IDcsXG4gICAgXCJCWVNFVFBPU1wiOiA4XG4gIH07XG5cbiAgaWNhbHJlY3VyX2l0ZXJhdG9yLl9leHBhbmRNYXAgPSB7XG4gICAgXCJTRUNPTkRMWVwiOiBbMSwgMSwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJNSU5VVEVMWVwiOiBbMiwgMSwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAgXCJIT1VSTFlcIjogWzIsIDIsIDEsIDEsIDEsIDEsIDEsIDFdLFxuICAgIFwiREFJTFlcIjogWzIsIDIsIDIsIDEsIDEsIDEsIDEsIDFdLFxuICAgIFwiV0VFS0xZXCI6IFsyLCAyLCAyLCAyLCAzLCAzLCAxLCAxXSxcbiAgICBcIk1PTlRITFlcIjogWzIsIDIsIDIsIDIsIDIsIDMsIDMsIDFdLFxuICAgIFwiWUVBUkxZXCI6IFsyLCAyLCAyLCAyLCAyLCAyLCAyLCAyXVxuICB9O1xuICBpY2FscmVjdXJfaXRlcmF0b3IuVU5LTk9XTiA9IDA7XG4gIGljYWxyZWN1cl9pdGVyYXRvci5DT05UUkFDVCA9IDE7XG4gIGljYWxyZWN1cl9pdGVyYXRvci5FWFBBTkQgPSAyO1xuICBpY2FscmVjdXJfaXRlcmF0b3IuSUxMRUdBTCA9IDM7XG5cbiAgcmV0dXJuIGljYWxyZWN1cl9pdGVyYXRvcjtcblxufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLlJlY3VyRXhwYW5zaW9uID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBmb3JtYXRUaW1lKGl0ZW0pIHtcbiAgICByZXR1cm4gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShpdGVtLCBJQ0FMLlRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZVRpbWUoYSwgYikge1xuICAgIHJldHVybiBhLmNvbXBhcmUoYik7XG4gIH1cblxuICBmdW5jdGlvbiBpc1JlY3VycmluZ0NvbXBvbmVudChjb21wKSB7XG4gICAgcmV0dXJuIGNvbXAuaGFzUHJvcGVydHkoJ3JkYXRlJykgfHxcbiAgICAgICAgICAgY29tcC5oYXNQcm9wZXJ0eSgncnJ1bGUnKSB8fFxuICAgICAgICAgICBjb21wLmhhc1Byb3BlcnR5KCdyZWN1cnJlbmNlLWlkJyk7XG4gIH1cblxuICAvKipcbiAgICogQGNsYXNzZGVzY1xuICAgKiBQcmltYXJ5IGNsYXNzIGZvciBleHBhbmRpbmcgcmVjdXJyaW5nIHJ1bGVzLiAgQ2FuIHRha2UgbXVsdGlwbGUgcnJ1bGVzLFxuICAgKiByZGF0ZXMsIGV4ZGF0ZShzKSBhbmQgaXRlcmF0ZSAoaW4gb3JkZXIpIG92ZXIgZWFjaCBuZXh0IG9jY3VycmVuY2UuXG4gICAqXG4gICAqIE9uY2UgaW5pdGlhbGl6ZWQgdGhpcyBjbGFzcyBjYW4gYWxzbyBiZSBzZXJpYWxpemVkIHNhdmVkIGFuZCBjb250aW51ZVxuICAgKiBpdGVyYXRpb24gZnJvbSB0aGUgbGFzdCBwb2ludC5cbiAgICpcbiAgICogTk9URTogaXQgaXMgaW50ZW5kZWQgdGhhdCB0aGlzIGNsYXNzIGlzIHRvIGJlIHVzZWRcbiAgICogICAgICAgd2l0aCBJQ0FMLkV2ZW50IHdoaWNoIGhhbmRsZXMgcmVjdXJyZW5jZSBleGNlcHRpb25zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBhc3N1bWluZyBldmVudCBpcyBhIHBhcnNlZCBpY2FsIGNvbXBvbmVudFxuICAgKiB2YXIgZXZlbnQ7XG4gICAqXG4gICAqIHZhciBleHBhbmQgPSBuZXcgSUNBTC5SZWN1ckV4cGFuc2lvbih7XG4gICAqICAgY29tcG9uZW50OiBldmVudCxcbiAgICogICBkdHN0YXJ0OiBldmVudC5nZXRGaXJzdFByb3BlcnR5VmFsdWUoJ2R0c3RhcnQnKVxuICAgKiB9KTtcbiAgICpcbiAgICogLy8gcmVtZW1iZXIgdGhlcmUgYXJlIGluZmluaXRlIHJ1bGVzXG4gICAqIC8vIHNvIGl0IGlzIGEgZ29vZCBpZGVhIHRvIGxpbWl0IHRoZSBzY29wZVxuICAgKiAvLyBvZiB0aGUgaXRlcmF0aW9ucyB0aGVuIHJlc3VtZSBsYXRlciBvbi5cbiAgICpcbiAgICogLy8gbmV4dCBpcyBhbHdheXMgYW4gSUNBTC5UaW1lIG9yIG51bGxcbiAgICogdmFyIG5leHQ7XG4gICAqXG4gICAqIHdoaWxlIChzb21lQ29uZGl0aW9uICYmIChuZXh0ID0gZXhwYW5kLm5leHQoKSkpIHtcbiAgICogICAvLyBkbyBzb21ldGhpbmcgd2l0aCBuZXh0XG4gICAqIH1cbiAgICpcbiAgICogLy8gc2F2ZSBpbnN0YW5jZSBmb3IgbGF0ZXJcbiAgICogdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShleHBhbmQpO1xuICAgKlxuICAgKiAvLy4uLlxuICAgKlxuICAgKiAvLyBOT1RFOiBpZiB0aGUgY29tcG9uZW50J3MgcHJvcGVydGllcyBoYXZlXG4gICAqIC8vICAgICAgIGNoYW5nZWQgeW91IHdpbGwgbmVlZCB0byByZWJ1aWxkIHRoZVxuICAgKiAvLyAgICAgICBjbGFzcyBhbmQgc3RhcnQgb3Zlci4gVGhpcyBvbmx5IHdvcmtzXG4gICAqIC8vICAgICAgIHdoZW4gdGhlIGNvbXBvbmVudCdzIHJlY3VycmVuY2UgaW5mbyBpcyB0aGUgc2FtZS5cbiAgICogdmFyIGV4cGFuZCA9IG5ldyBJQ0FMLlJlY3VyRXhwYW5zaW9uKEpTT04ucGFyc2UoanNvbikpO1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBiZSBmaWxsZWQgd2l0aCB0aGUgc3BlY2lmaWVkIGluaXRpYWwgdmFsdWVzLiBJdCBjYW5cbiAgICogYWxzbyBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycywgYXMgYSByZXN1bHQgb2Ygc2VyaWFsaXppbmcgYSBwcmV2aW91c1xuICAgKiBleHBhbnNpb24gc3RhdGUsIGFzIHNob3duIGluIHRoZSBleGFtcGxlLlxuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuUmVjdXJFeHBhbnNpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogICAgICAgIFJlY3VycmVuY2UgZXhwYW5zaW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IG9wdGlvbnMuZHRzdGFydFxuICAgKiAgICAgICAgU3RhcnQgdGltZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudD19IG9wdGlvbnMuY29tcG9uZW50XG4gICAqICAgICAgICBDb21wb25lbnQgZm9yIGV4cGFuc2lvbiwgcmVxdWlyZWQgaWYgbm90IHJlc3VtaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gUmVjdXJFeHBhbnNpb24ob3B0aW9ucykge1xuICAgIHRoaXMucnVsZURhdGVzID0gW107XG4gICAgdGhpcy5leERhdGVzID0gW107XG4gICAgdGhpcy5mcm9tRGF0YShvcHRpb25zKTtcbiAgfVxuXG4gIFJlY3VyRXhwYW5zaW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBUcnVlIHdoZW4gaXRlcmF0aW9uIGlzIGZ1bGx5IGNvbXBsZXRlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjb21wbGV0ZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBycnVsZSBpdGVyYXRvcnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5SZWN1ckl0ZXJhdG9yW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydWxlSXRlcmF0b3JzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcmRhdGUgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZVtdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVsZURhdGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgZXhkYXRlIGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWVbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGV4RGF0ZXM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHBvc2l0aW9uIGluIHJ1bGVEYXRlcyBhcnJheS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVsZURhdGVJbmM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHBvc2l0aW9uIGluIGV4RGF0ZXMgYXJyYXlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZXhEYXRlSW5jOiAwLFxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBuZWdhdGl2ZSBkYXRlLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGV4RGF0ZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgYWRkaXRpb25hbCBkYXRlLlxuICAgICAqXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bGVEYXRlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgZGF0ZSBvZiByZWN1cnJpbmcgcnVsZXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGR0c3RhcnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBMYXN0IGV4cGFuZGVkIHRpbWVcbiAgICAgKlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgbGFzdDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIHJlY3VycmVuY2UgZXhwYW5zaW9uIGZyb20gdGhlIGRhdGEgb2JqZWN0LiBUaGUgb3B0aW9uc1xuICAgICAqIG9iamVjdCBtYXkgYWxzbyBjb250YWluIGFkZGl0aW9uYWwgbWVtYmVycywgc2VlIHRoZVxuICAgICAqIHtAbGluayBJQ0FMLlJlY3VyRXhwYW5zaW9uIGNvbnN0cnVjdG9yfSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiAgICAgICAgUmVjdXJyZW5jZSBleHBhbnNpb24gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBvcHRpb25zLmR0c3RhcnRcbiAgICAgKiAgICAgICAgU3RhcnQgdGltZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50PX0gb3B0aW9ucy5jb21wb25lbnRcbiAgICAgKiAgICAgICAgQ29tcG9uZW50IGZvciBleHBhbnNpb24sIHJlcXVpcmVkIGlmIG5vdCByZXN1bWluZy5cbiAgICAgKi9cbiAgICBmcm9tRGF0YTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHN0YXJ0ID0gSUNBTC5oZWxwZXJzLmZvcm1hdENsYXNzVHlwZShvcHRpb25zLmR0c3RhcnQsIElDQUwuVGltZSk7XG5cbiAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcuZHRzdGFydCAoSUNBTC5UaW1lKSBtdXN0IGJlIGdpdmVuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmR0c3RhcnQgPSBzdGFydDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuX2luaXQob3B0aW9ucy5jb21wb25lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sYXN0ID0gZm9ybWF0VGltZShvcHRpb25zLmxhc3QpIHx8IHN0YXJ0LmNsb25lKCk7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLnJ1bGVJdGVyYXRvcnMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJy5ydWxlSXRlcmF0b3JzIG9yIC5jb21wb25lbnQgbXVzdCBiZSBnaXZlbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ydWxlSXRlcmF0b3JzID0gb3B0aW9ucy5ydWxlSXRlcmF0b3JzLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgcmV0dXJuIElDQUwuaGVscGVycy5mb3JtYXRDbGFzc1R5cGUoaXRlbSwgSUNBTC5SZWN1ckl0ZXJhdG9yKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ydWxlRGF0ZUluYyA9IG9wdGlvbnMucnVsZURhdGVJbmM7XG4gICAgICAgIHRoaXMuZXhEYXRlSW5jID0gb3B0aW9ucy5leERhdGVJbmM7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMucnVsZURhdGVzKSB7XG4gICAgICAgICAgdGhpcy5ydWxlRGF0ZXMgPSBvcHRpb25zLnJ1bGVEYXRlcy5tYXAoZm9ybWF0VGltZSk7XG4gICAgICAgICAgdGhpcy5ydWxlRGF0ZSA9IHRoaXMucnVsZURhdGVzW3RoaXMucnVsZURhdGVJbmNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZXhEYXRlcykge1xuICAgICAgICAgIHRoaXMuZXhEYXRlcyA9IG9wdGlvbnMuZXhEYXRlcy5tYXAoZm9ybWF0VGltZSk7XG4gICAgICAgICAgdGhpcy5leERhdGUgPSB0aGlzLmV4RGF0ZXNbdGhpcy5leERhdGVJbmNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihvcHRpb25zLmNvbXBsZXRlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgbmV4dCBvY2N1cnJlbmNlIGluIHRoZSBzZXJpZXMuXG4gICAgICogQHJldHVybiB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZXI7XG4gICAgICB2YXIgcnVsZU9mRGF5O1xuICAgICAgdmFyIG5leHQ7XG4gICAgICB2YXIgY29tcGFyZTtcblxuICAgICAgdmFyIG1heFRyaWVzID0gNTAwO1xuICAgICAgdmFyIGN1cnJlbnRUcnkgPSAwO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoY3VycmVudFRyeSsrID4gbWF4VHJpZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnbWF4IHRyaWVzIGhhdmUgb2NjdXJlZCwgcnVsZSBtYXkgYmUgaW1wb3NzaWJsZSB0byBmb3JmaWxsLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCA9IHRoaXMucnVsZURhdGU7XG4gICAgICAgIGl0ZXIgPSB0aGlzLl9uZXh0UmVjdXJyZW5jZUl0ZXIodGhpcy5sYXN0KTtcblxuICAgICAgICAvLyBubyBtb3JlIG1hdGNoZXNcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBpbmNyZW1lbnQgdGhlIHJ1bGUgZGF5IG9yIHJ1bGVcbiAgICAgICAgLy8gX2FmdGVyXyB3ZSBjaG9vc2UgYSB2YWx1ZSB0aGlzIHNob3VsZCBiZVxuICAgICAgICAvLyB0aGUgb25seSBzcG90IHdoZXJlIHdlIG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlXG4gICAgICAgIC8vIGVuZCBvZiBldmVudHMuXG4gICAgICAgIGlmICghbmV4dCAmJiAhaXRlcikge1xuICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBtb3JlIGl0ZXJhdG9ycyBvciByZGF0ZXNcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vIG5leHQgcnVsZSBkYXkgb3IgcmVjdXJyZW5jZSBydWxlIGlzIGZpcnN0LlxuICAgICAgICBpZiAoIW5leHQgfHwgKGl0ZXIgJiYgbmV4dC5jb21wYXJlKGl0ZXIubGFzdCkgPiAwKSkge1xuICAgICAgICAgIC8vIG11c3QgYmUgY2xvbmVkLCByZWN1ciB3aWxsIHJldXNlIHRoZSB0aW1lIGVsZW1lbnQuXG4gICAgICAgICAgbmV4dCA9IGl0ZXIubGFzdC5jbG9uZSgpO1xuICAgICAgICAgIC8vIG1vdmUgdG8gbmV4dCBzbyB3ZSBjYW4gY29udGludWVcbiAgICAgICAgICBpdGVyLm5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBydWxlRGF0ZSBpcyBzdGlsbCBuZXh0IGluY3JlbWVudCBpdC5cbiAgICAgICAgaWYgKHRoaXMucnVsZURhdGUgPT09IG5leHQpIHtcbiAgICAgICAgICB0aGlzLl9uZXh0UnVsZURheSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0ID0gbmV4dDtcblxuICAgICAgICAvLyBjaGVjayB0aGUgbmVnYXRpdmUgcnVsZXNcbiAgICAgICAgaWYgKHRoaXMuZXhEYXRlKSB7XG4gICAgICAgICAgY29tcGFyZSA9IHRoaXMuZXhEYXRlLmNvbXBhcmUodGhpcy5sYXN0KTtcblxuICAgICAgICAgIGlmIChjb21wYXJlIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dEV4RGF5KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgcnVsZSBpcyBleGNsdWRlZCBza2lwIGl0LlxuICAgICAgICAgIGlmIChjb21wYXJlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0RXhEYXkoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vWFhYOiBUaGUgc3BlYyBzdGF0ZXMgdGhhdCBhZnRlciB3ZSByZXNvbHZlIHRoZSBmaW5hbFxuICAgICAgICAvLyAgICAgbGlzdCBvZiBkYXRlcyB3ZSBleGVjdXRlIGV4ZGF0ZSB0aGlzIHNlZW1zIHNvbWV3aGF0IGNvdW50ZXJcbiAgICAgICAgLy8gICAgIGludHVpdGl2ZSB0byB3aGF0IEkgaGF2ZSBzZWVuIG1vc3Qgc2VydmVycyBkbyBzbyBmb3Igbm93XG4gICAgICAgIC8vICAgICBJIGV4Y2x1ZGUgYmFzZWQgb24gdGhlIG9yaWdpbmFsIGRhdGUgbm90IHRoZSBvbmUgdGhhdCBtYXlcbiAgICAgICAgLy8gICAgIGhhdmUgYmVlbiBtb2RpZmllZCBieSB0aGUgZXhjZXB0aW9uLlxuICAgICAgICByZXR1cm4gdGhpcy5sYXN0O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBvYmplY3QgaW50byBhIHNlcmlhbGl6ZS1hYmxlIGZvcm1hdC4gVGhpcyBmb3JtYXQgY2FuIGJlIHBhc3NlZFxuICAgICAqIGJhY2sgaW50byB0aGUgZXhwYW5zaW9uIHRvIHJlc3VtZSBpdGVyYXRpb24uXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICBmdW5jdGlvbiB0b0pTT04oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICByZXN1bHQucnVsZUl0ZXJhdG9ycyA9IHRoaXMucnVsZUl0ZXJhdG9ycy5tYXAodG9KU09OKTtcblxuICAgICAgaWYgKHRoaXMucnVsZURhdGVzKSB7XG4gICAgICAgIHJlc3VsdC5ydWxlRGF0ZXMgPSB0aGlzLnJ1bGVEYXRlcy5tYXAodG9KU09OKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZXhEYXRlcykge1xuICAgICAgICByZXN1bHQuZXhEYXRlcyA9IHRoaXMuZXhEYXRlcy5tYXAodG9KU09OKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnJ1bGVEYXRlSW5jID0gdGhpcy5ydWxlRGF0ZUluYztcbiAgICAgIHJlc3VsdC5leERhdGVJbmMgPSB0aGlzLmV4RGF0ZUluYztcbiAgICAgIHJlc3VsdC5sYXN0ID0gdGhpcy5sYXN0LnRvSlNPTigpO1xuICAgICAgcmVzdWx0LmR0c3RhcnQgPSB0aGlzLmR0c3RhcnQudG9KU09OKCk7XG4gICAgICByZXN1bHQuY29tcGxldGUgPSB0aGlzLmNvbXBsZXRlO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGFsbCBkYXRlcyBmcm9tIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBnaXZlbiBjb21wb25lbnQuIFRoZVxuICAgICAqIHByb3BlcnRpZXMgd2lsbCBiZSBmaWx0ZXJlZCBieSB0aGUgcHJvcGVydHkgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudH0gY29tcG9uZW50ICAgICAgICBUaGUgY29tcG9uZW50IHRvIHNlYXJjaCBpblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eU5hbWUgICAgICAgICAgICAgVGhlIHByb3BlcnR5IG5hbWUgdG8gc2VhcmNoIGZvclxuICAgICAqIEByZXR1cm4ge0lDQUwuVGltZVtdfSAgICAgICAgICAgICAgICAgICAgVGhlIGV4dHJhY3RlZCBkYXRlcy5cbiAgICAgKi9cbiAgICBfZXh0cmFjdERhdGVzOiBmdW5jdGlvbihjb21wb25lbnQsIHByb3BlcnR5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gaGFuZGxlUHJvcChwcm9wKSB7XG4gICAgICAgIGlkeCA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHByb3AsXG4gICAgICAgICAgY29tcGFyZVRpbWVcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBvcmRlcmVkIGluc2VydFxuICAgICAgICByZXN1bHQuc3BsaWNlKGlkeCwgMCwgcHJvcCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBwcm9wcyA9IGNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKHByb3BlcnR5TmFtZSk7XG4gICAgICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHByb3A7XG5cbiAgICAgIHZhciBpZHg7XG5cbiAgICAgIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcHJvcHNbaV0uZ2V0VmFsdWVzKCkuZm9yRWFjaChoYW5kbGVQcm9wKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgcmVjdXJyZW5jZSBleHBhbnNpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnR9IGNvbXBvbmVudCAgICBUaGUgY29tcG9uZW50IHRvIGluaXRpYWxpemUgZnJvbS5cbiAgICAgKi9cbiAgICBfaW5pdDogZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICB0aGlzLnJ1bGVJdGVyYXRvcnMgPSBbXTtcblxuICAgICAgdGhpcy5sYXN0ID0gdGhpcy5kdHN0YXJ0LmNsb25lKCk7XG5cbiAgICAgIC8vIHRvIHByb3ZpZGUgYXBpIGNvbnNpc3RlbmN5IG5vbi1yZWN1cnJpbmdcbiAgICAgIC8vIGV2ZW50cyBjYW4gYWxzbyB1c2UgdGhlIGl0ZXJhdG9yIHRob3VnaCBpdCB3aWxsXG4gICAgICAvLyBvbmx5IHJldHVybiBhIHNpbmdsZSB0aW1lLlxuICAgICAgaWYgKCFpc1JlY3VycmluZ0NvbXBvbmVudChjb21wb25lbnQpKSB7XG4gICAgICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLmxhc3QuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvbmVudC5oYXNQcm9wZXJ0eSgncmRhdGUnKSkge1xuICAgICAgICB0aGlzLnJ1bGVEYXRlcyA9IHRoaXMuX2V4dHJhY3REYXRlcyhjb21wb25lbnQsICdyZGF0ZScpO1xuXG4gICAgICAgIC8vIHNwZWNpYWwgaGFjayBmb3IgY2FzZXMgd2hlcmUgZmlyc3QgcmRhdGUgaXMgcHJpb3JcbiAgICAgICAgLy8gdG8gdGhlIHN0YXJ0IGRhdGUuIFdlIG9ubHkgY2hlY2sgZm9yIHRoZSBmaXJzdCByZGF0ZS5cbiAgICAgICAgLy8gVGhpcyBpcyBtb3N0bHkgZm9yIGdvb2dsZSdzIGNyYXp5IHJlY3VycmluZyBkYXRlIGxvZ2ljXG4gICAgICAgIC8vIChjb250YWN0cyBiaXJ0aGRheXMpLlxuICAgICAgICBpZiAoKHRoaXMucnVsZURhdGVzWzBdKSAmJlxuICAgICAgICAgICAgKHRoaXMucnVsZURhdGVzWzBdLmNvbXBhcmUodGhpcy5kdHN0YXJ0KSA8IDApKSB7XG5cbiAgICAgICAgICB0aGlzLnJ1bGVEYXRlSW5jID0gMDtcbiAgICAgICAgICB0aGlzLmxhc3QgPSB0aGlzLnJ1bGVEYXRlc1swXS5jbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucnVsZURhdGVJbmMgPSBJQ0FMLmhlbHBlcnMuYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICAgICAgdGhpcy5ydWxlRGF0ZXMsXG4gICAgICAgICAgICB0aGlzLmxhc3QsXG4gICAgICAgICAgICBjb21wYXJlVGltZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJ1bGVEYXRlID0gdGhpcy5ydWxlRGF0ZXNbdGhpcy5ydWxlRGF0ZUluY107XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnQuaGFzUHJvcGVydHkoJ3JydWxlJykpIHtcbiAgICAgICAgdmFyIHJ1bGVzID0gY29tcG9uZW50LmdldEFsbFByb3BlcnRpZXMoJ3JydWxlJyk7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcblxuICAgICAgICB2YXIgcnVsZTtcbiAgICAgICAgdmFyIGl0ZXI7XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHJ1bGUgPSBydWxlc1tpXS5nZXRGaXJzdFZhbHVlKCk7XG4gICAgICAgICAgaXRlciA9IHJ1bGUuaXRlcmF0b3IodGhpcy5kdHN0YXJ0KTtcbiAgICAgICAgICB0aGlzLnJ1bGVJdGVyYXRvcnMucHVzaChpdGVyKTtcblxuICAgICAgICAgIC8vIGluY3JlbWVudCB0byB0aGUgbmV4dCBvY2N1cnJlbmNlIHNvIGZ1dHVyZVxuICAgICAgICAgIC8vIGNhbGxzIHRvIG5leHQgcmV0dXJuIHRpbWVzIGJleW9uZCB0aGUgaW5pdGlhbCBpdGVyYXRpb24uXG4gICAgICAgICAgLy8gWFhYOiBJIGZpbmQgdGhpcyBzdXNwaWNpb3VzIG1pZ2h0IGJlIGEgYnVnP1xuICAgICAgICAgIGl0ZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb25lbnQuaGFzUHJvcGVydHkoJ2V4ZGF0ZScpKSB7XG4gICAgICAgIHRoaXMuZXhEYXRlcyA9IHRoaXMuX2V4dHJhY3REYXRlcyhjb21wb25lbnQsICdleGRhdGUnKTtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIC5sYXN0IGRheSB3ZSBpbmNyZW1lbnQgdGhlIGluZGV4IHRvIGJleW9uZCBpdC5cbiAgICAgICAgdGhpcy5leERhdGVJbmMgPSBJQ0FMLmhlbHBlcnMuYmluc2VhcmNoSW5zZXJ0KFxuICAgICAgICAgIHRoaXMuZXhEYXRlcyxcbiAgICAgICAgICB0aGlzLmxhc3QsXG4gICAgICAgICAgY29tcGFyZVRpbWVcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmV4RGF0ZSA9IHRoaXMuZXhEYXRlc1t0aGlzLmV4RGF0ZUluY107XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdG8gdGhlIG5leHQgZXhkYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfbmV4dEV4RGF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZXhEYXRlID0gdGhpcy5leERhdGVzWysrdGhpcy5leERhdGVJbmNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlIHRvIHRoZSBuZXh0IHJ1bGUgZGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25leHRSdWxlRGF5OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucnVsZURhdGUgPSB0aGlzLnJ1bGVEYXRlc1srK3RoaXMucnVsZURhdGVJbmNdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuZCByZXR1cm4gdGhlIHJlY3VycmVuY2UgcnVsZSB3aXRoIHRoZSBtb3N0IHJlY2VudCBldmVudCBhbmRcbiAgICAgKiByZXR1cm4gaXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4gez9JQ0FMLlJlY3VySXRlcmF0b3J9ICAgIEZvdW5kIGl0ZXJhdG9yLlxuICAgICAqL1xuICAgIF9uZXh0UmVjdXJyZW5jZUl0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGl0ZXJzID0gdGhpcy5ydWxlSXRlcmF0b3JzO1xuXG4gICAgICBpZiAoaXRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gaXRlcnMubGVuZ3RoO1xuICAgICAgdmFyIGl0ZXI7XG4gICAgICB2YXIgaXRlclRpbWU7XG4gICAgICB2YXIgaXRlcklkeCA9IDA7XG4gICAgICB2YXIgY2hvc2VuSXRlcjtcblxuICAgICAgLy8gbG9vcCB0aHJvdWdoIGVhY2ggaXRlcmF0b3JcbiAgICAgIGZvciAoOyBpdGVySWR4IDwgbGVuOyBpdGVySWR4KyspIHtcbiAgICAgICAgaXRlciA9IGl0ZXJzW2l0ZXJJZHhdO1xuICAgICAgICBpdGVyVGltZSA9IGl0ZXIubGFzdDtcblxuICAgICAgICAvLyBpZiBpdGVyYXRpb24gaXMgY29tcGxldGVcbiAgICAgICAgLy8gdGhlbiB3ZSBtdXN0IGV4Y2x1ZGUgaXQgZnJvbVxuICAgICAgICAvLyB0aGUgc2VhcmNoIGFuZCByZW1vdmUgaXQuXG4gICAgICAgIGlmIChpdGVyLmNvbXBsZXRlZCkge1xuICAgICAgICAgIGxlbi0tO1xuICAgICAgICAgIGlmIChpdGVySWR4ICE9PSAwKSB7XG4gICAgICAgICAgICBpdGVySWR4LS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZXJzLnNwbGljZShpdGVySWR4LCAxKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIG1vc3QgcmVjZW50IHBvc3NpYmxlIGNob2ljZVxuICAgICAgICBpZiAoIWNob3Nlbkl0ZXIgfHwgY2hvc2VuSXRlci5sYXN0LmNvbXBhcmUoaXRlclRpbWUpID4gMCkge1xuICAgICAgICAgIC8vIHRoYXQgaXRlcmF0b3IgaXMgc2F2ZWRcbiAgICAgICAgICBjaG9zZW5JdGVyID0gaXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0aGUgY2hvc2VuIGl0ZXJhdG9yIGlzIHJldHVybmVkIGJ1dCBub3QgbXV0YXRlZFxuICAgICAgLy8gdGhpcyBpdGVyYXRvciBjb250YWlucyB0aGUgbW9zdCByZWNlbnQgZXZlbnQuXG4gICAgICByZXR1cm4gY2hvc2VuSXRlcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJlY3VyRXhwYW5zaW9uO1xufSgpKTtcbi8qIFRoaXMgU291cmNlIENvZGUgRm9ybSBpcyBzdWJqZWN0IHRvIHRoZSB0ZXJtcyBvZiB0aGUgTW96aWxsYSBQdWJsaWNcbiAqIExpY2Vuc2UsIHYuIDIuMC4gSWYgYSBjb3B5IG9mIHRoZSBNUEwgd2FzIG5vdCBkaXN0cmlidXRlZCB3aXRoIHRoaXNcbiAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uXG4gKiBQb3J0aW9ucyBDb3B5cmlnaHQgKEMpIFBoaWxpcHAgS2V3aXNjaCwgMjAxMS0yMDE1ICovXG5cblxuLyoqXG4gKiBUaGlzIHN5bWJvbCBpcyBmdXJ0aGVyIGRlc2NyaWJlZCBsYXRlciBvblxuICogQGlnbm9yZVxuICovXG5JQ0FMLkV2ZW50ID0gKGZ1bmN0aW9uKCkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIElDQUwuanMgaXMgb3JnYW5pemVkIGludG8gbXVsdGlwbGUgbGF5ZXJzLiBUaGUgYm90dG9tIGxheWVyIGlzIGEgcmF3IGpDYWxcbiAgICogb2JqZWN0LCBmb2xsb3dlZCBieSB0aGUgY29tcG9uZW50L3Byb3BlcnR5IGxheWVyLiBUaGUgaGlnaGVzdCBsZXZlbCBpcyB0aGVcbiAgICogZXZlbnQgcmVwcmVzZW50YXRpb24sIHdoaWNoIHRoaXMgY2xhc3MgaXMgcGFydCBvZi4gU2VlIHRoZVxuICAgKiB7QHR1dG9yaWFsIGxheWVyc30gZ3VpZGUgZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogQGNsYXNzXG4gICAqIEBhbGlhcyBJQ0FMLkV2ZW50XG4gICAqIEBwYXJhbSB7SUNBTC5Db21wb25lbnQ9fSBjb21wb25lbnQgICAgICAgICBUaGUgSUNBTC5Db21wb25lbnQgdG8gYmFzZSB0aGlzIGV2ZW50IG9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgICAgICBPcHRpb25zIGZvciB0aGlzIGV2ZW50XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zXG4gICAqICAgICAgICAgIFdoZW4gdHJ1ZSwgd2lsbCB2ZXJpZnkgZXhjZXB0aW9ucyBhcmUgcmVsYXRlZCBieSB0aGVpciBVVUlEXG4gICAqIEBwYXJhbSB7QXJyYXk8SUNBTC5Db21wb25lbnR8SUNBTC5FdmVudD59IG9wdGlvbnMuZXhjZXB0aW9uc1xuICAgKiAgICAgICAgICBFeGNlcHRpb25zIHRvIHRoaXMgZXZlbnQsIGVpdGhlciBhcyBjb21wb25lbnRzIG9yIGV2ZW50cy4gSWYgbm90XG4gICAqICAgICAgICAgICAgc3BlY2lmaWVkIGV4Y2VwdGlvbnMgd2lsbCBhdXRvbWF0aWNhbGx5IGJlIHNldCBpbiByZWxhdGlvbiBvZlxuICAgKiAgICAgICAgICAgIGNvbXBvbmVudCdzIHBhcmVudFxuICAgKi9cbiAgZnVuY3Rpb24gRXZlbnQoY29tcG9uZW50LCBvcHRpb25zKSB7XG4gICAgaWYgKCEoY29tcG9uZW50IGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpKSB7XG4gICAgICBvcHRpb25zID0gY29tcG9uZW50O1xuICAgICAgY29tcG9uZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50KSB7XG4gICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21wb25lbnQgPSBuZXcgSUNBTC5Db21wb25lbnQoJ3ZldmVudCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3JhbmdlRXhjZXB0aW9uQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZXhjZXB0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5yYW5nZUV4Y2VwdGlvbnMgPSBbXTtcblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc3RyaWN0RXhjZXB0aW9ucykge1xuICAgICAgdGhpcy5zdHJpY3RFeGNlcHRpb25zID0gb3B0aW9ucy5zdHJpY3RFeGNlcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXhjZXB0aW9ucykge1xuICAgICAgb3B0aW9ucy5leGNlcHRpb25zLmZvckVhY2godGhpcy5yZWxhdGVFeGNlcHRpb24sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb21wb25lbnQucGFyZW50ICYmICF0aGlzLmlzUmVjdXJyZW5jZUV4Y2VwdGlvbigpKSB7XG4gICAgICB0aGlzLmNvbXBvbmVudC5wYXJlbnQuZ2V0QWxsU3ViY29tcG9uZW50cygndmV2ZW50JykuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuaGFzUHJvcGVydHkoJ3JlY3VycmVuY2UtaWQnKSkge1xuICAgICAgICAgIHRoaXMucmVsYXRlRXhjZXB0aW9uKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgRXZlbnQucHJvdG90eXBlID0ge1xuXG4gICAgVEhJU0FOREZVVFVSRTogJ1RISVNBTkRGVVRVUkUnLFxuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiByZWxhdGVkIGV2ZW50IGV4Y2VwdGlvbnMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SUNBTC5FdmVudFtdfVxuICAgICAqL1xuICAgIGV4Y2VwdGlvbnM6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUsIHdpbGwgdmVyaWZ5IGV4Y2VwdGlvbnMgYXJlIHJlbGF0ZWQgYnkgdGhlaXIgVVVJRC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN0cmljdEV4Y2VwdGlvbnM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogUmVsYXRlcyBhIGdpdmVuIGV2ZW50IGV4Y2VwdGlvbiB0byB0aGlzIG9iamVjdC4gIElmIHRoZSBnaXZlbiBjb21wb25lbnRcbiAgICAgKiBkb2VzIG5vdCBzaGFyZSB0aGUgVUlEIG9mIHRoaXMgZXZlbnQgaXQgY2Fubm90IGJlIHJlbGF0ZWQgYW5kIHdpbGwgdGhyb3dcbiAgICAgKiBhbiBleGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGNvbXBvbmVudCBpcyBhbiBleGNlcHRpb24gaXQgY2Fubm90IGhhdmUgb3RoZXIgZXhjZXB0aW9uc1xuICAgICAqIHJlbGF0ZWQgdG8gaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0lDQUwuQ29tcG9uZW50fElDQUwuRXZlbnR9IG9iaiAgICAgICBDb21wb25lbnQgb3IgZXZlbnRcbiAgICAgKi9cbiAgICByZWxhdGVFeGNlcHRpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKHRoaXMuaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgcmVsYXRlIGV4Y2VwdGlvbiB0byBleGNlcHRpb25zJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBJQ0FMLkNvbXBvbmVudCkge1xuICAgICAgICBvYmogPSBuZXcgSUNBTC5FdmVudChvYmopO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdHJpY3RFeGNlcHRpb25zICYmIG9iai51aWQgIT09IHRoaXMudWlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdGVkIHRvIHJlbGF0ZSB1bnJlbGF0ZWQgZXhjZXB0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZCA9IG9iai5yZWN1cnJlbmNlSWQudG9TdHJpbmcoKTtcblxuICAgICAgLy8gd2UgZG9uJ3Qgc29ydCBvciBtYW5hZ2UgZXhjZXB0aW9ucyBkaXJlY3RseVxuICAgICAgLy8gaGVyZSB0aGUgcmVjdXJyZW5jZSBleHBhbmRlciBoYW5kbGVzIHRoYXQuXG4gICAgICB0aGlzLmV4Y2VwdGlvbnNbaWRdID0gb2JqO1xuXG4gICAgICAvLyBpbmRleCBSQU5HRT1USElTQU5ERlVUVVJFIGV4Y2VwdGlvbnMgc28gd2UgY2FuXG4gICAgICAvLyBsb29rIHRoZW0gdXAgbGF0ZXIgaW4gZ2V0T2NjdXJyZW5jZURldGFpbHMuXG4gICAgICBpZiAob2JqLm1vZGlmaWVzRnV0dXJlKCkpIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBbXG4gICAgICAgICAgb2JqLnJlY3VycmVuY2VJZC50b1VuaXhUaW1lKCksIGlkXG4gICAgICAgIF07XG5cbiAgICAgICAgLy8gd2Uga2VlcCB0aGVtIHNvcnRlZCBzbyB3ZSBjYW4gZmluZCB0aGUgbmVhcmVzdFxuICAgICAgICAvLyB2YWx1ZSBsYXRlciBvbi4uLlxuICAgICAgICB2YXIgaWR4ID0gSUNBTC5oZWxwZXJzLmJpbnNlYXJjaEluc2VydChcbiAgICAgICAgICB0aGlzLnJhbmdlRXhjZXB0aW9ucyxcbiAgICAgICAgICBpdGVtLFxuICAgICAgICAgIGNvbXBhcmVSYW5nZUV4Y2VwdGlvblxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMucmFuZ2VFeGNlcHRpb25zLnNwbGljZShpZHgsIDAsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhpcyByZWNvcmQgaXMgYW4gZXhjZXB0aW9uIGFuZCBoYXMgdGhlIFJBTkdFPVRISVNBTkRGVVRVUkVcbiAgICAgKiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCB3aGVuIGV4Y2VwdGlvbiBpcyB3aXRoaW4gcmFuZ2VcbiAgICAgKi9cbiAgICBtb2RpZmllc0Z1dHVyZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZWN1cnJlbmNlLWlkJykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmNvbXBvbmVudC5nZXRGaXJzdFByb3BlcnR5KCdyZWN1cnJlbmNlLWlkJykuZ2V0UGFyYW1ldGVyKCdyYW5nZScpO1xuICAgICAgcmV0dXJuIHJhbmdlID09PSB0aGlzLlRISVNBTkRGVVRVUkU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSByYW5nZSBleGNlcHRpb24gbmVhcmVzdCB0byB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSB0aW1lIHVzdWFsbHkgYW4gb2NjdXJyZW5jZSB0aW1lIG9mIGFuIGV2ZW50XG4gICAgICogQHJldHVybiB7P0lDQUwuRXZlbnR9IHRoZSByZWxhdGVkIGV2ZW50L2V4Y2VwdGlvbiBvciBudWxsXG4gICAgICovXG4gICAgZmluZFJhbmdlRXhjZXB0aW9uOiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICBpZiAoIXRoaXMucmFuZ2VFeGNlcHRpb25zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHV0YyA9IHRpbWUudG9Vbml4VGltZSgpO1xuICAgICAgdmFyIGlkeCA9IElDQUwuaGVscGVycy5iaW5zZWFyY2hJbnNlcnQoXG4gICAgICAgIHRoaXMucmFuZ2VFeGNlcHRpb25zLFxuICAgICAgICBbdXRjXSxcbiAgICAgICAgY29tcGFyZVJhbmdlRXhjZXB0aW9uXG4gICAgICApO1xuXG4gICAgICBpZHggLT0gMTtcblxuICAgICAgLy8gb2NjdXJzIGJlZm9yZVxuICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZUl0ZW0gPSB0aGlzLnJhbmdlRXhjZXB0aW9uc1tpZHhdO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrIG9ubHkgKi9cbiAgICAgIGlmICh1dGMgPCByYW5nZUl0ZW1bMF0pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByYW5nZUl0ZW1bMV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0IGlzIHJldHVybmVkIGJ5IHtAbGluayBJQ0FMLkV2ZW50I2dldE9jY3VycmVuY2VEZXRhaWxzIGdldE9jY3VycmVuY2VEZXRhaWxzfVxuICAgICAqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gb2NjdXJyZW5jZURldGFpbHNcbiAgICAgKiBAbWVtYmVyb2YgSUNBTC5FdmVudFxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5UaW1lfSByZWN1cnJlbmNlSWQgICAgICAgVGhlIHBhc3NlZCBpbiByZWN1cnJlbmNlIGlkXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLkV2ZW50fSBpdGVtICAgICAgICAgICAgICBUaGUgb2NjdXJyZW5jZVxuICAgICAqIEBwcm9wZXJ0eSB7SUNBTC5UaW1lfSBzdGFydERhdGUgICAgICAgICAgVGhlIHN0YXJ0IG9mIHRoZSBvY2N1cnJlbmNlXG4gICAgICogQHByb3BlcnR5IHtJQ0FMLlRpbWV9IGVuZERhdGUgICAgICAgICAgICBUaGUgZW5kIG9mIHRoZSBvY2N1cnJlbmNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvY2N1cnJlbmNlIGRldGFpbHMgYmFzZWQgb24gaXRzIHN0YXJ0IHRpbWUuICBJZiB0aGVcbiAgICAgKiBvY2N1cnJlbmNlIGhhcyBhbiBleGNlcHRpb24gd2lsbCByZXR1cm4gdGhlIGRldGFpbHMgZm9yIHRoYXQgZXhjZXB0aW9uLlxuICAgICAqXG4gICAgICogTk9URTogdGhpcyBtZXRob2QgaXMgaW50ZW5kIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb25cbiAgICAgKiAgICAgICB3aXRoIHRoZSB7QGxpbmsgSUNBTC5FdmVudCNpdGVyYXRvciBpdGVyYXRvcn0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IG9jY3VycmVuY2UgdGltZSBvY2N1cnJlbmNlXG4gICAgICogQHJldHVybiB7SUNBTC5FdmVudC5vY2N1cnJlbmNlRGV0YWlsc30gSW5mb3JtYXRpb24gYWJvdXQgdGhlIG9jY3VycmVuY2VcbiAgICAgKi9cbiAgICBnZXRPY2N1cnJlbmNlRGV0YWlsczogZnVuY3Rpb24ob2NjdXJyZW5jZSkge1xuICAgICAgdmFyIGlkID0gb2NjdXJyZW5jZS50b1N0cmluZygpO1xuICAgICAgdmFyIHV0Y0lkID0gb2NjdXJyZW5jZS5jb252ZXJ0VG9ab25lKElDQUwuVGltZXpvbmUudXRjVGltZXpvbmUpLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgaXRlbTtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIC8vWFhYOiBDbG9uZT9cbiAgICAgICAgcmVjdXJyZW5jZUlkOiBvY2N1cnJlbmNlXG4gICAgICB9O1xuXG4gICAgICBpZiAoaWQgaW4gdGhpcy5leGNlcHRpb25zKSB7XG4gICAgICAgIGl0ZW0gPSByZXN1bHQuaXRlbSA9IHRoaXMuZXhjZXB0aW9uc1tpZF07XG4gICAgICAgIHJlc3VsdC5zdGFydERhdGUgPSBpdGVtLnN0YXJ0RGF0ZTtcbiAgICAgICAgcmVzdWx0LmVuZERhdGUgPSBpdGVtLmVuZERhdGU7XG4gICAgICAgIHJlc3VsdC5pdGVtID0gaXRlbTtcbiAgICAgIH0gZWxzZSBpZiAodXRjSWQgaW4gdGhpcy5leGNlcHRpb25zKSB7XG4gICAgICAgIGl0ZW0gPSB0aGlzLmV4Y2VwdGlvbnNbdXRjSWRdO1xuICAgICAgICByZXN1bHQuc3RhcnREYXRlID0gaXRlbS5zdGFydERhdGU7XG4gICAgICAgIHJlc3VsdC5lbmREYXRlID0gaXRlbS5lbmREYXRlO1xuICAgICAgICByZXN1bHQuaXRlbSA9IGl0ZW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByYW5nZSBleGNlcHRpb25zIChSQU5HRT1USElTQU5ERlVUVVJFKSBoYXZlIGFcbiAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgdGhlbiBkaXJlY3QgZXhjZXB0aW9ucyBidXRcbiAgICAgICAgLy8gbXVzdCBiZSBhY2NvdW50ZWQgZm9yIGZpcnN0LiBUaGVpciBpdGVtIGlzXG4gICAgICAgIC8vIGFsd2F5cyB0aGUgZmlyc3QgZXhjZXB0aW9uIHdpdGggdGhlIHJhbmdlIHByb3AuXG4gICAgICAgIHZhciByYW5nZUV4Y2VwdGlvbklkID0gdGhpcy5maW5kUmFuZ2VFeGNlcHRpb24oXG4gICAgICAgICAgb2NjdXJyZW5jZVxuICAgICAgICApO1xuICAgICAgICB2YXIgZW5kO1xuXG4gICAgICAgIGlmIChyYW5nZUV4Y2VwdGlvbklkKSB7XG4gICAgICAgICAgdmFyIGV4Y2VwdGlvbiA9IHRoaXMuZXhjZXB0aW9uc1tyYW5nZUV4Y2VwdGlvbklkXTtcblxuICAgICAgICAgIC8vIHJhbmdlIGV4Y2VwdGlvbiBtdXN0IG1vZGlmeSBzdGFuZGFyZCB0aW1lXG4gICAgICAgICAgLy8gYnkgdGhlIGRpZmZlcmVuY2UgKGlmIGFueSkgaW4gc3RhcnQvZW5kIHRpbWVzLlxuICAgICAgICAgIHJlc3VsdC5pdGVtID0gZXhjZXB0aW9uO1xuXG4gICAgICAgICAgdmFyIHN0YXJ0RGlmZiA9IHRoaXMuX3JhbmdlRXhjZXB0aW9uQ2FjaGVbcmFuZ2VFeGNlcHRpb25JZF07XG5cbiAgICAgICAgICBpZiAoIXN0YXJ0RGlmZikge1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gZXhjZXB0aW9uLnJlY3VycmVuY2VJZC5jbG9uZSgpO1xuICAgICAgICAgICAgdmFyIG5ld1N0YXJ0ID0gZXhjZXB0aW9uLnN0YXJ0RGF0ZS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAvLyB6b25lcyBtdXN0IGJlIHNhbWUgb3RoZXJ3aXNlIHN1YnRyYWN0IG1heSBiZSBpbmNvcnJlY3QuXG4gICAgICAgICAgICBvcmlnaW5hbC56b25lID0gbmV3U3RhcnQuem9uZTtcbiAgICAgICAgICAgIHN0YXJ0RGlmZiA9IG5ld1N0YXJ0LnN1YnRyYWN0RGF0ZShvcmlnaW5hbCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JhbmdlRXhjZXB0aW9uQ2FjaGVbcmFuZ2VFeGNlcHRpb25JZF0gPSBzdGFydERpZmY7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gb2NjdXJyZW5jZS5jbG9uZSgpO1xuICAgICAgICAgIHN0YXJ0LnpvbmUgPSBleGNlcHRpb24uc3RhcnREYXRlLnpvbmU7XG4gICAgICAgICAgc3RhcnQuYWRkRHVyYXRpb24oc3RhcnREaWZmKTtcblxuICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCk7XG4gICAgICAgICAgZW5kLmFkZER1cmF0aW9uKGV4Y2VwdGlvbi5kdXJhdGlvbik7XG5cbiAgICAgICAgICByZXN1bHQuc3RhcnREYXRlID0gc3RhcnQ7XG4gICAgICAgICAgcmVzdWx0LmVuZERhdGUgPSBlbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbm8gcmFuZ2UgZXhjZXB0aW9uIHN0YW5kYXJkIGV4cGFuc2lvblxuICAgICAgICAgIGVuZCA9IG9jY3VycmVuY2UuY2xvbmUoKTtcbiAgICAgICAgICBlbmQuYWRkRHVyYXRpb24odGhpcy5kdXJhdGlvbik7XG5cbiAgICAgICAgICByZXN1bHQuZW5kRGF0ZSA9IGVuZDtcbiAgICAgICAgICByZXN1bHQuc3RhcnREYXRlID0gb2NjdXJyZW5jZTtcbiAgICAgICAgICByZXN1bHQuaXRlbSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgcmVjdXIgZXhwYW5zaW9uIGluc3RhbmNlIGZvciBhIHNwZWNpZmljIHBvaW50IGluIHRpbWUgKGRlZmF1bHRzXG4gICAgICogdG8gc3RhcnREYXRlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SUNBTC5UaW1lfSBzdGFydFRpbWUgICAgIFN0YXJ0aW5nIHBvaW50IGZvciBleHBhbnNpb25cbiAgICAgKiBAcmV0dXJuIHtJQ0FMLlJlY3VyRXhwYW5zaW9ufSAgICBFeHBhbnNpb24gb2JqZWN0XG4gICAgICovXG4gICAgaXRlcmF0b3I6IGZ1bmN0aW9uKHN0YXJ0VGltZSkge1xuICAgICAgcmV0dXJuIG5ldyBJQ0FMLlJlY3VyRXhwYW5zaW9uKHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLmNvbXBvbmVudCxcbiAgICAgICAgZHRzdGFydDogc3RhcnRUaW1lIHx8IHRoaXMuc3RhcnREYXRlXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBldmVudCBpcyByZWN1cnJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBUcnVlLCBpZiBldmVudCBpcyByZWN1cnJpbmdcbiAgICAgKi9cbiAgICBpc1JlY3VycmluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tcCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgcmV0dXJuIGNvbXAuaGFzUHJvcGVydHkoJ3JydWxlJykgfHwgY29tcC5oYXNQcm9wZXJ0eSgncmRhdGUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBldmVudCBkZXNjcmliZXMgYSByZWN1cnJlbmNlIGV4Y2VwdGlvbi4gU2VlXG4gICAgICoge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICBUcnVlLCBpZiB0aGUgZXZlbnQgZGVzY3JpYmVzIGEgcmVjdXJyZW5jZSBleGNlcHRpb25cbiAgICAgKi9cbiAgICBpc1JlY3VycmVuY2VFeGNlcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdyZWN1cnJlbmNlLWlkJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHR5cGVzIG9mIHJlY3VycmVuY2VzIHRoaXMgZXZlbnQgbWF5IGhhdmUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5lZCBhcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBvc3NpYmxlIGtleXM6XG4gICAgICpcbiAgICAgKiAgICAtIFlFQVJMWVxuICAgICAqICAgIC0gTU9OVEhMWVxuICAgICAqICAgIC0gV0VFS0xZXG4gICAgICogICAgLSBEQUlMWVxuICAgICAqICAgIC0gTUlOVVRFTFlcbiAgICAgKiAgICAtIFNFQ09ORExZXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtPYmplY3QuPElDQUwuUmVjdXIuZnJlcXVlbmN5VmFsdWVzLCBCb29sZWFuPn1cbiAgICAgKiAgICAgICAgICBPYmplY3Qgb2YgcmVjdXJyZW5jZSBmbGFnc1xuICAgICAqL1xuICAgIGdldFJlY3VycmVuY2VUeXBlczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcnVsZXMgPSB0aGlzLmNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKCdycnVsZScpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHJ1bGVzLmxlbmd0aDtcbiAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJ1bGVzW2ldLmdldEZpcnN0VmFsdWUoKTtcbiAgICAgICAgcmVzdWx0W3ZhbHVlLmZyZXFdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHVpZCBvZiB0aGlzIGV2ZW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgdWlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgndWlkJyk7XG4gICAgfSxcblxuICAgIHNldCB1aWQodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ3VpZCcsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0YXJ0IGRhdGVcbiAgICAgKiBAdHlwZSB7SUNBTC5UaW1lfVxuICAgICAqL1xuICAgIGdldCBzdGFydERhdGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdkdHN0YXJ0Jyk7XG4gICAgfSxcblxuICAgIHNldCBzdGFydERhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFRpbWUoJ2R0c3RhcnQnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgZGF0ZS4gVGhpcyBjYW4gYmUgdGhlIHJlc3VsdCBkaXJlY3RseSBmcm9tIHRoZSBwcm9wZXJ0eSwgb3IgdGhlXG4gICAgICogZW5kIGRhdGUgY2FsY3VsYXRlZCBmcm9tIHN0YXJ0IGRhdGUgYW5kIGR1cmF0aW9uLiBTZXR0aW5nIHRoZSBwcm9wZXJ0eVxuICAgICAqIHdpbGwgcmVtb3ZlIGFueSBkdXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgICAqIEB0eXBlIHtJQ0FMLlRpbWV9XG4gICAgICovXG4gICAgZ2V0IGVuZERhdGUoKSB7XG4gICAgICB2YXIgZW5kRGF0ZSA9IHRoaXMuX2ZpcnN0UHJvcCgnZHRlbmQnKTtcbiAgICAgIGlmICghZW5kRGF0ZSkge1xuICAgICAgICAgIHZhciBkdXJhdGlvbiA9IHRoaXMuX2ZpcnN0UHJvcCgnZHVyYXRpb24nKTtcbiAgICAgICAgICBlbmREYXRlID0gdGhpcy5zdGFydERhdGUuY2xvbmUoKTtcbiAgICAgICAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgZW5kRGF0ZS5hZGREdXJhdGlvbihkdXJhdGlvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmREYXRlLmlzRGF0ZSkge1xuICAgICAgICAgICAgICBlbmREYXRlLmRheSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmREYXRlO1xuICAgIH0sXG5cbiAgICBzZXQgZW5kRGF0ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuY29tcG9uZW50Lmhhc1Byb3BlcnR5KCdkdXJhdGlvbicpKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50LnJlbW92ZVByb3BlcnR5KCdkdXJhdGlvbicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0VGltZSgnZHRlbmQnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBkdXJhdGlvbi4gVGhpcyBjYW4gYmUgdGhlIHJlc3VsdCBkaXJlY3RseSBmcm9tIHRoZSBwcm9wZXJ0eSwgb3IgdGhlXG4gICAgICogZHVyYXRpb24gY2FsY3VsYXRlZCBmcm9tIHN0YXJ0IGRhdGUgYW5kIGVuZCBkYXRlLiBTZXR0aW5nIHRoZSBwcm9wZXJ0eVxuICAgICAqIHdpbGwgcmVtb3ZlIGFueSBgZHRlbmRgIHByb3BlcnRpZXMuXG4gICAgICogQHR5cGUge0lDQUwuRHVyYXRpb259XG4gICAgICovXG4gICAgZ2V0IGR1cmF0aW9uKCkge1xuICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy5fZmlyc3RQcm9wKCdkdXJhdGlvbicpO1xuICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmREYXRlLnN1YnRyYWN0RGF0ZVR6KHRoaXMuc3RhcnREYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICB9LFxuXG4gICAgc2V0IGR1cmF0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5jb21wb25lbnQuaGFzUHJvcGVydHkoJ2R0ZW5kJykpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQucmVtb3ZlUHJvcGVydHkoJ2R0ZW5kJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFByb3AoJ2R1cmF0aW9uJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYXRpb24gb2YgdGhlIGV2ZW50LlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGxvY2F0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgnbG9jYXRpb24nKTtcbiAgICB9LFxuXG4gICAgc2V0IGxvY2F0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0UHJvcCgnbG9jYXRpb24nLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBhdHRlbmRlZXMgaW4gdGhlIGV2ZW50XG4gICAgICogQHR5cGUge0lDQUwuUHJvcGVydHlbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgYXR0ZW5kZWVzKCkge1xuICAgICAgLy9YWFg6IFRoaXMgaXMgd2F5IGxhbWUgd2Ugc2hvdWxkIGhhdmUgYSBiZXR0ZXJcbiAgICAgIC8vICAgICBkYXRhIHN0cnVjdHVyZSBmb3IgdGhpcyBsYXRlci5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5nZXRBbGxQcm9wZXJ0aWVzKCdhdHRlbmRlZScpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBzdW1tYXJ5XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgc3VtbWFyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ3N1bW1hcnknKTtcbiAgICB9LFxuXG4gICAgc2V0IHN1bW1hcnkodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ3N1bW1hcnknLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBkZXNjcmlwdGlvbi5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ2Rlc2NyaXB0aW9uJyk7XG4gICAgfSxcblxuICAgIHNldCBkZXNjcmlwdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnZGVzY3JpcHRpb24nLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCBjb2xvciBmcm9tIFtyZmM3OTg2XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzc5ODYpXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgY29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlyc3RQcm9wKCdjb2xvcicpO1xuICAgIH0sXG5cbiAgICBzZXQgY29sb3IodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldFByb3AoJ2NvbG9yJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3JnYW5pemVyIHZhbHVlIGFzIGFuIHVyaS4gSW4gbW9zdCBjYXNlcyB0aGlzIGlzIGEgbWFpbHRvOiB1cmksIGJ1dFxuICAgICAqIGl0IGNhbiBhbHNvIGJlIHNvbWV0aGluZyBlbHNlLCBsaWtlIHVybjp1dWlkOi4uLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IG9yZ2FuaXplcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ29yZ2FuaXplcicpO1xuICAgIH0sXG5cbiAgICBzZXQgb3JnYW5pemVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRQcm9wKCdvcmdhbml6ZXInLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZXF1ZW5jZSB2YWx1ZSBmb3IgdGhpcyBldmVudC4gVXNlZCBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHNlZSB7QHR1dG9yaWFsIHRlcm1pbm9sb2d5fS5cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzZXF1ZW5jZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maXJzdFByb3AoJ3NlcXVlbmNlJyk7XG4gICAgfSxcblxuICAgIHNldCBzZXF1ZW5jZSh2YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0UHJvcCgnc2VxdWVuY2UnLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWN1cnJlbmNlIGlkIGZvciB0aGlzIGV2ZW50LiBTZWUge0B0dXRvcmlhbCB0ZXJtaW5vbG9neX0gZm9yIGRldGFpbHMuXG4gICAgICogQHR5cGUge0lDQUwuVGltZX1cbiAgICAgKi9cbiAgICBnZXQgcmVjdXJyZW5jZUlkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpcnN0UHJvcCgncmVjdXJyZW5jZS1pZCcpO1xuICAgIH0sXG5cbiAgICBzZXQgcmVjdXJyZW5jZUlkKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRUaW1lKCdyZWN1cnJlbmNlLWlkJywgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQvdXBkYXRlIGEgdGltZSBwcm9wZXJ0eSdzIHZhbHVlLlxuICAgICAqIFRoaXMgd2lsbCBhbHNvIHVwZGF0ZSB0aGUgVFpJRCBvZiB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUT0RPOiB0aGlzIG1ldGhvZCBoYW5kbGVzIHRoZSBjYXNlIHdoZXJlIHdlIGFyZSBzd2l0Y2hpbmdcbiAgICAgKiBmcm9tIGEga25vd24gdGltZXpvbmUgdG8gYW4gaW1wbGllZCB0aW1lem9uZSAob25lIHdpdGhvdXQgVFpJRCkuXG4gICAgICogVGhpcyBkb2VzIF9ub3RfIGhhbmRsZSB0aGUgY2FzZSBvZiBtb3ZpbmcgYmV0d2VlbiBhIGtub3duXG4gICAgICogIChieSBUaW1lem9uZVNlcnZpY2UpIHRpbWV6b25lIHRvIGFuIHVua25vd24gdGltZXpvbmUuLi5cbiAgICAgKlxuICAgICAqIFdlIHdpbGwgbm90IGFkZC9yZW1vdmUvdXBkYXRlIHRoZSBWVElNRVpPTkUgc3ViY29tcG9uZW50c1xuICAgICAqICBsZWFkaW5nIHRvIGludmFsaWQgSUNBTCBkYXRhLi4uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWUgICAgIFRoZSBwcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV9IHRpbWUgICAgICBUaGUgdGltZSB0byBzZXRcbiAgICAgKi9cbiAgICBfc2V0VGltZTogZnVuY3Rpb24ocHJvcE5hbWUsIHRpbWUpIHtcbiAgICAgIHZhciBwcm9wID0gdGhpcy5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eShwcm9wTmFtZSk7XG5cbiAgICAgIGlmICghcHJvcCkge1xuICAgICAgICBwcm9wID0gbmV3IElDQUwuUHJvcGVydHkocHJvcE5hbWUpO1xuICAgICAgICB0aGlzLmNvbXBvbmVudC5hZGRQcm9wZXJ0eShwcm9wKTtcbiAgICAgIH1cblxuICAgICAgLy8gdXRjIGFuZCBsb2NhbCBkb24ndCBnZXQgYSB0emlkXG4gICAgICBpZiAoXG4gICAgICAgIHRpbWUuem9uZSA9PT0gSUNBTC5UaW1lem9uZS5sb2NhbFRpbWV6b25lIHx8XG4gICAgICAgIHRpbWUuem9uZSA9PT0gSUNBTC5UaW1lem9uZS51dGNUaW1lem9uZVxuICAgICAgKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdHppZFxuICAgICAgICBwcm9wLnJlbW92ZVBhcmFtZXRlcigndHppZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5zZXRQYXJhbWV0ZXIoJ3R6aWQnLCB0aW1lLnpvbmUudHppZCk7XG4gICAgICB9XG5cbiAgICAgIHByb3Auc2V0VmFsdWUodGltZSk7XG4gICAgfSxcblxuICAgIF9zZXRQcm9wOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgdGhpcy5jb21wb25lbnQudXBkYXRlUHJvcGVydHlXaXRoVmFsdWUobmFtZSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBfZmlyc3RQcm9wOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgZXZlbnQuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC50b1N0cmluZygpO1xuICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIGNvbXBhcmVSYW5nZUV4Y2VwdGlvbihhLCBiKSB7XG4gICAgaWYgKGFbMF0gPiBiWzBdKSByZXR1cm4gMTtcbiAgICBpZiAoYlswXSA+IGFbMF0pIHJldHVybiAtMTtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiBFdmVudDtcbn0oKSk7XG4vKiBUaGlzIFNvdXJjZSBDb2RlIEZvcm0gaXMgc3ViamVjdCB0byB0aGUgdGVybXMgb2YgdGhlIE1vemlsbGEgUHVibGljXG4gKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gKiBmaWxlLCBZb3UgY2FuIG9idGFpbiBvbmUgYXQgaHR0cDovL21vemlsbGEub3JnL01QTC8yLjAvLlxuICogUG9ydGlvbnMgQ29weXJpZ2h0IChDKSBQaGlsaXBwIEtld2lzY2gsIDIwMTEtMjAxNSAqL1xuXG5cbi8qKlxuICogVGhpcyBzeW1ib2wgaXMgZnVydGhlciBkZXNjcmliZWQgbGF0ZXIgb25cbiAqIEBpZ25vcmVcbiAqL1xuSUNBTC5Db21wb25lbnRQYXJzZXIgPSAoZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBAY2xhc3NkZXNjXG4gICAqIFRoZSBDb21wb25lbnRQYXJzZXIgaXMgdXNlZCB0byBwcm9jZXNzIGEgU3RyaW5nIG9yIGpDYWwgT2JqZWN0LFxuICAgKiBmaXJpbmcgY2FsbGJhY2tzIGZvciB2YXJpb3VzIGZvdW5kIGNvbXBvbmVudHMsIGFzIHdlbGwgYXMgY29tcGxldGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIG9wdGlvbnMgPSB7XG4gICAqICAgLy8gd2hlbiBmYWxzZSBubyBldmVudHMgd2lsbCBiZSBlbWl0dGVkIGZvciB0eXBlXG4gICAqICAgcGFyc2VFdmVudDogdHJ1ZSxcbiAgICogICBwYXJzZVRpbWV6b25lOiB0cnVlXG4gICAqIH07XG4gICAqXG4gICAqIHZhciBwYXJzZXIgPSBuZXcgSUNBTC5Db21wb25lbnRQYXJzZXIob3B0aW9ucyk7XG4gICAqXG4gICAqIHBhcnNlci5vbmV2ZW50KGV2ZW50Q29tcG9uZW50KSB7XG4gICAqICAgLy8uLi5cbiAgICogfVxuICAgKlxuICAgKiAvLyBvbnRpbWV6b25lLCBldGMuLi5cbiAgICpcbiAgICogcGFyc2VyLm9uY29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICpcbiAgICogfTtcbiAgICpcbiAgICogcGFyc2VyLnByb2Nlc3Moc3RyaW5nT3JDb21wb25lbnQpO1xuICAgKlxuICAgKiBAY2xhc3NcbiAgICogQGFsaWFzIElDQUwuQ29tcG9uZW50UGFyc2VyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAgICAgICAgQ29tcG9uZW50IHBhcnNlciBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5wYXJzZUV2ZW50ICAgICAgICBXaGV0aGVyIGV2ZW50cyBzaG91bGQgYmUgcGFyc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5wYXJzZVRpbWV6ZW9uZSAgICBXaGV0aGVyIHRpbWV6b25lcyBzaG91bGQgYmUgcGFyc2VkXG4gICAqL1xuICBmdW5jdGlvbiBDb21wb25lbnRQYXJzZXIob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Yob3B0aW9ucykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIGtleTtcbiAgICBmb3IgKGtleSBpbiBvcHRpb25zKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgQ29tcG9uZW50UGFyc2VyLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSwgcGFyc2UgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBwYXJzZUV2ZW50OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0cnVlLCBwYXJzZSB0aW1lem9uZXNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHBhcnNlVGltZXpvbmU6IHRydWUsXG5cblxuICAgIC8qIFNBWCBsaWtlIGV2ZW50cyBoZXJlIGZvciByZWZlcmVuY2UgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gcGFyc2luZyBpcyBjb21wbGV0ZVxuICAgICAqIEBjYWxsYmFja1xuICAgICAqL1xuICAgIG9uY29tcGxldGU6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCBpZiBhbiBlcnJvciBvY2N1cnMgZHVyaW5nIHBhcnNpbmcuXG4gICAgICpcbiAgICAgKiBAY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgZGV0YWlscyBvZiBlcnJvclxuICAgICAqL1xuICAgIG9uZXJyb3I6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKGVycikge30sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgdG9wIGxldmVsIGNvbXBvbmVudCAoVlRJTUVaT05FKSBpcyBmb3VuZFxuICAgICAqXG4gICAgICogQGNhbGxiYWNrXG4gICAgICogQHBhcmFtIHtJQ0FMLlRpbWV6b25lfSBjb21wb25lbnQgICAgIFRpbWV6b25lIG9iamVjdFxuICAgICAqL1xuICAgIG9udGltZXpvbmU6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uKGNvbXBvbmVudCkge30sXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGEgdG9wIGxldmVsIGNvbXBvbmVudCAoVkVWRU5UKSBpcyBmb3VuZC5cbiAgICAgKlxuICAgICAqIEBjYWxsYmFja1xuICAgICAqIEBwYXJhbSB7SUNBTC5FdmVudH0gY29tcG9uZW50ICAgIFRvcCBsZXZlbCBjb21wb25lbnRcbiAgICAgKi9cbiAgICBvbmV2ZW50OiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbihjb21wb25lbnQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHN0cmluZyBvciBwYXJzZSBpY2FsIG9iamVjdC4gIFRoaXMgZnVuY3Rpb24gaXRzZWxmIHdpbGwgcmV0dXJuXG4gICAgICogbm90aGluZyBidXQgd2lsbCBzdGFydCB0aGUgcGFyc2luZyBwcm9jZXNzLlxuICAgICAqXG4gICAgICogRXZlbnRzIG11c3QgYmUgcmVnaXN0ZXJlZCBwcmlvciB0byBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJQ0FMLkNvbXBvbmVudHxTdHJpbmd8T2JqZWN0fSBpY2FsICAgICAgVGhlIGNvbXBvbmVudCB0byBwcm9jZXNzLFxuICAgICAqICAgICAgICBlaXRoZXIgaW4gaXRzIGZpbmFsIGZvcm0sIGFzIGEgakNhbCBPYmplY3QsIG9yIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGljYWwpIHtcbiAgICAgIC8vVE9ETzogdGhpcyBpcyBzeW5jIG5vdyBpbiB0aGUgZnV0dXJlIHdlIHdpbGwgaGF2ZSBhIGluY3JlbWVudGFsIHBhcnNlci5cbiAgICAgIGlmICh0eXBlb2YoaWNhbCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGljYWwgPSBJQ0FMLnBhcnNlKGljYWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShpY2FsIGluc3RhbmNlb2YgSUNBTC5Db21wb25lbnQpKSB7XG4gICAgICAgIGljYWwgPSBuZXcgSUNBTC5Db21wb25lbnQoaWNhbCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wb25lbnRzID0gaWNhbC5nZXRBbGxTdWJjb21wb25lbnRzKCk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICB2YXIgY29tcG9uZW50O1xuXG4gICAgICBmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG5cbiAgICAgICAgc3dpdGNoIChjb21wb25lbnQubmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3Z0aW1lem9uZSc6XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZVRpbWV6b25lKSB7XG4gICAgICAgICAgICAgIHZhciB0emlkID0gY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHlWYWx1ZSgndHppZCcpO1xuICAgICAgICAgICAgICBpZiAodHppZCkge1xuICAgICAgICAgICAgICAgIHRoaXMub250aW1lem9uZShuZXcgSUNBTC5UaW1lem9uZSh7XG4gICAgICAgICAgICAgICAgICB0emlkOiB0emlkLFxuICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ZldmVudCc6XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZUV2ZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMub25ldmVudChuZXcgSUNBTC5FdmVudChjb21wb25lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL1hYWDogaWRlYWxseSB3ZSBzaG91bGQgZG8gYSBcIm5leHRUaWNrXCIgaGVyZVxuICAgICAgLy8gICAgIHNvIGluIGFsbCBjYXNlcyB0aGlzIGlzIGFjdHVhbGx5IGFzeW5jLlxuICAgICAgdGhpcy5vbmNvbXBsZXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBDb21wb25lbnRQYXJzZXI7XG59KCkpO1xuIiwgIi8vIGltcG9ydCB7IEFwcCwgRWRpdG9yLCBNYXJrZG93blZpZXcsIE1vZGFsLCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgSXRlbVZpZXcsIFBsYXRmb3JtLCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgQXBwLCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luTWFuaWZlc3QsIFRGaWxlLCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgQ2FsZW5kYXJWaWV3fSBmcm9tIFwiLi92aWV3cy9DYWxlbmRhclZpZXdcIlxuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tIFwiLi9jYWNoZVwiXG5pbXBvcnQgeyBQbHVnaW5TZXR0aW5ncyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgTXlTZXR0aW5nVGFiIH0gZnJvbSAnLi9zZXR0aW5nJztcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIENBQ0hFX0lELCBNU0dfUExHX05BTUUsIFZJRVdfVFlQRSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBTdGF0dXNDb3JyZWN0b3IgZnJvbSAnLi92aWV3cy9zdGF0dXNDb3JyZWN0b3InO1xuaW1wb3J0IEZpbGVNYW5hZ2VyIGZyb20gJy4vZmlsZU1hbmFnZXInO1xuaW1wb3J0IHsgVGlja0NoZWNrZXIgfSBmcm9tICcuL3ZpZXdzL1RpY2tDaGVrZXInO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcbiAgcHVibGljIGZpbGVNYW5hZ2VyOiBGaWxlTWFuYWdlclxuXG4gIHB1YmxpYyBjYWNoZTogQ2FjaGVcblxuICBwcml2YXRlIHN0YXR1c0NvcnJlY3RvcjogU3RhdHVzQ29ycmVjdG9yXG5cbiAgcHJpdmF0ZSBzZXR0aW5nczogUGx1Z2luU2V0dGluZ3NcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgbWFuaWZlc3Q6IFBsdWdpbk1hbmlmZXN0KSB7XG4gICAgc3VwZXIoYXBwLCBtYW5pZmVzdClcblxuICAgIGNvbnN0IGZpbGVNYW5hZ2VyID0gbmV3IEZpbGVNYW5hZ2VyKHRoaXMpXG4gICAgdGhpcy5maWxlTWFuYWdlciA9IGZpbGVNYW5hZ2VyXG5cbiAgICAvLyBcdTA0NDFcdTA0M0VcdTA0MzdcdTA0MzRcdTA0MzBcdTA0MzJcdTA0MzBcdTA0NDJcdTA0NEMgXHUwNDNGXHUwNDQwXHUwNDM4IG9ubG9hZCBcdTA0MzggXHUwNDQyXHUwNDNFXHUwNDMzXHUwNDM0XHUwNDMwIFx1MDQzNlx1MDQzNSBcdTA0MzdcdTA0MzBcdTA0M0ZcdTA0NDNcdTA0NDFcdTA0M0FcdTA0MzBcdTA0NDJcdTA0NEMgaW5pdFN0b3JhZ2VcbiAgICB0aGlzLmNhY2hlID0gbmV3IENhY2hlKHRoaXMsIGZpbGVNYW5hZ2VyKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIG9ubG9hZCgpIHtcbiAgICBhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpXG5cbiAgICB0aGlzLmluaXRSZWdpc3RlcigpXG5cbiAgICBhd2FpdCBuZXcgVGlja0NoZWNrZXIoQ0FDSEVfSUQuVElDS19DSEVDS0VSLCB0aGlzLnNldHRpbmdzLnNvdXJjZS5ub3RlU291cmNlcywgdGhpcylcblxuICAgIC8vIGlmICh0aGlzLnNldHRpbmdzLnN0YXR1c0NvcnJlY3Rvci5pc09uKSB7XG4gICAgLy8gICB0aGlzLnN0YXR1c0NvcnJlY3RvciA9IG5ldyBTdGF0dXNDb3JyZWN0b3IoQ0FDSEVfSUQuU1RBVFVTX0NPUlJFQ1RPUiwgdGhpcy5zZXR0aW5ncy5zb3VyY2Uubm90ZVNvdXJjZXMsIHRoaXMpXG5cbiAgICAvLyAgIGlmICh0aGlzLnNldHRpbmdzLnN0YXR1c0NvcnJlY3Rvci5zdGFydE9uU3RhcnRVcClcbiAgICAvLyAgICAgdGhpcy5zdGF0dXNDb3JyZWN0b3IuY29ycmVjdEFsbE5vdGVzKClcblxuICAgIC8vICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAvLyAgICAgaWQ6ICdmdWxsU3RhdHVzQ29ycmVjdCcsXG4gICAgLy8gICAgIG5hbWU6IE1TR19QTEdfTkFNRSArICdGdWxsIFN0YXR1c0NvcnJlY3RvcicsXG4gICAgLy8gICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgLy8gICAgICAgdGhpcy5zdGF0dXNDb3JyZWN0b3IuY29ycmVjdEFsbE5vdGVzKClcbiAgICAvLyAgICAgfVxuICAgIC8vICAgfSk7XG4gICAgLy8gfVxuXG4gICAgdGhpcy5yZWdpc3RlclZpZXcoXG4gICAgICAgIFZJRVdfVFlQRSxcbiAgICAgICAgKGxlYWY6IFdvcmtzcGFjZUxlYWYpID0+IG5ldyBDYWxlbmRhclZpZXcoXG4gICAgICAgICAgbGVhZixcbiAgICAgICAgICBDQUNIRV9JRC5DQUxFTkRBUixcbiAgICAgICAgICB0aGlzLnNldHRpbmdzLnNvdXJjZS5ub3RlU291cmNlcyxcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHRoaXMuc2V0dGluZ3Muc291cmNlLmRlZmF1bHRDcmVhdGVQYXRoXG4gICAgICAgIClcbiAgICApXG5cbiAgICB0aGlzLmFkZFJpYmJvbkljb24oXCJpbmZvXCIsIE1TR19QTEdfTkFNRSArIFwiT3BlbiBDYWxlbmRhclwiLCAoKSA9PiB0aGlzLmFjdGl2YXRlVmlldygpKVxuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAncmVzZXQtY2FjaGUnLFxuICAgICAgbmFtZTogTVNHX1BMR19OQU1FICsgJ1Jlc2V0IENhY2hlJyxcbiAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2FjaGUucmVzZXQoKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiAnbG9nLWNhY2hlJyxcbiAgICAgIG5hbWU6IE1TR19QTEdfTkFNRSArICdMb2cgQ2FjaGUnLFxuICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgdGhpcy5jYWNoZS5sb2coKVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIG9udW5sb2FkKCkge1xuICAgIC8vIFRPRE8gXHUwNDNBXHUwNDMwXHUwNDNBIFx1MDQzMVx1MDQ0M1x1MDQzNFx1MDQ0Mlx1MDQzRSBcdTA0MzRcdTA0NDBcdTA0NDNcdTA0MzNcdTA0MzhcdTA0NDUgXHUwNDNEXHUwNDM1IFx1MDQ0NVx1MDQzMlx1MDQzMFx1MDQ0Mlx1MDQzMFx1MDQzNVx1MDQ0MiBkZXN0b3lcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5zdGF0dXNDb3JyZWN0b3IuaXNPbilcbiAgICAgIHRoaXMuc3RhdHVzQ29ycmVjdG9yLmRlc3Ryb3koKVxuICB9XG5cbiAgcHJpdmF0ZSBpbml0UmVnaXN0ZXIoKSB7XG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5vbihcImNoYW5nZWRcIiwgZmlsZSA9PiB7XG4gICAgICAgIHRoaXMuY2FjaGUuY2hhbmdlRmlsZShmaWxlKVxuICAgICAgfSlcbiAgICApXG5cbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgICB0aGlzLmFwcC52YXVsdC5vbihcbiAgICAgICAgXCJyZW5hbWVcIixcbiAgICAgICAgKGZpbGUsIG9sZFBhdGgpID0+IHtcbiAgICAgICAgICAvLyBcdTA0M0ZcdTA0NDBcdTA0M0VcdTA0MzJcdTA0MzVcdTA0NDBcdTA0M0FcdTA0MzAgXHUwNDNEXHUwNDMwIFx1MDQ0Mlx1MDQzRSwgXHUwNDQ3XHUwNDQyXHUwNDNFIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0NDRcdTA0MzBcdTA0MzlcdTA0M0IsIFx1MDQzMCBcdTA0M0RcdTA0MzUgXHUwNDNGXHUwNDMwXHUwNDNGXHUwNDNBXHUwNDMwXG4gICAgICAgICAgaWYgKCEoZmlsZSBhcyBURmlsZSkuYmFzZW5hbWUpXG4gICAgICAgICAgICByZXR1cm5cblxuICAgICAgICAgIHRoaXMuY2FjaGUucmVuYW1lRmlsZShmaWxlIGFzIFRGaWxlLCBvbGRQYXRoKVxuICAgICAgICB9XG4gICAgICApXG4gICAgKVxuXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAudmF1bHQub24oXG4gICAgICAgIFwiZGVsZXRlXCIsXG4gICAgICAgIGZpbGUgPT4gdGhpcy5jYWNoZS5kZWxldGVGaWxlKGZpbGUpXG4gICAgICApXG4gICAgKVxuXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgdGhpcy5hcHAudmF1bHQub24oXG4gICAgICAgIFwiY3JlYXRlXCIsXG4gICAgICAgIGZpbGUgPT4ge1xuICAgICAgICAgIC8vIFx1MDQzRlx1MDQ0MFx1MDQzRVx1MDQzMlx1MDQzNVx1MDQ0MFx1MDQzQVx1MDQzMCBcdTA0M0RcdTA0MzAgXHUwNDQyXHUwNDNFLCBcdTA0NDdcdTA0NDJcdTA0M0UgXHUwNDREXHUwNDQyXHUwNDNFIFx1MDQ0NFx1MDQzMFx1MDQzOVx1MDQzQiwgXHUwNDMwIFx1MDQzRFx1MDQzNSBcdTA0M0ZcdTA0MzBcdTA0M0ZcdTA0M0FcdTA0MzBcbiAgICAgICAgICBpZiAoIShmaWxlIGFzIFRGaWxlKS5iYXNlbmFtZSlcbiAgICAgICAgICAgIHJldHVyblxuXG4gICAgICAgICAgdGhpcy5jYWNoZS5hZGRGaWxlKGZpbGUgYXMgVEZpbGUpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGFjdGl2YXRlVmlldygpIHtcbiAgICBjb25zdCBsZWF2ZXMgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFZJRVdfVFlQRSlcbiAgICBpZiAobGVhdmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICAgIGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHtcbiAgICAgICAgdHlwZTogVklFV19UWVBFLFxuICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICB9KVxuICAgIH1cbiAgICBlbHNlIGlmIChsZWF2ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAobGVhdmVzWzBdLnZpZXcgYXMgQ2FsZW5kYXJWaWV3KS5vbk9wZW4oKVxuICAgICAgdGhpcy5hcHAud29ya3NwYWNlLnNldEFjdGl2ZUxlYWYobGVhdmVzWzBdKVxuICAgIH1cbiAgICBlbHNlIGZvciAobGV0IGxlYWYgb2YgbGVhdmVzKVxuICAgICAgbGVhZi5kZXRhY2goKVxuICB9XG5cblxuICAvLyBTZXR0aW5nc1xuXG4gIHB1YmxpYyBnZXRTZXR0aW5ncygpOiBQbHVnaW5TZXR0aW5ncyB7XG4gICAgLy8gTk9URTogZnVsbCBjb3B5XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoXG4gICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLnNldHRpbmdzKVxuICAgIClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzYXZlU2V0dGluZ3Moc2V0dGluZ3M6IFBsdWdpblNldHRpbmdzKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzXG4gICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgfVxuXG5cblxuICBwcml2YXRlIGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcbiAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKVxuXG4gICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBNeVNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IEl0ZW1WaWV3LCBQbGF0Zm9ybSwgV29ya3NwYWNlTGVhZiwgTm90aWNlLCBNb2RhbCwgQXBwLCBTZXR0aW5nLCBNZW51LCBDb21wb25lbnQgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgTXlQbHVnaW4gZnJvbSBcIi4uL21haW5cIlxuaW1wb3J0IHsgTVNHX1BMR19OQU1FLCBURVhUX0RPTkUsIFZJRVdfVFlQRSB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDYWxlbmRhckV2ZW50LCBDYWxlbmRhclNldHRpbmdzLCBJRXZlbnQsIElQYWdlLCBNeVZpZXcsIFNyYyB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IENhbGVuZGFyRXZlbnRUb0lEYXRlLCBnZXRDb2xvdXJGcm9tUGF0aCwgSURhdGVUb0NhbGVuZGFyRXZlbnQsIG1pbGxpc2VjVG9TdHJpbmcsIHBhZ2VUb0V2ZW50cywgdGVtcGxhdGVJRFRpY2ssIHRlbXBsYXRlTmFtZVRpY2ssIHRpbWVBZGQgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7IHJlbmRlckNhbGVuZGFyIH0gZnJvbSAnbGliL29ic2lkaWFuLWZ1bGwtY2FsZW5kYXIvY2FsZW5kYXInO1xuaW1wb3J0IHsgQ2FsZW5kYXIgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2FjaGUgfSBmcm9tICdzcmMvY2FjaGUnO1xuaW1wb3J0IEZpbGVNYW5hZ2VyIGZyb20gJ3NyYy9maWxlTWFuYWdlcic7XG5cbmV4cG9ydCBjbGFzcyBDYWxlbmRhclZpZXcgZXh0ZW5kcyBJdGVtVmlldyBpbXBsZW1lbnRzIE15VmlldyB7XG4gIC8vIHByaXZhdGUgcGFycmVudFBvaW50ZXI6IE15UGx1Z2luXG5cbiAgcHJpdmF0ZSBjYWNoZTogQ2FjaGVcblxuICBwcml2YXRlIGNhbGVuZGFyOiBDYWxlbmRhciB8IG51bGwgPSBudWxsXG5cbiAgcHJpdmF0ZSBpZEZvckNhY2hlOiBudW1iZXJcblxuICBwcml2YXRlIGV2ZW50X3NyYzogU3JjW11cblxuICBwcml2YXRlIGxvY2FsU3RvcmFnZTogTWFwPHN0cmluZywgSVBhZ2VbXT5cblxuICBwcml2YXRlIHNlbGVjdGVkU3JjUGF0aHM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpXG5cbiAgcHJpdmF0ZSBmaWxlTWFuYWdlcjogRmlsZU1hbmFnZXJcblxuICBwcml2YXRlIGNhbGVuZGFyU2V0dGluZ3M6IENhbGVuZGFyU2V0dGluZ3NcblxuICAvLyBwcml2YXRlIHNyY0NoZWNrYm94Q29udGFpbmVyOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgcGxhY2VGb3JDcmVhdGluZ05vdGU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIGxlYWY6IFdvcmtzcGFjZUxlYWYsXG4gICAgY2FjaGU6IENhY2hlLFxuICAgIGlkRm9yQ2FjaGU6IG51bWJlcixcbiAgICBldmVudF9zcmM6IFNyY1tdLFxuICAgIGNhbGVuZGFyU2V0dGluZ3M6IENhbGVuZGFyU2V0dGluZ3MsXG4gICAgZmlsZU1hbmFnZXI6IEZpbGVNYW5hZ2VyLFxuICAgIHBsYWNlRm9yQ3JlYXRpbmdOb3RlOiBzdHJpbmcsXG4gICAgLy8gcGFycmVudFBvaW50ZXI6IE15UGx1Z2luLFxuICAgIC8vIGJhY2tHcm91bmRFdmVudHM6XG4gICkge1xuICAgIHN1cGVyKGxlYWYpXG5cbiAgICB0aGlzLmNhY2hlID0gY2FjaGVcbiAgICB0aGlzLmlkRm9yQ2FjaGUgPSBpZEZvckNhY2hlXG4gICAgdGhpcy5ldmVudF9zcmMgPSBldmVudF9zcmNcbiAgICB0aGlzLmZpbGVNYW5hZ2VyID0gZmlsZU1hbmFnZXJcbiAgICB0aGlzLmNhbGVuZGFyU2V0dGluZ3MgPSBjYWxlbmRhclNldHRpbmdzXG4gICAgdGhpcy5wbGFjZUZvckNyZWF0aW5nTm90ZSA9IHBsYWNlRm9yQ3JlYXRpbmdOb3RlXG5cbiAgICBmb3IgKGxldCBzcmMgb2YgZXZlbnRfc3JjKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkU3JjUGF0aHMuYWRkKHNyYy5wYXRoKVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRWaWV3VHlwZSgpIHtyZXR1cm4gVklFV19UWVBFfVxuXG4gIHB1YmxpYyBnZXREaXNwbGF5VGV4dCgpIHtyZXR1cm4gXCJDYWxlbmRhclwifVxuXG4gIHB1YmxpYyBhc3luYyBvbk9wZW4oKSB7XG4gICAgaWYgKFBsYXRmb3JtLmlzTW9iaWxlKVxuICAgICAgdGhpcy5jb250YWluZXJFbC5zdHlsZS5oZWlnaHQgPSBcIjk1dmhcIlxuXG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXSAvLyBUT0RPIFx1MDQ0N1x1MDQ0Mlx1MDQzRSBcdTA0MzdcdTA0MzAgXHUwNDM0XHUwNDM1XHUwNDQyXHUwNDM4IChcdTA0NDdcdTA0NDJcdTA0M0UgXHUwNDMyIFx1MDQzNFx1MDQ0MFx1MDQ0M1x1MDQzM1x1MDQzOFx1MDQ0NSBcdTA0MzhcdTA0M0RcdTA0MzRcdTA0MzVcdTA0M0FcdTA0NDFcdTA0MzBcdTA0NDU/KVxuICAgIGNvbnRhaW5lci5lbXB0eSgpXG5cbiAgICAvLyBcdTA0MjFcdTA0M0VcdTA0MzdcdTA0MzRcdTA0MzBcdTA0MzVcdTA0M0MgXHUwNDNBXHUwNDNFXHUwNDNEXHUwNDQyXHUwNDM1XHUwNDM5XHUwNDNEXHUwNDM1XHUwNDQwIFx1MDQzNFx1MDQzQlx1MDQ0RiBcdTA0NDdcdTA0MzVcdTA0M0FcdTA0MzFcdTA0M0VcdTA0M0FcdTA0NDFcdTA0M0VcdTA0MzJcbiAgICAvLyB0aGlzLnNyY0NoZWNrYm94Q29udGFpbmVyID0gY29udGFpbmVyLmNyZWF0ZURpdih7Y2xzOiAnY2FsZW5kYXItc3JjLWNoZWNrYm94ZXMnfSlcblxuICAgIHRoaXMucmVuZGVyKGNvbnRhaW5lcilcbiAgICAvLyAudGhlbihcbiAgICAgIC8vICgpID0+IHRoaXMucmVuZGVyU3JjQ2hlY2tib3hlcygpXG4gICAgLy8gKVxuICB9XG5cbiAgcHVibGljIG9uUmVzaXplKCkge1xuICAgIHRoaXMuY2FsZW5kYXI/LnJlbmRlcigpO1xuICB9XG5cbiAgcHVibGljIGFkZEZpbGUocGFnZTogSVBhZ2UpOiB2b2lkIHtcbiAgICAvLyBcdTA0MUZcdTA0NDBcdTA0M0VcdTA0MzJcdTA0MzVcdTA0NDBcdTA0NEZcdTA0MzVcdTA0M0MsIFx1MDQ0MVx1MDQzRVx1MDQzRVx1MDQ0Mlx1MDQzMlx1MDQzNVx1MDQ0Mlx1MDQ0MVx1MDQ0Mlx1MDQzMlx1MDQ0M1x1MDQzNVx1MDQ0MiBcdTA0M0JcdTA0MzggXHUwNDNGXHUwNDQzXHUwNDQyXHUwNDRDIFx1MDQ0MVx1MDQ0Mlx1MDQ0MFx1MDQzMFx1MDQzRFx1MDQzOFx1MDQ0Nlx1MDQ0QiBcdTA0MzJcdTA0NEJcdTA0MzFcdTA0NDBcdTA0MzBcdTA0M0RcdTA0M0RcdTA0NEJcdTA0M0MgXHUwNDM4XHUwNDQxXHUwNDQyXHUwNDNFXHUwNDQ3XHUwNDNEXHUwNDM4XHUwNDNBXHUwNDMwXHUwNDNDXG4gICAgaWYgKCF0aGlzLmlzUGFnZUluU2VsZWN0ZWRTcmMocGFnZS5maWxlLnBhdGgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBldmVudHMgPSBwYWdlVG9FdmVudHMocGFnZSlcbiAgICBmb3IgKGxldCBldmVudCBvZiBldmVudHMpXG4gICAgICB0aGlzLmNhbGVuZGFyPy5hZGRFdmVudChldmVudClcbiAgfVxuXG4gIHB1YmxpYyBjaGFuZ2VGaWxlKG5ld1BhZ2U6IElQYWdlLCBvbGRQYWdlOiBJUGFnZSk6IHZvaWQge1xuICAgIHRoaXMuY2FsZW5kYXI/LnBhdXNlUmVuZGVyaW5nKClcbiAgICB0aGlzLmRlbGV0ZUZpbGUob2xkUGFnZSlcbiAgICB0aGlzLmFkZEZpbGUobmV3UGFnZSlcbiAgICB0aGlzLmNhbGVuZGFyPy5yZXN1bWVSZW5kZXJpbmcoKVxuICB9XG5cbiAgcHVibGljIHJlbmFtZUZpbGUobmV3UGFnZTogSVBhZ2UsIG9sZFBhZ2U6IElQYWdlKTogdm9pZCB7XG4gICAgdGhpcy5jaGFuZ2VGaWxlKG5ld1BhZ2UsIG9sZFBhZ2UpXG4gIH1cblxuICBwdWJsaWMgZGVsZXRlRmlsZShwYWdlOiBJUGFnZSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5jYWxlbmRhcilcbiAgICAgIHJldHVyblxuXG4gICAgdGhpcy5jYWxlbmRhci5nZXRFdmVudEJ5SWQocGFnZS5maWxlLnBhdGgpPy5yZW1vdmUoKVxuXG4gICAgZm9yIChsZXQgdGljayBvZiBwYWdlLnRpY2tzKSB7XG4gICAgICB0aGlzLmNhbGVuZGFyLmdldEV2ZW50QnlJZChcbiAgICAgICAgdGVtcGxhdGVJRFRpY2socGFnZS5maWxlLnBhdGgsIHRpY2submFtZSlcbiAgICAgICk/LnJlbW92ZSgpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIHJlc2V0KCkge1xuICAgIHRoaXMub251bmxvYWQoKVxuICAgIHRoaXMub25PcGVuKClcbiAgfVxuXG4gIG9udW5sb2FkKCkge1xuICAgIGlmICghdGhpcy5jYWxlbmRhcilcbiAgICAgIHJldHVyblxuXG4gICAgdGhpcy5jYWxlbmRhci5kZXN0cm95KCk7XG4gICAgdGhpcy5jYWxlbmRhciA9IG51bGw7XG4gICAgdGhpcy5wYXJyZW50UG9pbnRlci5jYWNoZS51bnN1YnNjcmliZSh0aGlzLmlkRm9yQ2FjaGUpXG4gIH1cblxuICBwcml2YXRlIHJlbmRlclNyY0NoZWNrYm94ZXMoKSB7XG4gICAgaWYgKCF0aGlzLnNyY0NoZWNrYm94Q29udGFpbmVyKSByZXR1cm5cblxuICAgIHRoaXMuc3JjQ2hlY2tib3hDb250YWluZXIuZW1wdHkoKVxuXG4gICAgdGhpcy5ldmVudF9zcmMuZm9yRWFjaChzcmMgPT4ge1xuICAgICAgY29uc3QgY2hlY2tib3hDb250YWluZXIgPSB0aGlzLnNyY0NoZWNrYm94Q29udGFpbmVyIS5jcmVhdGVEaXYoe2NsczogJ3NyYy1jaGVja2JveC1pdGVtJ30pXG5cbiAgICAgIGNvbnN0IGNoZWNrYm94ID0gY2hlY2tib3hDb250YWluZXIuY3JlYXRlRWwoJ2lucHV0Jywge1xuICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICBhdHRyOiB7XG4gICAgICAgICAgaWQ6IGBzcmMtY2hlY2tib3gtJHtzcmMucGF0aH1gLFxuICAgICAgICAgIGNoZWNrZWQ6IHRoaXMuc2VsZWN0ZWRTcmNQYXRocy5oYXMoc3JjLnBhdGgpID8gJ2NoZWNrZWQnIDogbnVsbFxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgIGlmIChjaGVja2JveC5jaGVja2VkKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZFNyY1BhdGhzLmFkZChzcmMucGF0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkU3JjUGF0aHMuZGVsZXRlKHNyYy5wYXRoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaENhbGVuZGFyKClcbiAgICAgIH0pXG5cbiAgICAgIGNoZWNrYm94Q29udGFpbmVyLmNyZWF0ZUVsKCdsYWJlbCcsIHtcbiAgICAgICAgdGV4dDogc3JjLnBhdGgsXG4gICAgICAgIGF0dHI6IHtmb3I6IGBzcmMtY2hlY2tib3gtJHtzcmMucGF0aH1gfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBpc1BhZ2VJblNlbGVjdGVkU3JjKHBhZ2VQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBcdTA0MUZcdTA0NDBcdTA0M0VcdTA0MzJcdTA0MzVcdTA0NDBcdTA0NEZcdTA0MzVcdTA0M0MsIFx1MDQzRFx1MDQzMFx1MDQ0NVx1MDQzRVx1MDQzNFx1MDQzOFx1MDQ0Mlx1MDQ0MVx1MDQ0RiBcdTA0M0JcdTA0MzggXHUwNDQxXHUwNDQyXHUwNDQwXHUwNDMwXHUwNDNEXHUwNDM4XHUwNDQ2XHUwNDMwIFx1MDQzMiBcdTA0M0JcdTA0NEVcdTA0MzFcdTA0M0VcdTA0M0MgXHUwNDM4XHUwNDM3IFx1MDQzMlx1MDQ0Qlx1MDQzMVx1MDQ0MFx1MDQzMFx1MDQzRFx1MDQzRFx1MDQ0Qlx1MDQ0NSBcdTA0M0ZcdTA0NDNcdTA0NDJcdTA0MzVcdTA0MzlcbiAgICBmb3IgKGNvbnN0IHNyY1BhdGggb2YgdGhpcy5zZWxlY3RlZFNyY1BhdGhzKSB7XG4gICAgICBpZiAocGFnZVBhdGguc3RhcnRzV2l0aChzcmNQYXRoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVmcmVzaENhbGVuZGFyKCkge1xuICAgIGlmICghdGhpcy5jYWxlbmRhcikgcmV0dXJuXG5cbiAgICAvLyBcdTA0MjNcdTA0MzRcdTA0MzBcdTA0M0JcdTA0NEZcdTA0MzVcdTA0M0MgXHUwNDMyXHUwNDQxXHUwNDM1IFx1MDQ0MVx1MDQzRVx1MDQzMVx1MDQ0Qlx1MDQ0Mlx1MDQzOFx1MDQ0RlxuICAgIHRoaXMuY2FsZW5kYXIuZ2V0RXZlbnRzKCkuZm9yRWFjaChldmVudCA9PiBldmVudC5yZW1vdmUoKSlcblxuICAgIC8vIFx1MDQxNFx1MDQzRVx1MDQzMVx1MDQzMFx1MDQzMlx1MDQzQlx1MDQ0Rlx1MDQzNVx1MDQzQyBcdTA0NDFcdTA0M0VcdTA0MzFcdTA0NEJcdTA0NDJcdTA0MzhcdTA0NEYgXHUwNDQyXHUwNDNFXHUwNDNCXHUwNDRDXHUwNDNBXHUwNDNFIFx1MDQzOFx1MDQzNyBcdTA0MzJcdTA0NEJcdTA0MzFcdTA0NDBcdTA0MzBcdTA0M0RcdTA0M0RcdTA0NEJcdTA0NDUgXHUwNDM4XHUwNDQxXHUwNDQyXHUwNDNFXHUwNDQ3XHUwNDNEXHUwNDM4XHUwNDNBXHUwNDNFXHUwNDMyXG4gICAgY29uc3Qgc3Vic2NyaWJlRGF0YSA9IGF3YWl0IHRoaXMuY2FjaGUuc3Vic2NyaWJlKHRoaXMuaWRGb3JDYWNoZSwgdGhpcy5ldmVudF9zcmMsIHRoaXMpXG5cbiAgICBjb25zdCBldmVudHM6IElFdmVudFtdID0gW11cbiAgICBmb3IgKGNvbnN0IGRhdGEgb2Ygc3Vic2NyaWJlRGF0YSkge1xuICAgICAgLy8gXHUwNDFGXHUwNDQwXHUwNDNFXHUwNDMyXHUwNDM1XHUwNDQwXHUwNDRGXHUwNDM1XHUwNDNDLCBcdTA0MzJcdTA0NEJcdTA0MzFcdTA0NDBcdTA0MzBcdTA0M0QgXHUwNDNCXHUwNDM4IFx1MDQ0RFx1MDQ0Mlx1MDQzRVx1MDQ0MiBcdTA0MzhcdTA0NDFcdTA0NDJcdTA0M0VcdTA0NDdcdTA0M0RcdTA0MzhcdTA0M0FcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkU3JjUGF0aHMuaGFzKGRhdGEuc3JjLnBhdGgpKSB7XG4gICAgICAgIGZvciAobGV0IHBhZ2Ugb2YgZGF0YS5wYWdlcykge1xuICAgICAgICAgIGV2ZW50cy5wdXNoKC4uLnBhZ2VUb0V2ZW50cyhwYWdlKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IHRoaXMuY2FsZW5kYXI/LmFkZEV2ZW50KGV2ZW50KSlcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVuZGVyKGNvbnRhaW5lcjogRWxlbWVudCkgIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IG5ldyBNYXBcblxuICAgIGNvbnN0IHN1YnNjcmliZWREYXRhID0gYXdhaXQgdGhpcy5jYWNoZS5zdWJzY3JpYmUodGhpcy5pZEZvckNhY2hlLCB0aGlzLmV2ZW50X3NyYywgdGhpcylcbiAgICBmb3IgKGxldCBkYXRhIG9mIHN1YnNjcmliZWREYXRhKSB7XG4gICAgICB0aGlzLmxvY2FsU3RvcmFnZS5zZXQoZGF0YS5zcmMucGF0aCwgZGF0YS5wYWdlcylcbiAgICB9XG5cbiAgICBjb25zdCBldmVudHM6IElFdmVudFtdID0gW11cbiAgICBmb3IgKGNvbnN0IGRhdGEgb2Ygc3Vic2NyaWJlZERhdGEpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3RlZFNyY1BhdGhzLmhhcyhkYXRhLnNyYy5wYXRoKSlcbiAgICAgICAgY29udGludWVcblxuICAgICAgZm9yIChsZXQgcGFnZSBvZiBkYXRhLnBhZ2VzKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKCAuLi5wYWdlVG9FdmVudHMocGFnZSkgKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY2FsZW5kYXIgPSByZW5kZXJDYWxlbmRhcihcbiAgICAgIGNvbnRhaW5lciBhcyBIVE1MRWxlbWVudCxcbiAgICAgIHtcbiAgICAgICAgLy9AdHMtaWdub3JlIC8vIFRPRE8gcmVtb3ZlXG4gICAgICAgIGV2ZW50czogW1xuICAgICAgICAgIC4uLnRoaXMuY2FsZW5kYXJTZXR0aW5ncy5yZXN0VGltZSxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgXVxuICAgICAgfSwvLyBhcyBFdmVudFNvdXJjZSxcbiAgICAgICAgdGhpcy5nZXRTZXR0aW5nc0NhbGVuZGFyKCksXG4gICAgKVxuICAgIHRoaXMuY2FsZW5kYXIuc2V0T3B0aW9uKCd3ZWVrTnVtYmVycycsIHRydWUpXG5cbiAgICAvLyBOT1RFIHRvIGZpeCBidWcgZmlyc3QgcmVuZGVyXG4gICAgd2luZG93LnNldFRpbWVvdXQoXG4gICAgICAoXzogYW55KSA9PiB7XG4gICAgICAgIGlmIChQbGF0Zm9ybS5pc01vYmlsZSlcbiAgICAgICAgICB0aGlzLmNhbGVuZGFyPy5jaGFuZ2VWaWV3KCd0aW1lR3JpZDNEYXlzJylcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMuY2FsZW5kYXI/LmNoYW5nZVZpZXcoJ3RpbWVHcmlkV2VlaycpXG4gICAgICB9LCAxXG4gICAgKVxuICAgIHRoaXMuY2FsZW5kYXIucmVuZGVyKClcbiAgfVxuXG4gIHByaXZhdGUgZ2V0U2V0dGluZ3NDYWxlbmRhcigpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBmaXJzdERheTogMSxcbiAgICAgIHdlZWtOdW1iZXJzOiB0cnVlLFxuICAgICAgdGltZUZvcm1hdDI0aDogdHJ1ZSxcblxuICAgICAgLy8gVE9ETyByZW1vdmUgYW55XG4gICAgICBldmVudENsaWNrOiAoYXJnOiBhbnkpID0+IHtcbiAgICAgICAgY29uc3Qge2V2ZW50LCBqc0V2ZW50fSA9IGFyZ1xuICAgICAgICB0aGlzLmZpbGVNYW5hZ2VyLm9wZW5Ob3RlKGV2ZW50KVxuICAgICAgfSxcblxuICAgICAgLy8gVE9ETyByZW1vdmUgYW55XG4gICAgICBtb2RpZnlFdmVudDogYXN5bmMgKG5ld1BvczogYW55LCBvbGRQb3M6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wcyA9IG5ld1Bvcy5leHRlbmRlZFByb3BzXG5cbiAgICAgICAgY29uc3QgZXZlbnQ6IENhbGVuZGFyRXZlbnQgPSB7XG4gICAgICAgICAgc3RhcnQ6IG5ld1Bvcy5zdGFydCxcbiAgICAgICAgICBlbmQ6IG5ld1Bvcy5lbmQsXG4gICAgICAgICAgYWxsRGF5OiBuZXdQb3MuYWxsRGF5XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMubm90ZVBhdGgpIHtcbiAgICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5jYWNoZS5nZXRQYWdlKHByb3BzLm5vdGVQYXRoKVxuXG4gICAgICAgICAgaWYgKCFwYWdlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7TVNHX1BMR19OQU1FfTogY2FuJ3QgZmluZCBwYWdlIGJ5IEV2ZW50LiBldmVudElEOiAke3Byb3BzLm5vdGVQYXRofWApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0aWNrID0gcGFnZS50aWNrcy5maW5kKFxuICAgICAgICAgICAgZWwgPT4gZWwubmFtZSA9PSBwcm9wcy50aWNrTmFtZVxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAoIXRpY2spIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtNU0dfUExHX05BTUV9OiBjYW4ndCBmaW5kIHRpY2sgYnkgcGFnZS4gUGFnZSAtIHRpY2tOYW1lOiAke3Byb3BzLm5vdGVQYXRofSAtICR7cHJvcHMudGlja05hbWV9YClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aWNrLmZmX2R1cmF0aW9uICYmIG9sZFBvcy5hbGxEYXkgJiYgIW5ld1Bvcy5hbGxEYXkpIHtcbiAgICAgICAgICAgIGV2ZW50LmVuZCA9IHRpbWVBZGQobmV3UG9zLnN0YXJ0LCB0aWNrLmZmX2R1cmF0aW9uKVxuICAgICAgICAgICAgbmV3UG9zLnNldEVuZChldmVudC5lbmQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbmV3UHJvcCA9IENhbGVuZGFyRXZlbnRUb0lEYXRlKGV2ZW50KVxuICAgICAgICAgIGlmIChuZXdQb3MuYWxsRGF5KSB7XG4gICAgICAgICAgICBuZXdQcm9wWydmZl9kdXJhdGlvbiddID0gbWlsbGlzZWNUb1N0cmluZyhcbiAgICAgICAgICAgICAgdGljay5mZl9kdXJhdGlvbj8uYXMoXCJtaWxsaXNlY29uZHNcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZpbGVNYW5hZ2VyLmNoYW5nZVRpY2tGaWxlKHByb3BzLm5vdGVQYXRoLCBwcm9wcy50aWNrTmFtZSwgbmV3UHJvcClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5jYWNoZS5nZXRQYWdlKG5ld1Bvcy5pZClcblxuICAgICAgICAgIGlmICghcGFnZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke01TR19QTEdfTkFNRX06IGNhbid0IGZpbmQgcGFnZSBieSBFdmVudC4gZXZlbnRJRDogJHtuZXdQb3MuaWR9YClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYWdlLmZmX2R1cmF0aW9uICYmIG9sZFBvcy5hbGxEYXkgJiYgIW5ld1Bvcy5hbGxEYXkpIHtcbiAgICAgICAgICAgIGV2ZW50LmVuZCA9IHRpbWVBZGQobmV3UG9zLnN0YXJ0LCBwYWdlLmZmX2R1cmF0aW9uKVxuICAgICAgICAgICAgbmV3UG9zLnNldEVuZChldmVudC5lbmQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgbmV3UHJvcCA9IENhbGVuZGFyRXZlbnRUb0lEYXRlKGV2ZW50KVxuICAgICAgICAgIGlmIChuZXdQb3MuYWxsRGF5KSB7XG4gICAgICAgICAgICBuZXdQcm9wWydmZl9kdXJhdGlvbiddID0gbWlsbGlzZWNUb1N0cmluZyhcbiAgICAgICAgICAgICAgcGFnZS5mZl9kdXJhdGlvbj8uYXMoXCJtaWxsaXNlY29uZHNcIilcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmZpbGVNYW5hZ2VyLmNoYW5nZVByb3BlcnR5RmlsZShuZXdQb3MuaWQsIG5ld1Byb3ApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSxcbiAgICAgIHNlbGVjdDogKHN0YXJ0OiBEYXRlLCBlbmQ6IERhdGUsIGFsbERheTogYm9vbGVhbiwgX192aWV3TW9kZTogYW55KSA9PiB7XG4gICAgICAgIG5ldyBuYW1lTW9kYWwoXG4gICAgICAgICAgdGhpcy5hcHAsXG4gICAgICAgICAgYXN5bmMgKG5hbWVPZkZpbGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFuYW1lT2ZGaWxlKVxuICAgICAgICAgICAgICAgIHRocm93IDFcblxuICAgICAgICAgICAgICBjb25zdCBwYXRoT2ZGaWxlID0gdGhpcy5wbGFjZUZvckNyZWF0aW5nTm90ZSArIGAvJHtuYW1lT2ZGaWxlfS5tZGBcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5maWxlTWFuYWdlci5jcmVhdGVGaWxlKHBhdGhPZkZpbGUpXG5cbiAgICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAoKSA9PiB0aGlzLmZpbGVNYW5hZ2VyLmNoYW5nZVByb3BlcnR5RmlsZShcbiAgICAgICAgICAgICAgICAgIHBhdGhPZkZpbGUsXG4gICAgICAgICAgICAgICAgICBDYWxlbmRhckV2ZW50VG9JRGF0ZSh7c3RhcnQsIGVuZCwgYWxsRGF5fSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIDE1MDBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiSG0uLi4gZXJyb3IuLi5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICkub3BlbigpXG4gICAgICB9LFxuICAgICAgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQ6IChlOiBJRXZlbnQsIG1vdXNlRXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudUZvckV2ZW50KGUsIG1vdXNlRXZlbnQpXG4gICAgICB9LFxuICAgICAgc2xvdER1cmF0aW9uOiB0aGlzLmNhbGVuZGFyU2V0dGluZ3Muc2xvdER1cmF0aW9uXG4gICAgfVxuXG4gICAgaWYgKFBsYXRmb3JtLmlzTW9iaWxlKSB7XG4gICAgICByZXN1bHQuZXZlbnRDbGljayA9IChhcmc6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCB7ZXZlbnQsIGpzRXZlbnR9ID0gYXJnXG4gICAgICAgIHRoaXMuY29udGV4dE1lbnVGb3JFdmVudChldmVudCwganNFdmVudClcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5vcGVuQ29udGV4dE1lbnVGb3JFdmVudCA9IChfOklFdmVudCwgX186TW91c2VFdmVudCkgPT4ge31cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBwcml2YXRlIGNvbnRleHRNZW51Rm9yRXZlbnQoZXZlbnQ6IElFdmVudCwgbW91c2VFdmVudDogTW91c2VFdmVudCkge1xuICAgIGNvbnN0IG1lbnUgPSBuZXcgTWVudVxuXG4gICAgbWVudS5hZGRJdGVtKFxuICAgICAgKGl0ZW0pID0+IGl0ZW0uc2V0VGl0bGUoZXZlbnQuaWQpXG4gICAgICAgIC5vbkNsaWNrKGFzeW5jICgpID0+IHRoaXMuZmlsZU1hbmFnZXIub3Blbk5vdGUoZXZlbnQpKVxuICAgIClcblxuICAgIG1lbnUuc2hvd0F0TW91c2VFdmVudChtb3VzZUV2ZW50KVxuICB9XG59XG5cbmNsYXNzIG5hbWVNb2RhbCBleHRlbmRzIE1vZGFsIHtcbiAgcHJpdmF0ZSByZXN1bHQ6IHN0cmluZ1xuICBwcml2YXRlIG9uU3VibWl0OiBGdW5jdGlvblxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBvblN1Ym1pdDogRnVuY3Rpb24pIHtcbiAgICBzdXBlcihhcHApO1xuICAgIHRoaXMub25TdWJtaXQgPSBvblN1Ym1pdDtcbiAgfVxuXG4gIG9uT3BlbigpIHtcbiAgICBjb25zdCB7IGNvbnRlbnRFbCB9ID0gdGhpc1xuXG4gICAgY29udGVudEVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIk5hbWUgb2YgdGFza1wiIH0pXG5cbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgLnNldE5hbWUoXCJOYW1lXCIpXG4gICAgLmFkZFRleHQoXG4gICAgICB0ZXh0ID0+IHRleHQub25DaGFuZ2UodmFsdWUgPT4gdGhpcy5yZXN1bHQgPSB2YWx1ZSlcbiAgICApXG5cbiAgICBuZXcgU2V0dGluZyhjb250ZW50RWwpXG4gICAgLmFkZEJ1dHRvbihcbiAgICAgIChidG4pID0+IGJ0bi5zZXRCdXR0b25UZXh0KFwiU3VibWl0XCIpXG4gICAgICAgIC5zZXRDdGEoKVxuICAgICAgICAub25DbGljaygoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIHRoaXMub25TdWJtaXQodGhpcy5yZXN1bHQpO1xuICAgICAgICB9KSk7XG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIHRoaXMuY29udGVudEVsLmVtcHR5KCk7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBEVVJBVElPTl9UWVBFUyB9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlld1wiXG5cbmV4cG9ydCBjbGFzcyBTcmMge1xuICBjb25zdHJ1Y3RvcihwYXRoOnN0cmluZykge1xuICAgIHRoaXMuX3BhdGggPSBwYXRoXG4gIH1cblxuICBwdWJsaWMgYWRkRXhjbHVkZXMoZXhjbHVkZXM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XG4gICAgLy8gVE9ETyBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0MzQgXHUwNDM0XHUwNDNFXHUwNDMxXHUwNDMwXHUwNDMyXHUwNDNCXHUwNDM1XHUwNDNEXHUwNDM4XHUwNDM1XHUwNDNDIFx1MDQzRlx1MDQ0MFx1MDQzRVx1MDQzMlx1MDQzNVx1MDQ0MFx1MDQ0Rlx1MDQ0Mlx1MDQ0QywgXHUwNDQ3XHUwNDQyXHUwNDNFIGV4Y2x1ZGUgXHUwNDMyXHUwNDNEXHUwNDQzXHUwNDQyXHUwNDQwXHUwNDM4IHBhdGhcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgcHJpdmF0ZSBfcGF0aDogc3RyaW5nXG5cbiAgZ2V0IHBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGhcbiAgfVxuXG4gIHByaXZhdGUgX2V4Y2x1ZGVzOiBzdHJpbmdbXVxuXG4gIGdldCBleGNsdWRlcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh0aGlzLl9leGNsdWRlcylcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBDYWxlbmRhclNldHRpbmdzID0ge1xuICAgIHNsb3REdXJhdGlvbjogc3RyaW5nLFxuICAgIGNvbG91cnM6IHtcbiAgICAgIGZyZXF1ZW5jeTogc3RyaW5nLFxuICAgICAgZG9uZSAgICAgOiBzdHJpbmcsXG4gICAgICB0aWNrICAgICA6IHN0cmluZyxcbiAgICAgIGRlZmF1bHQgIDogc3RyaW5nLFxuICAgIH0sXG4gICAgcmVzdFRpbWU6IHtcbiAgICAgICAgc3RhcnRUaW1lOiBzdHJpbmcsXG4gICAgICAgIGVuZFRpbWU6IHN0cmluZyxcbiAgICAgICAgY29sb3I6IHN0cmluZyxcblxuICAgICAgICAvLyBUT0RPIHJlbW92ZSBhbnlcbiAgICAgICAgZGF5c09mV2VlazphbnksZGlzcGxheTphbnksXG4gICAgfVtdXG4gIH1cblxuZXhwb3J0IHR5cGUgUGx1Z2luU2V0dGluZ3MgPSB7XG4gIHN0YXR1c0NvcnJlY3Rvcjoge1xuICAgIGlzT246IGJvb2xlYW4sXG4gICAgc3RhcnRPblN0YXJ0VXA6IGJvb2xlYW5cbiAgfSxcbiAgY2FsZW5kYXI6IENhbGVuZGFyU2V0dGluZ3MsXG4gIHNvdXJjZToge1xuICAgIG5vdGVTb3VyY2VzOiBTcmNbXSxcblxuICAgIC8vIE5PVEUgZGVmYXVsdCBwYXRoIHdoZXJlIG5vdGUgd2lsbCBiZSBjcmVhdGVkXG4gICAgZGVmYXVsdENyZWF0ZVBhdGg6IHN0cmluZ1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURhdGUge1xuICAvLyBUT0RPIGRhdGUgXHUwNDNDXHUwNDNFXHUwNDM2XHUwNDM1XHUwNDQyIFx1MDQzOCBcdTA0M0RcdTA0MzUgXHUwNDMxXHUwNDRCXHUwNDQyXHUwNDRDIChcdTA0NDFcdTA0M0MuIGZpbGVNYW5hZ2VyLnRzL2dldFBhZ2UpXG4gIGZmX2RhdGU6IERhdGVcbiAgZmZfdGltZVN0YXJ0OiBEVVJBVElPTl9UWVBFU1xuICBmZl9kdXJhdGlvbjogRFVSQVRJT05fVFlQRVNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJVGljayBleHRlbmRzIElEYXRlIHtcbiAgbmFtZTogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVBhZ2UgZXh0ZW5kcyBJRGF0ZSB7XG4gIGZpbGU6IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgbmFtZTogc3RyaW5nXG4gIH0sXG4gIHRpY2tzOiBJVGlja1tdXG4gIGZmX2ZyZXF1ZW5jeT86IHN0cmluZ1xuICBmZl9zdGF0dXM/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRXZlbnQge1xuICBzdGFydDogRGF0ZVxuICBlbmQ/OiBEYXRlXG4gIGlkOiBzdHJpbmdcbiAgdGl0bGU6IHN0cmluZ1xuICBhbGxEYXk6IGJvb2xlYW5cbiAgY29sb3I/OiBzdHJpbmdcbiAgYm9yZGVyQ29sb3I6IHN0cmluZ1xuICBlZGl0YWJsZTogYm9vbGVhblxuICBleHRlbmRlZFByb3BzPzoge1xuICAgIHRpY2tOYW1lOiBzdHJpbmdcbiAgICBub3RlUGF0aDogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYWxlbmRhckV2ZW50IHtcbiAgc3RhcnQ6IERhdGVcbiAgYWxsRGF5OiBib29sZWFuXG4gIGVuZD86IERhdGVcbn1cblxuLy8gSU5GTyBcdTA0NERcdTA0NDJcdTA0M0UgXHUwNDM4XHUwNDNEXHUwNDQyXHUwNDM1XHUwNDQwXHUwNDQ0XHUwNDM1XHUwNDM5XHUwNDQxIFx1MDQzNFx1MDQzQlx1MDQ0RiBDYWNoZVxuLy8gVE9ETyBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0M0ZcdTA0MzhcdTA0NDFcdTA0MzBcdTA0NDJcdTA0NEMgXHUwNDQyXHUwNDM4XHUwNDNGXHUwNDRCXG5leHBvcnQgaW50ZXJmYWNlIE15VmlldyB7XG4gIHJlc2V0KCk6IHZvaWRcbiAgYWRkRmlsZShfOklQYWdlKTogdm9pZFxuICBkZWxldGVGaWxlKF86IElQYWdlKTogdm9pZFxuICBjaGFuZ2VGaWxlKG5ld1BhZ2U6IFNyYywgb2xkUGFnZTogU3JjKTogdm9pZFxuICByZW5hbWVGaWxlKG5ld1BhZ2U6IFNyYywgb2xkUGFnZTogU3JjKTogdm9pZFxufVxuXG4vLyBUT0RPIFx1MDQzMlx1MDQ0MFx1MDQzRVx1MDQzNFx1MDQzNSBcdTA0NERcdTA0NDJcdTA0M0UgXHUwNDNGXHUwNDNFXHUwNDMyXHUwNDQyXHUwNDNFXHUwNDQwXHUwNDRGXHUwNDM1XHUwNDQyXG5leHBvcnQgaW50ZXJmYWNlIElTdWJzY3JpYmVyIHtcbiAgcmVzZXQoKTogdm9pZFxuICBhZGRGaWxlKHBhZ2U6IElQYWdlKTogdm9pZFxuICBkZWxldGVGaWxlKHBhZ2U6IElQYWdlKTogdm9pZFxuICBjaGFuZ2VGaWxlKG5ld1BhZ2U6IElQYWdlLCBvbGRQYWdlOiBJUGFnZSk6IHZvaWRcbiAgcmVuYW1lRmlsZShuZXdQYWdlOiBJUGFnZSwgb2xkUGFnZTogSVBhZ2UpOiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVRhc2tzIHtcbiAgZG9uZTogbnVtYmVyLFxuICBhbGw6IG51bWJlclxufVxuIiwgImltcG9ydCB7IFBsdWdpblNldHRpbmdzLCBTcmMgfSBmcm9tIFwiLi90eXBlc1wiXG5cbmV4cG9ydCBjb25zdCBNU0dfUExHX05BTUUgPSBcIk15Q2FsZW5kYXJcIlxuXG5jb25zdCBFVkVOVF9TUkMgPSBcImRhdGFiYXNlc1wiXG5jb25zdCBQTEFDRV9GT1JfQ1JFQVRJTkdfTk9URSA9IFwiZGF0YWJhc2VzXCJcblxuY29uc3QgZGF5c09mV2VlayA9IFsgJzEnLCcyJywnMycsJzQnLCc1JywnNicsJzAnIF0gLy8gdGhlc2UgcmVjdXJyZW50IGV2ZW50cyBtb3ZlIHNlcGFyYXRlbHlcbmNvbnN0IGRpc3BsYXkgPSAnYmFja2dyb3VuZCdcbmV4cG9ydCBjb25zdCBDT0xPVVJfUkVTVCAgPSAnIzMwNUI2MCdcbmV4cG9ydCBjb25zdCBDT0xPVVJfU0xFRVAgPSAnI2NjMDAwMCdcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfU0VUVElOR1M6IFBsdWdpblNldHRpbmdzID0ge1xuICBzdGF0dXNDb3JyZWN0b3I6IHtcbiAgICBpc09uOiB0cnVlLFxuICAgIHN0YXJ0T25TdGFydFVwOiB0cnVlXG4gIH0sXG4gIGNhbGVuZGFyOiB7XG4gICAgc2xvdER1cmF0aW9uOiBcIjAwOjMwOjAwXCIsXG4gICAgY29sb3Vyczoge1xuICAgICAgZnJlcXVlbmN5OiBcIiM4QTE3MTdcIixcbiAgICAgIGRvbmUgICAgIDogXCIjMDA4RTA0XCIsXG4gICAgICB0aWNrICAgICA6IFwiIzQ1N0U3RVwiLFxuICAgICAgZGVmYXVsdCAgOiBcIiM1ZTNmYThcIixcbiAgICB9LFxuICAgIHJlc3RUaW1lOiBbXG4gICAgICB7ZGF5c09mV2VlayxkaXNwbGF5LFxuICAgICAgICAgIHN0YXJ0VGltZTogJzA6MDA6MDAnLFxuICAgICAgICAgIGVuZFRpbWU6ICc4OjAwOjAwJyxcbiAgICAgICAgICBjb2xvcjogQ09MT1VSX1NMRUVQLFxuICAgICAgfSxcbiAgICAgIHtkYXlzT2ZXZWVrLGRpc3BsYXksXG4gICAgICAgICAgc3RhcnRUaW1lOiAnMjQ6MDA6MDAnLFxuICAgICAgICAgIGVuZFRpbWU6ICcyNDowMDowMCcsXG4gICAgICAgICAgY29sb3I6IENPTE9VUl9TTEVFUCxcbiAgICAgIH0sXG4gICAgICB7ZGF5c09mV2VlayxkaXNwbGF5LFxuICAgICAgICAgIHN0YXJ0VGltZTogJzA6MDA6MDAnLFxuICAgICAgICAgIGVuZFRpbWU6ICc4OjMwOjAwJyxcbiAgICAgICAgICBjb2xvcjogQ09MT1VSX1JFU1QsXG4gICAgICB9LFxuICAgICAge2RheXNPZldlZWssZGlzcGxheSxcbiAgICAgICAgICBzdGFydFRpbWU6ICcyMzowMDowMCcsXG4gICAgICAgICAgZW5kVGltZTogJzI0OjAwOjAwJyxcbiAgICAgICAgICBjb2xvcjogQ09MT1VSX1JFU1QsXG4gICAgICB9XG4gICAgXVxuICB9LFxuICBzb3VyY2U6IHtcbiAgICBub3RlU291cmNlczogW25ldyBTcmMoRVZFTlRfU1JDKV0sXG5cbiAgICAvLyBOT1RFIGRlZmF1bHQgcGF0aCB3aGVyZSBub3RlIHdpbGwgYmUgY3JlYXRlZFxuICAgIGRlZmF1bHRDcmVhdGVQYXRoOiBQTEFDRV9GT1JfQ1JFQVRJTkdfTk9URVxuICB9XG5cbn1cblxuZXhwb3J0IGVudW0gQ0FDSEVfSUQge1xuICBDQUxFTkRBUiA9IDEsXG4gIFNUQVRVU19DT1JSRUNUT1IsXG4gIFRJQ0tfQ0hFQ0tFUlxufVxuXG5leHBvcnQgY29uc3QgVklFV19UWVBFID0gXCJteS1vYnNpZGlhbi1jYWxlbmRhci1wbHVnaW5cIlxuXG5cbi8vIFRPRE8gXHUwNDNGXHUwNDM1XHUwNDQwXHUwNDM1XHUwNDM0XHUwNDM1XHUwNDNCXHUwNDMwXHUwNDQyXHUwNDRDIFx1MDQzMiBURVhUID0ge0RPTkUuLi5CTE9DS0VEfVxuZXhwb3J0IGNvbnN0IFRFWFRfRE9ORSA9IFwiXHVEODNEXHVERkUyZG9uZVwiXG5leHBvcnQgY29uc3QgVEVYVF9JTl9QUk9HUkVTUyA9IFwiXHVEODNEXHVERDM1aW4gcHJvZ3Jlc3NcIlxuZXhwb3J0IGNvbnN0IFRFWFRfU09PTiA9IFwiXHVEODNEXHVERkUzc29vblwiXG5leHBvcnQgY29uc3QgVEVYVF9DSElMRF9JTl9QUk9HUkVTUyA9IFwiXHVEODNEXHVERkUxXHVEODNEXHVERkU2Y2hpbGQgaW4gcHJvZ3Jlc3NcIlxuZXhwb3J0IGNvbnN0IFRFWFRfQkxPQ0tFRCA9IFwiXHVEODNEXHVERkUxYmxvY2tlZFwiXG5cbmV4cG9ydCBjb25zdCBGT1JNQVRfREFZID0gJ2QnXG5leHBvcnQgY29uc3QgRk9STUFUX0hPVVIgPSAnaCdcbmV4cG9ydCBjb25zdCBGT1JNQVRfTUlOVVRFID0gJ20nXG5cbmV4cG9ydCBjb25zdCBCQUNLR1JPVU5EX0NPTE9VUiA9IHtcbiAgICBodWU6IHtcbiAgICAgICAgc2hpZnQ6IDAsXG4gICAgICAgIG1pbjogMCxcbiAgICAgICAgbWF4OiAzNjBcbiAgICB9LFxuICAgIHNhdHVyYXRpb246IHtcbiAgICAgICAgc2hpZnQ6IDAsXG4gICAgICAgIG1pbjogNzAsXG4gICAgICAgIG1heDogOTBcbiAgICB9LFxuICAgIGxpZ2h0bmVzczoge1xuICAgICAgICBzaGlmdDogMCxcbiAgICAgICAgbWluOiAzMCxcbiAgICAgICAgbWF4OiA1MFxuICAgIH1cbn1cblxuXG5jb25zdCBNaWxsaXNlY3NJblNlY29uZCA9IDEwMDBcbmNvbnN0IFNlY3NJbk1pbnV0ZSA9IDYwXG5jb25zdCBNaW51dGVzSW5Ib3VyID0gNjBcbmV4cG9ydCBjb25zdCBIb3Vyc0luRGF5ID0gMjRcbmV4cG9ydCBjb25zdCBNaWxsaXNlY3NJbk1pbnV0ZSA9IE1pbGxpc2Vjc0luU2Vjb25kICogU2Vjc0luTWludXRlXG5leHBvcnQgY29uc3QgTWlsbGlzZWNzSW5Ib3VyID0gTWlsbGlzZWNzSW5NaW51dGUgKiBNaW51dGVzSW5Ib3VyXG5leHBvcnQgY29uc3QgTWlsbGlzZWNzSW5EYXkgPSBNaWxsaXNlY3NJbkhvdXIgKiBIb3Vyc0luRGF5XG4iLCAiaW1wb3J0IHsgSVBhZ2UsIElUaWNrLCBJRGF0ZSwgQ2FsZW5kYXJFdmVudCwgSVRhc2tzLCBJRXZlbnQgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgRGF0YXZpZXdBcGkgfSBmcm9tIFwib2JzaWRpYW4tZGF0YXZpZXcvbGliL2FwaS9wbHVnaW4tYXBpXCJcbmltcG9ydCB7IGdldEFQSSB9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlld1wiXG5pbXBvcnQgeyBEVVJBVElPTl9UWVBFUyB9IGZyb20gXCJvYnNpZGlhbi1kYXRhdmlld1wiXG5cbmltcG9ydCB7XG4gIFRFWFRfRE9ORSxcbiAgTWlsbGlzZWNzSW5Ib3VyLFxuICBNaWxsaXNlY3NJbkRheSxcbiAgTWlsbGlzZWNzSW5NaW51dGUsXG4gIEZPUk1BVF9EQVksXG4gIEZPUk1BVF9IT1VSLFxuICBGT1JNQVRfTUlOVVRFLFxuICBCQUNLR1JPVU5EX0NPTE9VUixcbn0gZnJvbSBcIi4vY29uc3RhbnRzXCJcbmltcG9ydCBNeVBsdWdpbiBmcm9tIFwiLi9tYWluXCI7XG5cbmNvbnN0IFNMRUVQX1RJTUUgPSAxMDAwIC8vIG1zXG5cbmV4cG9ydCBjb25zdCBkdiA9IGdldEFQSSgpIGFzIERhdGF2aWV3QXBpXG5cbmZ1bmN0aW9uIHBhdGhUb0ZpbGVXaXRob3V0RmlsZU5hbWUocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IHBhdGhfc2VwYXJhdG9yID0gcGF0aC5sYXN0SW5kZXhPZihcIi9cIik7XG4gIGlmIChwYXRoX3NlcGFyYXRvciAhPT0gLTEpXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgcGF0aF9zZXBhcmF0b3IpO1xuICByZXR1cm4gXCJcIjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIElEYXRlVG9DYWxlbmRhckV2ZW50KGFyZ3M6IElEYXRlKTogQ2FsZW5kYXJFdmVudCB7XG4gIGNvbnN0IHN0cnVjdHVyZTogQ2FsZW5kYXJFdmVudCA9IHtcbiAgICBzdGFydDogbmV3IERhdGUoYXJncy5mZl9kYXRlKSxcbiAgICBhbGxEYXk6IGZhbHNlLFxuICB9XG5cbiAgaWYgKGFyZ3MuZmZfZHVyYXRpb24pIHtcbiAgICBzdHJ1Y3R1cmUuc3RhcnQuc2V0SG91cnMgIChhcmdzLmZmX3RpbWVTdGFydD8udmFsdWVzPy5ob3VycyAgIHx8IDApXG4gICAgc3RydWN0dXJlLnN0YXJ0LnNldE1pbnV0ZXMoYXJncy5mZl90aW1lU3RhcnQ/LnZhbHVlcz8ubWludXRlcyB8fCAwKVxuXG4gICAgbGV0IHRtcFRpbWUgPSBuZXcgRGF0ZShzdHJ1Y3R1cmUuc3RhcnQpXG4gICAgaWYgKGFyZ3MuZmZfZHVyYXRpb24/LnZhbHVlcz8ubWludXRlcyB8fCBhcmdzLmZmX2R1cmF0aW9uPy52YWx1ZXM/LmhvdXJzIHx8IGFyZ3MuZmZfZHVyYXRpb24/LnZhbHVlcz8uZGF5cykge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBhcmdzLmZmX2R1cmF0aW9uLnZhbHVlc1xuXG4gICAgICB0bXBUaW1lLnNldE1pbnV0ZXMoXG4gICAgICAgIHRtcFRpbWUuZ2V0TWludXRlcygpICsgKGR1cmF0aW9uLm1pbnV0ZXMgfHwgMClcbiAgICAgIClcbiAgICAgIHRtcFRpbWUuc2V0SG91cnMoXG4gICAgICAgIHRtcFRpbWUuZ2V0SG91cnMoKSArIChkdXJhdGlvbi5ob3VycyB8fCAwKVxuICAgICAgKVxuICAgICAgdG1wVGltZS5zZXREYXRlKFxuICAgICAgICB0bXBUaW1lLmdldERhdGUoKSArIChkdXJhdGlvbi5kYXlzIHx8IDApXG4gICAgICApXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RydWN0dXJlLmFsbERheSA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoIWFyZ3MuZmZfdGltZVN0YXJ0Py52YWx1ZXMpXG4gICAgICBzdHJ1Y3R1cmUuYWxsRGF5ID0gdHJ1ZVxuXG4gICAgc3RydWN0dXJlLmVuZCA9IHRtcFRpbWVcbiAgfVxuICBlbHNlIGlmIChhcmdzLmZmX2R1cmF0aW9uKSB7XG4gICAgc3RydWN0dXJlLmFsbERheSA9IHRydWVcbiAgfVxuICBlbHNlIHN0cnVjdHVyZS5hbGxEYXkgPSB0cnVlXG5cbiAgcmV0dXJuIHN0cnVjdHVyZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gQ2FsZW5kYXJFdmVudFRvSURhdGUoZXZlbnQ6IENhbGVuZGFyRXZlbnQpOiBJRGF0ZSB7XG4gIGNvbnN0IHtzdGFydCwgZW5kLCBhbGxEYXl9ID0gZXZlbnRcbiAgLy8gISBcdTA0MzRcdTA0M0JcdTA0NEYgSVNPIChcdTA0M0VcdTA0M0QgXHUwNDNGXHUwNDM1XHUwNDQwXHUwNDM1XHUwNDMyXHUwNDNFXHUwNDM0XHUwNDM4XHUwNDQyIFx1MDQzMiBcdTA0MzNcdTA0NDBcdTA0MzhcdTA0M0RcdTA0MzJcdTA0MzhcdTA0NDcgXHUwNDNDXHUwNDNFXHUwNDM1IFx1MDQzMlx1MDQ0MFx1MDQzNVx1MDQzQ1x1MDQ0RilcbiAgLy8gXHUwNDRGIFx1MDQ0Mlx1MDQ0M1x1MDQ0MiBcdTA0MzNcdTA0M0VcdTA0MzJcdTA0M0VcdTA0NDBcdTA0NEUsIFx1MDQ0N1x1MDQ0Mlx1MDQzRSBcdTA0NEYgXHUwNDMyIFx1MDQzM1x1MDQ0MFx1MDQzOFx1MDQzRFx1MDQzMlx1MDQzOFx1MDQ0N1x1MDQzNVxuICBzdGFydC5zZXRNaW51dGVzKFxuICAgIHN0YXJ0LmdldE1pbnV0ZXMoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KClcbiAgKVxuXG4gIGNvbnN0IHJlc3VsdDogSURhdGUgPSB7XG4gICAgZmZfZHVyYXRpb246IFwiXCIsXG4gICAgZmZfdGltZVN0YXJ0OiBcIlwiLFxuICAgIGZmX2RhdGU6IG5ldyBEYXRlKHN0YXJ0KVxuICB9XG5cbiAgLy8gISBcdTA0NDJcdTA0NDNcdTA0NDIgXHUwNDQzXHUwNDMxXHUwNDM4XHUwNDQwXHUwNDMwXHUwNDRFIFx1MDQzM1x1MDQ0MFx1MDQzOFx1MDQzRFx1MDQzMlx1MDQzOFx1MDQ0NyBcdTA0MzRcdTA0M0JcdTA0NEYgZ2V0J1x1MDQzNVx1MDQ0MFx1MDQzRVx1MDQzMiBcdTA0MzJcdTA0M0RcdTA0MzhcdTA0MzdcdTA0NDNcbiAgc3RhcnQuc2V0TWludXRlcyhcbiAgICBzdGFydC5nZXRNaW51dGVzKCkgKyBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpXG4gIClcblxuICBsZXQgc3JjTWlsbGlzZWMgPSBlbmRcbiAgLy8gQHRzLWlnbm9yZVxuICA/IGVuZCAtIHN0YXJ0XG4gIDogTWlsbGlzZWNzSW5Ib3VyXG5cbiAgaWYgKGFsbERheSkge1xuICAgIHJlc3VsdFsnZmZfdGltZVN0YXJ0J10gPSBcIlwiXG4gICAgaWYgKHNyY01pbGxpc2VjIDw9IE1pbGxpc2Vjc0luRGF5KVxuICAgICAgc3JjTWlsbGlzZWMgPSAwXG4gIH1cbiAgZWxzZVxuICAgIHJlc3VsdFsnZmZfdGltZVN0YXJ0J10gPSBzdGFydC5nZXRIb3VycygpICsgJ2gnICsgc3RhcnQuZ2V0TWludXRlcygpICsgJ20nXG5cbiAgcmVzdWx0WydmZl9kdXJhdGlvbiddID0gbWlsbGlzZWNUb1N0cmluZyhzcmNNaWxsaXNlYylcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaWNrc0Zyb21UZXh0KHRleHQ6IHN0cmluZyk6IElUaWNrW10ge1xuICBjb25zdCByZXN1bHQgPSBbXVxuICBjb25zdCByZWdFeHBUaWNrcyA9IC9cXFt0OjouK1xcXS9nbVxuICBjb25zdCBtYXRjaGVzID0gdGV4dC5tYXRjaChyZWdFeHBUaWNrcylcblxuICBpZiAobWF0Y2hlcykgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGNvbnN0IGFyZ3MgPSBtYXRjaC5zbGljZSgxLCAtMSkuc3BsaXQoXCI6OlwiKVsxXS5zcGxpdCgnLCcpXG4gICAgaWYgKCFhcmdzKVxuICAgICAgY29udGludWVcblxuICAgIGNvbnN0IG5hbWUgPSBhcmdzWzBdPy50cmltKClcbiAgICBjb25zdCBmZl9kYXRlID0gZHYuZGF0ZShhcmdzWzFdPy50cmltKCkpXG4gICAgY29uc3QgZmZfdGltZVN0YXJ0ID0gZHYuZHVyYXRpb24oYXJnc1syXT8udHJpbSgpKVxuXG4gICAgY29uc3QgdGVtcER1cmF0aW9uID0gYXJnc1szXT8udHJpbSgpXG4gICAgY29uc3QgZmZfZHVyYXRpb24gPSB0ZW1wRHVyYXRpb24gPT0gJ3gnXG4gICAgPyAneCdcbiAgICA6IGR2LmR1cmF0aW9uKGFyZ3NbM10/LnRyaW0oKSlcblxuICAgIGlmIChuYW1lID09ICcnKVxuICAgICAgY29udGludWVcblxuICAgIHJlc3VsdC5wdXNoKFxuICAgICAge25hbWUsIGZmX2RhdGUsIGZmX3RpbWVTdGFydCwgZmZfZHVyYXRpb259XG4gICAgKVxuXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWlsbGlzZWNUb1N0cmluZyhtaWxsaXNlYzpudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBkYXlzID0gTWF0aC5mbG9vcihcbiAgICAgIG1pbGxpc2VjIC8gKE1pbGxpc2Vjc0luRGF5KVxuICApXG4gIG1pbGxpc2VjIC09IGRheXMgKiBNaWxsaXNlY3NJbkRheVxuXG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihcbiAgICAgIG1pbGxpc2VjIC8gKE1pbGxpc2Vjc0luSG91cilcbiAgKVxuICBtaWxsaXNlYyAtPSBob3VycyAqIE1pbGxpc2Vjc0luSG91clxuXG4gIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKFxuICAgICAgbWlsbGlzZWMgLyAoTWlsbGlzZWNzSW5NaW51dGUpXG4gIClcbiAgbWlsbGlzZWMgLT0gbWludXRlcyAqIE1pbGxpc2Vjc0luTWludXRlXG5cbiAgbGV0IHJlc1N0cmluZyA9ICcnXG4gIGlmIChkYXlzKVxuICAgIHJlc1N0cmluZyArPSBkYXlzLnRvU3RyaW5nKCkgKyBGT1JNQVRfREFZXG4gIGlmIChob3VycylcbiAgICByZXNTdHJpbmcgKz0gaG91cnMudG9TdHJpbmcoKSArIEZPUk1BVF9IT1VSXG4gIGlmIChtaW51dGVzKVxuICAgIHJlc1N0cmluZyArPSBtaW51dGVzLnRvU3RyaW5nKCkgKyBGT1JNQVRfTUlOVVRFXG5cbiAgcmV0dXJuIHJlc1N0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbE9iaihvYmplY3QxOmFueSwgb2JqZWN0MjphbnkpIHtcbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmplY3QxKTtcbiAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmplY3QyKTtcblxuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGNvbnN0IHZhbDEgPSBvYmplY3QxW2tleV07XG4gICAgY29uc3QgdmFsMiA9IG9iamVjdDJba2V5XTtcbiAgICBjb25zdCBhcmVPYmplY3RzID0gaXNPYmplY3QodmFsMSkgJiYgaXNPYmplY3QodmFsMik7XG4gICAgaWYgKFxuICAgICAgYXJlT2JqZWN0cyAmJiAhaXNFcXVhbE9iaih2YWwxLCB2YWwyKSB8fFxuICAgICAgIWFyZU9iamVjdHMgJiYgdmFsMSAhPT0gdmFsMlxuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmplY3Q6IGFueSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG59XG5cbi8vIFx1MDQzQVx1MDQzMFx1MDQzQVx1MDQzOFx1MDQzQyBcdTA0MzFcdTA0NDNcdTA0MzRcdTA0MzVcdTA0NDIgSUQgXHUwNDMyIFx1MDQzQVx1MDQzMFx1MDQzQlx1MDQzNVx1MDQzRFx1MDQzNFx1MDQzMFx1MDQ0MFx1MDQzNSBcdTA0NDJcdTA0MzhcdTA0M0FcbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUlEVGljayhwYXRoOiBzdHJpbmcsIHRpY2tOYW1lOnN0cmluZykge1xuICByZXR1cm4gcGF0aCArIHRpY2tOYW1lXG59XG5cbi8vIFx1MDQzQVx1MDQzMFx1MDQzQSBcdTA0MzFcdTA0NDNcdTA0MzRcdTA0MzVcdTA0NDIgXHUwNDNFXHUwNDQyXHUwNDNFXHUwNDMxXHUwNDQwXHUwNDMwXHUwNDM2XHUwNDMwXHUwNDQyXHUwNDRDXHUwNDQxXHUwNDRGIFx1MDQzMiBcdTA0M0FcdTA0MzBcdTA0M0JcdTA0MzVcdTA0M0RcdTA0MzRcdTA0MzBcdTA0NDBcdTA0MzUgXHUwNDQyXHUwNDM4XHUwNDNBXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVOYW1lVGljayhmaWxlTmFtZTogc3RyaW5nLCB0aWNrTmFtZTpzdHJpbmcpIHtcbiAgcmV0dXJuIFwiKFwiK2ZpbGVOYW1lK1wiKVwiICsgdGlja05hbWVcbn1cblxuZnVuY3Rpb24gaGFzaFN0cmluZyhzdHI6IHN0cmluZykge1xuICBsZXQgaGFzaCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cbiAgcmV0dXJuIGhhc2g7XG59XG5cbi8vIFRPRE8gXHUwNDNEXHUwNDM1IFx1MDQ0MFx1MDQzMFx1MDQzMVx1MDQzRVx1MDQ0Mlx1MDQzMFx1MDQzNVx1MDQ0MiBcdTA0M0RcdTA0MzAgXHUwNDNFXHUwNDQyXHUwNDQwXHUwNDM4XHUwNDQ2XHUwNDMwXHUwNDQyXHUwNDM1XHUwNDNCXHUwNDRDXHUwNDNEXHUwNDRCXHUwNDQ1IFx1MDQ0N1x1MDQzOFx1MDQ0MVx1MDQzQlx1MDQzMFx1MDQ0NVxuLy8gXHUwNDM4IFx1MDQzRlx1MDQ0MFx1MDQzOCBtaW4gPiBtYXhcbmZ1bmN0aW9uIHRvUmFuZ2Uoc3JjOiBudW1iZXIsIG1pbjogbnVtYmVyLCBtYXg6IG51bWJlcikge1xuICBtYXggLT0gbWluXG4gIHNyYyAlPSBtYXgrMVxuXG4gIHJldHVybiAoc3JjICsgbWluKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sb3VyRnJvbVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc3Qgc3RyID0gcGF0aFRvRmlsZVdpdGhvdXRGaWxlTmFtZShwYXRoKVxuXG4gIC8vIE5PVEUgXHUwNDQyXHUwNDM4XHUwNDNGXHUwNDMwIFx1MDQzQVx1MDQzMFx1MDQzNlx1MDQzNFx1MDQ0Qlx1MDQzOSBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzJcdTA0NEJcdTA0MzksIFx1MDQzMlx1MDQ0Mlx1MDQzRVx1MDQ0MFx1MDQzRVx1MDQzOSBcdTA0MzhcdTA0M0JcdTA0MzggXHUwNDQyXHUwNDQwXHUwNDM1XHUwNDQyXHUwNDM4XHUwNDM5IFx1MDQ0MVx1MDQzOFx1MDQzQ1x1MDQzMlx1MDQzRVx1MDQzQiBcdTA0NDFcdTA0NDJcdTA0NDBcdTA0M0VcdTA0M0FcdTA0MzhcbiAgY29uc3Qgc3RyMSA9IGhhc2hTdHJpbmcoWy4uLnN0cl0uZmlsdGVyKChfLCBpbmRleCkgPT4gKGluZGV4ICsgMSkgJSAzICE9PSAwKS5qb2luKFwiXCIpKVxuICBjb25zdCBzdHIyID0gaGFzaFN0cmluZyhbLi4uc3RyXS5maWx0ZXIoKF8sIGluZGV4KSA9PiAoaW5kZXggKyAyKSAlIDMgIT09IDApLmpvaW4oXCJcIikpXG4gIGNvbnN0IHN0cjMgPSBoYXNoU3RyaW5nKFsuLi5zdHJdLmZpbHRlcigoXywgaW5kZXgpID0+IChpbmRleCArIDMpICUgMyAhPT0gMCkuam9pbihcIlwiKSlcblxuICBjb25zdCBodWUgPSB0b1JhbmdlKHN0cjEgKyBCQUNLR1JPVU5EX0NPTE9VUi5odWUuc2hpZnQsXG4gICAgQkFDS0dST1VORF9DT0xPVVIuaHVlLm1pbixcbiAgICBCQUNLR1JPVU5EX0NPTE9VUi5odWUubWF4XG4gIClcbiAgY29uc3Qgc2F0dXJhdGlvbiA9IHRvUmFuZ2Uoc3RyMiArIEJBQ0tHUk9VTkRfQ09MT1VSLnNhdHVyYXRpb24uc2hpZnQsXG4gICAgQkFDS0dST1VORF9DT0xPVVIuc2F0dXJhdGlvbi5taW4sXG4gICAgQkFDS0dST1VORF9DT0xPVVIuc2F0dXJhdGlvbi5tYXgpXG4gIGNvbnN0IGxpZ2h0bmVzcyAgPSB0b1JhbmdlKHN0cjMgKyBCQUNLR1JPVU5EX0NPTE9VUi5saWdodG5lc3Muc2hpZnQsXG4gICAgQkFDS0dST1VORF9DT0xPVVIubGlnaHRuZXNzLm1pbixcbiAgICBCQUNLR1JPVU5EX0NPTE9VUi5saWdodG5lc3MubWF4XG4gIClcbiAgcmV0dXJuIGBoc2woJHtodWV9LCAke3NhdHVyYXRpb259JSwgJHtsaWdodG5lc3N9JSlgXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdhaXREdkluaXQoKSB7XG4gIHdoaWxlICghZHYuaW5kZXguaW5pdGlhbGl6ZWQpXG4gICAgYXdhaXQgc2xlZXAoU0xFRVBfVElNRSlcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE5vdGVzV2l0aG91dFBhcmVudChzcmM6IHN0cmluZyk6IFByb21pc2U8SVBhZ2VbXT4ge1xuICBhd2FpdCB3YWl0RHZJbml0KClcblxuICBjb25zdCBjaGlsZCA9IGR2LnBhZ2VzKGBcIiR7c3JjfVwiYCkud2hlcmUoXG4gICAgKHBhZ2U6IGFueSkgPT4gIXBhZ2UuZmZfcGFyZW50XG4gICkuYXJyYXkoKVxuXG4gIHJldHVybiBjaGlsZCBhcyBJUGFnZVtdXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9ncmVzcyhwbGc6IE15UGx1Z2luLCBwYWdlOiBJUGFnZSk6IFByb21pc2U8SVRhc2tzPiB7XG4gIGNvbnN0IHJlc3VsdCA9IHtkb25lOjAsIGFsbDowfVxuICBjb25zdCBjYWNoZSA9IHBsZy5jYWNoZVxuICBjb25zdCBmaWxlTWFuYWdlciA9IHBsZy5maWxlTWFuYWdlclxuXG4gIGF3YWl0IHdhaXREdkluaXQoKVxuXG4gIGNvbnN0IHBhZ2VzID0gbmV3IFNldCgpXG4gIGNvbnN0IHN0YWNrID0gW3BhZ2UuZmlsZS5wYXRoXVxuICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHBhdGggPSBzdGFjay5wb3AoKSBhcyBzdHJpbmdcbiAgICBjb25zdCBwYWdlID0gY2FjaGUuZ2V0UGFnZShwYXRoKVxuICAgIGNvbnN0IG1ldGEgPSBkdi5wYWdlKHBhdGgpXG5cbiAgICBpZiAoIXBhZ2UgfHwgIW1ldGEpXG4gICAgICBjb250aW51ZVxuXG4gICAgY29uc3QgdGFza3MgPSBmaWxlTWFuYWdlci5nZXRUYXNrQ291bnQocGFnZSlcblxuICAgIHJlc3VsdC5hbGwgICs9ICB0YXNrcy5hbGxcbiAgICByZXN1bHQuZG9uZSAgKz0gIHRhc2tzLmRvbmVcblxuXG4gICAgY29uc3QgaW5saW5rcyA9IG1ldGEuZmlsZS5pbmxpbmtzLmFycmF5KClcbiAgICAvLyBpZiAoaW5saW5rcy5sZW5ndGggPT0gMCkge1xuICAgIGlmIChwYWdlLmZmX3N0YXR1cykge1xuICAgICAgKytyZXN1bHQuYWxsXG5cbiAgICAgIGlmIChwYWdlLmZmX3N0YXR1cyA9PSBURVhUX0RPTkUpXG4gICAgICAgICsrcmVzdWx0LmRvbmVcbiAgICB9XG4gICAgLy8gfVxuXG4gICAgZm9yIChsZXQgaW5saW5rIG9mIGlubGlua3MgKSB7XG4gICAgICBpZiAocGFnZXMuaGFzKGlubGluay5wYXRoKSlcbiAgICAgICAgY29udGludWVcblxuICAgICAgcGFnZXMuYWRkKGlubGluay5wYXRoKVxuICAgICAgc3RhY2sucHVzaChpbmxpbmsucGF0aClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDaGlsZE5vdGVQYXRocyhwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGF3YWl0IHdhaXREdkluaXQoKVxuXG4gIGNvbnN0IG1ldGEgPSBkdi5wYWdlKHBhdGgpXG4gIGNvbnN0IGlubGlua3MgPSBtZXRhPy5maWxlLmlubGlua3MuYXJyYXkoKVxuXG4gIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXVxuICBmb3IgKGxldCBpbmxpbmsgb2YgaW5saW5rcykge1xuICAgIHJlc3VsdC5wdXNoKCBpbmxpbmsucGF0aCApXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQYXJlbnROb3RlKHBhZ2U6IElQYWdlKTogUHJvbWlzZTwoSVBhZ2V8dW5kZWZpbmVkKVtdPiB7XG4gIGF3YWl0IHdhaXREdkluaXQoKVxuXG4gIGNvbnN0IG1ldGEgPSBkdi5wYWdlKHBhZ2UuZmlsZS5wYXRoKVxuICBjb25zdCBvdXRsaW5rcyA9IG1ldGE/LmZpbGUub3V0bGlua3MuYXJyYXkoKVxuXG4gIGNvbnN0IHJlc3VsdDogSVBhZ2VbXSA9IFtdXG4gIGZvciAobGV0IG91dGxpbmsgb2Ygb3V0bGlua3MpIHtcbiAgICByZXN1bHQucHVzaCggZHYucGFnZShvdXRsaW5rLnBhdGgpIGFzIElQYWdlIClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVQYXJzZUludChzdHI6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IG51bSA9IE51bWJlcihzdHIpO1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihudW0pID8gbnVtIDogTmFOO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUFkZChzdGFydDogRGF0ZSwgZHVyYXRpb246IERVUkFUSU9OX1RZUEVTKTogRGF0ZSB7XG4gIGNvbnN0IGR1ciA9IGR1cmF0aW9uLmFzKFwibWludXRlc1wiKVxuXG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBEYXRlKHN0YXJ0KVxuICByZXN1bHQuc2V0TWludXRlcyhyZXN1bHQuZ2V0TWludXRlcygpICsgZHVyKVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZ2VUb0V2ZW50cyhwYWdlOiBJUGFnZSk6IElFdmVudFtdIHtcbiAgY29uc3QgcmVzdWx0OiBJRXZlbnRbXSA9IFtdXG5cbiAgY29uc3QgY29sb3VycyA9IHRoaXMuY2FsZW5kYXJTZXR0aW5ncy5jb2xvdXJzXG5cbiAgY29uc3Qgc3RydWN0dXJlVGVtcGxhdGUgPSB7XG4gICAgaWQ6IFwiXCIsXG4gICAgdGl0bGU6IFwiXCIsXG4gICAgYm9yZGVyQ29sb3I6IGNvbG91cnMuZGVmYXVsdCxcbiAgICBjb2xvcjogZ2V0Q29sb3VyRnJvbVBhdGgocGFnZS5maWxlLnBhdGgpLFxuICAgIGVkaXRhYmxlOiB0cnVlLFxuICB9XG5cbiAgaWYgKHBhZ2UuZmZfZGF0ZSkge1xuICAgIGNvbnN0IHN0cnVjdHVyZTogSUV2ZW50ID0ge1xuICAgICAgLi4uc3RydWN0dXJlVGVtcGxhdGUsXG4gICAgICBpZDogcGFnZS5maWxlLnBhdGgsXG4gICAgICB0aXRsZTogcGFnZS5maWxlLm5hbWUsXG4gICAgICAuLi5JRGF0ZVRvQ2FsZW5kYXJFdmVudChwYWdlKVxuICAgIH1cbiAgICBpZiAocGFnZS5mZl9mcmVxdWVuY3kpXG4gICAgICBzdHJ1Y3R1cmUuYm9yZGVyQ29sb3IgPSBjb2xvdXJzLmZyZXF1ZW5jeVxuICAgIGlmIChwYWdlLmZmX3N0YXR1cyA9PSBURVhUX0RPTkUpXG4gICAgICAgIHN0cnVjdHVyZS5ib3JkZXJDb2xvciA9IGNvbG91cnMuZG9uZVxuXG4gICAgcmVzdWx0LnB1c2goc3RydWN0dXJlKVxuICB9XG4gIGZvciAobGV0IHRpY2sgb2YgcGFnZS50aWNrcykge1xuICAgIGNvbnN0IHN0cnVjdHVyZTogSUV2ZW50ID0ge1xuICAgICAgLi4uc3RydWN0dXJlVGVtcGxhdGUsXG4gICAgICBpZDogdGVtcGxhdGVJRFRpY2socGFnZS5maWxlLnBhdGgsIHRpY2submFtZSksXG4gICAgICB0aXRsZTogdGVtcGxhdGVOYW1lVGljayhwYWdlLmZpbGUubmFtZSwgdGljay5uYW1lKSxcbiAgICAgIGJvcmRlckNvbG9yOiBjb2xvdXJzLnRpY2ssXG4gICAgICBleHRlbmRlZFByb3BzOiB7XG4gICAgICAgIHRpY2tOYW1lOiB0aWNrLm5hbWUsXG4gICAgICAgIG5vdGVQYXRoOiBwYWdlLmZpbGUucGF0aFxuICAgICAgfSxcbiAgICAgIC4uLklEYXRlVG9DYWxlbmRhckV2ZW50KHRpY2spXG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHN0cnVjdHVyZSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsICJpbXBvcnQgeyBFTVBUWV9BUlIgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHQvLyBAdHMtaWdub3JlIFdlIGNoYW5nZSB0aGUgdHlwZSBvZiBgb2JqYCB0byBiZSBgTyAmIFBgXG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY2hpbGQgbm9kZSBmcm9tIGl0cyBwYXJlbnQgaWYgYXR0YWNoZWQuIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvclxuICogSUUxMSB3aGljaCBkb2Vzbid0IHN1cHBvcnQgYEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSgpYC4gVXNpbmcgdGhpcyBmdW5jdGlvblxuICogaXMgc21hbGxlciB0aGFuIGluY2x1ZGluZyBhIGRlZGljYXRlZCBwb2x5ZmlsbC5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuXHRsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0aWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5cbmV4cG9ydCBjb25zdCBzbGljZSA9IEVNUFRZX0FSUi5zbGljZTtcbiIsICJpbXBvcnQgeyBfY2F0Y2hFcnJvciB9IGZyb20gJy4vZGlmZi9jYXRjaC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBvcHRpb25gIG9iamVjdCBjYW4gcG90ZW50aWFsbHkgY29udGFpbiBjYWxsYmFjayBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIGNhbGxlZCBkdXJpbmcgdmFyaW91cyBzdGFnZXMgb2Ygb3VyIHJlbmRlcmVyLiBUaGlzIGlzIHRoZVxuICogZm91bmRhdGlvbiBvbiB3aGljaCBhbGwgb3VyIGFkZG9ucyBsaWtlIGBwcmVhY3QvZGVidWdgLCBgcHJlYWN0L2NvbXBhdGAsXG4gKiBhbmQgYHByZWFjdC9ob29rc2AgYXJlIGJhc2VkIG9uLiBTZWUgdGhlIGBPcHRpb25zYCB0eXBlIGluIGBpbnRlcm5hbC5kLnRzYFxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb24gaG9va3MgKG1vc3QgZWRpdG9ycy9JREVzIGFsbG93IHlvdSB0b1xuICogY3RybCtjbGljayBvciBjbWQrY2xpY2sgb24gbWFjIHRoZSB0eXBlIGRlZmluaXRpb24gYmVsb3cpLlxuICogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk9wdGlvbnN9XG4gKi9cbmNvbnN0IG9wdGlvbnMgPSB7XG5cdF9jYXRjaEVycm9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBvcHRpb25zO1xuIiwgImltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5cbmxldCB2bm9kZUlkID0gMDtcblxuLyoqXG4gKiBDcmVhdGUgYW4gdmlydHVhbCBub2RlICh1c2VkIGZvciBKU1gpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudFxuICogY29uc3RydWN0b3IgZm9yIHRoaXMgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGwgfCB1bmRlZmluZWR9IFtwcm9wc10gVGhlIHByb3BlcnRpZXMgb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4nKS5Db21wb25lbnRDaGlsZHJlbj59IFtjaGlsZHJlbl0gVGhlIGNoaWxkcmVuIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fSxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdrZXknKSBrZXkgPSBwcm9wc1tpXTtcblx0XHRlbHNlIGlmIChpID09ICdyZWYnKSByZWYgPSBwcm9wc1tpXTtcblx0XHRlbHNlIG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHByb3BzW2ldO1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzLmNoaWxkcmVuID1cblx0XHRcdGFyZ3VtZW50cy5sZW5ndGggPiAzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogY2hpbGRyZW47XG5cdH1cblxuXHQvLyBJZiBhIENvbXBvbmVudCBWTm9kZSwgY2hlY2sgZm9yIGFuZCBhcHBseSBkZWZhdWx0UHJvcHNcblx0Ly8gTm90ZTogdHlwZSBtYXkgYmUgdW5kZWZpbmVkIGluIGRldmVsb3BtZW50LCBtdXN0IG5ldmVyIGVycm9yIGhlcmUuXG5cdGlmICh0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nICYmIHR5cGUuZGVmYXVsdFByb3BzICE9IG51bGwpIHtcblx0XHRmb3IgKGkgaW4gdHlwZS5kZWZhdWx0UHJvcHMpIHtcblx0XHRcdGlmIChub3JtYWxpemVkUHJvcHNbaV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSB0eXBlLmRlZmF1bHRQcm9wc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbm9ybWFsaXplZFByb3BzLCBrZXksIHJlZiwgbnVsbCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgVk5vZGUgKHVzZWQgaW50ZXJuYWxseSBieSBQcmVhY3QpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudFxuICogQ29uc3RydWN0b3IgZm9yIHRoaXMgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdCB8IHN0cmluZyB8IG51bWJlciB8IG51bGx9IHByb3BzIFRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdmlydHVhbCBub2RlLlxuICogSWYgdGhpcyB2aXJ0dWFsIG5vZGUgcmVwcmVzZW50cyBhIHRleHQgbm9kZSwgdGhpcyBpcyB0aGUgdGV4dCBvZiB0aGUgbm9kZSAoc3RyaW5nIG9yIG51bWJlcikuXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IG51bGx9IGtleSBUaGUga2V5IGZvciB0aGlzIHZpcnR1YWwgbm9kZSwgdXNlZCB3aGVuXG4gKiBkaWZmaW5nIGl0IGFnYWluc3QgaXRzIGNoaWxkcmVuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1wicmVmXCJdfSByZWYgVGhlIHJlZiBwcm9wZXJ0eSB0aGF0IHdpbGxcbiAqIHJlY2VpdmUgYSByZWZlcmVuY2UgdG8gaXRzIGNyZWF0ZWQgY2hpbGRcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBrZXksIHJlZiwgb3JpZ2luYWwpIHtcblx0Ly8gVjggc2VlbXMgdG8gYmUgYmV0dGVyIGF0IGRldGVjdGluZyB0eXBlIHNoYXBlcyBpZiB0aGUgb2JqZWN0IGlzIGFsbG9jYXRlZCBmcm9tIHRoZSBzYW1lIGNhbGwgc2l0ZVxuXHQvLyBEbyBub3QgaW5saW5lIGludG8gY3JlYXRlRWxlbWVudCBhbmQgY29lcmNlVG9WTm9kZSFcblx0Y29uc3Qgdm5vZGUgPSB7XG5cdFx0dHlwZSxcblx0XHRwcm9wcyxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdF9jaGlsZHJlbjogbnVsbCxcblx0XHRfcGFyZW50OiBudWxsLFxuXHRcdF9kZXB0aDogMCxcblx0XHRfZG9tOiBudWxsLFxuXHRcdC8vIF9uZXh0RG9tIG11c3QgYmUgaW5pdGlhbGl6ZWQgdG8gdW5kZWZpbmVkIGIvYyBpdCB3aWxsIGV2ZW50dWFsbHlcblx0XHQvLyBiZSBzZXQgdG8gZG9tLm5leHRTaWJsaW5nIHdoaWNoIGNhbiByZXR1cm4gYG51bGxgIGFuZCBpdCBpcyBpbXBvcnRhbnRcblx0XHQvLyB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gYW4gdW5pbml0aWFsaXplZCBfbmV4dERvbSBhbmRcblx0XHQvLyBhIF9uZXh0RG9tIHRoYXQgaGFzIGJlZW4gc2V0IHRvIGBudWxsYFxuXHRcdF9uZXh0RG9tOiB1bmRlZmluZWQsXG5cdFx0X2NvbXBvbmVudDogbnVsbCxcblx0XHRfaHlkcmF0aW5nOiBudWxsLFxuXHRcdGNvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG5cdFx0X29yaWdpbmFsOiBvcmlnaW5hbCA9PSBudWxsID8gKyt2bm9kZUlkIDogb3JpZ2luYWxcblx0fTtcblxuXHQvLyBPbmx5IGludm9rZSB0aGUgdm5vZGUgaG9vayBpZiB0aGlzIHdhcyAqbm90KiBhIGRpcmVjdCBjb3B5OlxuXHRpZiAob3JpZ2luYWwgPT0gbnVsbCAmJiBvcHRpb25zLnZub2RlICE9IG51bGwpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcblx0cmV0dXJuIHsgY3VycmVudDogbnVsbCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRnJhZ21lbnQocHJvcHMpIHtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQgUHJlYWN0IFZOb2RlLlxuICogQHBhcmFtIHsqfSB2bm9kZVxuICogQHJldHVybnMge3Zub2RlIGlzIGltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEVsZW1lbnQgPSB2bm9kZSA9PlxuXHR2bm9kZSAhPSBudWxsICYmIHZub2RlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQ7XG4iLCAiaW1wb3J0IHsgSVNfTk9OX0RJTUVOU0lPTkFMIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdGhlIG9sZCBhbmQgbmV3IHByb3BlcnRpZXMgb2YgYSBWTm9kZSBhbmQgYXBwbHkgY2hhbmdlcyB0byB0aGUgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gYXBwbHlcbiAqIGNoYW5nZXMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBUaGUgbmV3IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkUHJvcHMgVGhlIG9sZCBwcm9wc1xuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaHlkcmF0ZSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uIG1vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGh5ZHJhdGUpIHtcblx0bGV0IGk7XG5cblx0Zm9yIChpIGluIG9sZFByb3BzKSB7XG5cdFx0aWYgKGkgIT09ICdjaGlsZHJlbicgJiYgaSAhPT0gJ2tleScgJiYgIShpIGluIG5ld1Byb3BzKSkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBudWxsLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxuXG5cdGZvciAoaSBpbiBuZXdQcm9wcykge1xuXHRcdGlmIChcblx0XHRcdCghaHlkcmF0ZSB8fCB0eXBlb2YgbmV3UHJvcHNbaV0gPT0gJ2Z1bmN0aW9uJykgJiZcblx0XHRcdGkgIT09ICdjaGlsZHJlbicgJiZcblx0XHRcdGkgIT09ICdrZXknICYmXG5cdFx0XHRpICE9PSAndmFsdWUnICYmXG5cdFx0XHRpICE9PSAnY2hlY2tlZCcgJiZcblx0XHRcdG9sZFByb3BzW2ldICE9PSBuZXdQcm9wc1tpXVxuXHRcdCkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBuZXdQcm9wc1tpXSwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIGtleSwgdmFsdWUpIHtcblx0aWYgKGtleVswXSA9PT0gJy0nKSB7XG5cdFx0c3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZSk7XG5cdH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdHN0eWxlW2tleV0gPSAnJztcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT0gJ251bWJlcicgfHwgSVNfTk9OX0RJTUVOU0lPTkFMLnRlc3Qoa2V5KSkge1xuXHRcdHN0eWxlW2tleV0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWUgKyAncHgnO1xuXHR9XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgdmFsdWUgb24gYSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBtb2RpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG9cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSB0aGUgcHJvcGVydHkgaGFkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGUgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShkb20sIG5hbWUsIHZhbHVlLCBvbGRWYWx1ZSwgaXNTdmcpIHtcblx0bGV0IHVzZUNhcHR1cmU7XG5cblx0bzogaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZFZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkVmFsdWUgPSAnJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9sZFZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiBvbGRWYWx1ZSkge1xuXHRcdFx0XHRcdGlmICghKHZhbHVlICYmIG5hbWUgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsICcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICghb2xkVmFsdWUgfHwgdmFsdWVbbmFtZV0gIT09IG9sZFZhbHVlW25hbWVdKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsIHZhbHVlW25hbWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gQmVuY2htYXJrIGZvciBjb21wYXJpc29uOiBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzU3NGM5NTRiZGI5NjViOWEwMDk2NWFjNlxuXHRlbHNlIGlmIChuYW1lWzBdID09PSAnbycgJiYgbmFtZVsxXSA9PT0gJ24nKSB7XG5cdFx0dXNlQ2FwdHVyZSA9IG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9DYXB0dXJlJC8sICcnKSk7XG5cblx0XHQvLyBJbmZlciBjb3JyZWN0IGNhc2luZyBmb3IgRE9NIGJ1aWx0LWluIGV2ZW50czpcblx0XHRpZiAobmFtZS50b0xvd2VyQ2FzZSgpIGluIGRvbSkgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgyKTtcblx0XHRlbHNlIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuXG5cdFx0aWYgKCFkb20uX2xpc3RlbmVycykgZG9tLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRkb20uX2xpc3RlbmVyc1tuYW1lICsgdXNlQ2FwdHVyZV0gPSB2YWx1ZTtcblxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFvbGRWYWx1ZSkge1xuXHRcdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSB1c2VDYXB0dXJlID8gZXZlbnRQcm94eUNhcHR1cmUgOiBldmVudFByb3h5O1xuXHRcdFx0ZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgIT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIHtcblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdC8vIE5vcm1hbGl6ZSBpbmNvcnJlY3QgcHJvcCB1c2FnZSBmb3IgU1ZHOlxuXHRcdFx0Ly8gLSB4bGluazpocmVmIC8geGxpbmtIcmVmIC0tPiBocmVmICh4bGluazpocmVmIHdhcyByZW1vdmVkIGZyb20gU1ZHIGFuZCBpc24ndCBuZWVkZWQpXG5cdFx0XHQvLyAtIGNsYXNzTmFtZSAtLT4gY2xhc3Ncblx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoL3hsaW5rKEh8OmgpLywgJ2gnKS5yZXBsYWNlKC9zTmFtZSQvLCAncycpO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRuYW1lICE9PSAnd2lkdGgnICYmXG5cdFx0XHRuYW1lICE9PSAnaGVpZ2h0JyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2hyZWYnICYmXG5cdFx0XHRuYW1lICE9PSAnbGlzdCcgJiZcblx0XHRcdG5hbWUgIT09ICdmb3JtJyAmJlxuXHRcdFx0Ly8gRGVmYXVsdCB2YWx1ZSBpbiBicm93c2VycyBpcyBgLTFgIGFuZCBhbiBlbXB0eSBzdHJpbmcgaXNcblx0XHRcdC8vIGNhc3QgdG8gYDBgIGluc3RlYWRcblx0XHRcdG5hbWUgIT09ICd0YWJJbmRleCcgJiZcblx0XHRcdG5hbWUgIT09ICdkb3dubG9hZCcgJiZcblx0XHRcdG5hbWUgaW4gZG9tXG5cdFx0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkb21bbmFtZV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcblx0XHRcdFx0Ly8gbGFiZWxsZWQgYnJlYWsgaXMgMWIgc21hbGxlciBoZXJlIHRoYW4gYSByZXR1cm4gc3RhdGVtZW50IChzb3JyeSlcblx0XHRcdFx0YnJlYWsgbztcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbm90aW9uIG9mIGJvb2xlYW4gdmFsdWVzLlxuXHRcdC8vIFRoZSB2YWx1ZSBgZmFsc2VgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhdHRyaWJ1dGUgbm90XG5cdFx0Ly8gZXhpc3Rpbmcgb24gdGhlIERPTSwgc28gd2UgY2FuJ3QgcmVtb3ZlIGl0LiBGb3Igbm9uLWJvb2xlYW5cblx0XHQvLyBBUklBLWF0dHJpYnV0ZXMgd2UgY291bGQgdHJlYXQgZmFsc2UgYXMgYSByZW1vdmFsLCBidXQgdGhlXG5cdFx0Ly8gYW1vdW50IG9mIGV4Y2VwdGlvbnMgd291bGQgY29zdCB1cyB0b28gbWFueSBieXRlcy4gT24gdG9wIG9mXG5cdFx0Ly8gdGhhdCBvdGhlciBWRE9NIGZyYW1ld29ya3MgYWxzbyBhbHdheXMgc3RyaW5naWZ5IGBmYWxzZWAuXG5cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBuZXZlciBzZXJpYWxpemUgZnVuY3Rpb25zIGFzIGF0dHJpYnV0ZSB2YWx1ZXNcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlICE9PSBmYWxzZSB8fCBuYW1lLmluZGV4T2YoJy0nKSAhPSAtMSkpIHtcblx0XHRcdGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgbGV0IGluRXZlbnQgPSBmYWxzZTtcblxuLyoqXG4gKiBQcm94eSBhbiBldmVudCB0byBob29rZWQgZXZlbnQgaGFuZGxlcnNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBicm93c2VyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFByb3h5KGUpIHtcblx0aW5FdmVudCA9IHRydWU7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMuX2xpc3RlbmVyc1tlLnR5cGUgKyBmYWxzZV0oXG5cdFx0XHRvcHRpb25zLmV2ZW50ID8gb3B0aW9ucy5ldmVudChlKSA6IGVcblx0XHQpO1xuXHR9IGZpbmFsbHkge1xuXHRcdGluRXZlbnQgPSBmYWxzZTtcblx0fVxufVxuXG5mdW5jdGlvbiBldmVudFByb3h5Q2FwdHVyZShlKSB7XG5cdGluRXZlbnQgPSB0cnVlO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgdHJ1ZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcblx0fSBmaW5hbGx5IHtcblx0XHRpbkV2ZW50ID0gZmFsc2U7XG5cdH1cbn1cbiIsICJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZGlmZiwgY29tbWl0Um9vdCB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IGluRXZlbnQgfSBmcm9tICcuL2RpZmYvcHJvcHMnO1xuXG4vKipcbiAqIEJhc2UgQ29tcG9uZW50IGNsYXNzLiBQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2hcbiAqIHRyaWdnZXIgcmVuZGVyaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGluaXRpYWwgY29tcG9uZW50IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBUaGUgaW5pdGlhbCBjb250ZXh0IGZyb20gcGFyZW50IGNvbXBvbmVudHMnXG4gKiBnZXRDaGlsZENvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuXHR0aGlzLnByb3BzID0gcHJvcHM7XG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKlxuICogVXBkYXRlIGNvbXBvbmVudCBzdGF0ZSBhbmQgc2NoZWR1bGUgYSByZS1yZW5kZXIuXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPSBudWxsICYmIHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gU29tZSBsaWJyYXJpZXMgbGlrZSBgaW1tZXJgIG1hcmsgdGhlIGN1cnJlbnQgc3RhdGUgYXMgcmVhZG9ubHksXG5cdFx0Ly8gcHJldmVudGluZyB1cyBmcm9tIG11dGF0aW5nIGl0LCBzbyB3ZSBuZWVkIHRvIGNsb25lIGl0LiBTZWUgIzI3MTZcblx0XHR1cGRhdGUgPSB1cGRhdGUoYXNzaWduKHt9LCBzKSwgdGhpcy5wcm9wcyk7XG5cdH1cblxuXHRpZiAodXBkYXRlKSB7XG5cdFx0YXNzaWduKHMsIHVwZGF0ZSk7XG5cdH1cblxuXHQvLyBTa2lwIHVwZGF0ZSBpZiB1cGRhdGVyIGZ1bmN0aW9uIHJldHVybmVkIG51bGxcblx0aWYgKHVwZGF0ZSA9PSBudWxsKSByZXR1cm47XG5cblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHR0aGlzLl9zdGF0ZUNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHR9XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBJbW1lZGlhdGVseSBwZXJmb3JtIGEgc3luY2hyb25vdXMgcmUtcmVuZGVyIG9mIHRoZSBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSB2bm9kZS5fb3JpZ2luYWwgKyAxO1xuXG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdHZub2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRjb21wb25lbnQuX2dsb2JhbENvbnRleHQsXG5cdFx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nICE9IG51bGwgPyBbb2xkRG9tXSA6IG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb20sXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nXG5cdFx0KTtcblx0XHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2RvbSAhPSBvbGREb20pIHtcblx0XHRcdHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSkge1xuXHRpZiAoKHZub2RlID0gdm5vZGUuX3BhcmVudCkgIT0gbnVsbCAmJiB2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gbnVsbDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBjaGlsZC5fZG9tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHJlbmRlciBxdWV1ZVxuICogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59XG4gKi9cbmxldCByZXJlbmRlclF1ZXVlID0gW107XG5cbi8qXG4gKiBUaGUgdmFsdWUgb2YgYENvbXBvbmVudC5kZWJvdW5jZWAgbXVzdCBhc3luY2hyb25vdXNseSBpbnZva2UgdGhlIHBhc3NlZCBpbiBjYWxsYmFjay4gSXQgaXNcbiAqIGltcG9ydGFudCB0aGF0IGNvbnRyaWJ1dG9ycyB0byBQcmVhY3QgY2FuIGNvbnNpc3RlbnRseSByZWFzb24gYWJvdXQgd2hhdCBjYWxscyB0byBgc2V0U3RhdGVgLCBldGMuXG4gKiBkbywgYW5kIHdoZW4gdGhlaXIgZWZmZWN0cyB3aWxsIGJlIGFwcGxpZWQuIFNlZSB0aGUgbGlua3MgYmVsb3cgZm9yIHNvbWUgZnVydGhlciByZWFkaW5nIG9uIGRlc2lnbmluZ1xuICogYXN5bmNocm9ub3VzIEFQSXMuXG4gKiAqIFtEZXNpZ25pbmcgQVBJcyBmb3IgQXN5bmNocm9ueV0oaHR0cHM6Ly9ibG9nLml6cy5tZS8yMDEzLzA4L2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogKiBbQ2FsbGJhY2tzIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXNdKGh0dHBzOi8vYmxvZy5vbWV0ZXIuY29tLzIwMTEvMDcvMjQvY2FsbGJhY2tzLXN5bmNocm9ub3VzLWFuZC1hc3luY2hyb25vdXMvKVxuICovXG5cbmxldCBwcmV2RGVib3VuY2U7XG5cbmNvbnN0IG1pY3JvVGljayA9XG5cdHR5cGVvZiBQcm9taXNlID09ICdmdW5jdGlvbidcblx0XHQ/IFByb21pc2UucHJvdG90eXBlLnRoZW4uYmluZChQcm9taXNlLnJlc29sdmUoKSlcblx0XHQ6IHNldFRpbWVvdXQ7XG5mdW5jdGlvbiBkZWZlcihjYikge1xuXHRpZiAoaW5FdmVudCkge1xuXHRcdHNldFRpbWVvdXQoY2IpO1xuXHR9IGVsc2Uge1xuXHRcdG1pY3JvVGljayhjYik7XG5cdH1cbn1cblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IGRlZmVyKShwcm9jZXNzKTtcblx0fVxufVxuXG4vKiogRmx1c2ggdGhlIHJlbmRlciBxdWV1ZSBieSByZXJlbmRlcmluZyBhbGwgcXVldWVkIGNvbXBvbmVudHMgKi9cbmZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdGxldCBjO1xuXHRyZXJlbmRlclF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuX3Zub2RlLl9kZXB0aCAtIGIuX3Zub2RlLl9kZXB0aCk7XG5cdC8vIERvbid0IHVwZGF0ZSBgcmVuZGVyQ291bnRgIHlldC4gS2VlcCBpdHMgdmFsdWUgbm9uLXplcm8gdG8gcHJldmVudCB1bm5lY2Vzc2FyeVxuXHQvLyBwcm9jZXNzKCkgY2FsbHMgZnJvbSBnZXR0aW5nIHNjaGVkdWxlZCB3aGlsZSBgcXVldWVgIGlzIHN0aWxsIGJlaW5nIGNvbnN1bWVkLlxuXHR3aGlsZSAoKGMgPSByZXJlbmRlclF1ZXVlLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKGMuX2RpcnR5KSB7XG5cdFx0XHRsZXQgcmVuZGVyUXVldWVMZW5ndGggPSByZXJlbmRlclF1ZXVlLmxlbmd0aDtcblx0XHRcdHJlbmRlckNvbXBvbmVudChjKTtcblx0XHRcdGlmIChyZXJlbmRlclF1ZXVlLmxlbmd0aCA+IHJlbmRlclF1ZXVlTGVuZ3RoKSB7XG5cdFx0XHRcdC8vIFdoZW4gaS5lLiByZXJlbmRlcmluZyBhIHByb3ZpZGVyIGFkZGl0aW9uYWwgbmV3IGl0ZW1zIGNhbiBiZSBpbmplY3RlZCwgd2Ugd2FudCB0b1xuXHRcdFx0XHQvLyBrZWVwIHRoZSBvcmRlciBmcm9tIHRvcCB0byBib3R0b20gd2l0aCB0aG9zZSBuZXcgaXRlbXMgc28gd2UgY2FuIGhhbmRsZSB0aGVtIGluIGFcblx0XHRcdFx0Ly8gc2luZ2xlIHBhc3Ncblx0XHRcdFx0cmVyZW5kZXJRdWV1ZS5zb3J0KChhLCBiKSA9PiBhLl92bm9kZS5fZGVwdGggLSBiLl92bm9kZS5fZGVwdGgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRwcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gMDtcbn1cblxucHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IDA7XG4iLCAiaW1wb3J0IHsgZW5xdWV1ZVJlbmRlciB9IGZyb20gJy4vY29tcG9uZW50JztcblxuZXhwb3J0IGxldCBpID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjb250ZXh0SWQpIHtcblx0Y29udGV4dElkID0gJ19fY0MnICsgaSsrO1xuXG5cdGNvbnN0IGNvbnRleHQgPSB7XG5cdFx0X2lkOiBjb250ZXh0SWQsXG5cdFx0X2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0Q29uc3VtZXIocHJvcHMsIGNvbnRleHRWYWx1ZSkge1xuXHRcdFx0Ly8gcmV0dXJuIHByb3BzLmNoaWxkcmVuKFxuXHRcdFx0Ly8gXHRjb250ZXh0W2NvbnRleHRJZF0gPyBjb250ZXh0W2NvbnRleHRJZF0ucHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWVcblx0XHRcdC8vICk7XG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW4oY29udGV4dFZhbHVlKTtcblx0XHR9LFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0UHJvdmlkZXIocHJvcHMpIHtcblx0XHRcdGlmICghdGhpcy5nZXRDaGlsZENvbnRleHQpIHtcblx0XHRcdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRbXX0gKi9cblx0XHRcdFx0bGV0IHN1YnMgPSBbXTtcblx0XHRcdFx0bGV0IGN0eCA9IHt9O1xuXHRcdFx0XHRjdHhbY29udGV4dElkXSA9IHRoaXM7XG5cblx0XHRcdFx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiBjdHg7XG5cblx0XHRcdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihfcHJvcHMpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHQvLyBJIHRoaW5rIHRoZSBmb3JjZWQgdmFsdWUgcHJvcGFnYXRpb24gaGVyZSB3YXMgb25seSBuZWVkZWQgd2hlbiBgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZ2Agd2FzIGJlaW5nIGJ5cGFzc2VkOlxuXHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9jb21taXQvNGQzMzlmYjgwM2JlYTA5ZTlmMTk4YWJmMzhjYTFiZjhlYTRiNzc3MSNkaWZmLTU0NjgyY2UzODA5MzVhNzE3ZTQxYjhiZmM1NDczN2Y2UjM1OFxuXHRcdFx0XHRcdFx0Ly8gSW4gdGhvc2UgY2FzZXMgdGhvdWdoLCBldmVuIHdpdGggdGhlIHZhbHVlIGNvcnJlY3RlZCwgd2UncmUgZG91YmxlLXJlbmRlcmluZyBhbGwgbm9kZXMuXG5cdFx0XHRcdFx0XHQvLyBJdCBtaWdodCBiZSBiZXR0ZXIgdG8ganVzdCB0ZWxsIGZvbGtzIG5vdCB0byB1c2UgZm9yY2Utc3luYyBtb2RlLlxuXHRcdFx0XHRcdFx0Ly8gQ3VycmVudGx5LCB1c2luZyBgdXNlQ29udGV4dCgpYCBpbiBhIGNsYXNzIGNvbXBvbmVudCB3aWxsIG92ZXJ3cml0ZSBpdHMgYHRoaXMuY29udGV4dGAgdmFsdWUuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dFtjb250ZXh0SWRdID0gX3Byb3BzLnZhbHVlO1xuXHRcdFx0XHRcdFx0Ly8gXHRlbnF1ZXVlUmVuZGVyKGMpO1xuXHRcdFx0XHRcdFx0Ly8gfSk7XG5cdFx0XHRcdFx0XHRzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHRcdGMuX2ZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN1YiA9IGMgPT4ge1xuXHRcdFx0XHRcdHN1YnMucHVzaChjKTtcblx0XHRcdFx0XHRsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcblx0XHRcdFx0XHRcdGlmIChvbGQpIG9sZC5jYWxsKGMpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcblx0XHR9XG5cdH07XG5cblx0Ly8gRGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB3aGVuIGl0XG5cdC8vIGVuY291bnRlcnMgYSBQcm92aWRlci4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gc3VwcG9ydFxuXHQvLyBzZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gdGhlIGNvbnRleHQgb2JqZWN0IGluc3RlYWRcblx0Ly8gb2Ygb24gdGhlIGNvbXBvbmVudCBpdHNlbGYuIFNlZTpcblx0Ly8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2NvbnRleHQuaHRtbCNjb250ZXh0ZGlzcGxheW5hbWVcblxuXHRyZXR1cm4gKGNvbnRleHQuUHJvdmlkZXIuX2NvbnRleHRSZWYgPSBjb250ZXh0LkNvbnN1bWVyLmNvbnRleHRUeXBlID0gY29udGV4dCk7XG59XG4iLCAiZXhwb3J0IGNvbnN0IEVNUFRZX09CSiA9IHt9O1xuZXhwb3J0IGNvbnN0IEVNUFRZX0FSUiA9IFtdO1xuZXhwb3J0IGNvbnN0IElTX05PTl9ESU1FTlNJT05BTCA9IC9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfGl0ZXJhL2k7XG4iLCAiaW1wb3J0IHsgZGlmZiwgdW5tb3VudCwgYXBwbHlSZWYgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZVZOb2RlLCBGcmFnbWVudCB9IGZyb20gJy4uL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IEVNUFRZX09CSiwgRU1QVFlfQVJSIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuXG4vKipcbiAqIERpZmYgdGhlIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHdob3NlXG4gKiBjaGlsZHJlbiBhcmUgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbltdfSByZW5kZXJSZXN1bHRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdQYXJlbnRWTm9kZSBUaGUgbmV3IHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBvbGRQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFBhcmVudFZOb2RlIFRoZSBvbGQgdmlydHVhbFxuICogbm9kZSB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgZGlmZidlZCBhZ2FpbnN0IG5ld1BhcmVudFZOb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdCAtIG1vZGlmaWVkIGJ5IGdldENoaWxkQ29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQ2hpbGRyZW4oXG5cdHBhcmVudERvbSxcblx0cmVuZGVyUmVzdWx0LFxuXHRuZXdQYXJlbnRWTm9kZSxcblx0b2xkUGFyZW50Vk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdG9sZERvbSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgaSwgaiwgb2xkVk5vZGUsIGNoaWxkVk5vZGUsIG5ld0RvbSwgZmlyc3RDaGlsZERvbSwgcmVmcztcblxuXHQvLyBUaGlzIGlzIGEgY29tcHJlc3Npb24gb2Ygb2xkUGFyZW50Vk5vZGUhPW51bGwgJiYgb2xkUGFyZW50Vk5vZGUgIT0gRU1QVFlfT0JKICYmIG9sZFBhcmVudFZOb2RlLl9jaGlsZHJlbiB8fCBFTVBUWV9BUlJcblx0Ly8gYXMgRU1QVFlfT0JKLl9jaGlsZHJlbiBzaG91bGQgYmUgYHVuZGVmaW5lZGAuXG5cdGxldCBvbGRDaGlsZHJlbiA9IChvbGRQYXJlbnRWTm9kZSAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4pIHx8IEVNUFRZX0FSUjtcblxuXHRsZXQgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cblx0bmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdGZvciAoaSA9IDA7IGkgPCByZW5kZXJSZXN1bHQubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZFZOb2RlID0gcmVuZGVyUmVzdWx0W2ldO1xuXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRWTm9kZSA9PSAnYm9vbGVhbicpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdH1cblx0XHQvLyBJZiB0aGlzIG5ld1ZOb2RlIGlzIGJlaW5nIHJldXNlZCAoZS5nLiA8ZGl2PntyZXVzZX17cmV1c2V9PC9kaXY+KSBpbiB0aGUgc2FtZSBkaWZmLFxuXHRcdC8vIG9yIHdlIGFyZSByZW5kZXJpbmcgYSBjb21wb25lbnQgKGUuZy4gc2V0U3RhdGUpIGNvcHkgdGhlIG9sZFZOb2RlcyBzbyBpdCBjYW4gaGF2ZVxuXHRcdC8vIGl0J3Mgb3duIERPTSAmIGV0Yy4gcG9pbnRlcnNcblx0XHRlbHNlIGlmIChcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdzdHJpbmcnIHx8XG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnbnVtYmVyJyB8fFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLXR5cGVvZlxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2JpZ2ludCdcblx0XHQpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZVxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRWTm9kZSkpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0RnJhZ21lbnQsXG5cdFx0XHRcdHsgY2hpbGRyZW46IGNoaWxkVk5vZGUgfSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKGNoaWxkVk5vZGUuX2RlcHRoID4gMCkge1xuXHRcdFx0Ly8gVk5vZGUgaXMgYWxyZWFkeSBpbiB1c2UsIGNsb25lIGl0LiBUaGlzIGNhbiBoYXBwZW4gaW4gdGhlIGZvbGxvd2luZ1xuXHRcdFx0Ly8gc2NlbmFyaW86XG5cdFx0XHQvLyAgIGNvbnN0IHJldXNlID0gPGRpdiAvPlxuXHRcdFx0Ly8gICA8ZGl2PntyZXVzZX08c3BhbiAvPntyZXVzZX08L2Rpdj5cblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlLFxuXHRcdFx0XHRjaGlsZFZOb2RlLnByb3BzLFxuXHRcdFx0XHRjaGlsZFZOb2RlLmtleSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5yZWYgPyBjaGlsZFZOb2RlLnJlZiA6IG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY2hpbGRWTm9kZTtcblx0XHR9XG5cblx0XHQvLyBUZXJzZXIgcmVtb3ZlcyB0aGUgYGNvbnRpbnVlYCBoZXJlIGFuZCB3cmFwcyB0aGUgbG9vcCBib2R5XG5cdFx0Ly8gaW4gYSBgaWYgKGNoaWxkVk5vZGUpIHsgLi4uIH0gY29uZGl0aW9uXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y2hpbGRWTm9kZS5fcGFyZW50ID0gbmV3UGFyZW50Vk5vZGU7XG5cdFx0Y2hpbGRWTm9kZS5fZGVwdGggPSBuZXdQYXJlbnRWTm9kZS5fZGVwdGggKyAxO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZmluZCBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBvbGRDaGlsZHJlbi5cblx0XHQvLyBJZiBmb3VuZCwgZGVsZXRlIHRoZSBhcnJheSBpdGVtIGJ5IHNldHRpbmcgdG8gYHVuZGVmaW5lZGAuXG5cdFx0Ly8gV2UgdXNlIGB1bmRlZmluZWRgLCBhcyBgbnVsbGAgaXMgcmVzZXJ2ZWQgZm9yIGVtcHR5IHBsYWNlaG9sZGVyc1xuXHRcdC8vIChob2xlcykuXG5cdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcblxuXHRcdGlmIChcblx0XHRcdG9sZFZOb2RlID09PSBudWxsIHx8XG5cdFx0XHQob2xkVk5vZGUgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZSlcblx0XHQpIHtcblx0XHRcdG9sZENoaWxkcmVuW2ldID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFaXRoZXIgb2xkVk5vZGUgPT09IHVuZGVmaW5lZCBvciBvbGRDaGlsZHJlbkxlbmd0aCA+IDAsXG5cdFx0XHQvLyBzbyBhZnRlciB0aGlzIGxvb3Agb2xkVk5vZGUgPT0gbnVsbCBvciBvbGRWTm9kZSBpcyBhIHZhbGlkIHZhbHVlLlxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IG9sZENoaWxkcmVuTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltqXTtcblx0XHRcdFx0Ly8gSWYgY2hpbGRWTm9kZSBpcyB1bmtleWVkLCB3ZSBvbmx5IG1hdGNoIHNpbWlsYXJseSB1bmtleWVkIG5vZGVzLCBvdGhlcndpc2Ugd2UgbWF0Y2ggYnkga2V5LlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgbWF0Y2ggYnkgdHlwZSAoaW4gZWl0aGVyIGNhc2UpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0b2xkVk5vZGUgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGVcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0b2xkQ2hpbGRyZW5bal0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2xkVk5vZGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG9sZFZOb2RlID0gb2xkVk5vZGUgfHwgRU1QVFlfT0JKO1xuXG5cdFx0Ly8gTW9ycGggdGhlIG9sZCBlbGVtZW50IGludG8gdGhlIG5ldyBvbmUsIGJ1dCBkb24ndCBhcHBlbmQgaXQgdG8gdGhlIGRvbSB5ZXRcblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdGlzU3ZnLFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSxcblx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0KTtcblxuXHRcdG5ld0RvbSA9IGNoaWxkVk5vZGUuX2RvbTtcblxuXHRcdGlmICgoaiA9IGNoaWxkVk5vZGUucmVmKSAmJiBvbGRWTm9kZS5yZWYgIT0gaikge1xuXHRcdFx0aWYgKCFyZWZzKSByZWZzID0gW107XG5cdFx0XHRpZiAob2xkVk5vZGUucmVmKSByZWZzLnB1c2gob2xkVk5vZGUucmVmLCBudWxsLCBjaGlsZFZOb2RlKTtcblx0XHRcdHJlZnMucHVzaChqLCBjaGlsZFZOb2RlLl9jb21wb25lbnQgfHwgbmV3RG9tLCBjaGlsZFZOb2RlKTtcblx0XHR9XG5cblx0XHRpZiAobmV3RG9tICE9IG51bGwpIHtcblx0XHRcdGlmIChmaXJzdENoaWxkRG9tID09IG51bGwpIHtcblx0XHRcdFx0Zmlyc3RDaGlsZERvbSA9IG5ld0RvbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgY2hpbGRWTm9kZS50eXBlID09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5fY2hpbGRyZW4gPT09IG9sZFZOb2RlLl9jaGlsZHJlblxuXHRcdFx0KSB7XG5cdFx0XHRcdGNoaWxkVk5vZGUuX25leHREb20gPSBvbGREb20gPSByZW9yZGVyQ2hpbGRyZW4oXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdFx0cGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKFxuXHRcdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRcdG9sZENoaWxkcmVuLFxuXHRcdFx0XHRcdG5ld0RvbSxcblx0XHRcdFx0XHRvbGREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBuZXdQYXJlbnRWTm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gQmVjYXVzZSB0aGUgbmV3UGFyZW50Vk5vZGUgaXMgRnJhZ21lbnQtbGlrZSwgd2UgbmVlZCB0byBzZXQgaXQnc1xuXHRcdFx0XHQvLyBfbmV4dERvbSBwcm9wZXJ0eSB0byB0aGUgbmV4dFNpYmxpbmcgb2YgaXRzIGxhc3QgY2hpbGQgRE9NIG5vZGUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGBvbGREb21gIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHZhbHVlIGhlcmUgYmVjYXVzZSBpZiB0aGUgbGFzdCBjaGlsZFxuXHRcdFx0XHQvLyBpcyBhIEZyYWdtZW50LWxpa2UsIHRoZW4gb2xkRG9tIGhhcyBhbHJlYWR5IGJlZW4gc2V0IHRvIHRoYXQgY2hpbGQncyBfbmV4dERvbS5cblx0XHRcdFx0Ly8gSWYgdGhlIGxhc3QgY2hpbGQgaXMgYSBET00gVk5vZGUsIHRoZW4gb2xkRG9tIHdpbGwgYmUgc2V0IHRvIHRoYXQgRE9NXG5cdFx0XHRcdC8vIG5vZGUncyBuZXh0U2libGluZy5cblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBvbGREb207XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdG9sZERvbSAmJlxuXHRcdFx0b2xkVk5vZGUuX2RvbSA9PSBvbGREb20gJiZcblx0XHRcdG9sZERvbS5wYXJlbnROb2RlICE9IHBhcmVudERvbVxuXHRcdCkge1xuXHRcdFx0Ly8gVGhlIGFib3ZlIGNvbmRpdGlvbiBpcyB0byBoYW5kbGUgbnVsbCBwbGFjZWhvbGRlcnMuIFNlZSB0ZXN0IGluIHBsYWNlaG9sZGVyLnRlc3QuanM6XG5cdFx0XHQvLyBgZWZmaWNpZW50bHkgcmVwbGFjZSBudWxsIHBsYWNlaG9sZGVycyBpbiBwYXJlbnQgcmVyZW5kZXJzYFxuXHRcdFx0b2xkRG9tID0gZ2V0RG9tU2libGluZyhvbGRWTm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0bmV3UGFyZW50Vk5vZGUuX2RvbSA9IGZpcnN0Q2hpbGREb207XG5cblx0Ly8gUmVtb3ZlIHJlbWFpbmluZyBvbGRDaGlsZHJlbiBpZiB0aGVyZSBhcmUgYW55LlxuXHRmb3IgKGkgPSBvbGRDaGlsZHJlbkxlbmd0aDsgaS0tOyApIHtcblx0XHRpZiAob2xkQ2hpbGRyZW5baV0gIT0gbnVsbCkge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdG9sZENoaWxkcmVuW2ldLl9kb20gIT0gbnVsbCAmJlxuXHRcdFx0XHRvbGRDaGlsZHJlbltpXS5fZG9tID09IG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIG5ld1BhcmVudFZOb2RlLl9fbmV4dERvbSBwb2ludHMgdG8gYSBkb20gbm9kZSB0aGF0IGlzIGFib3V0IHRvXG5cdFx0XHRcdC8vIGJlIHVubW91bnRlZCwgdGhlbiBnZXQgdGhlIG5leHQgc2libGluZyBvZiB0aGF0IHZub2RlIGFuZCBzZXRcblx0XHRcdFx0Ly8gX25leHREb20gdG8gaXRcblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBnZXRMYXN0RG9tKG9sZFBhcmVudFZOb2RlKS5uZXh0U2libGluZztcblx0XHRcdH1cblxuXHRcdFx0dW5tb3VudChvbGRDaGlsZHJlbltpXSwgb2xkQ2hpbGRyZW5baV0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNldCByZWZzIG9ubHkgYWZ0ZXIgdW5tb3VudFxuXHRpZiAocmVmcykge1xuXHRcdGZvciAoaSA9IDA7IGkgPCByZWZzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcHBseVJlZihyZWZzW2ldLCByZWZzWysraV0sIHJlZnNbKytpXSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlb3JkZXJDaGlsZHJlbihjaGlsZFZOb2RlLCBvbGREb20sIHBhcmVudERvbSkge1xuXHQvLyBOb3RlOiBWTm9kZXMgaW4gbmVzdGVkIHN1c3BlbmRlZCB0cmVlcyBtYXkgYmUgbWlzc2luZyBfY2hpbGRyZW4uXG5cdGxldCBjID0gY2hpbGRWTm9kZS5fY2hpbGRyZW47XG5cdGxldCB0bXAgPSAwO1xuXHRmb3IgKDsgYyAmJiB0bXAgPCBjLmxlbmd0aDsgdG1wKyspIHtcblx0XHRsZXQgdm5vZGUgPSBjW3RtcF07XG5cdFx0aWYgKHZub2RlKSB7XG5cdFx0XHQvLyBXZSB0eXBpY2FsbHkgZW50ZXIgdGhpcyBjb2RlIHBhdGggb24gc0NVIGJhaWxvdXQsIHdoZXJlIHdlIGNvcHlcblx0XHRcdC8vIG9sZFZOb2RlLl9jaGlsZHJlbiB0byBuZXdWTm9kZS5fY2hpbGRyZW4uIElmIHRoYXQgaXMgdGhlIGNhc2UsIHdlIG5lZWRcblx0XHRcdC8vIHRvIHVwZGF0ZSB0aGUgb2xkIGNoaWxkcmVuJ3MgX3BhcmVudCBwb2ludGVyIHRvIHBvaW50IHRvIHRoZSBuZXdWTm9kZVxuXHRcdFx0Ly8gKGNoaWxkVk5vZGUgaGVyZSkuXG5cdFx0XHR2bm9kZS5fcGFyZW50ID0gY2hpbGRWTm9kZTtcblxuXHRcdFx0aWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0b2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKHZub2RlLCBvbGREb20sIHBhcmVudERvbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKHBhcmVudERvbSwgdm5vZGUsIHZub2RlLCBjLCB2bm9kZS5fZG9tLCBvbGREb20pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG5cbi8qKlxuICogRmxhdHRlbiBhbmQgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW59IGNoaWxkcmVuIFRoZSB1bmZsYXR0ZW5lZFxuICogY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ2hpbGRBcnJheShjaGlsZHJlbiwgb3V0KSB7XG5cdG91dCA9IG91dCB8fCBbXTtcblx0aWYgKGNoaWxkcmVuID09IG51bGwgfHwgdHlwZW9mIGNoaWxkcmVuID09ICdib29sZWFuJykge1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0Y2hpbGRyZW4uc29tZShjaGlsZCA9PiB7XG5cdFx0XHR0b0NoaWxkQXJyYXkoY2hpbGQsIG91dCk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b3V0LnB1c2goY2hpbGRyZW4pO1xuXHR9XG5cdHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQ2hpbGQoXG5cdHBhcmVudERvbSxcblx0Y2hpbGRWTm9kZSxcblx0b2xkVk5vZGUsXG5cdG9sZENoaWxkcmVuLFxuXHRuZXdEb20sXG5cdG9sZERvbVxuKSB7XG5cdGxldCBuZXh0RG9tO1xuXHRpZiAoY2hpbGRWTm9kZS5fbmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gT25seSBGcmFnbWVudHMgb3IgY29tcG9uZW50cyB0aGF0IHJldHVybiBGcmFnbWVudCBsaWtlIFZOb2RlcyB3aWxsXG5cdFx0Ly8gaGF2ZSBhIG5vbi11bmRlZmluZWQgX25leHREb20uIENvbnRpbnVlIHRoZSBkaWZmIGZyb20gdGhlIHNpYmxpbmdcblx0XHQvLyBvZiBsYXN0IERPTSBjaGlsZCBvZiB0aGlzIGNoaWxkIFZOb2RlXG5cdFx0bmV4dERvbSA9IGNoaWxkVk5vZGUuX25leHREb207XG5cblx0XHQvLyBFYWdlcmx5IGNsZWFudXAgX25leHREb20uIFdlIGRvbid0IG5lZWQgdG8gcGVyc2lzdCB0aGUgdmFsdWUgYmVjYXVzZVxuXHRcdC8vIGl0IGlzIG9ubHkgdXNlZCBieSBgZGlmZkNoaWxkcmVuYCB0byBkZXRlcm1pbmUgd2hlcmUgdG8gcmVzdW1lIHRoZSBkaWZmIGFmdGVyXG5cdFx0Ly8gZGlmZmluZyBDb21wb25lbnRzIGFuZCBGcmFnbWVudHMuIE9uY2Ugd2Ugc3RvcmUgaXQgdGhlIG5leHRET00gbG9jYWwgdmFyLCB3ZVxuXHRcdC8vIGNhbiBjbGVhbiB1cCB0aGUgcHJvcGVydHlcblx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKFxuXHRcdG9sZFZOb2RlID09IG51bGwgfHxcblx0XHRuZXdEb20gIT0gb2xkRG9tIHx8XG5cdFx0bmV3RG9tLnBhcmVudE5vZGUgPT0gbnVsbFxuXHQpIHtcblx0XHRvdXRlcjogaWYgKG9sZERvbSA9PSBudWxsIHx8IG9sZERvbS5wYXJlbnROb2RlICE9PSBwYXJlbnREb20pIHtcblx0XHRcdHBhcmVudERvbS5hcHBlbmRDaGlsZChuZXdEb20pO1xuXHRcdFx0bmV4dERvbSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGBqPG9sZENoaWxkcmVuTGVuZ3RoOyBqKz0yYCBpcyBhbiBhbHRlcm5hdGl2ZSB0byBgaisrPG9sZENoaWxkcmVuTGVuZ3RoLzJgXG5cdFx0XHRmb3IgKFxuXHRcdFx0XHRsZXQgc2liRG9tID0gb2xkRG9tLCBqID0gMDtcblx0XHRcdFx0KHNpYkRvbSA9IHNpYkRvbS5uZXh0U2libGluZykgJiYgaiA8IG9sZENoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0aiArPSAxXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKHNpYkRvbSA9PSBuZXdEb20pIHtcblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyZW50RG9tLmluc2VydEJlZm9yZShuZXdEb20sIG9sZERvbSk7XG5cdFx0XHRuZXh0RG9tID0gb2xkRG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgcHJlLWNhbGN1bGF0ZWQgdGhlIG5leHRET00gbm9kZSwgdXNlIGl0LiBFbHNlIGNhbGN1bGF0ZSBpdCBub3dcblx0Ly8gU3RyaWN0bHkgY2hlY2sgZm9yIGB1bmRlZmluZWRgIGhlcmUgY3V6IGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlIG9mIGBuZXh0RG9tYC5cblx0Ly8gU2VlIG1vcmUgZGV0YWlsIGluIGNyZWF0ZS1lbGVtZW50LmpzOmNyZWF0ZVZOb2RlXG5cdGlmIChuZXh0RG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHRvbGREb20gPSBuZXh0RG9tO1xuXHR9IGVsc2Uge1xuXHRcdG9sZERvbSA9IG5ld0RvbS5uZXh0U2libGluZztcblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmZ1bmN0aW9uIGdldExhc3REb20odm5vZGUpIHtcblx0aWYgKHZub2RlLnR5cGUgPT0gbnVsbCB8fCB0eXBlb2Ygdm5vZGUudHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gdm5vZGUuX2RvbTtcblx0fVxuXG5cdGlmICh2bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRmb3IgKGxldCBpID0gdm5vZGUuX2NoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRsZXQgY2hpbGQgPSB2bm9kZS5fY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQpIHtcblx0XHRcdFx0bGV0IGxhc3REb20gPSBnZXRMYXN0RG9tKGNoaWxkKTtcblx0XHRcdFx0aWYgKGxhc3REb20pIHtcblx0XHRcdFx0XHRyZXR1cm4gbGFzdERvbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufVxuIiwgImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBkaWZmQ2hpbGRyZW4gfSBmcm9tICcuL2NoaWxkcmVuJztcbmltcG9ydCB7IGRpZmZQcm9wcywgc2V0UHJvcGVydHkgfSBmcm9tICcuL3Byb3BzJztcbmltcG9ydCB7IGFzc2lnbiwgcmVtb3ZlTm9kZSwgc2xpY2UgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgYW5kIGFwcGx5IHByb3BlciBjaGFuZ2VzIHRvIHRoZSBET01cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgcGFyZW50IG9mIHRoZSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0LiBNb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBlbGVtZW50IGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNIeWRyYXRpbmddIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoXG5cdHBhcmVudERvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IHRtcCxcblx0XHRuZXdUeXBlID0gbmV3Vk5vZGUudHlwZTtcblxuXHQvLyBXaGVuIHBhc3NpbmcgdGhyb3VnaCBjcmVhdGVFbGVtZW50IGl0IGFzc2lnbnMgdGhlIG9iamVjdFxuXHQvLyBjb25zdHJ1Y3RvciBhcyB1bmRlZmluZWQuIFRoaXMgdG8gcHJldmVudCBKU09OLWluamVjdGlvbi5cblx0aWYgKG5ld1ZOb2RlLmNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG5cdC8vIElmIHRoZSBwcmV2aW91cyBkaWZmIGJhaWxlZCBvdXQsIHJlc3VtZSBjcmVhdGluZy9oeWRyYXRpbmcuXG5cdGlmIChvbGRWTm9kZS5faHlkcmF0aW5nICE9IG51bGwpIHtcblx0XHRpc0h5ZHJhdGluZyA9IG9sZFZOb2RlLl9oeWRyYXRpbmc7XG5cdFx0b2xkRG9tID0gbmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0Ly8gaWYgd2UgcmVzdW1lLCB3ZSB3YW50IHRoZSB0cmVlIHRvIGJlIFwidW5sb2NrZWRcIlxuXHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gW29sZERvbV07XG5cdH1cblxuXHRpZiAoKHRtcCA9IG9wdGlvbnMuX2RpZmYpKSB0bXAobmV3Vk5vZGUpO1xuXG5cdHRyeSB7XG5cdFx0b3V0ZXI6IGlmICh0eXBlb2YgbmV3VHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRsZXQgYywgaXNOZXcsIG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QsIGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbjtcblx0XHRcdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXG5cdFx0XHQvLyBOZWNlc3NhcnkgZm9yIGNyZWF0ZUNvbnRleHQgYXBpLiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgd2lsbCBwYXNzXG5cdFx0XHQvLyB0aGUgY29udGV4dCB2YWx1ZSBhcyBgdGhpcy5jb250ZXh0YCBqdXN0IGZvciB0aGlzIGNvbXBvbmVudC5cblx0XHRcdHRtcCA9IG5ld1R5cGUuY29udGV4dFR5cGU7XG5cdFx0XHRsZXQgcHJvdmlkZXIgPSB0bXAgJiYgZ2xvYmFsQ29udGV4dFt0bXAuX2lkXTtcblx0XHRcdGxldCBjb21wb25lbnRDb250ZXh0ID0gdG1wXG5cdFx0XHRcdD8gcHJvdmlkZXJcblx0XHRcdFx0XHQ/IHByb3ZpZGVyLnByb3BzLnZhbHVlXG5cdFx0XHRcdFx0OiB0bXAuX2RlZmF1bHRWYWx1ZVxuXHRcdFx0XHQ6IGdsb2JhbENvbnRleHQ7XG5cblx0XHRcdC8vIEdldCBjb21wb25lbnQgYW5kIHNldCBpdCB0byBgY2Bcblx0XHRcdGlmIChvbGRWTm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRcdGMgPSBuZXdWTm9kZS5fY29tcG9uZW50ID0gb2xkVk5vZGUuX2NvbXBvbmVudDtcblx0XHRcdFx0Y2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3BlbmRpbmdFcnJvcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEluc3RhbnRpYXRlIHRoZSBuZXcgY29tcG9uZW50XG5cdFx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVGhlIGNoZWNrIGFib3ZlIHZlcmlmaWVzIHRoYXQgbmV3VHlwZSBpcyBzdXBwb3NlIHRvIGJlIGNvbnN0cnVjdGVkXG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgbmV3VHlwZShuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVHJ1c3QgbWUsIENvbXBvbmVudCBpbXBsZW1lbnRzIHRoZSBpbnRlcmZhY2Ugd2Ugd2FudFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IENvbXBvbmVudChuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdFx0Yy5jb25zdHJ1Y3RvciA9IG5ld1R5cGU7XG5cdFx0XHRcdFx0Yy5yZW5kZXIgPSBkb1JlbmRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvdmlkZXIpIHByb3ZpZGVyLnN1YihjKTtcblxuXHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdGlmICghYy5zdGF0ZSkgYy5zdGF0ZSA9IHt9O1xuXHRcdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0XHRjLl9nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcblx0XHRcdFx0aXNOZXcgPSBjLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2UgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG5cdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IG51bGwpIHtcblx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYy5zdGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBjLnN0YXRlKSB7XG5cdFx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCBjLl9uZXh0U3RhdGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXNzaWduKFxuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSxcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXdQcm9wcywgYy5fbmV4dFN0YXRlKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRvbGRQcm9wcyA9IGMucHJvcHM7XG5cdFx0XHRvbGRTdGF0ZSA9IGMuc3RhdGU7XG5cdFx0XHRjLl92bm9kZSA9IG5ld1ZOb2RlO1xuXG5cdFx0XHQvLyBJbnZva2UgcHJlLXJlbmRlciBsaWZlY3ljbGUgbWV0aG9kc1xuXHRcdFx0aWYgKGlzTmV3KSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkTW91bnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuY29tcG9uZW50RGlkTW91bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdG5ld1Byb3BzICE9PSBvbGRQcm9wcyAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KCFjLl9mb3JjZSAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUoXG5cdFx0XHRcdFx0XHRcdG5ld1Byb3BzLFxuXHRcdFx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudENvbnRleHRcblx0XHRcdFx0XHRcdCkgPT09IGZhbHNlKSB8fFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIE1vcmUgaW5mbyBhYm91dCB0aGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0pvdmlEZUNyb29jay9iZWM1ZjJjZTkzNTQ0ZDJlNjA3MGVmOGUwMDM2ZTRlOFxuXHRcdFx0XHRcdGlmIChuZXdWTm9kZS5fb3JpZ2luYWwgIT09IG9sZFZOb2RlLl9vcmlnaW5hbCkge1xuXHRcdFx0XHRcdFx0Ly8gV2hlbiB3ZSBhcmUgZGVhbGluZyB3aXRoIGEgYmFpbCBiZWNhdXNlIG9mIHNDVSB3ZSBoYXZlIHRvIHVwZGF0ZVxuXHRcdFx0XHRcdFx0Ly8gdGhlIHByb3BzLCBzdGF0ZSBhbmQgZGlydHktc3RhdGUuXG5cdFx0XHRcdFx0XHQvLyB3aGVuIHdlIGFyZSBkZWFsaW5nIHdpdGggc3RyaWN0LWVxdWFsaXR5IHdlIGRvbid0IGFzIHRoZSBjaGlsZCBjb3VsZCBzdGlsbFxuXHRcdFx0XHRcdFx0Ly8gYmUgZGlydGllZCBzZWUgIzM4ODNcblx0XHRcdFx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuLmZvckVhY2godm5vZGUgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKHZub2RlKSB2bm9kZS5fcGFyZW50ID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGMuX3N0YXRlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLl9zdGF0ZUNhbGxiYWNrc1tpXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cblx0XHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudFdpbGxVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgYy5fbmV4dFN0YXRlLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0Yy5jb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdGMuX3BhcmVudERvbSA9IHBhcmVudERvbTtcblxuXHRcdFx0bGV0IHJlbmRlckhvb2sgPSBvcHRpb25zLl9yZW5kZXIsXG5cdFx0XHRcdGNvdW50ID0gMDtcblx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYy5fc3RhdGVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaChjLl9zdGF0ZUNhbGxiYWNrc1tpXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Yy5fc3RhdGVDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHRcdHRtcCA9IGMucmVuZGVyKGMucHJvcHMsIGMuc3RhdGUsIGMuY29udGV4dCk7XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0fSB3aGlsZSAoYy5fZGlydHkgJiYgKytjb3VudCA8IDI1KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIHNldFN0YXRlIGNhbGxlZCBpbiByZW5kZXIsIHNlZSAjMjU1M1xuXHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblxuXHRcdFx0aWYgKGMuZ2V0Q2hpbGRDb250ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCA9IGFzc2lnbihhc3NpZ24oe30sIGdsb2JhbENvbnRleHQpLCBjLmdldENoaWxkQ29udGV4dCgpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpc05ldyAmJiBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0c25hcHNob3QgPSBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBpc1RvcExldmVsRnJhZ21lbnQgPVxuXHRcdFx0XHR0bXAgIT0gbnVsbCAmJiB0bXAudHlwZSA9PT0gRnJhZ21lbnQgJiYgdG1wLmtleSA9PSBudWxsO1xuXHRcdFx0bGV0IHJlbmRlclJlc3VsdCA9IGlzVG9wTGV2ZWxGcmFnbWVudCA/IHRtcC5wcm9wcy5jaGlsZHJlbiA6IHRtcDtcblxuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkocmVuZGVyUmVzdWx0KSA/IHJlbmRlclJlc3VsdCA6IFtyZW5kZXJSZXN1bHRdLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdG9sZERvbSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdGMuYmFzZSA9IG5ld1ZOb2RlLl9kb207XG5cblx0XHRcdC8vIFdlIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCB0aGlzIFZOb2RlLCB1bnNldCBhbnkgc3RvcmVkIGh5ZHJhdGlvbi9iYWlsb3V0IHN0YXRlOlxuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdFx0Yy5fcGVuZGluZ0Vycm9yID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGMuX2ZvcmNlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID09IG51bGwgJiZcblx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0KSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IGRpZmZFbGVtZW50Tm9kZXMoXG5cdFx0XHRcdG9sZFZOb2RlLl9kb20sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCh0bXAgPSBvcHRpb25zLmRpZmZlZCkpIHRtcChuZXdWTm9kZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdC8vIGlmIGh5ZHJhdGluZyBvciBjcmVhdGluZyBpbml0aWFsIHRyZWUsIGJhaWxvdXQgcHJlc2VydmVzIERPTTpcblx0XHRpZiAoaXNIeWRyYXRpbmcgfHwgZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZERvbTtcblx0XHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSAhIWlzSHlkcmF0aW5nO1xuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5bZXhjZXNzRG9tQ2hpbGRyZW4uaW5kZXhPZihvbGREb20pXSA9IG51bGw7XG5cdFx0XHQvLyBeIGNvdWxkIHBvc3NpYmx5IGJlIHNpbXBsaWZpZWQgdG86XG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGggPSAwO1xuXHRcdH1cblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIG5ld1ZOb2RlLCBvbGRWTm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcm9vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0Um9vdChjb21taXRRdWV1ZSwgcm9vdCkge1xuXHRpZiAob3B0aW9ucy5fY29tbWl0KSBvcHRpb25zLl9jb21taXQocm9vdCwgY29tbWl0UXVldWUpO1xuXG5cdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgUmV1c2UgdGhlIGNvbW1pdFF1ZXVlIHZhcmlhYmxlIGhlcmUgc28gdGhlIHR5cGUgY2hhbmdlc1xuXHRcdFx0Y29tbWl0UXVldWUgPSBjLl9yZW5kZXJDYWxsYmFja3M7XG5cdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoY2IgPT4ge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFNlZSBhYm92ZSB0cy1pZ25vcmUgb24gY29tbWl0UXVldWVcblx0XHRcdFx0Y2IuY2FsbChjKTtcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgYy5fdm5vZGUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogRGlmZiB0d28gdmlydHVhbCBub2RlcyByZXByZXNlbnRpbmcgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nXG4gKiB0aGUgdmlydHVhbCBub2RlcyBiZWluZyBkaWZmZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0geyp9IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzSHlkcmF0aW5nIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZGlmZkVsZW1lbnROb2Rlcyhcblx0ZG9tLFxuXHRuZXdWTm9kZSxcblx0b2xkVk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHM7XG5cdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXHRsZXQgbm9kZVR5cGUgPSBuZXdWTm9kZS50eXBlO1xuXHRsZXQgaSA9IDA7XG5cblx0Ly8gVHJhY2tzIGVudGVyaW5nIGFuZCBleGl0aW5nIFNWRyBuYW1lc3BhY2Ugd2hlbiBkZXNjZW5kaW5nIHRocm91Z2ggdGhlIHRyZWUuXG5cdGlmIChub2RlVHlwZSA9PT0gJ3N2ZycpIGlzU3ZnID0gdHJ1ZTtcblxuXHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdGZvciAoOyBpIDwgZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNoaWxkID0gZXhjZXNzRG9tQ2hpbGRyZW5baV07XG5cblx0XHRcdC8vIGlmIG5ld1ZOb2RlIG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiBvciB0aGUgYGRvbWBcblx0XHRcdC8vIGFyZ3VtZW50IG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiwgcmVtb3ZlIGl0IGZyb21cblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuIHNvIGl0IGlzbid0IGxhdGVyIHJlbW92ZWQgaW4gZGlmZkNoaWxkcmVuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNoaWxkICYmXG5cdFx0XHRcdCdzZXRBdHRyaWJ1dGUnIGluIGNoaWxkID09PSAhIW5vZGVUeXBlICYmXG5cdFx0XHRcdChub2RlVHlwZSA/IGNoaWxkLmxvY2FsTmFtZSA9PT0gbm9kZVR5cGUgOiBjaGlsZC5ub2RlVHlwZSA9PT0gMylcblx0XHRcdCkge1xuXHRcdFx0XHRkb20gPSBjaGlsZDtcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoZG9tID09IG51bGwpIHtcblx0XHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgY3JlYXRlVGV4dE5vZGUgcmV0dXJucyBUZXh0LCB3ZSBleHBlY3QgUHJlYWN0RWxlbWVudFxuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld1Byb3BzKTtcblx0XHR9XG5cblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcblx0XHRcdFx0J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZSxcblx0XHRcdFx0bmV3UHJvcHMuaXMgJiYgbmV3UHJvcHNcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgY3JlYXRlZCBhIG5ldyBwYXJlbnQsIHNvIG5vbmUgb2YgdGhlIHByZXZpb3VzbHkgYXR0YWNoZWQgY2hpbGRyZW4gY2FuIGJlIHJldXNlZDpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IG51bGw7XG5cdFx0Ly8gd2UgYXJlIGNyZWF0aW5nIGEgbmV3IG5vZGUsIHNvIHdlIGNhbiBhc3N1bWUgdGhpcyBpcyBhIG5ldyBzdWJ0cmVlIChpbiBjYXNlIHdlIGFyZSBoeWRyYXRpbmcpLCB0aGlzIGRlb3B0cyB0aGUgaHlkcmF0ZVxuXHRcdGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cdH1cblxuXHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHQvLyBEdXJpbmcgaHlkcmF0aW9uLCB3ZSBzdGlsbCBoYXZlIHRvIHNwbGl0IG1lcmdlZCB0ZXh0IGZyb20gU1NSJ2QgSFRNTC5cblx0XHRpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzICYmICghaXNIeWRyYXRpbmcgfHwgZG9tLmRhdGEgIT09IG5ld1Byb3BzKSkge1xuXHRcdFx0ZG9tLmRhdGEgPSBuZXdQcm9wcztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgZXhjZXNzRG9tQ2hpbGRyZW4gd2FzIG5vdCBudWxsLCByZXBvcHVsYXRlIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudCdzIGNoaWxkcmVuOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gZXhjZXNzRG9tQ2hpbGRyZW4gJiYgc2xpY2UuY2FsbChkb20uY2hpbGROb2Rlcyk7XG5cblx0XHRvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcblxuXHRcdGxldCBvbGRIdG1sID0gb2xkUHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cdFx0bGV0IG5ld0h0bWwgPSBuZXdQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblxuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHByb3BzIGFyZSBub3QgZGlmZmVkIGF0IGFsbCAoaW5jbHVkaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKVxuXHRcdC8vIEBUT0RPIHdlIHNob3VsZCB3YXJuIGluIGRlYnVnIG1vZGUgd2hlbiBwcm9wcyBkb24ndCBtYXRjaCBoZXJlLlxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdC8vIEJ1dCwgaWYgd2UgYXJlIGluIGEgc2l0dWF0aW9uIHdoZXJlIHdlIGFyZSB1c2luZyBleGlzdGluZyBET00gKGUuZy4gcmVwbGFjZU5vZGUpXG5cdFx0XHQvLyB3ZSBzaG91bGQgcmVhZCB0aGUgZXhpc3RpbmcgRE9NIGF0dHJpYnV0ZXMgdG8gZGlmZiB0aGVtXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRvbGRQcm9wcyA9IHt9O1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvbGRQcm9wc1tkb20uYXR0cmlidXRlc1tpXS5uYW1lXSA9IGRvbS5hdHRyaWJ1dGVzW2ldLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXdIdG1sIHx8IG9sZEh0bWwpIHtcblx0XHRcdFx0Ly8gQXZvaWQgcmUtYXBwbHlpbmcgdGhlIHNhbWUgJ19faHRtbCcgaWYgaXQgZGlkIG5vdCBjaGFuZ2VkIGJldHdlZW4gcmUtcmVuZGVyXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhbmV3SHRtbCB8fFxuXHRcdFx0XHRcdCgoIW9sZEh0bWwgfHwgbmV3SHRtbC5fX2h0bWwgIT0gb2xkSHRtbC5fX2h0bWwpICYmXG5cdFx0XHRcdFx0XHRuZXdIdG1sLl9faHRtbCAhPT0gZG9tLmlubmVySFRNTClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZG9tLmlubmVySFRNTCA9IChuZXdIdG1sICYmIG5ld0h0bWwuX19odG1sKSB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGlzSHlkcmF0aW5nKTtcblxuXHRcdC8vIElmIHRoZSBuZXcgdm5vZGUgZGlkbid0IGhhdmUgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIGRpZmYgaXRzIGNoaWxkcmVuXG5cdFx0aWYgKG5ld0h0bWwpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpID0gbmV3Vk5vZGUucHJvcHMuY2hpbGRyZW47XG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdGRvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShpKSA/IGkgOiBbaV0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcgJiYgbm9kZVR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlblxuXHRcdFx0XHRcdD8gZXhjZXNzRG9tQ2hpbGRyZW5bMF1cblx0XHRcdFx0XHQ6IG9sZFZOb2RlLl9jaGlsZHJlbiAmJiBnZXREb21TaWJsaW5nKG9sZFZOb2RlLCAwKSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBub3QgcGFydCBvZiBhbnkgdm5vZGUuXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGkgPSBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldICE9IG51bGwpIHJlbW92ZU5vZGUoZXhjZXNzRG9tQ2hpbGRyZW5baV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gKGFzIGFib3ZlLCBkb24ndCBkaWZmIHByb3BzIGR1cmluZyBoeWRyYXRpb24pXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQndmFsdWUnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMudmFsdWUpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0Ly8gIzI3NTYgRm9yIHRoZSA8cHJvZ3Jlc3M+LWVsZW1lbnQgdGhlIGluaXRpYWwgdmFsdWUgaXMgMCxcblx0XHRcdFx0Ly8gZGVzcGl0ZSB0aGUgYXR0cmlidXRlIG5vdCBiZWluZyBwcmVzZW50LiBXaGVuIHRoZSBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gaXMgbWlzc2luZyB0aGUgcHJvZ3Jlc3MgYmFyIGlzIHRyZWF0ZWQgYXMgaW5kZXRlcm1pbmF0ZS5cblx0XHRcdFx0Ly8gVG8gZml4IHRoYXQgd2UnbGwgYWx3YXlzIHVwZGF0ZSBpdCB3aGVuIGl0IGlzIDAgZm9yIHByb2dyZXNzIGVsZW1lbnRzXG5cdFx0XHRcdChpICE9PSBkb20udmFsdWUgfHxcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdwcm9ncmVzcycgJiYgIWkpIHx8XG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBvbmx5IGZvciBJRSAxMSB0byBmaXggPHNlbGVjdD4gdmFsdWUgbm90IGJlaW5nIHVwZGF0ZWQuXG5cdFx0XHRcdFx0Ly8gVG8gYXZvaWQgYSBzdGFsZSBzZWxlY3QgdmFsdWUgd2UgbmVlZCB0byBzZXQgdGhlIG9wdGlvbi52YWx1ZVxuXHRcdFx0XHRcdC8vIGFnYWluLCB3aGljaCB0cmlnZ2VycyBJRTExIHRvIHJlLWV2YWx1YXRlIHRoZSBzZWxlY3QgdmFsdWVcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdvcHRpb24nICYmIGkgIT09IG9sZFByb3BzLnZhbHVlKSlcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICd2YWx1ZScsIGksIG9sZFByb3BzLnZhbHVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCdjaGVja2VkJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLmNoZWNrZWQpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0aSAhPT0gZG9tLmNoZWNrZWRcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICdjaGVja2VkJywgaSwgb2xkUHJvcHMuY2hlY2tlZCwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkb207XG59XG5cbi8qKlxuICogSW52b2tlIG9yIHVwZGF0ZSBhIHJlZiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYSBmdW5jdGlvbiBvciBvYmplY3QgcmVmLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHJlZlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UmVmKHJlZiwgdmFsdWUsIHZub2RlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykgcmVmKHZhbHVlKTtcblx0XHRlbHNlIHJlZi5jdXJyZW50ID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFVubW91bnQgYSB2aXJ0dWFsIG5vZGUgZnJvbSB0aGUgdHJlZSBhbmQgYXBwbHkgRE9NIGNoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHVubW91bnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBwYXJlbnRWTm9kZSBUaGUgcGFyZW50IG9mIHRoZSBWTm9kZSB0aGF0XG4gKiBpbml0aWF0ZWQgdGhlIHVubW91bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmVdIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIHBhcmVudCBub2RlIG9mIHRoZVxuICogY3VycmVudCBlbGVtZW50IGlzIGFscmVhZHkgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSwgcGFyZW50Vk5vZGUsIHNraXBSZW1vdmUpIHtcblx0bGV0IHI7XG5cdGlmIChvcHRpb25zLnVubW91bnQpIG9wdGlvbnMudW5tb3VudCh2bm9kZSk7XG5cblx0aWYgKChyID0gdm5vZGUucmVmKSkge1xuXHRcdGlmICghci5jdXJyZW50IHx8IHIuY3VycmVudCA9PT0gdm5vZGUuX2RvbSkge1xuXHRcdFx0YXBwbHlSZWYociwgbnVsbCwgcGFyZW50Vk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdGlmICgociA9IHZub2RlLl9jb21wb25lbnQpICE9IG51bGwpIHtcblx0XHRpZiAoci5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ci5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHBhcmVudFZOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyLmJhc2UgPSByLl9wYXJlbnREb20gPSBudWxsO1xuXHRcdHZub2RlLl9jb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY2hpbGRyZW4pKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocltpXSkge1xuXHRcdFx0XHR1bm1vdW50KFxuXHRcdFx0XHRcdHJbaV0sXG5cdFx0XHRcdFx0cGFyZW50Vk5vZGUsXG5cdFx0XHRcdFx0c2tpcFJlbW92ZSB8fCB0eXBlb2Ygdm5vZGUudHlwZSAhPT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICghc2tpcFJlbW92ZSAmJiB2bm9kZS5fZG9tICE9IG51bGwpIHtcblx0XHRyZW1vdmVOb2RlKHZub2RlLl9kb20pO1xuXHR9XG5cblx0Ly8gTXVzdCBiZSBzZXQgdG8gYHVuZGVmaW5lZGAgdG8gcHJvcGVybHkgY2xlYW4gdXAgYF9uZXh0RG9tYFxuXHQvLyBmb3Igd2hpY2ggYG51bGxgIGlzIGEgdmFsaWQgdmFsdWUuIFNlZSBjb21tZW50IGluIGBjcmVhdGUtZWxlbWVudC5qc2Bcblx0dm5vZGUuX3BhcmVudCA9IHZub2RlLl9kb20gPSB2bm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcbn1cblxuLyoqIFRoZSBgLnJlbmRlcigpYCBtZXRob2QgZm9yIGEgUEZDIGJhY2tpbmcgaW5zdGFuY2UuICovXG5mdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xufVxuIiwgImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNvbW1pdFJvb3QsIGRpZmYgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogUmVuZGVyIGEgUHJlYWN0IHZpcnR1YWwgbm9kZSBpbnRvIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHJlbmRlciBpbnRvXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnQgfCBvYmplY3R9IFtyZXBsYWNlTm9kZV0gT3B0aW9uYWw6IEF0dGVtcHQgdG8gcmUtdXNlIGFuXG4gKiBleGlzdGluZyBET00gdHJlZSByb290ZWQgYXQgYHJlcGxhY2VOb2RlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnREb20sIHJlcGxhY2VOb2RlKSB7XG5cdGlmIChvcHRpb25zLl9yb290KSBvcHRpb25zLl9yb290KHZub2RlLCBwYXJlbnREb20pO1xuXG5cdC8vIFdlIGFidXNlIHRoZSBgcmVwbGFjZU5vZGVgIHBhcmFtZXRlciBpbiBgaHlkcmF0ZSgpYCB0byBzaWduYWwgaWYgd2UgYXJlIGluXG5cdC8vIGh5ZHJhdGlvbiBtb2RlIG9yIG5vdCBieSBwYXNzaW5nIHRoZSBgaHlkcmF0ZWAgZnVuY3Rpb24gaW5zdGVhZCBvZiBhIERPTVxuXHQvLyBlbGVtZW50Li5cblx0bGV0IGlzSHlkcmF0aW5nID0gdHlwZW9mIHJlcGxhY2VOb2RlID09PSAnZnVuY3Rpb24nO1xuXG5cdC8vIFRvIGJlIGFibGUgdG8gc3VwcG9ydCBjYWxsaW5nIGByZW5kZXIoKWAgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWVcblx0Ly8gRE9NIG5vZGUsIHdlIG5lZWQgdG8gb2J0YWluIGEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyB0cmVlLiBXZSBkb1xuXHQvLyB0aGlzIGJ5IGFzc2lnbmluZyBhIG5ldyBgX2NoaWxkcmVuYCBwcm9wZXJ0eSB0byBET00gbm9kZXMgd2hpY2ggcG9pbnRzXG5cdC8vIHRvIHRoZSBsYXN0IHJlbmRlcmVkIHRyZWUuIEJ5IGRlZmF1bHQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCwgd2hpY2hcblx0Ly8gbWVhbnMgdGhhdCB3ZSBhcmUgbW91bnRpbmcgYSBuZXcgdHJlZSBmb3IgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBvbGRWTm9kZSA9IGlzSHlkcmF0aW5nXG5cdFx0PyBudWxsXG5cdFx0OiAocmVwbGFjZU5vZGUgJiYgcmVwbGFjZU5vZGUuX2NoaWxkcmVuKSB8fCBwYXJlbnREb20uX2NoaWxkcmVuO1xuXG5cdHZub2RlID0gKFxuXHRcdCghaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGUpIHx8XG5cdFx0cGFyZW50RG9tXG5cdCkuX2NoaWxkcmVuID0gY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgW3Zub2RlXSk7XG5cblx0Ly8gTGlzdCBvZiBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXIgZGlmZmluZy5cblx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdGRpZmYoXG5cdFx0cGFyZW50RG9tLFxuXHRcdC8vIERldGVybWluZSB0aGUgbmV3IHZub2RlIHRyZWUgYW5kIHN0b3JlIGl0IG9uIHRoZSBET00gZWxlbWVudCBvblxuXHRcdC8vIG91ciBjdXN0b20gYF9jaGlsZHJlbmAgcHJvcGVydHkuXG5cdFx0dm5vZGUsXG5cdFx0b2xkVk5vZGUgfHwgRU1QVFlfT0JKLFxuXHRcdEVNUFRZX09CSixcblx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0IWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlXG5cdFx0XHQ/IFtyZXBsYWNlTm9kZV1cblx0XHRcdDogb2xkVk5vZGVcblx0XHRcdD8gbnVsbFxuXHRcdFx0OiBwYXJlbnREb20uZmlyc3RDaGlsZFxuXHRcdFx0PyBzbGljZS5jYWxsKHBhcmVudERvbS5jaGlsZE5vZGVzKVxuXHRcdFx0OiBudWxsLFxuXHRcdGNvbW1pdFF1ZXVlLFxuXHRcdCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZVxuXHRcdFx0PyByZXBsYWNlTm9kZVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBvbGRWTm9kZS5fZG9tXG5cdFx0XHQ6IHBhcmVudERvbS5maXJzdENoaWxkLFxuXHRcdGlzSHlkcmF0aW5nXG5cdCk7XG5cblx0Ly8gRmx1c2ggYWxsIHF1ZXVlZCBlZmZlY3RzXG5cdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgRE9NIGVsZW1lbnQgd2l0aCBkYXRhIGZyb20gYSBQcmVhY3QgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHRvXG4gKiB1cGRhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudERvbSkge1xuXHRyZW5kZXIodm5vZGUsIHBhcmVudERvbSwgaHlkcmF0ZSk7XG59XG4iLCAiaW1wb3J0IHsgYXNzaWduLCBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIENsb25lcyB0aGUgZ2l2ZW4gVk5vZGUsIG9wdGlvbmFsbHkgYWRkaW5nIGF0dHJpYnV0ZXMvcHJvcHMgYW5kIHJlcGxhY2luZyBpdHMgY2hpbGRyZW4uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBET00gZWxlbWVudCB0byBjbG9uZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIEF0dHJpYnV0ZXMvcHJvcHMgdG8gYWRkIHdoZW4gY2xvbmluZ1xuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbj59IHJlc3QgQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHdpbGwgYmUgdXNlZCBhcyByZXBsYWNlbWVudCBjaGlsZHJlbi5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRWxlbWVudCh2bm9kZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSBhc3NpZ24oe30sIHZub2RlLnByb3BzKSxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdrZXknKSBrZXkgPSBwcm9wc1tpXTtcblx0XHRlbHNlIGlmIChpID09ICdyZWYnKSByZWYgPSBwcm9wc1tpXTtcblx0XHRlbHNlIG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHByb3BzW2ldO1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzLmNoaWxkcmVuID1cblx0XHRcdGFyZ3VtZW50cy5sZW5ndGggPiAzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogY2hpbGRyZW47XG5cdH1cblxuXHRyZXR1cm4gY3JlYXRlVk5vZGUoXG5cdFx0dm5vZGUudHlwZSxcblx0XHRub3JtYWxpemVkUHJvcHMsXG5cdFx0a2V5IHx8IHZub2RlLmtleSxcblx0XHRyZWYgfHwgdm5vZGUucmVmLFxuXHRcdG51bGxcblx0KTtcbn1cbiIsICIvKipcbiAqIEZpbmQgdGhlIGNsb3Nlc3QgZXJyb3IgYm91bmRhcnkgdG8gYSB0aHJvd24gZXJyb3IgYW5kIGNhbGwgaXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvciBUaGUgdGhyb3duIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRoYXQgdGhyZXdcbiAqIHRoZSBlcnJvciB0aGF0IHdhcyBjYXVnaHQgKGV4Y2VwdCBmb3IgdW5tb3VudGluZyB3aGVuIHRoaXMgcGFyYW1ldGVyXG4gKiBpcyB0aGUgaGlnaGVzdCBwYXJlbnQgdGhhdCB3YXMgYmVpbmcgdW5tb3VudGVkKVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IFtvbGRWTm9kZV1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkVycm9ySW5mb30gW2Vycm9ySW5mb11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXRjaEVycm9yKGVycm9yLCB2bm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQsIGN0b3IsIGhhbmRsZWQ7XG5cblx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmICFjb21wb25lbnQuX3Byb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGN0b3IgPSBjb21wb25lbnQuY29uc3RydWN0b3I7XG5cblx0XHRcdFx0aWYgKGN0b3IgJiYgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5zZXRTdGF0ZShjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikpO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8gfHwge30pO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBhbiBlcnJvciBib3VuZGFyeS4gTWFyayBpdCBhcyBoYXZpbmcgYmFpbGVkIG91dCwgYW5kIHdoZXRoZXIgaXQgd2FzIG1pZC1oeWRyYXRpb24uXG5cdFx0XHRcdGlmIChoYW5kbGVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChjb21wb25lbnQuX3BlbmRpbmdFcnJvciA9IGNvbXBvbmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRocm93IGVycm9yO1xufVxuIiwgImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SW5kZXg7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IGN1cnJlbnRDb21wb25lbnQ7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IHByZXZpb3VzQ29tcG9uZW50O1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SG9vayA9IDA7XG5cbi8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn0gKi9cbmxldCBhZnRlclBhaW50RWZmZWN0cyA9IFtdO1xuXG5sZXQgRU1QVFkgPSBbXTtcblxubGV0IG9sZEJlZm9yZURpZmYgPSBvcHRpb25zLl9kaWZmO1xubGV0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbmxldCBvbGRBZnRlckRpZmYgPSBvcHRpb25zLmRpZmZlZDtcbmxldCBvbGRDb21taXQgPSBvcHRpb25zLl9jb21taXQ7XG5sZXQgb2xkQmVmb3JlVW5tb3VudCA9IG9wdGlvbnMudW5tb3VudDtcblxuY29uc3QgUkFGX1RJTUVPVVQgPSAxMDA7XG5sZXQgcHJldlJhZjtcblxub3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0Y3VycmVudENvbXBvbmVudCA9IG51bGw7XG5cdGlmIChvbGRCZWZvcmVEaWZmKSBvbGRCZWZvcmVEaWZmKHZub2RlKTtcbn07XG5cbm9wdGlvbnMuX3JlbmRlciA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVJlbmRlcikgb2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0Y3VycmVudEluZGV4ID0gMDtcblxuXHRjb25zdCBob29rcyA9IGN1cnJlbnRDb21wb25lbnQuX19ob29rcztcblx0aWYgKGhvb2tzKSB7XG5cdFx0aWYgKHByZXZpb3VzQ29tcG9uZW50ID09PSBjdXJyZW50Q29tcG9uZW50KSB7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0aG9va3MuX2xpc3QuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdGlmIChob29rSXRlbS5fbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX25leHRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRob29rSXRlbS5fcGVuZGluZ1ZhbHVlID0gRU1QVFk7XG5cdFx0XHRcdGhvb2tJdGVtLl9uZXh0VmFsdWUgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3MgPSB1bmRlZmluZWQ7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VFZmZlY3QpO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0fVxuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudDtcbn07XG5cbm9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQWZ0ZXJEaWZmKSBvbGRBZnRlckRpZmYodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRpZiAoYy5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5sZW5ndGgpIGFmdGVyUGFpbnQoYWZ0ZXJQYWludEVmZmVjdHMucHVzaChjKSk7XG5cdFx0Yy5fX2hvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0aWYgKGhvb2tJdGVtLl9wZW5kaW5nQXJncykge1xuXHRcdFx0XHRob29rSXRlbS5fYXJncyA9IGhvb2tJdGVtLl9wZW5kaW5nQXJncztcblx0XHRcdH1cblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ1ZhbHVlICE9PSBFTVBUWSkge1xuXHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fcGVuZGluZ1ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdH0pO1xuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudCA9IG51bGw7XG59O1xuXG5vcHRpb25zLl9jb21taXQgPSAodm5vZGUsIGNvbW1pdFF1ZXVlKSA9PiB7XG5cdGNvbW1pdFF1ZXVlLnNvbWUoY29tcG9uZW50ID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzID0gY29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZmlsdGVyKGNiID0+XG5cdFx0XHRcdGNiLl92YWx1ZSA/IGludm9rZUVmZmVjdChjYikgOiB0cnVlXG5cdFx0XHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MpIGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fSk7XG5cdFx0XHRjb21taXRRdWV1ZSA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChvbGRDb21taXQpIG9sZENvbW1pdCh2bm9kZSwgY29tbWl0UXVldWUpO1xufTtcblxub3B0aW9ucy51bm1vdW50ID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQmVmb3JlVW5tb3VudCkgb2xkQmVmb3JlVW5tb3VudCh2bm9kZSk7XG5cblx0Y29uc3QgYyA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjICYmIGMuX19ob29rcykge1xuXHRcdGxldCBoYXNFcnJvcmVkO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKHMgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aW52b2tlQ2xlYW51cChzKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aGFzRXJyb3JlZCA9IGU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Yy5fX2hvb2tzID0gdW5kZWZpbmVkO1xuXHRcdGlmIChoYXNFcnJvcmVkKSBvcHRpb25zLl9jYXRjaEVycm9yKGhhc0Vycm9yZWQsIGMuX3Zub2RlKTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXQgYSBob29rJ3Mgc3RhdGUgZnJvbSB0aGUgY3VycmVudENvbXBvbmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tTdGF0ZShpbmRleCwgdHlwZSkge1xuXHRpZiAob3B0aW9ucy5faG9vaykge1xuXHRcdG9wdGlvbnMuX2hvb2soY3VycmVudENvbXBvbmVudCwgaW5kZXgsIGN1cnJlbnRIb29rIHx8IHR5cGUpO1xuXHR9XG5cdGN1cnJlbnRIb29rID0gMDtcblxuXHQvLyBMYXJnZWx5IGluc3BpcmVkIGJ5OlxuXHQvLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWVsLWtsZWluL2Z1bmN5LmpzL2Jsb2IvZjZiZTczNDY4ZTZlYzQ2YjBmZjVhYTNjYzRjOWJhZjcyYTI5MDI1YS9zcmMvaG9va3MvY29yZV9ob29rcy5tanNcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iLzY1MGJlYWE1OGM0M2MzM2E3NDgyMGEzYzk4YjNjNzA3OWNmMmUzMzMvc3JjL3JlbmRlcmVyLm1qc1xuXHQvLyBPdGhlciBpbXBsZW1lbnRhdGlvbnMgdG8gbG9vayBhdDpcblx0Ly8gKiBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvbW5veDA1cXA4XG5cdGNvbnN0IGhvb2tzID1cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MgfHxcblx0XHQoY3VycmVudENvbXBvbmVudC5fX2hvb2tzID0ge1xuXHRcdFx0X2xpc3Q6IFtdLFxuXHRcdFx0X3BlbmRpbmdFZmZlY3RzOiBbXVxuXHRcdH0pO1xuXG5cdGlmIChpbmRleCA+PSBob29rcy5fbGlzdC5sZW5ndGgpIHtcblx0XHRob29rcy5fbGlzdC5wdXNoKHsgX3BlbmRpbmdWYWx1ZTogRU1QVFkgfSk7XG5cdH1cblx0cmV0dXJuIGhvb2tzLl9saXN0W2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBbaW5pdGlhbFN0YXRlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG5cdGN1cnJlbnRIb29rID0gMTtcblx0cmV0dXJuIHVzZVJlZHVjZXIoaW52b2tlT3JSZXR1cm4sIGluaXRpYWxTdGF0ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5SZWR1Y2VyPGFueSwgYW55Pn0gcmVkdWNlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gaW5pdGlhbFN0YXRlXG4gKiBAcGFyYW0geyhpbml0aWFsU3RhdGU6IGFueSkgPT4gdm9pZH0gW2luaXRdXG4gKiBAcmV0dXJucyB7WyBhbnksIChzdGF0ZTogYW55KSA9PiB2b2lkIF19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgaW5pdCkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlJlZHVjZXJIb29rU3RhdGV9ICovXG5cdGNvbnN0IGhvb2tTdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMik7XG5cdGhvb2tTdGF0ZS5fcmVkdWNlciA9IHJlZHVjZXI7XG5cdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQpIHtcblx0XHRob29rU3RhdGUuX3ZhbHVlID0gW1xuXHRcdFx0IWluaXQgPyBpbnZva2VPclJldHVybih1bmRlZmluZWQsIGluaXRpYWxTdGF0ZSkgOiBpbml0KGluaXRpYWxTdGF0ZSksXG5cblx0XHRcdGFjdGlvbiA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tTdGF0ZS5fbmV4dFZhbHVlXG5cdFx0XHRcdFx0PyBob29rU3RhdGUuX25leHRWYWx1ZVswXVxuXHRcdFx0XHRcdDogaG9va1N0YXRlLl92YWx1ZVswXTtcblx0XHRcdFx0Y29uc3QgbmV4dFZhbHVlID0gaG9va1N0YXRlLl9yZWR1Y2VyKGN1cnJlbnRWYWx1ZSwgYWN0aW9uKTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlICE9PSBuZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRob29rU3RhdGUuX25leHRWYWx1ZSA9IFtuZXh0VmFsdWUsIGhvb2tTdGF0ZS5fdmFsdWVbMV1dO1xuXHRcdFx0XHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50LnNldFN0YXRlKHt9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF07XG5cblx0XHRob29rU3RhdGUuX2NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cblx0XHRpZiAoIWN1cnJlbnRDb21wb25lbnQuX2hhc1NjdUZyb21Ib29rcykge1xuXHRcdFx0Y3VycmVudENvbXBvbmVudC5faGFzU2N1RnJvbUhvb2tzID0gdHJ1ZTtcblx0XHRcdGNvbnN0IHByZXZTY3UgPSBjdXJyZW50Q29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZTtcblxuXHRcdFx0Ly8gVGhpcyBTQ1UgaGFzIHRoZSBwdXJwb3NlIG9mIGJhaWxpbmcgb3V0IGFmdGVyIHJlcGVhdGVkIHVwZGF0ZXNcblx0XHRcdC8vIHRvIHN0YXRlZnVsIGhvb2tzLlxuXHRcdFx0Ly8gd2Ugc3RvcmUgdGhlIG5leHQgdmFsdWUgaW4gX25leHRWYWx1ZVswXSBhbmQga2VlcCBkb2luZyB0aGF0IGZvciBhbGxcblx0XHRcdC8vIHN0YXRlIHNldHRlcnMsIGlmIHdlIGhhdmUgbmV4dCBzdGF0ZXMgYW5kXG5cdFx0XHQvLyBhbGwgbmV4dCBzdGF0ZXMgd2l0aGluIGEgY29tcG9uZW50IGVuZCB1cCBiZWluZyBlcXVhbCB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZVxuXHRcdFx0Ly8gd2UgYXJlIHNhZmUgdG8gYmFpbCBvdXQgZm9yIHRoaXMgc3BlY2lmaWMgY29tcG9uZW50LlxuXHRcdFx0Y3VycmVudENvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwLCBzLCBjKSB7XG5cdFx0XHRcdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQuX19ob29rcykgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0Y29uc3Qgc3RhdGVIb29rcyA9IGhvb2tTdGF0ZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZmlsdGVyKFxuXHRcdFx0XHRcdHggPT4geC5fY29tcG9uZW50XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IGFsbEhvb2tzRW1wdHkgPSBzdGF0ZUhvb2tzLmV2ZXJ5KHggPT4gIXguX25leHRWYWx1ZSk7XG5cdFx0XHRcdC8vIFdoZW4gd2UgaGF2ZSBubyB1cGRhdGVkIGhvb2tzIGluIHRoZSBjb21wb25lbnQgd2UgaW52b2tlIHRoZSBwcmV2aW91cyBTQ1Ugb3Jcblx0XHRcdFx0Ly8gdHJhdmVyc2UgdGhlIFZET00gdHJlZSBmdXJ0aGVyLlxuXHRcdFx0XHRpZiAoYWxsSG9va3NFbXB0eSkge1xuXHRcdFx0XHRcdHJldHVybiBwcmV2U2N1ID8gcHJldlNjdS5jYWxsKHRoaXMsIHAsIHMsIGMpIDogdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIGNoZWNrIHdoZXRoZXIgd2UgaGF2ZSBjb21wb25lbnRzIHdpdGggYSBuZXh0VmFsdWUgc2V0IHRoYXRcblx0XHRcdFx0Ly8gaGF2ZSB2YWx1ZXMgdGhhdCBhcmVuJ3QgZXF1YWwgdG8gb25lIGFub3RoZXIgdGhpcyBwdXNoZXNcblx0XHRcdFx0Ly8gdXMgdG8gdXBkYXRlIGZ1cnRoZXIgZG93biB0aGUgdHJlZVxuXHRcdFx0XHRsZXQgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdHN0YXRlSG9va3MuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdFx0aWYgKGhvb2tJdGVtLl9uZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tJdGVtLl92YWx1ZVswXTtcblx0XHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gaG9va0l0ZW0uX3ZhbHVlWzBdKSBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHNob3VsZFVwZGF0ZSB8fCBob29rU3RhdGUuX2NvbXBvbmVudC5wcm9wcyAhPT0gcFxuXHRcdFx0XHRcdD8gcHJldlNjdVxuXHRcdFx0XHRcdFx0PyBwcmV2U2N1LmNhbGwodGhpcywgcCwgcywgYylcblx0XHRcdFx0XHRcdDogdHJ1ZVxuXHRcdFx0XHRcdDogZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBob29rU3RhdGUuX25leHRWYWx1ZSB8fCBob29rU3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0fSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRWZmZWN0KGNhbGxiYWNrLCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMyk7XG5cdGlmICghb3B0aW9ucy5fc2tpcEVmZmVjdHMgJiYgYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gY2FsbGJhY2s7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDQpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcblx0Y3VycmVudEhvb2sgPSA1O1xuXHRyZXR1cm4gdXNlTWVtbygoKSA9PiAoeyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksIFtdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmXG4gKiBAcGFyYW0geygpID0+IG9iamVjdH0gY3JlYXRlSGFuZGxlXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlSGFuZGxlLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gNjtcblx0dXNlTGF5b3V0RWZmZWN0KFxuXHRcdCgpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmVmKGNyZWF0ZUhhbmRsZSgpKTtcblx0XHRcdFx0cmV0dXJuICgpID0+IHJlZihudWxsKTtcblx0XHRcdH0gZWxzZSBpZiAocmVmKSB7XG5cdFx0XHRcdHJlZi5jdXJyZW50ID0gY3JlYXRlSGFuZGxlKCk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFyZ3MgPT0gbnVsbCA/IGFyZ3MgOiBhcmdzLmNvbmNhdChyZWYpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbW8oZmFjdG9yeSwgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk1lbW9Ib29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA3KTtcblx0aWYgKGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl9wZW5kaW5nVmFsdWUgPSBmYWN0b3J5KCk7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblx0XHRzdGF0ZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG5cdFx0cmV0dXJuIHN0YXRlLl9wZW5kaW5nVmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gODtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gY2FsbGJhY2ssIGFyZ3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0Q29udGV4dH0gY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG5cdGNvbnN0IHByb3ZpZGVyID0gY3VycmVudENvbXBvbmVudC5jb250ZXh0W2NvbnRleHQuX2lkXTtcblx0Ly8gV2UgY291bGQgc2tpcCB0aGlzIGNhbGwgaGVyZSwgYnV0IHRoYW4gd2UnZCBub3QgY2FsbFxuXHQvLyBgb3B0aW9ucy5faG9va2AuIFdlIG5lZWQgdG8gZG8gdGhhdCBpbiBvcmRlciB0byBtYWtlXG5cdC8vIHRoZSBkZXZ0b29scyBhd2FyZSBvZiB0aGlzIGhvb2suXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29udGV4dEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDkpO1xuXHQvLyBUaGUgZGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB0b1xuXHQvLyBiZSBhYmxlIHRvIHB1bGwgb2YgdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBubyBwcm92aWRlclxuXHQvLyBpcyBwcmVzZW50IGluIHRoZSB0cmVlLlxuXHRzdGF0ZS5fY29udGV4dCA9IGNvbnRleHQ7XG5cdGlmICghcHJvdmlkZXIpIHJldHVybiBjb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG5cdC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHNhZmUgdG8gY29udmVydCB0byBcIiFcIlxuXHRpZiAoc3RhdGUuX3ZhbHVlID09IG51bGwpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSB0cnVlO1xuXHRcdHByb3ZpZGVyLnN1YihjdXJyZW50Q29tcG9uZW50KTtcblx0fVxuXHRyZXR1cm4gcHJvdmlkZXIucHJvcHMudmFsdWU7XG59XG5cbi8qKlxuICogRGlzcGxheSBhIGN1c3RvbSBsYWJlbCBmb3IgYSBjdXN0b20gaG9vayBmb3IgdGhlIGRldnRvb2xzIHBhbmVsXG4gKiBAdHlwZSB7PFQ+KHZhbHVlOiBULCBjYj86ICh2YWx1ZTogVCkgPT4gc3RyaW5nIHwgbnVtYmVyKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyKSB7XG5cdGlmIChvcHRpb25zLnVzZURlYnVnVmFsdWUpIHtcblx0XHRvcHRpb25zLnVzZURlYnVnVmFsdWUoZm9ybWF0dGVyID8gZm9ybWF0dGVyKHZhbHVlKSA6IHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KGVycm9yOiBhbnksIGVycm9ySW5mbzogaW1wb3J0KCdwcmVhY3QnKS5FcnJvckluZm8pID0+IHZvaWR9IGNiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFcnJvckJvdW5kYXJ5KGNiKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRXJyb3JCb3VuZGFyeUhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDEwKTtcblx0Y29uc3QgZXJyU3RhdGUgPSB1c2VTdGF0ZSgpO1xuXHRzdGF0ZS5fdmFsdWUgPSBjYjtcblx0aWYgKCFjdXJyZW50Q29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKSB7XG5cdFx0Y3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCA9IChlcnIsIGVycm9ySW5mbykgPT4ge1xuXHRcdFx0aWYgKHN0YXRlLl92YWx1ZSkgc3RhdGUuX3ZhbHVlKGVyciwgZXJyb3JJbmZvKTtcblx0XHRcdGVyclN0YXRlWzFdKGVycik7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gW1xuXHRcdGVyclN0YXRlWzBdLFxuXHRcdCgpID0+IHtcblx0XHRcdGVyclN0YXRlWzFdKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSWQoKSB7XG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMSk7XG5cdGlmICghc3RhdGUuX3ZhbHVlKSB7XG5cdFx0Ly8gR3JhYiBlaXRoZXIgdGhlIHJvb3Qgbm9kZSBvciB0aGUgbmVhcmVzdCBhc3luYyBib3VuZGFyeSBub2RlLlxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsLmQnKS5WTm9kZX0gKi9cblx0XHRsZXQgcm9vdCA9IGN1cnJlbnRDb21wb25lbnQuX3Zub2RlO1xuXHRcdHdoaWxlIChyb290ICE9PSBudWxsICYmICFyb290Ll9tYXNrICYmIHJvb3QuX3BhcmVudCAhPT0gbnVsbCkge1xuXHRcdFx0cm9vdCA9IHJvb3QuX3BhcmVudDtcblx0XHR9XG5cblx0XHRsZXQgbWFzayA9IHJvb3QuX21hc2sgfHwgKHJvb3QuX21hc2sgPSBbMCwgMF0pO1xuXHRcdHN0YXRlLl92YWx1ZSA9ICdQJyArIG1hc2tbMF0gKyAnLScgKyBtYXNrWzFdKys7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuLyoqXG4gKiBBZnRlciBwYWludCBlZmZlY3RzIGNvbnN1bWVyLlxuICovXG5mdW5jdGlvbiBmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKCkge1xuXHRsZXQgY29tcG9uZW50O1xuXHR3aGlsZSAoKGNvbXBvbmVudCA9IGFmdGVyUGFpbnRFZmZlY3RzLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKCFjb21wb25lbnQuX3BhcmVudERvbSB8fCAhY29tcG9uZW50Ll9faG9va3MpIGNvbnRpbnVlO1xuXHRcdHRyeSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUVmZmVjdCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmxldCBIQVNfUkFGID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIFNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgYnJvd3NlciBoYXMgYSBjaGFuY2UgdG8gcGFpbnQgYSBuZXcgZnJhbWUuXG4gKiBEbyB0aGlzIGJ5IGNvbWJpbmluZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHJBRikgKyBzZXRUaW1lb3V0IHRvIGludm9rZSBhIGNhbGxiYWNrIGFmdGVyXG4gKiB0aGUgbmV4dCBicm93c2VyIGZyYW1lLlxuICpcbiAqIEFsc28sIHNjaGVkdWxlIGEgdGltZW91dCBpbiBwYXJhbGxlbCB0byB0aGUgdGhlIHJBRiB0byBlbnN1cmUgdGhlIGNhbGxiYWNrIGlzIGludm9rZWRcbiAqIGV2ZW4gaWYgUkFGIGRvZXNuJ3QgZmlyZSAoZm9yIGV4YW1wbGUgaWYgdGhlIGJyb3dzZXIgdGFiIGlzIG5vdCB2aXNpYmxlKVxuICpcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJOZXh0RnJhbWUoY2FsbGJhY2spIHtcblx0Y29uc3QgZG9uZSA9ICgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0aWYgKEhBU19SQUYpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG5cdFx0c2V0VGltZW91dChjYWxsYmFjayk7XG5cdH07XG5cdGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvbmUsIFJBRl9USU1FT1VUKTtcblxuXHRsZXQgcmFmO1xuXHRpZiAoSEFTX1JBRikge1xuXHRcdHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkb25lKTtcblx0fVxufVxuXG4vLyBOb3RlOiBpZiBzb21lb25lIHVzZWQgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSxcbi8vIHRoZW4gZWZmZWN0cyB3aWxsIEFMV0FZUyBydW4gb24gdGhlIE5FWFQgZnJhbWUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBvbmUsIGluY3VycmluZyBhIH4xNm1zIGRlbGF5LlxuLy8gUGVyaGFwcyB0aGlzIGlzIG5vdCBzdWNoIGEgYmlnIGRlYWwuXG4vKipcbiAqIFNjaGVkdWxlIGFmdGVyUGFpbnRFZmZlY3RzIGZsdXNoIGFmdGVyIHRoZSBicm93c2VyIHBhaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5ld1F1ZXVlTGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGFmdGVyUGFpbnQobmV3UXVldWVMZW5ndGgpIHtcblx0aWYgKG5ld1F1ZXVlTGVuZ3RoID09PSAxIHx8IHByZXZSYWYgIT09IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0cHJldlJhZiA9IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdChwcmV2UmFmIHx8IGFmdGVyTmV4dEZyYW1lKShmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSBob29rXG4gKi9cbmZ1bmN0aW9uIGludm9rZUNsZWFudXAoaG9vaykge1xuXHQvLyBBIGhvb2sgY2xlYW51cCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRsZXQgY2xlYW51cCA9IGhvb2suX2NsZWFudXA7XG5cdGlmICh0eXBlb2YgY2xlYW51cCA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0aG9vay5fY2xlYW51cCA9IHVuZGVmaW5lZDtcblx0XHRjbGVhbnVwKCk7XG5cdH1cblxuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBJbnZva2UgYSBIb29rJ3MgZWZmZWN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VFZmZlY3QoaG9vaykge1xuXHQvLyBBIGhvb2sgY2FsbCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRob29rLl9jbGVhbnVwID0gaG9vay5fdmFsdWUoKTtcblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gb2xkQXJnc1xuICogQHBhcmFtIHthbnlbXX0gbmV3QXJnc1xuICovXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzLCBuZXdBcmdzKSB7XG5cdHJldHVybiAoXG5cdFx0IW9sZEFyZ3MgfHxcblx0XHRvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncy5sZW5ndGggfHxcblx0XHRuZXdBcmdzLnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGludm9rZU9yUmV0dXJuKGFyZywgZikge1xuXHRyZXR1cm4gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/IGYoYXJnKSA6IGY7XG59XG4iLCAiLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHR3byBvYmplY3RzIGhhdmUgYSBkaWZmZXJlbnQgc2hhcGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBhXG4gKiBAcGFyYW0ge29iamVjdH0gYlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGFsbG93RGlmZmVycyhhLCBiKSB7XG5cdGZvciAobGV0IGkgaW4gYSkgaWYgKGkgIT09ICdfX3NvdXJjZScgJiYgIShpIGluIGIpKSByZXR1cm4gdHJ1ZTtcblx0Zm9yIChsZXQgaSBpbiBiKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiBhW2ldICE9PSBiW2ldKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG5cdGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSB0aGUgc2FtZSB2YWx1ZVxuICogQHBhcmFtIHsqfSB4XG4gKiBAcGFyYW0geyp9IHlcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXMoeCwgeSkge1xuXHRyZXR1cm4gKHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSkgfHwgKHggIT09IHggJiYgeSAhPT0geSk7XG59XG4iLCAiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBDb21wb25lbnQgY2xhc3Mgd2l0aCBhIHByZWRlZmluZWQgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaW1wbGVtZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFB1cmVDb21wb25lbnQocCkge1xuXHR0aGlzLnByb3BzID0gcDtcbn1cblB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuLy8gU29tZSB0aGlyZC1wYXJ0eSBsaWJyYXJpZXMgY2hlY2sgaWYgdGhpcyBwcm9wZXJ0eSBpcyBwcmVzZW50XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIHByb3BzKSB8fCBzaGFsbG93RGlmZmVycyh0aGlzLnN0YXRlLCBzdGF0ZSk7XG59O1xuIiwgImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0RpZmZlcnMgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIE1lbW9pemUgYSBjb21wb25lbnQsIHNvIHRoYXQgaXQgb25seSB1cGRhdGVzIHdoZW4gdGhlIHByb3BzIGFjdHVhbGx5IGhhdmVcbiAqIGNoYW5nZWQuIFRoaXMgd2FzIHByZXZpb3VzbHkga25vd24gYXMgYFJlYWN0LnB1cmVgLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH0gYyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICogQHBhcmFtIHsocHJldjogb2JqZWN0LCBuZXh0OiBvYmplY3QpID0+IGJvb2xlYW59IFtjb21wYXJlcl0gQ3VzdG9tIGVxdWFsaXR5IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vKGMsIGNvbXBhcmVyKSB7XG5cdGZ1bmN0aW9uIHNob3VsZFVwZGF0ZShuZXh0UHJvcHMpIHtcblx0XHRsZXQgcmVmID0gdGhpcy5wcm9wcy5yZWY7XG5cdFx0bGV0IHVwZGF0ZVJlZiA9IHJlZiA9PSBuZXh0UHJvcHMucmVmO1xuXHRcdGlmICghdXBkYXRlUmVmICYmIHJlZikge1xuXHRcdFx0cmVmLmNhbGwgPyByZWYobnVsbCkgOiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBhcmVyKSB7XG5cdFx0XHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgbmV4dFByb3BzKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gIWNvbXBhcmVyKHRoaXMucHJvcHMsIG5leHRQcm9wcykgfHwgIXVwZGF0ZVJlZjtcblx0fVxuXG5cdGZ1bmN0aW9uIE1lbW9lZChwcm9wcykge1xuXHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gc2hvdWxkVXBkYXRlO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KGMsIHByb3BzKTtcblx0fVxuXHRNZW1vZWQuZGlzcGxheU5hbWUgPSAnTWVtbygnICsgKGMuZGlzcGxheU5hbWUgfHwgYy5uYW1lKSArICcpJztcblx0TWVtb2VkLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblx0TWVtb2VkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRyZXR1cm4gTWVtb2VkO1xufVxuIiwgImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxubGV0IG9sZERpZmZIb29rID0gb3B0aW9ucy5fZGlmZjtcbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGlmICh2bm9kZS50eXBlICYmIHZub2RlLnR5cGUuX2ZvcndhcmRlZCAmJiB2bm9kZS5yZWYpIHtcblx0XHR2bm9kZS5wcm9wcy5yZWYgPSB2bm9kZS5yZWY7XG5cdFx0dm5vZGUucmVmID0gbnVsbDtcblx0fVxuXHRpZiAob2xkRGlmZkhvb2spIG9sZERpZmZIb29rKHZub2RlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9GT1JXQVJEX1NZTUJPTCA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmXG5cdFx0U3ltYm9sLmZvciAmJlxuXHRcdFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykpIHx8XG5cdDB4ZjQ3O1xuXG4vKipcbiAqIFBhc3MgcmVmIGRvd24gdG8gYSBjaGlsZC4gVGhpcyBpcyBtYWlubHkgdXNlZCBpbiBsaWJyYXJpZXMgd2l0aCBIT0NzIHRoYXRcbiAqIHdyYXAgY29tcG9uZW50cy4gVXNpbmcgYGZvcndhcmRSZWZgIHRoZXJlIGlzIGFuIGVhc3kgd2F5IHRvIGdldCBhIHJlZmVyZW5jZVxuICogb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50IGluc3RlYWQgb2Ygb25lIG9mIHRoZSB3cmFwcGVyIGl0c2VsZi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuRm9yd2FyZEZufSBmblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZFJlZihmbikge1xuXHRmdW5jdGlvbiBGb3J3YXJkZWQocHJvcHMpIHtcblx0XHRsZXQgY2xvbmUgPSBhc3NpZ24oe30sIHByb3BzKTtcblx0XHRkZWxldGUgY2xvbmUucmVmO1xuXHRcdHJldHVybiBmbihjbG9uZSwgcHJvcHMucmVmIHx8IG51bGwpO1xuXHR9XG5cblx0Ly8gbW9ieC1yZWFjdCBjaGVja3MgZm9yIHRoaXMgYmVpbmcgcHJlc2VudFxuXHRGb3J3YXJkZWQuJCR0eXBlb2YgPSBSRUFDVF9GT1JXQVJEX1NZTUJPTDtcblx0Ly8gbW9ieC1yZWFjdCBoZWF2aWx5IHJlbGllcyBvbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuXHQvLyBJdCBleHBlY3RzIGFuIG9iamVjdCBoZXJlIHdpdGggYSBgcmVuZGVyYCBwcm9wZXJ0eSxcblx0Ly8gYW5kIHByb3RvdHlwZS5yZW5kZXIgd2lsbCBmYWlsLiBXaXRob3V0IHRoaXNcblx0Ly8gbW9ieC1yZWFjdCB0aHJvd3MuXG5cdEZvcndhcmRlZC5yZW5kZXIgPSBGb3J3YXJkZWQ7XG5cblx0Rm9yd2FyZGVkLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0gRm9yd2FyZGVkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRGb3J3YXJkZWQuZGlzcGxheU5hbWUgPSAnRm9yd2FyZFJlZignICsgKGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUpICsgJyknO1xuXHRyZXR1cm4gRm9yd2FyZGVkO1xufVxuIiwgImltcG9ydCB7IHRvQ2hpbGRBcnJheSB9IGZyb20gJ3ByZWFjdCc7XG5cbmNvbnN0IG1hcEZuID0gKGNoaWxkcmVuLCBmbikgPT4ge1xuXHRpZiAoY2hpbGRyZW4gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cdHJldHVybiB0b0NoaWxkQXJyYXkodG9DaGlsZEFycmF5KGNoaWxkcmVuKS5tYXAoZm4pKTtcbn07XG5cbi8vIFRoaXMgQVBJIGlzIGNvbXBsZXRlbHkgdW5uZWNlc3NhcnkgZm9yIFByZWFjdCwgc28gaXQncyBiYXNpY2FsbHkgcGFzc3Rocm91Z2guXG5leHBvcnQgY29uc3QgQ2hpbGRyZW4gPSB7XG5cdG1hcDogbWFwRm4sXG5cdGZvckVhY2g6IG1hcEZuLFxuXHRjb3VudChjaGlsZHJlbikge1xuXHRcdHJldHVybiBjaGlsZHJlbiA/IHRvQ2hpbGRBcnJheShjaGlsZHJlbikubGVuZ3RoIDogMDtcblx0fSxcblx0b25seShjaGlsZHJlbikge1xuXHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSB0b0NoaWxkQXJyYXkoY2hpbGRyZW4pO1xuXHRcdGlmIChub3JtYWxpemVkLmxlbmd0aCAhPT0gMSkgdGhyb3cgJ0NoaWxkcmVuLm9ubHknO1xuXHRcdHJldHVybiBub3JtYWxpemVkWzBdO1xuXHR9LFxuXHR0b0FycmF5OiB0b0NoaWxkQXJyYXlcbn07XG4iLCAiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBvbGRDYXRjaEVycm9yID0gb3B0aW9ucy5fY2F0Y2hFcnJvcjtcbm9wdGlvbnMuX2NhdGNoRXJyb3IgPSBmdW5jdGlvbihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pIHtcblx0aWYgKGVycm9yLnRoZW4pIHtcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0XHRsZXQgY29tcG9uZW50O1xuXHRcdGxldCB2bm9kZSA9IG5ld1ZOb2RlO1xuXG5cdFx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRcdGlmICgoY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudCkgJiYgY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQpIHtcblx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9kb20gPT0gbnVsbCkge1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBEb24ndCBjYWxsIG9sZENhdGNoRXJyb3IgaWYgd2UgZm91bmQgYSBTdXNwZW5zZVxuXHRcdFx0XHRyZXR1cm4gY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQoZXJyb3IsIG5ld1ZOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0b2xkQ2F0Y2hFcnJvcihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pO1xufTtcblxuY29uc3Qgb2xkVW5tb3VudCA9IG9wdGlvbnMudW5tb3VudDtcbm9wdGlvbnMudW5tb3VudCA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRjb25zdCBjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5fb25SZXNvbHZlKSB7XG5cdFx0Y29tcG9uZW50Ll9vblJlc29sdmUoKTtcblx0fVxuXG5cdC8vIGlmIHRoZSBjb21wb25lbnQgaXMgc3RpbGwgaHlkcmF0aW5nXG5cdC8vIG1vc3QgbGlrZWx5IGl0IGlzIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWRcblx0Ly8gd2Ugc2V0IHRoZSB2bm9kZS50eXBlIGFzIGBudWxsYCBzbyB0aGF0IGl0IGlzIG5vdCBhIHR5cGVvZiBmdW5jdGlvblxuXHQvLyBzbyB0aGUgdW5tb3VudCB3aWxsIHJlbW92ZSB0aGUgdm5vZGUuX2RvbVxuXHRpZiAoY29tcG9uZW50ICYmIHZub2RlLl9oeWRyYXRpbmcgPT09IHRydWUpIHtcblx0XHR2bm9kZS50eXBlID0gbnVsbDtcblx0fVxuXG5cdGlmIChvbGRVbm1vdW50KSBvbGRVbm1vdW50KHZub2RlKTtcbn07XG5cbmZ1bmN0aW9uIGRldGFjaGVkQ2xvbmUodm5vZGUsIGRldGFjaGVkUGFyZW50LCBwYXJlbnREb20pIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQgJiYgdm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzKSB7XG5cdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZm9yRWFjaChlZmZlY3QgPT4ge1xuXHRcdFx0XHRpZiAodHlwZW9mIGVmZmVjdC5fY2xlYW51cCA9PSAnZnVuY3Rpb24nKSBlZmZlY3QuX2NsZWFudXAoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9faG9va3MgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlID0gYXNzaWduKHt9LCB2bm9kZSk7XG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQgIT0gbnVsbCkge1xuXHRcdFx0aWYgKHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9PT0gcGFyZW50RG9tKSB7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IGRldGFjaGVkUGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dm5vZGUuX2NoaWxkcmVuID1cblx0XHRcdHZub2RlLl9jaGlsZHJlbiAmJlxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuLm1hcChjaGlsZCA9PlxuXHRcdFx0XHRkZXRhY2hlZENsb25lKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKVxuXHRcdFx0KTtcblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlT3JpZ2luYWwodm5vZGUsIGRldGFjaGVkUGFyZW50LCBvcmlnaW5hbFBhcmVudCkge1xuXHRpZiAodm5vZGUpIHtcblx0XHR2bm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0cmVtb3ZlT3JpZ2luYWwoY2hpbGQsIGRldGFjaGVkUGFyZW50LCBvcmlnaW5hbFBhcmVudClcblx0XHRcdCk7XG5cblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCkge1xuXHRcdFx0aWYgKHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9PT0gZGV0YWNoZWRQYXJlbnQpIHtcblx0XHRcdFx0aWYgKHZub2RlLl9kb20pIHtcblx0XHRcdFx0XHRvcmlnaW5hbFBhcmVudC5pbnNlcnRCZWZvcmUodm5vZGUuX2RvbSwgdm5vZGUuX25leHREb20pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX2ZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID0gb3JpZ2luYWxQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG4vLyBoYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2UoKSB7XG5cdC8vIHdlIGRvIG5vdCBjYWxsIHN1cGVyIGhlcmUgdG8gZ29sZiBzb21lIGJ5dGVzLi4uXG5cdHRoaXMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQgPSAwO1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gbnVsbDtcblx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcbn1cblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2UucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBUaGUgdGhyb3duIHByb21pc2VcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGU8YW55LCBhbnk+fSBzdXNwZW5kaW5nVk5vZGUgVGhlIHN1c3BlbmRpbmcgY29tcG9uZW50XG4gKi9cblN1c3BlbnNlLnByb3RvdHlwZS5fY2hpbGREaWRTdXNwZW5kID0gZnVuY3Rpb24ocHJvbWlzZSwgc3VzcGVuZGluZ1ZOb2RlKSB7XG5cdGNvbnN0IHN1c3BlbmRpbmdDb21wb25lbnQgPSBzdXNwZW5kaW5nVk5vZGUuX2NvbXBvbmVudDtcblxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fSAqL1xuXHRjb25zdCBjID0gdGhpcztcblxuXHRpZiAoYy5fc3VzcGVuZGVycyA9PSBudWxsKSB7XG5cdFx0Yy5fc3VzcGVuZGVycyA9IFtdO1xuXHR9XG5cdGMuX3N1c3BlbmRlcnMucHVzaChzdXNwZW5kaW5nQ29tcG9uZW50KTtcblxuXHRjb25zdCByZXNvbHZlID0gc3VzcGVuZGVkKGMuX3Zub2RlKTtcblxuXHRsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcblx0Y29uc3Qgb25SZXNvbHZlZCA9ICgpID0+IHtcblx0XHRpZiAocmVzb2x2ZWQpIHJldHVybjtcblxuXHRcdHJlc29sdmVkID0gdHJ1ZTtcblx0XHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBudWxsO1xuXG5cdFx0aWYgKHJlc29sdmUpIHtcblx0XHRcdHJlc29sdmUob25TdXNwZW5zaW9uQ29tcGxldGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvblN1c3BlbnNpb25Db21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBvblJlc29sdmVkO1xuXG5cdGNvbnN0IG9uU3VzcGVuc2lvbkNvbXBsZXRlID0gKCkgPT4ge1xuXHRcdGlmICghLS1jLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50KSB7XG5cdFx0XHQvLyBJZiB0aGUgc3VzcGVuc2lvbiB3YXMgZHVyaW5nIGh5ZHJhdGlvbiB3ZSBkb24ndCBuZWVkIHRvIHJlc3RvcmUgdGhlXG5cdFx0XHQvLyBzdXNwZW5kZWQgY2hpbGRyZW4gaW50byB0aGUgX2NoaWxkcmVuIGFycmF5XG5cdFx0XHRpZiAoYy5zdGF0ZS5fc3VzcGVuZGVkKSB7XG5cdFx0XHRcdGNvbnN0IHN1c3BlbmRlZFZOb2RlID0gYy5zdGF0ZS5fc3VzcGVuZGVkO1xuXHRcdFx0XHRjLl92bm9kZS5fY2hpbGRyZW5bMF0gPSByZW1vdmVPcmlnaW5hbChcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZSxcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20sXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fb3JpZ2luYWxQYXJlbnREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsKSB9KTtcblxuXHRcdFx0bGV0IHN1c3BlbmRlZDtcblx0XHRcdHdoaWxlICgoc3VzcGVuZGVkID0gYy5fc3VzcGVuZGVycy5wb3AoKSkpIHtcblx0XHRcdFx0c3VzcGVuZGVkLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXZSBkbyBub3Qgc2V0IGBzdXNwZW5kZWQ6IHRydWVgIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB3ZSB3YW50IHRoZSBhY3R1YWwgbWFya3VwXG5cdCAqIHRvIHJlbWFpbiBvbiBzY3JlZW4gYW5kIGh5ZHJhdGUgaXQgd2hlbiB0aGUgc3VzcGVuc2UgYWN0dWFsbHkgZ2V0cyByZXNvbHZlZC5cblx0ICogV2hpbGUgaW4gbm9uLWh5ZHJhdGlvbiBjYXNlcyB0aGUgdXN1YWwgZmFsbGJhY2sgLT4gY29tcG9uZW50IGZsb3cgd291bGQgb2Njb3VyLlxuXHQgKi9cblx0Y29uc3Qgd2FzSHlkcmF0aW5nID0gc3VzcGVuZGluZ1ZOb2RlLl9oeWRyYXRpbmcgPT09IHRydWU7XG5cdGlmICghYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCsrICYmICF3YXNIeWRyYXRpbmcpIHtcblx0XHRjLnNldFN0YXRlKHsgX3N1c3BlbmRlZDogKGMuX2RldGFjaE9uTmV4dFJlbmRlciA9IGMuX3Zub2RlLl9jaGlsZHJlblswXSkgfSk7XG5cdH1cblx0cHJvbWlzZS50aGVuKG9uUmVzb2x2ZWQsIG9uUmVzb2x2ZWQpO1xufTtcblxuU3VzcGVuc2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX3N1c3BlbmRlcnMgPSBbXTtcbn07XG5cbi8qKlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudFtcInByb3BzXCJdfSBwcm9wc1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZVN0YXRlfSBzdGF0ZVxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMsIHN0YXRlKSB7XG5cdGlmICh0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIpIHtcblx0XHQvLyBXaGVuIHRoZSBTdXNwZW5zZSdzIF92bm9kZSB3YXMgY3JlYXRlZCBieSBhIGNhbGwgdG8gY3JlYXRlVk5vZGVcblx0XHQvLyAoaS5lLiBkdWUgdG8gYSBzZXRTdGF0ZSBmdXJ0aGVyIHVwIGluIHRoZSB0cmVlKVxuXHRcdC8vIGl0J3MgX2NoaWxkcmVuIHByb3AgaXMgbnVsbCwgaW4gdGhpcyBjYXNlIHdlIFwiZm9yZ2V0XCIgYWJvdXQgdGhlIHBhcmtlZCB2bm9kZXMgdG8gZGV0YWNoXG5cdFx0aWYgKHRoaXMuX3Zub2RlLl9jaGlsZHJlbikge1xuXHRcdFx0Y29uc3QgZGV0YWNoZWRQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdGNvbnN0IGRldGFjaGVkQ29tcG9uZW50ID0gdGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdLl9jb21wb25lbnQ7XG5cdFx0XHR0aGlzLl92bm9kZS5fY2hpbGRyZW5bMF0gPSBkZXRhY2hlZENsb25lKFxuXHRcdFx0XHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIsXG5cdFx0XHRcdGRldGFjaGVkUGFyZW50LFxuXHRcdFx0XHQoZGV0YWNoZWRDb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tID0gZGV0YWNoZWRDb21wb25lbnQuX3BhcmVudERvbSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcblx0fVxuXG5cdC8vIFdyYXAgZmFsbGJhY2sgdHJlZSBpbiBhIFZOb2RlIHRoYXQgcHJldmVudHMgaXRzZWxmIGZyb20gYmVpbmcgbWFya2VkIGFzIGFib3J0aW5nIG1pZC1oeWRyYXRpb246XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9ICovXG5cdGNvbnN0IGZhbGxiYWNrID1cblx0XHRzdGF0ZS5fc3VzcGVuZGVkICYmIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHByb3BzLmZhbGxiYWNrKTtcblx0aWYgKGZhbGxiYWNrKSBmYWxsYmFjay5faHlkcmF0aW5nID0gbnVsbDtcblxuXHRyZXR1cm4gW1xuXHRcdGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHN0YXRlLl9zdXNwZW5kZWQgPyBudWxsIDogcHJvcHMuY2hpbGRyZW4pLFxuXHRcdGZhbGxiYWNrXG5cdF07XG59O1xuXG4vKipcbiAqIENoZWNrcyBhbmQgY2FsbHMgdGhlIHBhcmVudCBjb21wb25lbnQncyBfc3VzcGVuZGVkIG1ldGhvZCwgcGFzc2luZyBpbiB0aGVcbiAqIHN1c3BlbmRlZCB2bm9kZS4gVGhpcyBpcyBhIHdheSBmb3IgYSBwYXJlbnQgKGUuZy4gU3VzcGVuc2VMaXN0KSB0byBnZXQgbm90aWZpZWRcbiAqIHRoYXQgb25lIG9mIGl0cyBjaGlsZHJlbi9kZXNjZW5kYW50cyBzdXNwZW5kZWQuXG4gKlxuICogVGhlIHBhcmVudCBNQVkgcmV0dXJuIGEgY2FsbGJhY2suIFRoZSBjYWxsYmFjayB3aWxsIGdldCBjYWxsZWQgd2hlbiB0aGVcbiAqIHN1c3BlbnNpb24gcmVzb2x2ZXMsIG5vdGlmeWluZyB0aGUgcGFyZW50IG9mIHRoZSBmYWN0LlxuICogTW9yZW92ZXIsIHRoZSBjYWxsYmFjayBnZXRzIGZ1bmN0aW9uIGB1bnN1c3BlbmRgIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzb2x2ZWRcbiAqIGNoaWxkIGRlc2NlbmRhbnQgd2lsbCBub3QgYWN0dWFsbHkgZ2V0IHVuc3VzcGVuZGVkIHVudGlsIGB1bnN1c3BlbmRgIGdldHMgY2FsbGVkLlxuICogVGhpcyBpcyBhIHdheSBmb3IgdGhlIHBhcmVudCB0byBkZWxheSB1bnN1c3BlbmRpbmcuXG4gKlxuICogSWYgdGhlIHBhcmVudCBkb2VzIG5vdCByZXR1cm4gYSBjYWxsYmFjayB0aGVuIHRoZSByZXNvbHZlZCB2bm9kZVxuICogZ2V0cyB1bnN1c3BlbmRlZCBpbW1lZGlhdGVseSB3aGVuIGl0IHJlc29sdmVzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcmV0dXJucyB7KCh1bnN1c3BlbmQ6ICgpID0+IHZvaWQpID0+IHZvaWQpP31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1c3BlbmRlZCh2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0bGV0IGNvbXBvbmVudCA9IHZub2RlLl9wYXJlbnQuX2NvbXBvbmVudDtcblx0cmV0dXJuIGNvbXBvbmVudCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCh2bm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXp5KGxvYWRlcikge1xuXHRsZXQgcHJvbTtcblx0bGV0IGNvbXBvbmVudDtcblx0bGV0IGVycm9yO1xuXG5cdGZ1bmN0aW9uIExhenkocHJvcHMpIHtcblx0XHRpZiAoIXByb20pIHtcblx0XHRcdHByb20gPSBsb2FkZXIoKTtcblx0XHRcdHByb20udGhlbihcblx0XHRcdFx0ZXhwb3J0cyA9PiB7XG5cdFx0XHRcdFx0Y29tcG9uZW50ID0gZXhwb3J0cy5kZWZhdWx0IHx8IGV4cG9ydHM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGUgPT4ge1xuXHRcdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdGlmICghY29tcG9uZW50KSB7XG5cdFx0XHR0aHJvdyBwcm9tO1xuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpO1xuXHR9XG5cblx0TGF6eS5kaXNwbGF5TmFtZSA9ICdMYXp5Jztcblx0TGF6eS5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIExhenk7XG59XG4iLCAiaW1wb3J0IHsgQ29tcG9uZW50LCB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc3VzcGVuZGVkIH0gZnJvbSAnLi9zdXNwZW5zZS5qcyc7XG5cbi8vIEluZGV4ZXMgdG8gbGlua2VkIGxpc3Qgbm9kZXMgKG5vZGVzIGFyZSBzdG9yZWQgYXMgYXJyYXlzIHRvIHNhdmUgYnl0ZXMpLlxuY29uc3QgU1VTUEVOREVEX0NPVU5UID0gMDtcbmNvbnN0IFJFU09MVkVEX0NPVU5UID0gMTtcbmNvbnN0IE5FWFRfTk9ERSA9IDI7XG5cbi8vIEhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXMuXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2VMaXN0KCkge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbnVsbDtcbn1cblxuLy8gTWFyayBvbmUgb2YgY2hpbGQncyBlYXJsaWVyIHN1c3BlbnNpb25zIGFzIHJlc29sdmVkLlxuLy8gU29tZSBwZW5kaW5nIGNhbGxiYWNrcyBtYXkgYmVjb21lIGNhbGxhYmxlIGR1ZSB0byB0aGlzXG4vLyAoZS5nLiB0aGUgbGFzdCBzdXNwZW5kZWQgZGVzY2VuZGFudCBnZXRzIHJlc29sdmVkIHdoZW5cbi8vIHJldmVhbE9yZGVyID09PSAndG9nZXRoZXInKS4gUHJvY2VzcyB0aG9zZSBjYWxsYmFja3MgYXMgd2VsbC5cbmNvbnN0IHJlc29sdmUgPSAobGlzdCwgY2hpbGQsIG5vZGUpID0+IHtcblx0aWYgKCsrbm9kZVtSRVNPTFZFRF9DT1VOVF0gPT09IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdC8vIFRoZSBudW1iZXIgYSBjaGlsZCAob3IgYW55IG9mIGl0cyBkZXNjZW5kYW50cykgaGFzIGJlZW4gc3VzcGVuZGVkXG5cdFx0Ly8gbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIHRpbWVzIGl0J3MgYmVlbiByZXNvbHZlZC4gVGhlcmVmb3JlIHdlXG5cdFx0Ly8gbWFyayB0aGUgY2hpbGQgYXMgY29tcGxldGVseSByZXNvbHZlZCBieSBkZWxldGluZyBpdCBmcm9tIC5fbWFwLlxuXHRcdC8vIFRoaXMgaXMgdXNlZCB0byBmaWd1cmUgb3V0IHdoZW4gKmFsbCogY2hpbGRyZW4gaGF2ZSBiZWVuIGNvbXBsZXRlbHlcblx0XHQvLyByZXNvbHZlZCB3aGVuIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicuXG5cdFx0bGlzdC5fbWFwLmRlbGV0ZShjaGlsZCk7XG5cdH1cblxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyBmYWxzeSB0aGVuIHdlIGNhbiBkbyBhbiBlYXJseSBleGl0LCBhcyB0aGVcblx0Ly8gY2FsbGJhY2tzIHdvbid0IGdldCBxdWV1ZWQgaW4gdGhlIG5vZGUgYW55d2F5LlxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInIHRoZW4gYWxzbyBkbyBhbiBlYXJseSBleGl0XG5cdC8vIGlmIGFsbCBzdXNwZW5kZWQgZGVzY2VuZGFudHMgaGF2ZSBub3QgeWV0IGJlZW4gcmVzb2x2ZWQuXG5cdGlmIChcblx0XHQhbGlzdC5wcm9wcy5yZXZlYWxPcmRlciB8fFxuXHRcdChsaXN0LnByb3BzLnJldmVhbE9yZGVyWzBdID09PSAndCcgJiYgbGlzdC5fbWFwLnNpemUpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFdhbGsgdGhlIGN1cnJlbnRseSBzdXNwZW5kZWQgY2hpbGRyZW4gaW4gb3JkZXIsIGNhbGxpbmcgdGhlaXJcblx0Ly8gc3RvcmVkIGNhbGxiYWNrcyBvbiB0aGUgd2F5LiBTdG9wIGlmIHdlIGVuY291bnRlciBhIGNoaWxkIHRoYXRcblx0Ly8gaGFzIG5vdCBiZWVuIGNvbXBsZXRlbHkgcmVzb2x2ZWQgeWV0LlxuXHRub2RlID0gbGlzdC5fbmV4dDtcblx0d2hpbGUgKG5vZGUpIHtcblx0XHR3aGlsZSAobm9kZS5sZW5ndGggPiAzKSB7XG5cdFx0XHRub2RlLnBvcCgpKCk7XG5cdFx0fVxuXHRcdGlmIChub2RlW1JFU09MVkVEX0NPVU5UXSA8IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGxpc3QuX25leHQgPSBub2RlID0gbm9kZVtORVhUX05PREVdO1xuXHR9XG59O1xuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLl9zdXNwZW5kZWQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRjb25zdCBsaXN0ID0gdGhpcztcblx0Y29uc3QgZGVsZWdhdGVkID0gc3VzcGVuZGVkKGxpc3QuX3Zub2RlKTtcblxuXHRsZXQgbm9kZSA9IGxpc3QuX21hcC5nZXQoY2hpbGQpO1xuXHRub2RlW1NVU1BFTkRFRF9DT1VOVF0rKztcblxuXHRyZXR1cm4gdW5zdXNwZW5kID0+IHtcblx0XHRjb25zdCB3cmFwcGVkVW5zdXNwZW5kID0gKCkgPT4ge1xuXHRcdFx0aWYgKCFsaXN0LnByb3BzLnJldmVhbE9yZGVyKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0aGUgdW5kZWZpbmVkIChmYWxzeSkgcmV2ZWFsT3JkZXIsIGFzIHRoZXJlXG5cdFx0XHRcdC8vIGlzIG5vIG5lZWQgdG8gY29vcmRpbmF0ZSBhIHNwZWNpZmljIG9yZGVyIG9yIHVuc3VzcGVuZHMuXG5cdFx0XHRcdHVuc3VzcGVuZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5wdXNoKHVuc3VzcGVuZCk7XG5cdFx0XHRcdHJlc29sdmUobGlzdCwgY2hpbGQsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0aWYgKGRlbGVnYXRlZCkge1xuXHRcdFx0ZGVsZWdhdGVkKHdyYXBwZWRVbnN1c3BlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3cmFwcGVkVW5zdXNwZW5kKCk7XG5cdFx0fVxuXHR9O1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IGNoaWxkcmVuID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKTtcblx0aWYgKHByb3BzLnJldmVhbE9yZGVyICYmIHByb3BzLnJldmVhbE9yZGVyWzBdID09PSAnYicpIHtcblx0XHQvLyBJZiBvcmRlciA9PT0gJ2JhY2t3YXJkcycgKG9yLCB3ZWxsLCBhbnl0aGluZyBzdGFydGluZyB3aXRoIGEgJ2InKVxuXHRcdC8vIHRoZW4gZmxpcCB0aGUgY2hpbGQgbGlzdCBhcm91bmQgc28gdGhhdCB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlXG5cdFx0Ly8gdGhlIGZpcnN0IGluIHRoZSBsaW5rZWQgbGlzdC5cblx0XHRjaGlsZHJlbi5yZXZlcnNlKCk7XG5cdH1cblx0Ly8gQnVpbGQgdGhlIGxpbmtlZCBsaXN0LiBJdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGluIHJldmVyc2Ugb3JkZXJcblx0Ly8gc28gdGhhdCBgX25leHRgIHBvaW50cyB0byB0aGUgZmlyc3QgbGlua2VkIGxpc3Qgbm9kZSB0byBiZSByZXNvbHZlZC5cblx0Zm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHQvLyBDcmVhdGUgYSBuZXcgbGlua2VkIGxpc3Qgbm9kZSBhcyBhbiBhcnJheSBvZiBmb3JtOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZV1cblx0XHQvLyB3aGVyZSBzdXNwZW5kZWRfY291bnQgYW5kIHJlc29sdmVkX2NvdW50IGFyZSBudW1lcmljIGNvdW50ZXJzIGZvclxuXHRcdC8vIGtlZXBpbmcgdHJhY2sgaG93IG1hbnkgdGltZXMgYSBub2RlIGhhcyBiZWVuIHN1c3BlbmRlZCBhbmQgcmVzb2x2ZWQuXG5cdFx0Ly9cblx0XHQvLyBOb3RlIHRoYXQgc3VzcGVuZGVkX2NvdW50IHN0YXJ0cyBmcm9tIDEgaW5zdGVhZCBvZiAwLCBzbyB3ZSBjYW4gYmxvY2tcblx0XHQvLyBwcm9jZXNzaW5nIGNhbGxiYWNrcyB1bnRpbCBjb21wb25lbnREaWRNb3VudCBoYXMgYmVlbiBjYWxsZWQuIEluIGEgc2Vuc2Vcblx0XHQvLyBub2RlIGlzIHN1c3BlbmRlZCBhdCBsZWFzdCB1bnRpbCBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZCFcblx0XHQvL1xuXHRcdC8vIFBlbmRpbmcgY2FsbGJhY2tzIGFyZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBub2RlOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZSwgY2FsbGJhY2tfMCwgY2FsbGJhY2tfMSwgLi4uXVxuXHRcdHRoaXMuX21hcC5zZXQoY2hpbGRyZW5baV0sICh0aGlzLl9uZXh0ID0gWzEsIDAsIHRoaXMuX25leHRdKSk7XG5cdH1cblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBTdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYWZ0ZXIgbW91bnRpbmcgZm9yIHR3byByZWFzb25zOlxuXHQvLyAxLiBBcyBlYWNoIG5vZGVbU1VTUEVOREVEX0NPVU5UXSBzdGFydHMgZnJvbSAxLCB0aGlzIGl0ZXJhdGlvbiBpbmNyZWFzZXNcblx0Ly8gICAgZWFjaCBub2RlW1JFTEVBU0VEX0NPVU5UXSBieSAxLCB0aGVyZWZvcmUgYmFsYW5jaW5nIHRoZSBjb3VudGVycy5cblx0Ly8gICAgVGhlIG5vZGVzIGNhbiBub3cgYmUgY29tcGxldGVseSBjb25zdW1lZCBmcm9tIHRoZSBsaW5rZWQgbGlzdC5cblx0Ly8gMi4gSGFuZGxlIG5vZGVzIHRoYXQgbWlnaHQgaGF2ZSBnb3R0ZW4gcmVzb2x2ZWQgYmV0d2VlbiByZW5kZXIgYW5kXG5cdC8vICAgIGNvbXBvbmVudERpZE1vdW50LlxuXHR0aGlzLl9tYXAuZm9yRWFjaCgobm9kZSwgY2hpbGQpID0+IHtcblx0XHRyZXNvbHZlKHRoaXMsIGNoaWxkLCBub2RlKTtcblx0fSk7XG59O1xuIiwgImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIHJlbmRlciB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3NyYy9pbmRleCcpLlJlbmRlcmFibGVQcm9wczx7IGNvbnRleHQ6IGFueSB9Pn0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gQ29udGV4dFByb3ZpZGVyKHByb3BzKSB7XG5cdHRoaXMuZ2V0Q2hpbGRDb250ZXh0ID0gKCkgPT4gcHJvcHMuY29udGV4dDtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIFBvcnRhbCBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGwgfCB1bmRlZmluZWR9IHByb3BzXG4gKlxuICogVE9ETzogdXNlIGNyZWF0ZVJvb3QoKSBpbnN0ZWFkIG9mIGZha2Ugcm9vdFxuICovXG5mdW5jdGlvbiBQb3J0YWwocHJvcHMpIHtcblx0Y29uc3QgX3RoaXMgPSB0aGlzO1xuXHRsZXQgY29udGFpbmVyID0gcHJvcHMuX2NvbnRhaW5lcjtcblxuXHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlbmRlcihudWxsLCBfdGhpcy5fdGVtcCk7XG5cdFx0X3RoaXMuX3RlbXAgPSBudWxsO1xuXHRcdF90aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHR9O1xuXG5cdC8vIFdoZW4gd2UgY2hhbmdlIGNvbnRhaW5lciB3ZSBzaG91bGQgY2xlYXIgb3VyIG9sZCBjb250YWluZXIgYW5kXG5cdC8vIGluZGljYXRlIGEgbmV3IG1vdW50LlxuXHRpZiAoX3RoaXMuX2NvbnRhaW5lciAmJiBfdGhpcy5fY29udGFpbmVyICE9PSBjb250YWluZXIpIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG5cblx0Ly8gV2hlbiBwcm9wcy52bm9kZSBpcyB1bmRlZmluZWQvZmFsc2UvbnVsbCB3ZSBhcmUgZGVhbGluZyB3aXRoIHNvbWUga2luZCBvZlxuXHQvLyBjb25kaXRpb25hbCB2bm9kZS4gVGhpcyBzaG91bGQgbm90IHRyaWdnZXIgYSByZW5kZXIuXG5cdGlmIChwcm9wcy5fdm5vZGUpIHtcblx0XHRpZiAoIV90aGlzLl90ZW1wKSB7XG5cdFx0XHRfdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBmYWtlIERPTSBwYXJlbnQgbm9kZSB0aGF0IG1hbmFnZXMgYSBzdWJzZXQgb2YgYGNvbnRhaW5lcmAncyBjaGlsZHJlbjpcblx0XHRcdF90aGlzLl90ZW1wID0ge1xuXHRcdFx0XHRub2RlVHlwZTogMSxcblx0XHRcdFx0cGFyZW50Tm9kZTogY29udGFpbmVyLFxuXHRcdFx0XHRjaGlsZE5vZGVzOiBbXSxcblx0XHRcdFx0YXBwZW5kQ2hpbGQoY2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZW1vdmVDaGlsZChjaGlsZCkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5zcGxpY2UodGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpID4+PiAxLCAxKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBSZW5kZXIgb3VyIHdyYXBwaW5nIGVsZW1lbnQgaW50byB0ZW1wLlxuXHRcdHJlbmRlcihcblx0XHRcdGNyZWF0ZUVsZW1lbnQoQ29udGV4dFByb3ZpZGVyLCB7IGNvbnRleHQ6IF90aGlzLmNvbnRleHQgfSwgcHJvcHMuX3Zub2RlKSxcblx0XHRcdF90aGlzLl90ZW1wXG5cdFx0KTtcblx0fVxuXHQvLyBXaGVuIHdlIGNvbWUgZnJvbSBhIGNvbmRpdGlvbmFsIHJlbmRlciwgb24gYSBtb3VudGVkXG5cdC8vIHBvcnRhbCB3ZSBzaG91bGQgY2xlYXIgdGhlIERPTS5cblx0ZWxzZSBpZiAoX3RoaXMuX3RlbXApIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFBvcnRhbGAgdG8gY29udGludWUgcmVuZGVyaW5nIHRoZSB2bm9kZSB0cmVlIGF0IGEgZGlmZmVyZW50IERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgRE9NIG5vZGUgdG8gY29udGludWUgcmVuZGVyaW5nIGluIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUG9ydGFsKHZub2RlLCBjb250YWluZXIpIHtcblx0Y29uc3QgZWwgPSBjcmVhdGVFbGVtZW50KFBvcnRhbCwgeyBfdm5vZGU6IHZub2RlLCBfY29udGFpbmVyOiBjb250YWluZXIgfSk7XG5cdGVsLmNvbnRhaW5lckluZm8gPSBjb250YWluZXI7XG5cdHJldHVybiBlbDtcbn1cbiIsICJpbXBvcnQge1xuXHRyZW5kZXIgYXMgcHJlYWN0UmVuZGVyLFxuXHRoeWRyYXRlIGFzIHByZWFjdEh5ZHJhdGUsXG5cdG9wdGlvbnMsXG5cdHRvQ2hpbGRBcnJheSxcblx0Q29tcG9uZW50XG59IGZyb20gJ3ByZWFjdCc7XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9FTEVNRU5UX1RZUEUgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICYmIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcblx0MHhlYWM3O1xuXG5jb25zdCBDQU1FTF9QUk9QUyA9IC9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZG9taW5hbnR8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8aW1hZ2V8bGV0dGVyfGxpZ2h0aW5nfG1hcmtlcig/IUh8V3xVKXxvdmVybGluZXxwYWludHxwb2ludGVyfHNoYXBlfHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHRyYW5zZm9ybXx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KD8hQykpW0EtWl0vO1xuXG5jb25zdCBJU19ET00gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBJbnB1dCB0eXBlcyBmb3Igd2hpY2ggb25jaGFuZ2Ugc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gb25pbnB1dC5cbi8vIHR5cGU9XCJmaWxlfGNoZWNrYm94fHJhZGlvXCIsIHBsdXMgXCJyYW5nZVwiIGluIElFMTEuXG4vLyAoSUUxMSBkb2Vzbid0IHN1cHBvcnQgU3ltYm9sLCB3aGljaCB3ZSB1c2UgaGVyZSB0byB0dXJuIGByYWRgIGludG8gYHJhYCB3aGljaCBtYXRjaGVzIFwicmFuZ2VcIilcbmNvbnN0IG9uQ2hhbmdlSW5wdXRUeXBlID0gdHlwZSA9PlxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sKCkgPT0gJ3N5bWJvbCdcblx0XHQ/IC9maWx8Y2hlfHJhZC9pXG5cdFx0OiAvZmlsfGNoZXxyYS9pXG5cdCkudGVzdCh0eXBlKTtcblxuLy8gU29tZSBsaWJyYXJpZXMgbGlrZSBgcmVhY3QtdmlydHVhbGl6ZWRgIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoaXMuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLy8gYFVOU0FGRV8qYCBsaWZlY3ljbGUgaG9va3Ncbi8vIFByZWFjdCBvbmx5IGV2ZXIgaW52b2tlcyB0aGUgdW5wcmVmaXhlZCBtZXRob2RzLlxuLy8gSGVyZSB3ZSBwcm92aWRlIGEgYmFzZSBcImZhbGxiYWNrXCIgaW1wbGVtZW50YXRpb24gdGhhdCBjYWxscyBhbnkgZGVmaW5lZCBVTlNBRkVfIHByZWZpeGVkIG1ldGhvZC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBpdHMgb3duIGBjb21wb25lbnREaWRNb3VudCgpYCAoaW5jbHVkaW5nIHZpYSBkZWZpbmVQcm9wZXJ0eSksIHVzZSB0aGF0LlxuLy8gLSBJZiBhIGNvbXBvbmVudCBkZWZpbmVzIGBVTlNBRkVfY29tcG9uZW50RGlkTW91bnQoKWAsIGBjb21wb25lbnREaWRNb3VudGAgaXMgdGhlIGFsaWFzIGdldHRlci9zZXR0ZXIuXG4vLyAtIElmIGFueXRoaW5nIGFzc2lnbnMgdG8gYW4gYFVOU0FGRV8qYCBwcm9wZXJ0eSwgdGhlIGFzc2lnbm1lbnQgaXMgZm9yd2FyZGVkIHRvIHRoZSB1bnByZWZpeGVkIHByb3BlcnR5LlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzE5NDFcbltcblx0J2NvbXBvbmVudFdpbGxNb3VudCcsXG5cdCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcblx0J2NvbXBvbmVudFdpbGxVcGRhdGUnXG5dLmZvckVhY2goa2V5ID0+IHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIGtleSwge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1snVU5TQUZFXycgKyBrZXldO1xuXHRcdH0sXG5cdFx0c2V0KHYpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHZcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59KTtcblxuLyoqXG4gKiBQcm94eSByZW5kZXIoKSBzaW5jZSBSZWFjdCByZXR1cm5zIGEgQ29tcG9uZW50IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFZOb2RlIHRyZWUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudCBET00gbm9kZSB0byByZW5kZXIgdm5vZGUgdHJlZSBpbnRvXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gT3B0aW9uYWwgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciByZW5kZXJpbmdcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQgfCBudWxsfSBUaGUgcm9vdCBjb21wb25lbnQgcmVmZXJlbmNlIG9yIG51bGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHQvLyBSZWFjdCBkZXN0cm95cyBhbnkgZXhpc3RpbmcgRE9NIG5vZGVzLCBzZWUgIzE3Mjdcblx0Ly8gLi4uYnV0IG9ubHkgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlICMxODI4XG5cdGlmIChwYXJlbnQuX2NoaWxkcmVuID09IG51bGwpIHtcblx0XHRwYXJlbnQudGV4dENvbnRlbnQgPSAnJztcblx0fVxuXG5cdHByZWFjdFJlbmRlcih2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHRwcmVhY3RIeWRyYXRlKHZub2RlLCBwYXJlbnQpO1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG5cblx0cmV0dXJuIHZub2RlID8gdm5vZGUuX2NvbXBvbmVudCA6IG51bGw7XG59XG5cbmxldCBvbGRFdmVudEhvb2sgPSBvcHRpb25zLmV2ZW50O1xub3B0aW9ucy5ldmVudCA9IGUgPT4ge1xuXHRpZiAob2xkRXZlbnRIb29rKSBlID0gb2xkRXZlbnRIb29rKGUpO1xuXHRlLnBlcnNpc3QgPSBlbXB0eTtcblx0ZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGlzUHJvcGFnYXRpb25TdG9wcGVkO1xuXHRlLmlzRGVmYXVsdFByZXZlbnRlZCA9IGlzRGVmYXVsdFByZXZlbnRlZDtcblx0cmV0dXJuIChlLm5hdGl2ZUV2ZW50ID0gZSk7XG59O1xuXG5mdW5jdGlvbiBlbXB0eSgpIHt9XG5cbmZ1bmN0aW9uIGlzUHJvcGFnYXRpb25TdG9wcGVkKCkge1xuXHRyZXR1cm4gdGhpcy5jYW5jZWxCdWJibGU7XG59XG5cbmZ1bmN0aW9uIGlzRGVmYXVsdFByZXZlbnRlZCgpIHtcblx0cmV0dXJuIHRoaXMuZGVmYXVsdFByZXZlbnRlZDtcbn1cblxubGV0IGNsYXNzTmFtZURlc2NyaXB0b3IgPSB7XG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0Z2V0KCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzO1xuXHR9XG59O1xuXG5sZXQgb2xkVk5vZGVIb29rID0gb3B0aW9ucy52bm9kZTtcbm9wdGlvbnMudm5vZGUgPSB2bm9kZSA9PiB7XG5cdGxldCB0eXBlID0gdm5vZGUudHlwZTtcblx0bGV0IHByb3BzID0gdm5vZGUucHJvcHM7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSBwcm9wcztcblxuXHQvLyBvbmx5IG5vcm1hbGl6ZSBwcm9wcyBvbiBFbGVtZW50IG5vZGVzXG5cdGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRjb25zdCBub25DdXN0b21FbGVtZW50ID0gdHlwZS5pbmRleE9mKCctJykgPT09IC0xO1xuXHRcdG5vcm1hbGl6ZWRQcm9wcyA9IHt9O1xuXG5cdFx0Zm9yIChsZXQgaSBpbiBwcm9wcykge1xuXHRcdFx0bGV0IHZhbHVlID0gcHJvcHNbaV07XG5cblx0XHRcdGlmIChJU19ET00gJiYgaSA9PT0gJ2NoaWxkcmVuJyAmJiB0eXBlID09PSAnbm9zY3JpcHQnKSB7XG5cdFx0XHRcdC8vIEVtdWxhdGUgUmVhY3QncyBiZWhhdmlvciBvZiBub3QgcmVuZGVyaW5nIHRoZSBjb250ZW50cyBvZiBub3NjcmlwdCB0YWdzIG9uIHRoZSBjbGllbnQuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAndmFsdWUnICYmICdkZWZhdWx0VmFsdWUnIGluIHByb3BzICYmIHZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0Ly8gU2tpcCBhcHBseWluZyB2YWx1ZSBpZiBpdCBpcyBudWxsL3VuZGVmaW5lZCBhbmQgd2UgYWxyZWFkeSBzZXRcblx0XHRcdFx0Ly8gYSBkZWZhdWx0IHZhbHVlXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0aSA9PT0gJ2RlZmF1bHRWYWx1ZScgJiZcblx0XHRcdFx0J3ZhbHVlJyBpbiBwcm9wcyAmJlxuXHRcdFx0XHRwcm9wcy52YWx1ZSA9PSBudWxsXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgaXMgdHJlYXRlZCBhcyBhIGZhbGxiYWNrIGB2YWx1ZWAgd2hlbiBhIHZhbHVlIHByb3AgaXMgcHJlc2VudCBidXQgbnVsbC91bmRlZmluZWQuXG5cdFx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGZvciBFbGVtZW50cyB3aXRoIG5vIHZhbHVlIHByb3AgaXMgdGhlIHNhbWUgYXMgdGhlIERPTSBkZWZhdWx0VmFsdWUgcHJvcGVydHkuXG5cdFx0XHRcdGkgPSAndmFsdWUnO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAnZG93bmxvYWQnICYmIHZhbHVlID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIENhbGxpbmcgYHNldEF0dHJpYnV0ZWAgd2l0aCBhIHRydXRoeSB2YWx1ZSB3aWxsIGxlYWQgdG8gaXQgYmVpbmdcblx0XHRcdFx0Ly8gcGFzc2VkIGFzIGEgc3RyaW5naWZpZWQgdmFsdWUsIGUuZy4gYGRvd25sb2FkPVwidHJ1ZVwiYC4gUmVhY3Rcblx0XHRcdFx0Ly8gY29udmVydHMgaXQgdG8gYW4gZW1wdHkgc3RyaW5nIGluc3RlYWQsIG90aGVyd2lzZSB0aGUgYXR0cmlidXRlXG5cdFx0XHRcdC8vIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgZmlsZSBuYW1lIGFuZCB0aGUgZmlsZSB3aWxsIGJlIGNhbGxlZFxuXHRcdFx0XHQvLyBcInRydWVcIiB1cG9uIGRvd25sb2FkaW5nIGl0LlxuXHRcdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdFx0fSBlbHNlIGlmICgvb25kb3VibGVjbGljay9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmRibGNsaWNrJztcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdC9eb25jaGFuZ2UodGV4dGFyZWF8aW5wdXQpL2kudGVzdChpICsgdHlwZSkgJiZcblx0XHRcdFx0IW9uQ2hhbmdlSW5wdXRUeXBlKHByb3BzLnR5cGUpXG5cdFx0XHQpIHtcblx0XHRcdFx0aSA9ICdvbmlucHV0Jztcblx0XHRcdH0gZWxzZSBpZiAoL15vbmZvY3VzJC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmZvY3VzaW4nO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uYmx1ciQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c291dCc7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb24oQW5pfFRyYXxUb3V8QmVmb3JlSW5wfENvbXBvKS8udGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChub25DdXN0b21FbGVtZW50ICYmIENBTUVMX1BST1BTLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkucmVwbGFjZSgvW0EtWjAtOV0vZywgJy0kJicpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdHZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgc3VwcG9ydCBmb3Igb25JbnB1dCBhbmQgb25DaGFuZ2UsIHNlZSAjMzU2MVxuXHRcdFx0Ly8gaWYgd2UgaGF2ZSBhbiBvbmlucHV0IHByb3AgYWxyZWFkeSBjaGFuZ2UgaXQgdG8gb25pbnB1dENhcHR1cmVcblx0XHRcdGlmICgvXm9uaW5wdXQkL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRpZiAobm9ybWFsaXplZFByb3BzW2ldKSB7XG5cdFx0XHRcdFx0aSA9ICdvbmlucHV0Q2FwdHVyZSc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIGFycmF5IHNlbGVjdCB2YWx1ZXM6IDxzZWxlY3QgbXVsdGlwbGUgdmFsdWU9e1tdfSAvPlxuXHRcdGlmIChcblx0XHRcdHR5cGUgPT0gJ3NlbGVjdCcgJiZcblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5tdWx0aXBsZSAmJlxuXHRcdFx0QXJyYXkuaXNBcnJheShub3JtYWxpemVkUHJvcHMudmFsdWUpXG5cdFx0KSB7XG5cdFx0XHQvLyBmb3JFYWNoKCkgYWx3YXlzIHJldHVybnMgdW5kZWZpbmVkLCB3aGljaCB3ZSBhYnVzZSBoZXJlIHRvIHVuc2V0IHRoZSB2YWx1ZSBwcm9wLlxuXHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKSAhPSAtMTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIEFkZGluZyBzdXBwb3J0IGZvciBkZWZhdWx0VmFsdWUgaW4gc2VsZWN0IHRhZ1xuXHRcdGlmICh0eXBlID09ICdzZWxlY3QnICYmIG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKS5mb3JFYWNoKGNoaWxkID0+IHtcblx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wcy5tdWx0aXBsZSkge1xuXHRcdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZSA9PSBjaGlsZC5wcm9wcy52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0dm5vZGUucHJvcHMgPSBub3JtYWxpemVkUHJvcHM7XG5cblx0XHRpZiAocHJvcHMuY2xhc3MgIT0gcHJvcHMuY2xhc3NOYW1lKSB7XG5cdFx0XHRjbGFzc05hbWVEZXNjcmlwdG9yLmVudW1lcmFibGUgPSAnY2xhc3NOYW1lJyBpbiBwcm9wcztcblx0XHRcdGlmIChwcm9wcy5jbGFzc05hbWUgIT0gbnVsbCkgbm9ybWFsaXplZFByb3BzLmNsYXNzID0gcHJvcHMuY2xhc3NOYW1lO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5vcm1hbGl6ZWRQcm9wcywgJ2NsYXNzTmFtZScsIGNsYXNzTmFtZURlc2NyaXB0b3IpO1xuXHRcdH1cblx0fVxuXG5cdHZub2RlLiQkdHlwZW9mID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5cdGlmIChvbGRWTm9kZUhvb2spIG9sZFZOb2RlSG9vayh2bm9kZSk7XG59O1xuXG4vLyBPbmx5IG5lZWRlZCBmb3IgcmVhY3QtcmVsYXlcbmxldCBjdXJyZW50Q29tcG9uZW50O1xuY29uc3Qgb2xkQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5fcmVuZGVyO1xub3B0aW9ucy5fcmVuZGVyID0gZnVuY3Rpb24odm5vZGUpIHtcblx0aWYgKG9sZEJlZm9yZVJlbmRlcikge1xuXHRcdG9sZEJlZm9yZVJlbmRlcih2bm9kZSk7XG5cdH1cblx0Y3VycmVudENvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG59O1xuXG4vLyBUaGlzIGlzIGEgdmVyeSB2ZXJ5IHByaXZhdGUgaW50ZXJuYWwgZnVuY3Rpb24gZm9yIFJlYWN0IGl0XG4vLyBpcyB1c2VkIHRvIHNvcnQtb2YgZG8gcnVudGltZSBkZXBlbmRlbmN5IGluamVjdGlvbi4gU28gZmFyXG4vLyBvbmx5IGByZWFjdC1yZWxheWAgbWFrZXMgdXNlIG9mIGl0LiBJdCB1c2VzIGl0IHRvIHJlYWQgdGhlXG4vLyBjb250ZXh0IHZhbHVlLlxuZXhwb3J0IGNvbnN0IF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0ge1xuXHRSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiB7XG5cdFx0Y3VycmVudDoge1xuXHRcdFx0cmVhZENvbnRleHQoY29udGV4dCkge1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudENvbXBvbmVudC5fZ2xvYmFsQ29udGV4dFtjb250ZXh0Ll9pZF0ucHJvcHMudmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuIiwgImltcG9ydCB7XG5cdGNyZWF0ZUVsZW1lbnQsXG5cdHJlbmRlciBhcyBwcmVhY3RSZW5kZXIsXG5cdGNsb25lRWxlbWVudCBhcyBwcmVhY3RDbG9uZUVsZW1lbnQsXG5cdGNyZWF0ZVJlZixcblx0Q29tcG9uZW50LFxuXHRjcmVhdGVDb250ZXh0LFxuXHRGcmFnbWVudFxufSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHtcblx0dXNlU3RhdGUsXG5cdHVzZUlkLFxuXHR1c2VSZWR1Y2VyLFxuXHR1c2VFZmZlY3QsXG5cdHVzZUxheW91dEVmZmVjdCxcblx0dXNlUmVmLFxuXHR1c2VJbXBlcmF0aXZlSGFuZGxlLFxuXHR1c2VNZW1vLFxuXHR1c2VDYWxsYmFjayxcblx0dXNlQ29udGV4dCxcblx0dXNlRGVidWdWYWx1ZVxufSBmcm9tICdwcmVhY3QvaG9va3MnO1xuaW1wb3J0IHsgUHVyZUNvbXBvbmVudCB9IGZyb20gJy4vUHVyZUNvbXBvbmVudCc7XG5pbXBvcnQgeyBtZW1vIH0gZnJvbSAnLi9tZW1vJztcbmltcG9ydCB7IGZvcndhcmRSZWYgfSBmcm9tICcuL2ZvcndhcmRSZWYnO1xuaW1wb3J0IHsgQ2hpbGRyZW4gfSBmcm9tICcuL0NoaWxkcmVuJztcbmltcG9ydCB7IFN1c3BlbnNlLCBsYXp5IH0gZnJvbSAnLi9zdXNwZW5zZSc7XG5pbXBvcnQgeyBTdXNwZW5zZUxpc3QgfSBmcm9tICcuL3N1c3BlbnNlLWxpc3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAnLi9wb3J0YWxzJztcbmltcG9ydCB7IGlzIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7XG5cdGh5ZHJhdGUsXG5cdHJlbmRlcixcblx0UkVBQ1RfRUxFTUVOVF9UWVBFLFxuXHRfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRFxufSBmcm9tICcuL3JlbmRlcic7XG5cbmNvbnN0IHZlcnNpb24gPSAnMTcuMC4yJzsgLy8gdHJpY2sgbGlicmFyaWVzIHRvIHRoaW5rIHdlIGFyZSByZWFjdFxuXG4vKipcbiAqIExlZ2FjeSB2ZXJzaW9uIG9mIGNyZWF0ZUVsZW1lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudCBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5KHR5cGUpIHtcblx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgcGFzc2VkIGVsZW1lbnQgaXMgYSB2YWxpZCAocClyZWFjdCBub2RlLlxuICogQHBhcmFtIHsqfSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkge1xuXHRyZXR1cm4gISFlbGVtZW50ICYmIGVsZW1lbnQuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxuLyoqXG4gKiBXcmFwIGBjbG9uZUVsZW1lbnRgIHRvIGFib3J0IGlmIHRoZSBwYXNzZWQgZWxlbWVudCBpcyBub3QgYSB2YWxpZCBlbGVtZW50IGFuZCBhcHBseVxuICogYWxsIHZub2RlIG5vcm1hbGl6YXRpb25zLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gZWxlbWVudCBUaGUgdm5vZGUgdG8gY2xvbmVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBQcm9wcyB0byBhZGQgd2hlbiBjbG9uaW5nXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkcmVuPn0gcmVzdCBPcHRpb25hbCBjb21wb25lbnQgY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQpIHtcblx0aWYgKCFpc1ZhbGlkRWxlbWVudChlbGVtZW50KSkgcmV0dXJuIGVsZW1lbnQ7XG5cdHJldHVybiBwcmVhY3RDbG9uZUVsZW1lbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBjb21wb25lbnQgdHJlZSBmcm9tIHRoZSBET00sIGluY2x1ZGluZyBzdGF0ZSBhbmQgZXZlbnQgaGFuZGxlcnMuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGNvbnRhaW5lclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRBdE5vZGUoY29udGFpbmVyKSB7XG5cdGlmIChjb250YWluZXIuX2NoaWxkcmVuKSB7XG5cdFx0cHJlYWN0UmVuZGVyKG51bGwsIGNvbnRhaW5lcik7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbWF0Y2hpbmcgRE9NIG5vZGUgZm9yIGEgY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudCB8IG51bGx9XG4gKi9cbmZ1bmN0aW9uIGZpbmRET01Ob2RlKGNvbXBvbmVudCkge1xuXHRyZXR1cm4gKFxuXHRcdChjb21wb25lbnQgJiZcblx0XHRcdChjb21wb25lbnQuYmFzZSB8fCAoY29tcG9uZW50Lm5vZGVUeXBlID09PSAxICYmIGNvbXBvbmVudCkpKSB8fFxuXHRcdG51bGxcblx0KTtcbn1cblxuLyoqXG4gKiBEZXByZWNhdGVkIHdheSB0byBjb250cm9sIGJhdGNoZWQgcmVuZGVyaW5nIGluc2lkZSB0aGUgcmVjb25jaWxlciwgYnV0IHdlXG4gKiBhbHJlYWR5IHNjaGVkdWxlIGluIGJhdGNoZXMgaW5zaWRlIG91ciByZW5kZXJpbmcgY29kZVxuICogQHRlbXBsYXRlIEFyZ1xuICogQHBhcmFtIHsoYXJnOiBBcmcpID0+IHZvaWR9IGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgdHJpZ2dlcnMgdGhlIHVwZGF0ZWRcbiAqIEBwYXJhbSB7QXJnfSBbYXJnXSBPcHRpb25hbCBhcmd1bWVudCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbmNvbnN0IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzID0gKGNhbGxiYWNrLCBhcmcpID0+IGNhbGxiYWNrKGFyZyk7XG5cbi8qKlxuICogSW4gUmVhY3QsIGBmbHVzaFN5bmNgIGZsdXNoZXMgdGhlIGVudGlyZSB0cmVlIGFuZCBmb3JjZXMgYSByZXJlbmRlci4gSXQnc1xuICogaW1wbG1lbnRlZCBoZXJlIGFzIGEgbm8tb3AuXG4gKiBAdGVtcGxhdGUgQXJnXG4gKiBAdGVtcGxhdGUgUmVzdWx0XG4gKiBAcGFyYW0geyhhcmc6IEFyZykgPT4gUmVzdWx0fSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IHJ1bnMgYmVmb3JlIHRoZSBmbHVzaFxuICogQHBhcmFtIHtBcmd9IFthcmddIE9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2tcbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IGZsdXNoU3luYyA9IChjYWxsYmFjaywgYXJnKSA9PiBjYWxsYmFjayhhcmcpO1xuXG4vKipcbiAqIFN0cmljdCBNb2RlIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBQcmVhY3QsIHNvIHdlIHByb3ZpZGUgYSBzdGFuZC1pbiBmb3IgaXRcbiAqIHRoYXQganVzdCByZW5kZXJzIGl0cyBjaGlsZHJlbiB3aXRob3V0IGltcG9zaW5nIGFueSByZXN0cmljdGlvbnMuXG4gKi9cbmNvbnN0IFN0cmljdE1vZGUgPSBGcmFnbWVudDtcblxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihjYikge1xuXHRjYigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVmZXJyZWRWYWx1ZSh2YWwpIHtcblx0cmV0dXJuIHZhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG5cdHJldHVybiBbZmFsc2UsIHN0YXJ0VHJhbnNpdGlvbl07XG59XG5cbi8vIFRPRE86IGluIHRoZW9yeSB0aGlzIHNob3VsZCBiZSBkb25lIGFmdGVyIGEgVk5vZGUgaXMgZGlmZmVkIGFzIHdlIHdhbnQgdG8gaW5zZXJ0XG4vLyBzdHlsZXMvLi4uIGJlZm9yZSBpdCBhdHRhY2hlc1xuZXhwb3J0IGNvbnN0IHVzZUluc2VydGlvbkVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcblxuLyoqXG4gKiBUaGlzIGlzIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFpbi9wYWNrYWdlcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zcmMvdXNlU3luY0V4dGVybmFsU3RvcmVTaGltQ2xpZW50LmpzI0w4NFxuICogb24gYSBoaWdoIGxldmVsIHRoaXMgY3V0cyBvdXQgdGhlIHdhcm5pbmdzLCAuLi4gYW5kIGF0dGVtcHRzIGEgc21hbGxlciBpbXBsZW1lbnRhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCkge1xuXHRjb25zdCB2YWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cblx0Y29uc3QgW3sgX2luc3RhbmNlIH0sIGZvcmNlVXBkYXRlXSA9IHVzZVN0YXRlKHtcblx0XHRfaW5zdGFuY2U6IHsgX3ZhbHVlOiB2YWx1ZSwgX2dldFNuYXBzaG90OiBnZXRTbmFwc2hvdCB9XG5cdH0pO1xuXG5cdHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG5cdFx0X2luc3RhbmNlLl92YWx1ZSA9IHZhbHVlO1xuXHRcdF9pbnN0YW5jZS5fZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDtcblxuXHRcdGlmICghaXMoX2luc3RhbmNlLl92YWx1ZSwgZ2V0U25hcHNob3QoKSkpIHtcblx0XHRcdGZvcmNlVXBkYXRlKHsgX2luc3RhbmNlIH0pO1xuXHRcdH1cblx0fSwgW3N1YnNjcmliZSwgdmFsdWUsIGdldFNuYXBzaG90XSk7XG5cblx0dXNlRWZmZWN0KCgpID0+IHtcblx0XHRpZiAoIWlzKF9pbnN0YW5jZS5fdmFsdWUsIF9pbnN0YW5jZS5fZ2V0U25hcHNob3QoKSkpIHtcblx0XHRcdGZvcmNlVXBkYXRlKHsgX2luc3RhbmNlIH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdWJzY3JpYmUoKCkgPT4ge1xuXHRcdFx0aWYgKCFpcyhfaW5zdGFuY2UuX3ZhbHVlLCBfaW5zdGFuY2UuX2dldFNuYXBzaG90KCkpKSB7XG5cdFx0XHRcdGZvcmNlVXBkYXRlKHsgX2luc3RhbmNlIH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LCBbc3Vic2NyaWJlXSk7XG5cblx0cmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgKiBmcm9tICdwcmVhY3QvaG9va3MnO1xuZXhwb3J0IHtcblx0dmVyc2lvbixcblx0Q2hpbGRyZW4sXG5cdHJlbmRlcixcblx0aHlkcmF0ZSxcblx0dW5tb3VudENvbXBvbmVudEF0Tm9kZSxcblx0Y3JlYXRlUG9ydGFsLFxuXHRjcmVhdGVFbGVtZW50LFxuXHRjcmVhdGVDb250ZXh0LFxuXHRjcmVhdGVGYWN0b3J5LFxuXHRjbG9uZUVsZW1lbnQsXG5cdGNyZWF0ZVJlZixcblx0RnJhZ21lbnQsXG5cdGlzVmFsaWRFbGVtZW50LFxuXHRmaW5kRE9NTm9kZSxcblx0Q29tcG9uZW50LFxuXHRQdXJlQ29tcG9uZW50LFxuXHRtZW1vLFxuXHRmb3J3YXJkUmVmLFxuXHRmbHVzaFN5bmMsXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2Vcblx0dW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMsXG5cdFN0cmljdE1vZGUsXG5cdFN1c3BlbnNlLFxuXHRTdXNwZW5zZUxpc3QsXG5cdGxhenksXG5cdF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEXG59O1xuXG4vLyBSZWFjdCBjb3BpZXMgdGhlIG5hbWVkIGV4cG9ydHMgdG8gdGhlIGRlZmF1bHQgb25lLlxuZXhwb3J0IGRlZmF1bHQge1xuXHR1c2VTdGF0ZSxcblx0dXNlSWQsXG5cdHVzZVJlZHVjZXIsXG5cdHVzZUVmZmVjdCxcblx0dXNlTGF5b3V0RWZmZWN0LFxuXHR1c2VJbnNlcnRpb25FZmZlY3QsXG5cdHVzZVRyYW5zaXRpb24sXG5cdHVzZURlZmVycmVkVmFsdWUsXG5cdHVzZVN5bmNFeHRlcm5hbFN0b3JlLFxuXHRzdGFydFRyYW5zaXRpb24sXG5cdHVzZVJlZixcblx0dXNlSW1wZXJhdGl2ZUhhbmRsZSxcblx0dXNlTWVtbyxcblx0dXNlQ2FsbGJhY2ssXG5cdHVzZUNvbnRleHQsXG5cdHVzZURlYnVnVmFsdWUsXG5cdHZlcnNpb24sXG5cdENoaWxkcmVuLFxuXHRyZW5kZXIsXG5cdGh5ZHJhdGUsXG5cdHVubW91bnRDb21wb25lbnRBdE5vZGUsXG5cdGNyZWF0ZVBvcnRhbCxcblx0Y3JlYXRlRWxlbWVudCxcblx0Y3JlYXRlQ29udGV4dCxcblx0Y3JlYXRlRmFjdG9yeSxcblx0Y2xvbmVFbGVtZW50LFxuXHRjcmVhdGVSZWYsXG5cdEZyYWdtZW50LFxuXHRpc1ZhbGlkRWxlbWVudCxcblx0ZmluZERPTU5vZGUsXG5cdENvbXBvbmVudCxcblx0UHVyZUNvbXBvbmVudCxcblx0bWVtbyxcblx0Zm9yd2FyZFJlZixcblx0Zmx1c2hTeW5jLFxuXHR1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyxcblx0U3RyaWN0TW9kZSxcblx0U3VzcGVuc2UsXG5cdFN1c3BlbnNlTGlzdCxcblx0bGF6eSxcblx0X19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRURcbn07XG4iLCAiaW1wb3J0ICogYXMgcHJlYWN0IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQsIGlzVmFsaWRFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVQb3J0YWwgfSBmcm9tICdwcmVhY3QvY29tcGF0JztcblxuY29uc3Qgc3R5bGVUZXh0cyA9IFtdO1xuY29uc3Qgc3R5bGVFbHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBpbmplY3RTdHlsZXMoc3R5bGVUZXh0KSB7XG4gICAgc3R5bGVUZXh0cy5wdXNoKHN0eWxlVGV4dCk7XG4gICAgc3R5bGVFbHMuZm9yRWFjaCgoc3R5bGVFbCkgPT4ge1xuICAgICAgICBhcHBlbmRTdHlsZXNUbyhzdHlsZUVsLCBzdHlsZVRleHQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW5zdXJlRWxIYXNTdHlsZXMoZWwpIHtcbiAgICBpZiAoZWwuaXNDb25uZWN0ZWQgJiYgLy8gc29tZXRpbWVzIHRydWUgaWYgU1NSIHN5c3RlbSBzaW11bGF0ZXMgRE9NXG4gICAgICAgIGVsLmdldFJvb3ROb2RlIC8vIHNvbWV0aW1lcyB1bmRlZmluZWQgaWYgU1NSIHN5c3RlbSBzaW11bGF0ZXMgRE9NXG4gICAgKSB7XG4gICAgICAgIHJlZ2lzdGVyU3R5bGVzUm9vdChlbC5nZXRSb290Tm9kZSgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWdpc3RlclN0eWxlc1Jvb3Qocm9vdE5vZGUpIHtcbiAgICBsZXQgc3R5bGVFbCA9IHN0eWxlRWxzLmdldChyb290Tm9kZSk7XG4gICAgaWYgKCFzdHlsZUVsIHx8ICFzdHlsZUVsLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIHN0eWxlRWwgPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZVtkYXRhLWZ1bGxjYWxlbmRhcl0nKTtcbiAgICAgICAgaWYgKCFzdHlsZUVsKSB7XG4gICAgICAgICAgICBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHN0eWxlRWwuc2V0QXR0cmlidXRlKCdkYXRhLWZ1bGxjYWxlbmRhcicsICcnKTtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gZ2V0Tm9uY2VWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVFbC5ub25jZSA9IG5vbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyZW50RWwgPSByb290Tm9kZSA9PT0gZG9jdW1lbnQgPyBkb2N1bWVudC5oZWFkIDogcm9vdE5vZGU7XG4gICAgICAgICAgICBjb25zdCBpbnNlcnRCZWZvcmUgPSByb290Tm9kZSA9PT0gZG9jdW1lbnRcbiAgICAgICAgICAgICAgICA/IHBhcmVudEVsLnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdCxsaW5rW3JlbD1zdHlsZXNoZWV0XSxsaW5rW2FzPXN0eWxlXSxzdHlsZScpXG4gICAgICAgICAgICAgICAgOiBwYXJlbnRFbC5maXJzdENoaWxkO1xuICAgICAgICAgICAgcGFyZW50RWwuaW5zZXJ0QmVmb3JlKHN0eWxlRWwsIGluc2VydEJlZm9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVFbHMuc2V0KHJvb3ROb2RlLCBzdHlsZUVsKTtcbiAgICAgICAgaHlkcmF0ZVN0eWxlc1Jvb3Qoc3R5bGVFbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaHlkcmF0ZVN0eWxlc1Jvb3Qoc3R5bGVFbCkge1xuICAgIGZvciAoY29uc3Qgc3R5bGVUZXh0IG9mIHN0eWxlVGV4dHMpIHtcbiAgICAgICAgYXBwZW5kU3R5bGVzVG8oc3R5bGVFbCwgc3R5bGVUZXh0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmRTdHlsZXNUbyhzdHlsZUVsLCBzdHlsZVRleHQpIHtcbiAgICBjb25zdCB7IHNoZWV0IH0gPSBzdHlsZUVsO1xuICAgIGNvbnN0IHJ1bGVDbnQgPSBzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgc3R5bGVUZXh0LnNwbGl0KCd9JykuZm9yRWFjaCgoc3R5bGVTdHIsIGkpID0+IHtcbiAgICAgICAgc3R5bGVTdHIgPSBzdHlsZVN0ci50cmltKCk7XG4gICAgICAgIGlmIChzdHlsZVN0cikge1xuICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShzdHlsZVN0ciArICd9JywgcnVsZUNudCArIGkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyBub25jZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxubGV0IHF1ZXJpZWROb25jZVZhbHVlO1xuZnVuY3Rpb24gZ2V0Tm9uY2VWYWx1ZSgpIHtcbiAgICBpZiAocXVlcmllZE5vbmNlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBxdWVyaWVkTm9uY2VWYWx1ZSA9IHF1ZXJ5Tm9uY2VWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcmllZE5vbmNlVmFsdWU7XG59XG4vKlxuVE9ETzogZGlzY291cmFnZSBtZXRhIHRhZyBhbmQgaW5zdGVhZCBwdXQgbm9uY2UgYXR0cmlidXRlIG9uIHBsYWNlaG9sZGVyIDxzdHlsZT4gdGFnXG4qL1xuZnVuY3Rpb24gcXVlcnlOb25jZVZhbHVlKCkge1xuICAgIGNvbnN0IG1ldGFXaXRoTm9uY2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJjc3Atbm9uY2VcIl0nKTtcbiAgICBpZiAobWV0YVdpdGhOb25jZSAmJiBtZXRhV2l0aE5vbmNlLmhhc0F0dHJpYnV0ZSgnY29udGVudCcpKSB7XG4gICAgICAgIHJldHVybiBtZXRhV2l0aE5vbmNlLmdldEF0dHJpYnV0ZSgnY29udGVudCcpO1xuICAgIH1cbiAgICBjb25zdCBlbFdpdGhOb25jZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFtub25jZV0nKTtcbiAgICBpZiAoZWxXaXRoTm9uY2UpIHtcbiAgICAgICAgcmV0dXJuIGVsV2l0aE5vbmNlLm5vbmNlIHx8ICcnO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG4vLyBtYWluXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJlZ2lzdGVyU3R5bGVzUm9vdChkb2N1bWVudCk7XG59XG5cbnZhciBjc3NfMjQ4eiA9IFwiOnJvb3R7LS1mYy1zbWFsbC1mb250LXNpemU6Ljg1ZW07LS1mYy1wYWdlLWJnLWNvbG9yOiNmZmY7LS1mYy1uZXV0cmFsLWJnLWNvbG9yOmhzbGEoMCwwJSw4MiUsLjMpOy0tZmMtbmV1dHJhbC10ZXh0LWNvbG9yOmdyZXk7LS1mYy1ib3JkZXItY29sb3I6I2RkZDstLWZjLWJ1dHRvbi10ZXh0LWNvbG9yOiNmZmY7LS1mYy1idXR0b24tYmctY29sb3I6IzJjM2U1MDstLWZjLWJ1dHRvbi1ib3JkZXItY29sb3I6IzJjM2U1MDstLWZjLWJ1dHRvbi1ob3Zlci1iZy1jb2xvcjojMWUyYjM3Oy0tZmMtYnV0dG9uLWhvdmVyLWJvcmRlci1jb2xvcjojMWEyNTJmOy0tZmMtYnV0dG9uLWFjdGl2ZS1iZy1jb2xvcjojMWEyNTJmOy0tZmMtYnV0dG9uLWFjdGl2ZS1ib3JkZXItY29sb3I6IzE1MWUyNzstLWZjLWV2ZW50LWJnLWNvbG9yOiMzNzg4ZDg7LS1mYy1ldmVudC1ib3JkZXItY29sb3I6IzM3ODhkODstLWZjLWV2ZW50LXRleHQtY29sb3I6I2ZmZjstLWZjLWV2ZW50LXNlbGVjdGVkLW92ZXJsYXktY29sb3I6cmdiYSgwLDAsMCwuMjUpOy0tZmMtbW9yZS1saW5rLWJnLWNvbG9yOiNkMGQwZDA7LS1mYy1tb3JlLWxpbmstdGV4dC1jb2xvcjppbmhlcml0Oy0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3M6OHB4Oy0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGg6OHB4Oy0tZmMtZXZlbnQtcmVzaXplci1kb3QtYm9yZGVyLXdpZHRoOjFweDstLWZjLW5vbi1idXNpbmVzcy1jb2xvcjpoc2xhKDAsMCUsODQlLC4zKTstLWZjLWJnLWV2ZW50LWNvbG9yOiM4ZmRmODI7LS1mYy1iZy1ldmVudC1vcGFjaXR5OjAuMzstLWZjLWhpZ2hsaWdodC1jb2xvcjpyZ2JhKDE4OCwyMzIsMjQxLC4zKTstLWZjLXRvZGF5LWJnLWNvbG9yOnJnYmEoMjU1LDIyMCw0MCwuMTUpOy0tZmMtbm93LWluZGljYXRvci1jb2xvcjpyZWR9LmZjLW5vdC1hbGxvd2VkLC5mYy1ub3QtYWxsb3dlZCAuZmMtZXZlbnR7Y3Vyc29yOm5vdC1hbGxvd2VkfS5mY3tkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2ZvbnQtc2l6ZToxZW19LmZjLC5mYyAqLC5mYyA6YWZ0ZXIsLmZjIDpiZWZvcmV7Ym94LXNpemluZzpib3JkZXItYm94fS5mYyB0YWJsZXtib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7Ym9yZGVyLXNwYWNpbmc6MDtmb250LXNpemU6MWVtfS5mYyB0aHt0ZXh0LWFsaWduOmNlbnRlcn0uZmMgdGQsLmZjIHRoe3BhZGRpbmc6MDt2ZXJ0aWNhbC1hbGlnbjp0b3B9LmZjIGFbZGF0YS1uYXZsaW5rXXtjdXJzb3I6cG9pbnRlcn0uZmMgYVtkYXRhLW5hdmxpbmtdOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9LmZjLWRpcmVjdGlvbi1sdHJ7ZGlyZWN0aW9uOmx0cjt0ZXh0LWFsaWduOmxlZnR9LmZjLWRpcmVjdGlvbi1ydGx7ZGlyZWN0aW9uOnJ0bDt0ZXh0LWFsaWduOnJpZ2h0fS5mYy10aGVtZS1zdGFuZGFyZCB0ZCwuZmMtdGhlbWUtc3RhbmRhcmQgdGh7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IpfS5mYy1saXF1aWQtaGFjayB0ZCwuZmMtbGlxdWlkLWhhY2sgdGh7cG9zaXRpb246cmVsYXRpdmV9QGZvbnQtZmFjZXtmb250LWZhbWlseTpmY2ljb25zO2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtd2VpZ2h0OjQwMDtzcmM6dXJsKFxcXCJkYXRhOmFwcGxpY2F0aW9uL3gtZm9udC10dGY7Y2hhcnNldD11dGYtODtiYXNlNjQsQUFFQUFBQUxBSUFBQXdBd1QxTXZNZzhTQmZBQUFBQzhBQUFBWUdOdFlYQVhWdEtOQUFBQkhBQUFBRlJuWVhOd0FBQUFFQUFBQVhBQUFBQUlaMng1WmdZeWR4SUFBQUY0QUFBRk5HaGxZV1FVSjdjSUFBQUdyQUFBQURab2FHVmhCMjBEekFBQUJ1UUFBQUFrYUcxMGVDSUFCaFFBQUFjSUFBQUFMR3h2WTJFRDRBVTZBQUFITkFBQUFCaHRZWGh3QUE4QWpBQUFCMHdBQUFBZ2JtRnRaWHNyNjkwQUFBZHNBQUFCaG5CdmMzUUFBd0FBQUFBSTlBQUFBQ0FBQXdQQUFaQUFCUUFBQXBrQ3pBQUFBSThDbVFMTUFBQUI2d0F6QVFrQUFBQUFBQUFBQUFBQUFBQUFBQUFCRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFEcEJnUEEvOEFBUUFQQUFFQUFBQUFCQUFBQUFBQUFBQUFBQUFBZ0FBQUFBQUFEQUFBQUF3QUFBQndBQVFBREFBQUFIQUFEQUFFQUFBQWNBQVFBT0FBQUFBb0FDQUFDQUFJQUFRQWc2UWIvL2YvL0FBQUFBQUFnNlFELy9mLy9BQUgvNHhjRUFBTUFBUUFBQUFBQUFBQUFBQUFBQVFBQi8vOEFEd0FCQUFBQUFBQUFBQUFBQWdBQU56a0JBQUFBQUFFQUFBQUFBQUFBQUFBQ0FBQTNPUUVBQUFBQUFRQUFBQUFBQUFBQUFBSUFBRGM1QVFBQUFBQUJBV0lBalFLZUFza0FFd0FBSlNjM05qUW5KaUlIQVFZVUZ3RVdNamMyTkNjQ251TGlEUTBNSkF6L0FBME5BUUFNSkF3TkRjbmk0Z3dqRFF3TS93QU5Jd3ovQUEwTkRDTU5BQUFBQVFGaUFJMENuZ0xKQUJNQUFDVUJOalFuQVNZaUJ3WVVId0VIQmhRWEZqSTNBWjRCQUEwTi93QU1KQXdORGVMaURRME1KQXlOQVFBTUl3MEJBQXdNRFNNTTR1SU5Jd3dORFFBQUFBSUE0Z0MzQXg0Q25nQVRBQ2NBQUNVbk56WTBKeVlpRHdFR0ZCOEJGakkzTmpRbklTYzNOalFuSmlJUEFRWVVId0VXTWpjMk5DY0I4N2UzRFEwTUl3M1ZEUTNWRFNNTURRMEJLN2UzRFEwTUpBelZEUTNWRENRTURRM3p1TGNNSkF3TkRkVU5Jd3pXREF3Tkl3eTR0d3drREEwTjFRMGpETllNREEwakRBQUFBZ0RpQUxjREhnS2VBQk1BSndBQUpUYzJOQzhCSmlJSEJoUWZBUWNHRkJjV01qY2hOelkwTHdFbUlnY0dGQjhCQndZVUZ4WXlOd0pKMVEwTjFRMGpEQTBOdDdjTkRRd2pEZjdWMVEwTjFRd2tEQTBOdDdjTkRRd2tETGZXRENNTjFRME5EQ1FNdDdnTUl3ME1ETllNSXczVkRRME1KQXkzdUF3akRRd01BQUFEQUZVQUFBT3JBMVVBTXdCb0FIY0FBQk1pQmdjT0FRY09BUWNPQVJVUkZCWVhIZ0VYSGdFWEhnRXpJVEkyTno0Qk56NEJOejRCTlJFMEppY3VBU2N1QVNjdUFTTUZJVElXRng0QkZ4NEJGeDRCRlJFVUJnY09BUWNPQVFjT0FTTWhJaVluTGdFbkxnRW5MZ0UxRVRRMk56NEJOejRCTno0Qk14TWhNalkxTkNZaklTSUdGUlFXTTlVTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ05BbFlOR0F3TEZRa0pEZ1VGQlFVRkJRNEpDUlVMREJnTi9hb0NWZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FUOXFnUUlCQVFIQXdNRkFRSUJBUUlCQlFNREJ3UUVDQVNBQVZZUkdSa1IvcW9SR1JrUkExVUZCQVVPQ1FrVkRBc1pEZjJyRFJrTERCVUpDQTRGQlFVRkJRVU9DUWdWREFzWkRRSlZEUmtMREJVSkNRNEZCQVZWQWdFQ0JRTUNCd1FFQ0FYOXF3UUpBd1FIQXdNRkFRSUNBZ0lCQlFNREJ3UURDUVFDVlFVSUJBUUhBZ01GQWdFQy9vQVpFaEVaR1JFU0dRQUFBQUFEQUZVQUFBT3JBMVVBTXdCb0FJa0FBQk1pQmdjT0FRY09BUWNPQVJVUkZCWVhIZ0VYSGdFWEhnRXpJVEkyTno0Qk56NEJOejRCTlJFMEppY3VBU2N1QVNjdUFTTUZJVElXRng0QkZ4NEJGeDRCRlJFVUJnY09BUWNPQVFjT0FTTWhJaVluTGdFbkxnRW5MZ0UxRVRRMk56NEJOejRCTno0Qk14TXpGUlFXTXpJMlBRRXpNalkxTkNZckFUVTBKaU1pQmgwQkl5SUdGUlFXTTlVTkdBd0xGUWtKRGdVRkJRVUZCUTRKQ1JVTERCZ05BbFlOR0F3TEZRa0pEZ1VGQlFVRkJRNEpDUlVMREJnTi9hb0NWZ1FJQkFRSEF3TUZBUUlCQVFJQkJRTURCd1FFQ0FUOXFnUUlCQVFIQXdNRkFRSUJBUUlCQlFNREJ3UUVDQVNBZ0JrU0VobUFFUmtaRVlBWkVoSVpnQkVaR1JFRFZRVUVCUTRKQ1JVTUN4a04vYXNOR1FzTUZRa0lEZ1VGQlFVRkJRNEpDQlVNQ3hrTkFsVU5HUXNNRlFrSkRnVUVCVlVDQVFJRkF3SUhCQVFJQmYyckJBa0RCQWNEQXdVQkFnSUNBZ0VGQXdNSEJBTUpCQUpWQlFnRUJBY0NBd1VDQVFMK2dJQVNHUmtTZ0JrU0VSbUFFaGtaRW9BWkVSSVpBQUFCQU9JQWpRTWVBc2tBSUFBQUV4Y0hCaFFYRmpJL0FSY1dNamMyTkM4Qk56WTBKeVlpRHdFbkppSUhCaFFYNHVMaURRME1KQXppNGd3a0RBME40dUlORFF3a0RPTGlEQ1FNRFEwQ2plTGlEU01NRFEzaDRRME5EQ01ONHVJTUl3ME1ET0xpREF3Tkl3d0FBQUFCQUFBQUFRQUFhNW4weTE4UFBQVUFDd1FBQUFBQUFOaXZPVnNBQUFBQTJLODVXd0FBQUFBRHF3TlZBQUFBQ0FBQ0FBQUFBQUFBQUFFQUFBUEEvOEFBQUFRQUFBQUFBQU9yQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFMQkFBQUFBQUFBQUFBQUFBQUFnQUFBQVFBQVdJRUFBRmlCQUFBNGdRQUFPSUVBQUJWQkFBQVZRUUFBT0lBQUFBQUFBb0FGQUFlQUVRQWFnQ3FBT29CbmdKa0Fwb0FBUUFBQUFzQWlnQURBQUFBQUFBQ0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBNEFyZ0FCQUFBQUFBQUJBQWNBQUFBQkFBQUFBQUFDQUFjQVlBQUJBQUFBQUFBREFBY0FOZ0FCQUFBQUFBQUVBQWNBZFFBQkFBQUFBQUFGQUFzQUZRQUJBQUFBQUFBR0FBY0FTd0FCQUFBQUFBQUtBQm9BaWdBREFBRUVDUUFCQUE0QUJ3QURBQUVFQ1FBQ0FBNEFad0FEQUFFRUNRQURBQTRBUFFBREFBRUVDUUFFQUE0QWZBQURBQUVFQ1FBRkFCWUFJQUFEQUFFRUNRQUdBQTRBVWdBREFBRUVDUUFLQURRQXBHWmphV052Ym5NQVpnQmpBR2tBWXdCdkFHNEFjMVpsY25OcGIyNGdNUzR3QUZZQVpRQnlBSE1BYVFCdkFHNEFJQUF4QUM0QU1HWmphV052Ym5NQVpnQmpBR2tBWXdCdkFHNEFjMlpqYVdOdmJuTUFaZ0JqQUdrQVl3QnZBRzRBYzFKbFozVnNZWElBVWdCbEFHY0FkUUJzQUdFQWNtWmphV052Ym5NQVpnQmpBR2tBWXdCdkFHNEFjMFp2Ym5RZ1oyVnVaWEpoZEdWa0lHSjVJRWxqYjAxdmIyNHVBRVlBYndCdUFIUUFJQUJuQUdVQWJnQmxBSElBWVFCMEFHVUFaQUFnQUdJQWVRQWdBRWtBWXdCdkFFMEFid0J2QUc0QUxnQUFBQU1BQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBPVxcXCIpIGZvcm1hdChcXFwidHJ1ZXR5cGVcXFwiKX0uZmMtaWNvbntzcGVhazpub25lOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZvbnQtZmFtaWx5OmZjaWNvbnMhaW1wb3J0YW50O2ZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtdmFyaWFudDpub3JtYWw7Zm9udC13ZWlnaHQ6NDAwO2hlaWdodDoxZW07bGluZS1oZWlnaHQ6MTt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LXRyYW5zZm9ybTpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO3dpZHRoOjFlbX0uZmMtaWNvbi1jaGV2cm9uLWxlZnQ6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTAwXFxcIn0uZmMtaWNvbi1jaGV2cm9uLXJpZ2h0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwMVxcXCJ9LmZjLWljb24tY2hldnJvbnMtbGVmdDpiZWZvcmV7Y29udGVudDpcXFwiXFxcXGU5MDJcXFwifS5mYy1pY29uLWNoZXZyb25zLXJpZ2h0OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwM1xcXCJ9LmZjLWljb24tbWludXMtc3F1YXJlOmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwNFxcXCJ9LmZjLWljb24tcGx1cy1zcXVhcmU6YmVmb3Jle2NvbnRlbnQ6XFxcIlxcXFxlOTA1XFxcIn0uZmMtaWNvbi14OmJlZm9yZXtjb250ZW50OlxcXCJcXFxcZTkwNlxcXCJ9LmZjIC5mYy1idXR0b257Ym9yZGVyLXJhZGl1czowO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7bGluZS1oZWlnaHQ6aW5oZXJpdDttYXJnaW46MDtvdmVyZmxvdzp2aXNpYmxlO3RleHQtdHJhbnNmb3JtOm5vbmV9LmZjIC5mYy1idXR0b246Zm9jdXN7b3V0bGluZToxcHggZG90dGVkO291dGxpbmU6NXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yfS5mYyAuZmMtYnV0dG9uey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b259LmZjIC5mYy1idXR0b246bm90KDpkaXNhYmxlZCl7Y3Vyc29yOnBvaW50ZXJ9LmZjIC5mYy1idXR0b257YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6LjI1ZW07ZGlzcGxheTppbmxpbmUtYmxvY2s7Zm9udC1zaXplOjFlbTtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS41O3BhZGRpbmc6LjRlbSAuNjVlbTt0ZXh0LWFsaWduOmNlbnRlcjstbW96LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b246aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjIC5mYy1idXR0b246Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAuMnJlbSByZ2JhKDQ0LDYyLDgwLC4yNSk7b3V0bGluZTowfS5mYyAuZmMtYnV0dG9uOmRpc2FibGVke29wYWNpdHk6LjY1fS5mYyAuZmMtYnV0dG9uLXByaW1hcnl7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1idXR0b24tYmctY29sb3IpO2JvcmRlci1jb2xvcjp2YXIoLS1mYy1idXR0b24tYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ob3Zlci1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1ob3Zlci1ib3JkZXItY29sb3IpO2NvbG9yOnZhcigtLWZjLWJ1dHRvbi10ZXh0LWNvbG9yKX0uZmMgLmZjLWJ1dHRvbi1wcmltYXJ5OmRpc2FibGVke2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJnLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tZmMtYnV0dG9uLWJvcmRlci1jb2xvcik7Y29sb3I6dmFyKC0tZmMtYnV0dG9uLXRleHQtY29sb3IpfS5mYyAuZmMtYnV0dG9uLXByaW1hcnk6Zm9jdXN7Ym94LXNoYWRvdzowIDAgMCAuMnJlbSByZ2JhKDc2LDkxLDEwNiwuNSl9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlLC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZle2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtYnV0dG9uLWFjdGl2ZS1iZy1jb2xvcik7Ym9yZGVyLWNvbG9yOnZhcigtLWZjLWJ1dHRvbi1hY3RpdmUtYm9yZGVyLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1idXR0b24tdGV4dC1jb2xvcil9LmZjIC5mYy1idXR0b24tcHJpbWFyeTpub3QoOmRpc2FibGVkKS5mYy1idXR0b24tYWN0aXZlOmZvY3VzLC5mYyAuZmMtYnV0dG9uLXByaW1hcnk6bm90KDpkaXNhYmxlZCk6YWN0aXZlOmZvY3Vze2JveC1zaGFkb3c6MCAwIDAgLjJyZW0gcmdiYSg3Niw5MSwxMDYsLjUpfS5mYyAuZmMtYnV0dG9uIC5mYy1pY29ue2ZvbnQtc2l6ZToxLjVlbTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b24tZ3JvdXB7ZGlzcGxheTppbmxpbmUtZmxleDtwb3NpdGlvbjpyZWxhdGl2ZTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmZjIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbntmbGV4OjEgMSBhdXRvO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b24uZmMtYnV0dG9uLWFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmFjdGl2ZSwuZmMgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOmZvY3VzLC5mYyAuZmMtYnV0dG9uLWdyb3VwPi5mYy1idXR0b246aG92ZXJ7ei1pbmRleDoxfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO21hcmdpbi1sZWZ0Oi0xcHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1idXR0b24tZ3JvdXA+LmZjLWJ1dHRvbjpub3QoOmZpcnN0LWNoaWxkKXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjA7bWFyZ2luLXJpZ2h0Oi0xcHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWJ1dHRvbi1ncm91cD4uZmMtYnV0dG9uOm5vdCg6bGFzdC1jaGlsZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MH0uZmMgLmZjLXRvb2xiYXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn0uZmMgLmZjLXRvb2xiYXIuZmMtaGVhZGVyLXRvb2xiYXJ7bWFyZ2luLWJvdHRvbToxLjVlbX0uZmMgLmZjLXRvb2xiYXIuZmMtZm9vdGVyLXRvb2xiYXJ7bWFyZ2luLXRvcDoxLjVlbX0uZmMgLmZjLXRvb2xiYXItdGl0bGV7Zm9udC1zaXplOjEuNzVlbTttYXJnaW46MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtdG9vbGJhcj4qPjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tbGVmdDouNzVlbX0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdG9vbGJhcj4qPjpub3QoOmZpcnN0LWNoaWxkKXttYXJnaW4tcmlnaHQ6Ljc1ZW19LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRvb2xiYXItbHRye2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfS5mYyAuZmMtc2Nyb2xsZXJ7LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6dG91Y2g7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1zY3JvbGxlci1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjIC5mYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGV7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy1zY3JvbGxlci1oYXJuZXNze2RpcmVjdGlvbjpsdHI7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtc2Nyb2xsZXItaGFybmVzcy1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXNjcm9sbGVyLWhhcm5lc3M+LmZjLXNjcm9sbGVye2RpcmVjdGlvbjpydGx9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1zY3JvbGxncmlke2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtYm9yZGVyLWNvbG9yKX0uZmMgLmZjLXNjcm9sbGdyaWQsLmZjIC5mYy1zY3JvbGxncmlkIHRhYmxle3RhYmxlLWxheW91dDpmaXhlZDt3aWR0aDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZCB0YWJsZXtib3JkZXItbGVmdC1zdHlsZTpoaWRkZW47Ym9yZGVyLXJpZ2h0LXN0eWxlOmhpZGRlbjtib3JkZXItdG9wLXN0eWxlOmhpZGRlbn0uZmMgLmZjLXNjcm9sbGdyaWR7Ym9yZGVyLWJvdHRvbS13aWR0aDowO2JvcmRlci1jb2xsYXBzZTpzZXBhcmF0ZTtib3JkZXItcmlnaHQtd2lkdGg6MH0uZmMgLmZjLXNjcm9sbGdyaWQtbGlxdWlke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uIHRhYmxlLC5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uPnRke2hlaWdodDoxcHh9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkPnRke2hlaWdodDoxMDAlfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uPip7Ym9yZGVyLWxlZnQtd2lkdGg6MDtib3JkZXItdG9wLXdpZHRoOjB9LmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tZm9vdGVyPiosLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24taGVhZGVyPip7Ym9yZGVyLWJvdHRvbS13aWR0aDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWJvZHkgdGFibGUsLmZjIC5mYy1zY3JvbGxncmlkLXNlY3Rpb24tZm9vdGVyIHRhYmxle2JvcmRlci1ib3R0b20tc3R5bGU6aGlkZGVufS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe2JhY2tncm91bmQ6dmFyKC0tZmMtcGFnZS1iZy1jb2xvcik7cG9zaXRpb246c3RpY2t5O3otaW5kZXg6M30uZmMgLmZjLXNjcm9sbGdyaWQtc2VjdGlvbi1oZWFkZXIuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreT4qe3RvcDowfS5mYyAuZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWZvb3Rlci5mYy1zY3JvbGxncmlkLXNlY3Rpb24tc3RpY2t5Pip7Ym90dG9tOjB9LmZjIC5mYy1zY3JvbGxncmlkLXN0aWNreS1zaGlte2hlaWdodDoxcHg7bWFyZ2luLWJvdHRvbTotMXB4fS5mYy1zdGlja3l7cG9zaXRpb246c3RpY2t5fS5mYyAuZmMtdmlldy1oYXJuZXNze2ZsZXgtZ3JvdzoxO3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtdmlldy1oYXJuZXNzLWFjdGl2ZT4uZmMtdmlld3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MnB4IDRweH0uZmMgLmZjLWJnLWV2ZW50LC5mYyAuZmMtaGlnaGxpZ2h0LC5mYyAuZmMtbm9uLWJ1c2luZXNze2JvdHRvbTowO2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtbm9uLWJ1c2luZXNze2JhY2tncm91bmQ6dmFyKC0tZmMtbm9uLWJ1c2luZXNzLWNvbG9yKX0uZmMgLmZjLWJnLWV2ZW50e2JhY2tncm91bmQ6dmFyKC0tZmMtYmctZXZlbnQtY29sb3IpO29wYWNpdHk6dmFyKC0tZmMtYmctZXZlbnQtb3BhY2l0eSl9LmZjIC5mYy1iZy1ldmVudCAuZmMtZXZlbnQtdGl0bGV7Zm9udC1zaXplOnZhcigtLWZjLXNtYWxsLWZvbnQtc2l6ZSk7Zm9udC1zdHlsZTppdGFsaWM7bWFyZ2luOi41ZW19LmZjIC5mYy1oaWdobGlnaHR7YmFja2dyb3VuZDp2YXIoLS1mYy1oaWdobGlnaHQtY29sb3IpfS5mYyAuZmMtY2VsbC1zaGFkZWQsLmZjIC5mYy1kYXktZGlzYWJsZWR7YmFja2dyb3VuZDp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKX1hLmZjLWV2ZW50LGEuZmMtZXZlbnQ6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmZjLWV2ZW50LmZjLWV2ZW50LWRyYWdnYWJsZSwuZmMtZXZlbnRbaHJlZl17Y3Vyc29yOnBvaW50ZXJ9LmZjLWV2ZW50IC5mYy1ldmVudC1tYWlue3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6Mn0uZmMtZXZlbnQtZHJhZ2dpbmc6bm90KC5mYy1ldmVudC1zZWxlY3RlZCl7b3BhY2l0eTouNzV9LmZjLWV2ZW50LWRyYWdnaW5nLmZjLWV2ZW50LXNlbGVjdGVke2JveC1zaGFkb3c6MCAycHggN3B4IHJnYmEoMCwwLDAsLjMpfS5mYy1ldmVudCAuZmMtZXZlbnQtcmVzaXplcntkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo0fS5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplciwuZmMtZXZlbnQ6aG92ZXIgLmZjLWV2ZW50LXJlc2l6ZXJ7ZGlzcGxheTpibG9ja30uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtib3JkZXItY29sb3I6aW5oZXJpdDtib3JkZXItcmFkaXVzOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLzIpO2JvcmRlci1zdHlsZTpzb2xpZDtib3JkZXItd2lkdGg6dmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtYm9yZGVyLXdpZHRoKTtoZWlnaHQ6dmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpO3dpZHRoOnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKX0uZmMtZXZlbnQtc2VsZWN0ZWQgLmZjLWV2ZW50LXJlc2l6ZXI6YmVmb3Jle2JvdHRvbTotMjBweDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6LTIwcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6LTIwcHg7dG9wOi0yMHB4fS5mYy1ldmVudC1zZWxlY3RlZCwuZmMtZXZlbnQ6Zm9jdXN7Ym94LXNoYWRvdzowIDJweCA1cHggcmdiYSgwLDAsMCwuMil9LmZjLWV2ZW50LXNlbGVjdGVkOmJlZm9yZSwuZmMtZXZlbnQ6Zm9jdXM6YmVmb3Jle2JvdHRvbTowO2NvbnRlbnQ6XFxcIlxcXCI7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjA7ei1pbmRleDozfS5mYy1ldmVudC1zZWxlY3RlZDphZnRlciwuZmMtZXZlbnQ6Zm9jdXM6YWZ0ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1ldmVudC1zZWxlY3RlZC1vdmVybGF5LWNvbG9yKTtib3R0b206LTFweDtjb250ZW50OlxcXCJcXFwiO2xlZnQ6LTFweDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotMXB4O3RvcDotMXB4O3otaW5kZXg6MX0uZmMtaC1ldmVudHtiYWNrZ3JvdW5kLWNvbG9yOnZhcigtLWZjLWV2ZW50LWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7ZGlzcGxheTpibG9ja30uZmMtaC1ldmVudCAuZmMtZXZlbnQtbWFpbntjb2xvcjp2YXIoLS1mYy1ldmVudC10ZXh0LWNvbG9yKX0uZmMtaC1ldmVudCAuZmMtZXZlbnQtbWFpbi1mcmFtZXtkaXNwbGF5OmZsZXh9LmZjLWgtZXZlbnQgLmZjLWV2ZW50LXRpbWV7bWF4LXdpZHRoOjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5mYy1oLWV2ZW50IC5mYy1ldmVudC10aXRsZS1jb250YWluZXJ7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTttaW4td2lkdGg6MH0uZmMtaC1ldmVudCAuZmMtZXZlbnQtdGl0bGV7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGVmdDowO21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbjtyaWdodDowO3ZlcnRpY2FsLWFsaWduOnRvcH0uZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZDpiZWZvcmV7Ym90dG9tOi0xMHB4O3RvcDotMTBweH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LXN0YXJ0KSwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LWVuZCl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowO2JvcmRlci1sZWZ0LXdpZHRoOjA7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWJsb2NrLWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKSwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC1ibG9jay1ldmVudDpub3QoLmZjLWV2ZW50LXN0YXJ0KXtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2JvcmRlci1yaWdodC13aWR0aDowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjB9LmZjLWgtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXJ7Ym90dG9tOjA7dG9wOjA7d2lkdGg6dmFyKC0tZmMtZXZlbnQtcmVzaXplci10aGlja25lc3MpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLXN0YXJ0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZHtjdXJzb3I6dy1yZXNpemU7bGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKSotLjUpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydHtjdXJzb3I6ZS1yZXNpemU7cmlnaHQ6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykqLS41KX0uZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplcnttYXJnaW4tdG9wOmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpKi0uNSk7dG9wOjUwJX0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1lbmR7bGVmdDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpfS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1oLWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLWVuZCwuZmMtZGlyZWN0aW9uLXJ0bCAuZmMtaC1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydHtyaWdodDpjYWxjKHZhcigtLWZjLWV2ZW50LXJlc2l6ZXItZG90LXRvdGFsLXdpZHRoKSotLjUpfS5mYyAuZmMtcG9wb3Zlcntib3gtc2hhZG93OjAgMnB4IDZweCByZ2JhKDAsMCwwLC4xNSk7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDo5OTk5fS5mYyAuZmMtcG9wb3Zlci1oZWFkZXJ7YWxpZ24taXRlbXM6Y2VudGVyO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47cGFkZGluZzozcHggNHB4fS5mYyAuZmMtcG9wb3Zlci10aXRsZXttYXJnaW46MCAycHh9LmZjIC5mYy1wb3BvdmVyLWNsb3Nle2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjFlbTtvcGFjaXR5Oi42NX0uZmMtdGhlbWUtc3RhbmRhcmQgLmZjLXBvcG92ZXJ7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtib3JkZXI6MXB4IHNvbGlkIHZhcigtLWZjLWJvcmRlci1jb2xvcil9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1wb3BvdmVyLWhlYWRlcntiYWNrZ3JvdW5kOnZhcigtLWZjLW5ldXRyYWwtYmctY29sb3IpfVwiO1xuaW5qZWN0U3R5bGVzKGNzc18yNDh6KTtcblxuY2xhc3MgRGVsYXllZFJ1bm5lciB7XG4gICAgY29uc3RydWN0b3IoZHJhaW5lZE9wdGlvbikge1xuICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24gPSBkcmFpbmVkT3B0aW9uO1xuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IDA7XG4gICAgfVxuICAgIHJlcXVlc3QoZGVsYXkpIHtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUGF1c2VkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dCgvLyBOT1QgT1BUSU1BTCEgVE9ETzogbG9vayBhdCBkZWJvdW5jZVxuICAgICAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4uYmluZCh0aGlzKSwgZGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBhdXNlKHNjb3BlID0gJycpIHtcbiAgICAgICAgbGV0IHsgcGF1c2VEZXB0aHMgfSA9IHRoaXM7XG4gICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSA9IChwYXVzZURlcHRoc1tzY29wZV0gfHwgMCkgKyAxO1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgIH1cbiAgICByZXN1bWUoc2NvcGUgPSAnJywgZm9yY2UpIHtcbiAgICAgICAgbGV0IHsgcGF1c2VEZXB0aHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChzY29wZSBpbiBwYXVzZURlcHRocykge1xuICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdXNlRGVwdGhzW3Njb3BlXSAtPSAxO1xuICAgICAgICAgICAgICAgIGxldCBkZXB0aCA9IHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGF1c2VEZXB0aHNbc2NvcGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJ5RHJhaW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1BhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucGF1c2VEZXB0aHMpLmxlbmd0aDtcbiAgICB9XG4gICAgdHJ5RHJhaW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcgJiYgIXRoaXMuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhaW5lZCgpOyAvLyBtaWdodCBzZXQgaXNEaXJ0eSB0byB0cnVlIGFnYWluXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXVzZURlcHRocyA9IHt9O1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMudGltZW91dElkID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmFpbmVkKCkge1xuICAgICAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbCkge1xuICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIH1cbn1cbi8vIFF1ZXJ5aW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBlbGVtZW50Q2xvc2VzdChlbCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoZWwuY2xvc2VzdCkge1xuICAgICAgICByZXR1cm4gZWwuY2xvc2VzdChzZWxlY3Rvcik7XG4gICAgICAgIC8vIHJlYWxseSBiYWQgZmFsbGJhY2sgZm9yIElFXG4gICAgICAgIC8vIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvY2xvc2VzdFxuICAgIH1cbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhlbCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgICAgaWYgKGVsZW1lbnRNYXRjaGVzKGVsLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgICAgICBlbCA9IChlbC5wYXJlbnRFbGVtZW50IHx8IGVsLnBhcmVudE5vZGUpO1xuICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVzKGVsLCBzZWxlY3Rvcikge1xuICAgIGxldCBtZXRob2QgPSBlbC5tYXRjaGVzIHx8IGVsLm1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3RvcjtcbiAgICByZXR1cm4gbWV0aG9kLmNhbGwoZWwsIHNlbGVjdG9yKTtcbn1cbi8vIGFjY2VwdHMgbXVsdGlwbGUgc3ViamVjdCBlbHNcbi8vIHJldHVybnMgYSByZWFsIGFycmF5LiBnb29kIGZvciBtZXRob2RzIGxpa2UgZm9yRWFjaFxuLy8gVE9ETzogYWNjZXB0IHRoZSBkb2N1bWVudFxuZnVuY3Rpb24gZmluZEVsZW1lbnRzKGNvbnRhaW5lciwgc2VsZWN0b3IpIHtcbiAgICBsZXQgY29udGFpbmVycyA9IGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gW2NvbnRhaW5lcl0gOiBjb250YWluZXI7XG4gICAgbGV0IGFsbE1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRhaW5lcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IG1hdGNoZXMgPSBjb250YWluZXJzW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFsbE1hdGNoZXMucHVzaChtYXRjaGVzW2pdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsTWF0Y2hlcztcbn1cbi8vIGFjY2VwdHMgbXVsdGlwbGUgc3ViamVjdCBlbHNcbi8vIG9ubHkgcXVlcmllcyBkaXJlY3QgY2hpbGQgZWxlbWVudHMgLy8gVE9ETzogcmVuYW1lIHRvIGZpbmREaXJlY3RDaGlsZHJlbiFcbmZ1bmN0aW9uIGZpbmREaXJlY3RDaGlsZHJlbihwYXJlbnQsIHNlbGVjdG9yKSB7XG4gICAgbGV0IHBhcmVudHMgPSBwYXJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IFtwYXJlbnRdIDogcGFyZW50O1xuICAgIGxldCBhbGxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBjaGlsZE5vZGVzID0gcGFyZW50c1tpXS5jaGlsZHJlbjsgLy8gb25seSBldmVyIGVsZW1lbnRzXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbal07XG4gICAgICAgICAgICBpZiAoIXNlbGVjdG9yIHx8IGVsZW1lbnRNYXRjaGVzKGNoaWxkTm9kZSwgc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgYWxsTWF0Y2hlcy5wdXNoKGNoaWxkTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsbE1hdGNoZXM7XG59XG4vLyBTdHlsZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgUElYRUxfUFJPUF9SRSA9IC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tfHdpZHRofGhlaWdodCkkL2k7XG5mdW5jdGlvbiBhcHBseVN0eWxlKGVsLCBwcm9wcykge1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgIGFwcGx5U3R5bGVQcm9wKGVsLCBwcm9wTmFtZSwgcHJvcHNbcHJvcE5hbWVdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVN0eWxlUHJvcChlbCwgbmFtZSwgdmFsKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIFBJWEVMX1BST1BfUkUudGVzdChuYW1lKSkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IGAke3ZhbH1weGA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbDtcbiAgICB9XG59XG4vLyBFdmVudCBIYW5kbGluZ1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gaWYgaW50ZXJjZXB0aW5nIGJ1YmJsZWQgZXZlbnRzIGF0IHRoZSBkb2N1bWVudC93aW5kb3cvYm9keSBsZXZlbCxcbi8vIGFuZCB3YW50IHRvIHNlZSBvcmlnaW5hdGluZyBlbGVtZW50ICh0aGUgJ3RhcmdldCcpLCB1c2UgdGhpcyB1dGlsIGluc3RlYWRcbi8vIG9mIGBldi50YXJnZXRgIGJlY2F1c2UgaXQgZ29lcyB3aXRoaW4gd2ViLWNvbXBvbmVudCBib3VuZGFyaWVzLlxuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXRWaWFSb290KGV2KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gZXYuY29tcG9zZWRQYXRoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChldilbMF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGV2LnRhcmdldDtcbn1cbi8vIFVuaXF1ZSBJRCBmb3IgRE9NIGF0dHJpYnV0ZVxubGV0IGd1aWQkMSA9IDA7XG5mdW5jdGlvbiBnZXRVbmlxdWVEb21JZCgpIHtcbiAgICBndWlkJDEgKz0gMTtcbiAgICByZXR1cm4gJ2ZjLWRvbS0nICsgZ3VpZCQxO1xufVxuXG4vLyBTdG9wcyBhIG1vdXNlL3RvdWNoIGV2ZW50IGZyb20gZG9pbmcgaXQncyBuYXRpdmUgYnJvd3NlciBhY3Rpb25cbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KGV2KSB7XG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcbn1cbi8vIEV2ZW50IERlbGVnYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGJ1aWxkRGVsZWdhdGlvbkhhbmRsZXIoc2VsZWN0b3IsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gKGV2KSA9PiB7XG4gICAgICAgIGxldCBtYXRjaGVkQ2hpbGQgPSBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKG1hdGNoZWRDaGlsZCkge1xuICAgICAgICAgICAgaGFuZGxlci5jYWxsKG1hdGNoZWRDaGlsZCwgZXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsIGV2ZW50VHlwZSwgc2VsZWN0b3IsIGhhbmRsZXIpIHtcbiAgICBsZXQgYXR0YWNoZWRIYW5kbGVyID0gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcihzZWxlY3RvciwgaGFuZGxlcik7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhdHRhY2hlZEhhbmRsZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgYXR0YWNoZWRIYW5kbGVyKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3IoY29udGFpbmVyLCBzZWxlY3Rvciwgb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmUpIHtcbiAgICBsZXQgY3VycmVudE1hdGNoZWRDaGlsZDtcbiAgICByZXR1cm4gbGlzdGVuQnlTZWxlY3Rvcihjb250YWluZXIsICdtb3VzZW92ZXInLCBzZWxlY3RvciwgKG1vdXNlT3ZlckV2LCBtYXRjaGVkQ2hpbGQpID0+IHtcbiAgICAgICAgaWYgKG1hdGNoZWRDaGlsZCAhPT0gY3VycmVudE1hdGNoZWRDaGlsZCkge1xuICAgICAgICAgICAgY3VycmVudE1hdGNoZWRDaGlsZCA9IG1hdGNoZWRDaGlsZDtcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcihtb3VzZU92ZXJFdiwgbWF0Y2hlZENoaWxkKTtcbiAgICAgICAgICAgIGxldCByZWFsT25Nb3VzZUxlYXZlID0gKG1vdXNlTGVhdmVFdikgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRNYXRjaGVkQ2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZShtb3VzZUxlYXZlRXYsIG1hdGNoZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgbWF0Y2hlZENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCByZWFsT25Nb3VzZUxlYXZlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcbiAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIEFuaW1hdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSBbXG4gICAgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICdvdHJhbnNpdGlvbmVuZCcsXG4gICAgJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAnbXNUcmFuc2l0aW9uRW5kJyxcbiAgICAndHJhbnNpdGlvbmVuZCcsXG5dO1xuLy8gdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbmV4dCBzaW5nbGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZpbmlzaGVzXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkRvbmUoZWwsIGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlYWxDYWxsYmFjayA9IChldikgPT4ge1xuICAgICAgICBjYWxsYmFjayhldik7XG4gICAgICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spOyAvLyBjcm9zcy1icm93c2VyIHdheSB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlc1xuICAgIH0pO1xufVxuLy8gQVJJQSB3b3JrYXJvdW5kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgb25DbGljazogaGFuZGxlciB9LCBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycyhoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgIG9uS2V5RG93bihldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyB8fCBldi5rZXkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXYpO1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHNwYWNlLCBkb24ndCBzY3JvbGwgZG93biBwYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxubGV0IGd1aWROdW1iZXIgPSAwO1xuZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBndWlkTnVtYmVyICs9IDE7XG4gICAgcmV0dXJuIFN0cmluZyhndWlkTnVtYmVyKTtcbn1cbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcbmZ1bmN0aW9uIGVuYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vKiBTZWxlY3Rpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudFNlbGVjdGlvbihlbCkge1xuICAgIGVsLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgZWwuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9ICdub25lJztcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGFsbG93U2VsZWN0aW9uKGVsKSB7XG4gICAgZWwuc3R5bGUudXNlclNlbGVjdCA9ICcnO1xuICAgIGVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnJztcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cbi8qIENvbnRleHQgTWVudVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwcmV2ZW50Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGFsbG93Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xuICAgIGxldCBzcGVjcyA9IFtdO1xuICAgIGxldCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBsZXQgdG9rZW47XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9rZW5zID0gW2lucHV0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQ7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHRva2VuLmNoYXJBdCgwKSA9PT0gJy0nID9cbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwZWNzO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGNtcDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbXAgPSBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjc1tpXSk7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjKSB7XG4gICAgaWYgKGZpZWxkU3BlYy5mdW5jKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFNwZWMuZnVuYyhvYmowLCBvYmoxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsZXhpYmxlQ29tcGFyZShvYmowW2ZpZWxkU3BlYy5maWVsZF0sIG9iajFbZmllbGRTcGVjLmZpZWxkXSlcbiAgICAgICAgKiAoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xufVxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuLyogU3RyaW5nIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwYWRTdGFydCh2YWwsIGxlbikge1xuICAgIGxldCBzID0gU3RyaW5nKHZhbCk7XG4gICAgcmV0dXJuICcwMDAnLnN1YnN0cigwLCBsZW4gLSBzLmxlbmd0aCkgKyBzO1xufVxuZnVuY3Rpb24gZm9ybWF0V2l0aE9yZGluYWxzKGZvcm1hdHRlciwgYXJncywgZmFsbGJhY2tUZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlciguLi5hcmdzKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdzdHJpbmcnKSB7IC8vIG5vbi1ibGFuayBzdHJpbmdcbiAgICAgICAgcmV0dXJuIGFyZ3MucmVkdWNlKChzdHIsIGFyZywgaW5kZXgpID0+IChzdHIucmVwbGFjZSgnJCcgKyBpbmRleCwgYXJnIHx8ICcnKSksIGZvcm1hdHRlcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFja1RleHQ7XG59XG4vKiBOdW1iZXIgVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNvbXBhcmVOdW1iZXJzKGEsIGIpIHtcbiAgICByZXR1cm4gYSAtIGI7XG59XG5mdW5jdGlvbiBpc0ludChuKSB7XG4gICAgcmV0dXJuIG4gJSAxID09PSAwO1xufVxuLyogRkMtc3BlY2lmaWMgRE9NIGRpbWVuc2lvbiBzdHVmZlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGgoY2VsbEVsKSB7XG4gICAgbGV0IGFsbFdpZHRoRWwgPSBjZWxsRWwucXVlcnlTZWxlY3RvcignLmZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lJyk7XG4gICAgbGV0IGNvbnRlbnRXaWR0aEVsID0gY2VsbEVsLnF1ZXJ5U2VsZWN0b3IoJy5mYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJyk7XG4gICAgaWYgKCFhbGxXaWR0aEVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVlZHMgZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUgY2xhc3NOYW1lJyk7IC8vIFRPRE86IHVzZSBjb25zdFxuICAgIH1cbiAgICBpZiAoIWNvbnRlbnRXaWR0aEVsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmVlZHMgZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbiBjbGFzc05hbWUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIGFsbFdpZHRoRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyAvLyB0aGUgY2VsbCBwYWRkaW5nK2JvcmRlclxuICAgICAgICBjb250ZW50V2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbn1cblxuY29uc3QgSU5URVJOQUxfVU5JVFMgPSBbJ3llYXJzJywgJ21vbnRocycsICdkYXlzJywgJ21pbGxpc2Vjb25kcyddO1xuY29uc3QgUEFSU0VfUkUgPSAvXigtPykoPzooXFxkKylcXC4pPyhcXGQrKTooXFxkXFxkKSg/OjooXFxkXFxkKSg/OlxcLihcXGRcXGRcXGQpKT8pPy87XG4vLyBQYXJzaW5nIGFuZCBDcmVhdGlvblxuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHVuaXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnb2JqZWN0JyAmJiBpbnB1dCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0KHsgW3VuaXQgfHwgJ21pbGxpc2Vjb25kcyddOiBpbnB1dCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzKSB7XG4gICAgbGV0IG0gPSBQQVJTRV9SRS5leGVjKHMpO1xuICAgIGlmIChtKSB7XG4gICAgICAgIGxldCBzaWduID0gbVsxXSA/IC0xIDogMTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiAwLFxuICAgICAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICAgICAgZGF5czogc2lnbiAqIChtWzJdID8gcGFyc2VJbnQobVsyXSwgMTApIDogMCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IHNpZ24gKiAoKG1bM10gPyBwYXJzZUludChtWzNdLCAxMCkgOiAwKSAqIDYwICogNjAgKiAxMDAwICsgLy8gaG91cnNcbiAgICAgICAgICAgICAgICAobVs0XSA/IHBhcnNlSW50KG1bNF0sIDEwKSA6IDApICogNjAgKiAxMDAwICsgLy8gbWludXRlc1xuICAgICAgICAgICAgICAgIChtWzVdID8gcGFyc2VJbnQobVs1XSwgMTApIDogMCkgKiAxMDAwICsgLy8gc2Vjb25kc1xuICAgICAgICAgICAgICAgIChtWzZdID8gcGFyc2VJbnQobVs2XSwgMTApIDogMCkgLy8gbXNcbiAgICAgICAgICAgICksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3Qob2JqKSB7XG4gICAgbGV0IGR1cmF0aW9uID0ge1xuICAgICAgICB5ZWFyczogb2JqLnllYXJzIHx8IG9iai55ZWFyIHx8IDAsXG4gICAgICAgIG1vbnRoczogb2JqLm1vbnRocyB8fCBvYmoubW9udGggfHwgMCxcbiAgICAgICAgZGF5czogb2JqLmRheXMgfHwgb2JqLmRheSB8fCAwLFxuICAgICAgICBtaWxsaXNlY29uZHM6IChvYmouaG91cnMgfHwgb2JqLmhvdXIgfHwgMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAob2JqLm1pbnV0ZXMgfHwgb2JqLm1pbnV0ZSB8fCAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgIChvYmouc2Vjb25kcyB8fCBvYmouc2Vjb25kIHx8IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgIChvYmoubWlsbGlzZWNvbmRzIHx8IG9iai5taWxsaXNlY29uZCB8fCBvYmoubXMgfHwgMCksIC8vIG1zXG4gICAgfTtcbiAgICBsZXQgd2Vla3MgPSBvYmoud2Vla3MgfHwgb2JqLndlZWs7XG4gICAgaWYgKHdlZWtzKSB7XG4gICAgICAgIGR1cmF0aW9uLmRheXMgKz0gd2Vla3MgKiA3O1xuICAgICAgICBkdXJhdGlvbi5zcGVjaWZpZWRXZWVrcyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBkdXJhdGlvbjtcbn1cbi8vIEVxdWFsaXR5XG5mdW5jdGlvbiBkdXJhdGlvbnNFcXVhbChkMCwgZDEpIHtcbiAgICByZXR1cm4gZDAueWVhcnMgPT09IGQxLnllYXJzICYmXG4gICAgICAgIGQwLm1vbnRocyA9PT0gZDEubW9udGhzICYmXG4gICAgICAgIGQwLmRheXMgPT09IGQxLmRheXMgJiZcbiAgICAgICAgZDAubWlsbGlzZWNvbmRzID09PSBkMS5taWxsaXNlY29uZHM7XG59XG5mdW5jdGlvbiBhc0NsZWFuRGF5cyhkdXIpIHtcbiAgICBpZiAoIWR1ci55ZWFycyAmJiAhZHVyLm1vbnRocyAmJiAhZHVyLm1pbGxpc2Vjb25kcykge1xuICAgICAgICByZXR1cm4gZHVyLmRheXM7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuLy8gU2ltcGxlIE1hdGhcbmZ1bmN0aW9uIGFkZER1cmF0aW9ucyhkMCwgZDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZDAueWVhcnMgKyBkMS55ZWFycyxcbiAgICAgICAgbW9udGhzOiBkMC5tb250aHMgKyBkMS5tb250aHMsXG4gICAgICAgIGRheXM6IGQwLmRheXMgKyBkMS5kYXlzLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQwLm1pbGxpc2Vjb25kcyArIGQxLm1pbGxpc2Vjb25kcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gc3VidHJhY3REdXJhdGlvbnMoZDEsIGQwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQxLnllYXJzIC0gZDAueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDEubW9udGhzIC0gZDAubW9udGhzLFxuICAgICAgICBkYXlzOiBkMS5kYXlzIC0gZDAuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMS5taWxsaXNlY29uZHMgLSBkMC5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5RHVyYXRpb24oZCwgbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkLnllYXJzICogbixcbiAgICAgICAgbW9udGhzOiBkLm1vbnRocyAqIG4sXG4gICAgICAgIGRheXM6IGQuZGF5cyAqIG4sXG4gICAgICAgIG1pbGxpc2Vjb25kczogZC5taWxsaXNlY29uZHMgKiBuLFxuICAgIH07XG59XG4vLyBDb252ZXJzaW9uc1xuLy8gXCJSb3VnaFwiIGJlY2F1c2UgdGhleSBhcmUgYmFzZWQgb24gYXZlcmFnZS1jYXNlIEdyZWdvcmlhbiBtb250aHMveWVhcnNcbmZ1bmN0aW9uIGFzUm91Z2hZZWFycyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaERheXMoZHVyKSAvIDM2NTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNb250aHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hEYXlzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvIDg2NGU1O1xufVxuZnVuY3Rpb24gYXNSb3VnaE1pbnV0ZXMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBhc1JvdWdoU2Vjb25kcyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyAxMDAwO1xufVxuZnVuY3Rpb24gYXNSb3VnaE1zKGR1cikge1xuICAgIHJldHVybiBkdXIueWVhcnMgKiAoMzY1ICogODY0ZTUpICtcbiAgICAgICAgZHVyLm1vbnRocyAqICgzMCAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5kYXlzICogODY0ZTUgK1xuICAgICAgICBkdXIubWlsbGlzZWNvbmRzO1xufVxuLy8gQWR2YW5jZWQgTWF0aFxuZnVuY3Rpb24gd2hvbGVEaXZpZGVEdXJhdGlvbnMobnVtZXJhdG9yLCBkZW5vbWluYXRvcikge1xuICAgIGxldCByZXMgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgSU5URVJOQUxfVU5JVFMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHVuaXQgPSBJTlRFUk5BTF9VTklUU1tpXTtcbiAgICAgICAgaWYgKGRlbm9taW5hdG9yW3VuaXRdKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxSZXMgPSBudW1lcmF0b3JbdW5pdF0gLyBkZW5vbWluYXRvclt1bml0XTtcbiAgICAgICAgICAgIGlmICghaXNJbnQobG9jYWxSZXMpIHx8IChyZXMgIT09IG51bGwgJiYgcmVzICE9PSBsb2NhbFJlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcyA9IGxvY2FsUmVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG51bWVyYXRvclt1bml0XSkge1xuICAgICAgICAgICAgLy8gbmVlZHMgdG8gZGl2aWRlIGJ5IHNvbWV0aGluZyBidXQgY2FuJ3QhXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cikge1xuICAgIGxldCBtcyA9IGR1ci5taWxsaXNlY29uZHM7XG4gICAgaWYgKG1zKSB7XG4gICAgICAgIGlmIChtcyAlIDEwMDAgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiBtcyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcyAlICgxMDAwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnc2Vjb25kJywgdmFsdWU6IG1zIC8gMTAwMCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcyAlICgxMDAwICogNjAgKiA2MCkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdtaW51dGUnLCB2YWx1ZTogbXMgLyAoMTAwMCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtcykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2hvdXInLCB2YWx1ZTogbXMgLyAoMTAwMCAqIDYwICogNjApIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGR1ci5kYXlzKSB7XG4gICAgICAgIGlmIChkdXIuc3BlY2lmaWVkV2Vla3MgJiYgZHVyLmRheXMgJSA3ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnd2VlaycsIHZhbHVlOiBkdXIuZGF5cyAvIDcgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1bml0OiAnZGF5JywgdmFsdWU6IGR1ci5kYXlzIH07XG4gICAgfVxuICAgIGlmIChkdXIubW9udGhzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICdtb250aCcsIHZhbHVlOiBkdXIubW9udGhzIH07XG4gICAgfVxuICAgIGlmIChkdXIueWVhcnMpIHtcbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3llYXInLCB2YWx1ZTogZHVyLnllYXJzIH07XG4gICAgfVxuICAgIHJldHVybiB7IHVuaXQ6ICdtaWxsaXNlY29uZCcsIHZhbHVlOiAwIH07XG59XG5cbi8vIFRPRE86IG5ldyB1dGlsIGFycmF5aWZ5P1xuZnVuY3Rpb24gcmVtb3ZlRXhhY3QoYXJyYXksIGV4YWN0VmFsKSB7XG4gICAgbGV0IHJlbW92ZUNudCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJlbW92ZUNudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVDbnQ7XG59XG5mdW5jdGlvbiBpc0FycmF5c0VxdWFsKGEwLCBhMSwgZXF1YWxpdHlGdW5jKSB7XG4gICAgaWYgKGEwID09PSBhMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGxlbiA9IGEwLmxlbmd0aDtcbiAgICBsZXQgaTtcbiAgICBpZiAobGVuICE9PSBhMS5sZW5ndGgpIHsgLy8gbm90IGFycmF5PyBvciBub3Qgc2FtZSBsZW5ndGg/XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICghKGVxdWFsaXR5RnVuYyA/IGVxdWFsaXR5RnVuYyhhMFtpXSwgYTFbaV0pIDogYTBbaV0gPT09IGExW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5jb25zdCBEQVlfSURTID0gWydzdW4nLCAnbW9uJywgJ3R1ZScsICd3ZWQnLCAndGh1JywgJ2ZyaScsICdzYXQnXTtcbi8vIEFkZGluZ1xuZnVuY3Rpb24gYWRkV2Vla3MobSwgbikge1xuICAgIGxldCBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVsyXSArPSBuICogNztcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XG59XG5mdW5jdGlvbiBhZGREYXlzKG0sIG4pIHtcbiAgICBsZXQgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbjtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoYSk7XG59XG5mdW5jdGlvbiBhZGRNcyhtLCBuKSB7XG4gICAgbGV0IGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzZdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuLy8gRGlmZmluZyAoYWxsIHJldHVybiBmbG9hdHMpXG4vLyBUT0RPOiB3aHkgbm90IHVzZSByYW5nZXM/XG5mdW5jdGlvbiBkaWZmV2Vla3MobTAsIG0xKSB7XG4gICAgcmV0dXJuIGRpZmZEYXlzKG0wLCBtMSkgLyA3O1xufVxuZnVuY3Rpb24gZGlmZkRheXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCAqIDYwICogMjQpO1xufVxuZnVuY3Rpb24gZGlmZkhvdXJzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmTWludXRlcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwKTtcbn1cbmZ1bmN0aW9uIGRpZmZTZWNvbmRzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIDEwMDA7XG59XG5mdW5jdGlvbiBkaWZmRGF5QW5kVGltZShtMCwgbTEpIHtcbiAgICBsZXQgbTBkYXkgPSBzdGFydE9mRGF5KG0wKTtcbiAgICBsZXQgbTFkYXkgPSBzdGFydE9mRGF5KG0xKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgbW9udGhzOiAwLFxuICAgICAgICBkYXlzOiBNYXRoLnJvdW5kKGRpZmZEYXlzKG0wZGF5LCBtMWRheSkpLFxuICAgICAgICBtaWxsaXNlY29uZHM6IChtMS52YWx1ZU9mKCkgLSBtMWRheS52YWx1ZU9mKCkpIC0gKG0wLnZhbHVlT2YoKSAtIG0wZGF5LnZhbHVlT2YoKSksXG4gICAgfTtcbn1cbi8vIERpZmZpbmcgV2hvbGUgVW5pdHNcbmZ1bmN0aW9uIGRpZmZXaG9sZVdlZWtzKG0wLCBtMSkge1xuICAgIGxldCBkID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgIGlmIChkICE9PSBudWxsICYmIGQgJSA3ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkIC8gNztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBkaWZmV2hvbGVEYXlzKG0wLCBtMSkge1xuICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChkaWZmRGF5cyhtMCwgbTEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vLyBTdGFydC1PZlxuZnVuY3Rpb24gc3RhcnRPZkRheShtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZkhvdXIobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZk1pbnV0ZShtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgICAgICBtLmdldFVUQ0hvdXJzKCksXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxuICAgIF0pO1xufVxuZnVuY3Rpb24gc3RhcnRPZlNlY29uZChtKSB7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKFtcbiAgICAgICAgbS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICBtLmdldFVUQ01vbnRoKCksXG4gICAgICAgIG0uZ2V0VVRDRGF0ZSgpLFxuICAgICAgICBtLmdldFVUQ0hvdXJzKCksXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpLFxuICAgICAgICBtLmdldFVUQ1NlY29uZHMoKSxcbiAgICBdKTtcbn1cbi8vIFdlZWsgQ29tcHV0YXRpb25cbmZ1bmN0aW9uIHdlZWtPZlllYXIobWFya2VyLCBkb3csIGRveSkge1xuICAgIGxldCB5ID0gbWFya2VyLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgbGV0IHcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5LCBkb3csIGRveSk7XG4gICAgaWYgKHcgPCAxKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5IC0gMSwgZG93LCBkb3kpO1xuICAgIH1cbiAgICBsZXQgbmV4dFcgPSB3ZWVrT2ZHaXZlblllYXIobWFya2VyLCB5ICsgMSwgZG93LCBkb3kpO1xuICAgIGlmIChuZXh0VyA+PSAxKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbih3LCBuZXh0Vyk7XG4gICAgfVxuICAgIHJldHVybiB3O1xufVxuZnVuY3Rpb24gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeWVhciwgZG93LCBkb3kpIHtcbiAgICBsZXQgZmlyc3RXZWVrU3RhcnQgPSBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgMSArIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSldKTtcbiAgICBsZXQgZGF5U3RhcnQgPSBzdGFydE9mRGF5KG1hcmtlcik7XG4gICAgbGV0IGRheXMgPSBNYXRoLnJvdW5kKGRpZmZEYXlzKGZpcnN0V2Vla1N0YXJ0LCBkYXlTdGFydCkpO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGRheXMgLyA3KSArIDE7IC8vIHplcm8taW5kZXhlZFxufVxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgIGxldCBmd2QgPSA3ICsgZG93IC0gZG95O1xuICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICBsZXQgZndkbHcgPSAoNyArIGFycmF5VG9VdGNEYXRlKFt5ZWFyLCAwLCBmd2RdKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xufVxuLy8gQXJyYXkgQ29udmVyc2lvblxuZnVuY3Rpb24gZGF0ZVRvTG9jYWxBcnJheShkYXRlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgIGRhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICBkYXRlLmdldEhvdXJzKCksXG4gICAgICAgIGRhdGUuZ2V0TWludXRlcygpLFxuICAgICAgICBkYXRlLmdldFNlY29uZHMoKSxcbiAgICAgICAgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSxcbiAgICBdO1xufVxuZnVuY3Rpb24gYXJyYXlUb0xvY2FsRGF0ZShhKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKGFbMF0sIGFbMV0gfHwgMCwgYVsyXSA9PSBudWxsID8gMSA6IGFbMl0sIC8vIGRheSBvZiBtb250aFxuICAgIGFbM10gfHwgMCwgYVs0XSB8fCAwLCBhWzVdIHx8IDApO1xufVxuZnVuY3Rpb24gZGF0ZVRvVXRjQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNb250aCgpLFxuICAgICAgICBkYXRlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENIb3VycygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9VdGNEYXRlKGEpIHtcbiAgICAvLyBhY2NvcmRpbmcgdG8gd2ViIHN0YW5kYXJkcyAoYW5kIFNhZmFyaSksIGEgbW9udGggaW5kZXggaXMgcmVxdWlyZWQuXG4gICAgLy8gbWFzc2FnZSBpZiBvbmx5IGdpdmVuIGEgeWVhci5cbiAgICBpZiAoYS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYSA9IGEuY29uY2F0KFswXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyguLi5hKSk7XG59XG4vLyBPdGhlciBVdGlsc1xuZnVuY3Rpb24gaXNWYWxpZERhdGUobSkge1xuICAgIHJldHVybiAhaXNOYU4obS52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gdGltZUFzTXMobSkge1xuICAgIHJldHVybiBtLmdldFVUQ0hvdXJzKCkgKiAxMDAwICogNjAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDTWludXRlcygpICogMTAwMCAqIDYwICtcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCkgKiAxMDAwICtcbiAgICAgICAgbS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbn1cblxuLy8gdGltZVpvbmVPZmZzZXQgaXMgaW4gbWludXRlc1xuZnVuY3Rpb24gYnVpbGRJc29TdHJpbmcobWFya2VyLCB0aW1lWm9uZU9mZnNldCwgc3RyaXBaZXJvVGltZSA9IGZhbHNlKSB7XG4gICAgbGV0IHMgPSBtYXJrZXIudG9JU09TdHJpbmcoKTtcbiAgICBzID0gcy5yZXBsYWNlKCcuMDAwJywgJycpO1xuICAgIGlmIChzdHJpcFplcm9UaW1lKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJ1QwMDowMDowMFonLCAnJyk7XG4gICAgfVxuICAgIGlmIChzLmxlbmd0aCA+IDEwKSB7IC8vIHRpbWUgcGFydCB3YXNuJ3Qgc3RyaXBwZWQsIGNhbiBhZGQgdGltZXpvbmUgaW5mb1xuICAgICAgICBpZiAodGltZVpvbmVPZmZzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnWicsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aW1lWm9uZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnWicsIGZvcm1hdFRpbWVab25lT2Zmc2V0KHRpbWVab25lT2Zmc2V0LCB0cnVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBpdHMgVVRDLTAgYW5kIHdlIHdhbnQgdG8ga2VlcCB0aGUgWlxuICAgIH1cbiAgICByZXR1cm4gcztcbn1cbi8vIGZvcm1hdHMgdGhlIGRhdGUsIGJ1dCB3aXRoIG5vIHRpbWUgcGFydFxuLy8gVE9ETzogc29tZWhvdyBtZXJnZSB3aXRoIGJ1aWxkSXNvU3RyaW5nIGFuZCBzdHJpcFplcm9UaW1lXG4vLyBUT0RPOiByZW5hbWUuIG9taXQgXCJzdHJpbmdcIlxuZnVuY3Rpb24gZm9ybWF0RGF5U3RyaW5nKG1hcmtlcikge1xuICAgIHJldHVybiBtYXJrZXIudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9ULiokLywgJycpO1xufVxuZnVuY3Rpb24gZm9ybWF0SXNvTW9udGhTdHIobWFya2VyKSB7XG4gICAgcmV0dXJuIG1hcmtlci50b0lTT1N0cmluZygpLm1hdGNoKC9eXFxkezR9LVxcZHsyfS8pWzBdO1xufVxuLy8gVE9ETzogdXNlIERhdGU6OnRvSVNPU3RyaW5nIGFuZCB1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgVD9cbmZ1bmN0aW9uIGZvcm1hdElzb1RpbWVTdHJpbmcobWFya2VyKSB7XG4gICAgcmV0dXJuIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENIb3VycygpLCAyKSArICc6JyArXG4gICAgICAgIHBhZFN0YXJ0KG1hcmtlci5nZXRVVENNaW51dGVzKCksIDIpICsgJzonICtcbiAgICAgICAgcGFkU3RhcnQobWFya2VyLmdldFVUQ1NlY29uZHMoKSwgMik7XG59XG5mdW5jdGlvbiBmb3JtYXRUaW1lWm9uZU9mZnNldChtaW51dGVzLCBkb0lzbyA9IGZhbHNlKSB7XG4gICAgbGV0IHNpZ24gPSBtaW51dGVzIDwgMCA/ICctJyA6ICcrJztcbiAgICBsZXQgYWJzID0gTWF0aC5hYnMobWludXRlcyk7XG4gICAgbGV0IGhvdXJzID0gTWF0aC5mbG9vcihhYnMgLyA2MCk7XG4gICAgbGV0IG1pbnMgPSBNYXRoLnJvdW5kKGFicyAlIDYwKTtcbiAgICBpZiAoZG9Jc28pIHtcbiAgICAgICAgcmV0dXJuIGAke3NpZ24gKyBwYWRTdGFydChob3VycywgMil9OiR7cGFkU3RhcnQobWlucywgMil9YDtcbiAgICB9XG4gICAgcmV0dXJuIGBHTVQke3NpZ259JHtob3Vyc30ke21pbnMgPyBgOiR7cGFkU3RhcnQobWlucywgMil9YCA6ICcnfWA7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemUod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIGxldCBjdXJyZW50QXJncztcbiAgICBsZXQgY3VycmVudFJlcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLm5ld0FyZ3MpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJncykge1xuICAgICAgICAgICAgY3VycmVudFJlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ3MsIG5ld0FyZ3MpKSB7XG4gICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlcyA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJncyA9IG5ld0FyZ3M7XG4gICAgICAgIHJldHVybiBjdXJyZW50UmVzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplT2JqQXJnKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICBsZXQgY3VycmVudEFyZztcbiAgICBsZXQgY3VycmVudFJlcztcbiAgICByZXR1cm4gKG5ld0FyZykgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRBcmcpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZXMgPSB3b3JrZXJGdW5jLmNhbGwodGhpcywgbmV3QXJnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNQcm9wc0VxdWFsKGN1cnJlbnRBcmcsIG5ld0FyZykpIHtcbiAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzID0gd29ya2VyRnVuYy5jYWxsKHRoaXMsIG5ld0FyZyk7XG4gICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlcyA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJnID0gbmV3QXJnO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZUFycmF5bGlrZSgvLyB1c2VkIGF0IGFsbD9cbndvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICBsZXQgY3VycmVudEFyZ1NldHMgPSBbXTtcbiAgICBsZXQgY3VycmVudFJlc3VsdHMgPSBbXTtcbiAgICByZXR1cm4gKG5ld0FyZ1NldHMpID0+IHtcbiAgICAgICAgbGV0IGN1cnJlbnRMZW4gPSBjdXJyZW50QXJnU2V0cy5sZW5ndGg7XG4gICAgICAgIGxldCBuZXdMZW4gPSBuZXdBcmdTZXRzLmxlbmd0aDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGN1cnJlbnRMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFuZXdBcmdTZXRzW2ldKSB7IC8vIG9uZSBvZiB0aGUgb2xkIHNldHMgbm8gbG9uZ2VyIGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXN1bHRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJnU2V0c1tpXSwgbmV3QXJnU2V0c1tpXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGVhcmRvd25GdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzdWx0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc3VsdHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXN1bHRzW2ldID0gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IG5ld0xlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHdvcmtlckZ1bmMuYXBwbHkodGhpcywgbmV3QXJnU2V0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ1NldHMgPSBuZXdBcmdTZXRzO1xuICAgICAgICBjdXJyZW50UmVzdWx0cy5zcGxpY2UobmV3TGVuKTsgLy8gcmVtb3ZlIGV4Y2Vzc1xuICAgICAgICByZXR1cm4gY3VycmVudFJlc3VsdHM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVIYXNobGlrZSh3b3JrZXJGdW5jLCByZXNFcXVhbGl0eSwgdGVhcmRvd25GdW5jKSB7XG4gICAgbGV0IGN1cnJlbnRBcmdIYXNoID0ge307XG4gICAgbGV0IGN1cnJlbnRSZXNIYXNoID0ge307XG4gICAgcmV0dXJuIChuZXdBcmdIYXNoKSA9PiB7XG4gICAgICAgIGxldCBuZXdSZXNIYXNoID0ge307XG4gICAgICAgIGZvciAobGV0IGtleSBpbiBuZXdBcmdIYXNoKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRSZXNIYXNoW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ0hhc2hba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJnSGFzaFtrZXldLCBuZXdBcmdIYXNoW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc0hhc2hba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXMgPSB3b3JrZXJGdW5jLmFwcGx5KHRoaXMsIG5ld0FyZ0hhc2hba2V5XSk7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gKHJlc0VxdWFsaXR5ICYmIHJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc0hhc2hba2V5XSkpXG4gICAgICAgICAgICAgICAgICAgID8gY3VycmVudFJlc0hhc2hba2V5XVxuICAgICAgICAgICAgICAgICAgICA6IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1Jlc0hhc2hba2V5XSA9IGN1cnJlbnRSZXNIYXNoW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudEFyZ0hhc2ggPSBuZXdBcmdIYXNoO1xuICAgICAgICBjdXJyZW50UmVzSGFzaCA9IG5ld1Jlc0hhc2g7XG4gICAgICAgIHJldHVybiBuZXdSZXNIYXNoO1xuICAgIH07XG59XG5cbmNvbnN0IEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTID0ge1xuICAgIHdlZWs6IDMsXG4gICAgc2VwYXJhdG9yOiAwLFxuICAgIG9taXRaZXJvTWludXRlOiAwLFxuICAgIG1lcmlkaWVtOiAwLFxuICAgIG9taXRDb21tYXM6IDAsXG59O1xuY29uc3QgU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMgPSB7XG4gICAgdGltZVpvbmVOYW1lOiA3LFxuICAgIGVyYTogNixcbiAgICB5ZWFyOiA1LFxuICAgIG1vbnRoOiA0LFxuICAgIGRheTogMixcbiAgICB3ZWVrZGF5OiAyLFxuICAgIGhvdXI6IDEsXG4gICAgbWludXRlOiAxLFxuICAgIHNlY29uZDogMSxcbn07XG5jb25zdCBNRVJJRElFTV9SRSA9IC9cXHMqKFthcF0pXFwuP21cXC4/L2k7IC8vIGVhdHMgdXAgbGVhZGluZyBzcGFjZXMgdG9vXG5jb25zdCBDT01NQV9SRSA9IC8sL2c7IC8vIHdlIG5lZWQgcmUgZm9yIGdsb2JhbG5lc3NcbmNvbnN0IE1VTFRJX1NQQUNFX1JFID0gL1xccysvZztcbmNvbnN0IExUUl9SRSA9IC9cXHUyMDBlL2c7IC8vIGNvbnRyb2wgY2hhcmFjdGVyXG5jb25zdCBVVENfUkUgPSAvVVRDfEdNVC87XG5jbGFzcyBOYXRpdmVGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGZvcm1hdFNldHRpbmdzKSB7XG4gICAgICAgIGxldCBzdGFuZGFyZERhdGVQcm9wcyA9IHt9O1xuICAgICAgICBsZXQgZXh0ZW5kZWRTZXR0aW5ncyA9IHt9O1xuICAgICAgICBsZXQgc2V2ZXJpdHkgPSAwO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGZvcm1hdFNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAobmFtZSBpbiBFWFRFTkRFRF9TRVRUSU5HU19BTkRfU0VWRVJJVElFUykge1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkU2V0dGluZ3NbbmFtZV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTW25hbWVdLCBzZXZlcml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wc1tuYW1lXSA9IGZvcm1hdFNldHRpbmdzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB7IC8vIFRPRE86IHdoYXQgYWJvdXQgaG91cjEyPyBubyBzZXZlcml0eVxuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVdLCBzZXZlcml0eSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhbmRhcmREYXRlUHJvcHMgPSBzdGFuZGFyZERhdGVQcm9wcztcbiAgICAgICAgdGhpcy5leHRlbmRlZFNldHRpbmdzID0gZXh0ZW5kZWRTZXR0aW5ncztcbiAgICAgICAgdGhpcy5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB0aGlzLmJ1aWxkRm9ybWF0dGluZ0Z1bmMgPSBtZW1vaXplKGJ1aWxkRm9ybWF0dGluZ0Z1bmMpO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jKHRoaXMuc3RhbmRhcmREYXRlUHJvcHMsIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkoZGF0ZSk7XG4gICAgfVxuICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgbGV0IHsgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MgfSA9IHRoaXM7XG4gICAgICAgIGxldCBkaWZmU2V2ZXJpdHkgPSBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KHN0YXJ0Lm1hcmtlciwgZW5kLm1hcmtlciwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XG4gICAgICAgIGlmICghZGlmZlNldmVyaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSBkaWZmU2V2ZXJpdHk7XG4gICAgICAgIGlmIChiaWdnZXN0VW5pdEZvclBhcnRpYWwgPiAxICYmIC8vIHRoZSB0d28gZGF0ZXMgYXJlIGRpZmZlcmVudCBpbiBhIHdheSB0aGF0J3MgbGFyZ2VyIHNjYWxlIHRoYW4gdGltZVxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnMi1kaWdpdCcpICYmXG4gICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJzItZGlnaXQnKSkge1xuICAgICAgICAgICAgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gMTsgLy8gbWFrZSBpdCBsb29rIGxpa2UgdGhlIGRhdGVzIGFyZSBvbmx5IGRpZmZlcmVudCBpbiB0ZXJtcyBvZiB0aW1lXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bGwwID0gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xuICAgICAgICBsZXQgZnVsbDEgPSB0aGlzLmZvcm1hdChlbmQsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZnVsbDAgPT09IGZ1bGwxKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVsbDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcnRpYWxEYXRlUHJvcHMgPSBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKHN0YW5kYXJkRGF0ZVByb3BzLCBiaWdnZXN0VW5pdEZvclBhcnRpYWwpO1xuICAgICAgICBsZXQgcGFydGlhbEZvcm1hdHRpbmdGdW5jID0gYnVpbGRGb3JtYXR0aW5nRnVuYyhwYXJ0aWFsRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KTtcbiAgICAgICAgbGV0IHBhcnRpYWwwID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKHN0YXJ0KTtcbiAgICAgICAgbGV0IHBhcnRpYWwxID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKGVuZCk7XG4gICAgICAgIGxldCBpbnNlcnRpb24gPSBmaW5kQ29tbW9uSW5zZXJ0aW9uKGZ1bGwwLCBwYXJ0aWFsMCwgZnVsbDEsIHBhcnRpYWwxKTtcbiAgICAgICAgbGV0IHNlcGFyYXRvciA9IGV4dGVuZGVkU2V0dGluZ3Muc2VwYXJhdG9yIHx8IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yIHx8ICcnO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0aW9uLmJlZm9yZSArIHBhcnRpYWwwICsgc2VwYXJhdG9yICsgcGFydGlhbDEgKyBpbnNlcnRpb24uYWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bGwwICsgc2VwYXJhdG9yICsgZnVsbDE7XG4gICAgfVxuICAgIGdldExhcmdlc3RVbml0KCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2V2ZXJpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3llYXInO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnbW9udGgnO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiAnd2Vlayc7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkYXknO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RpbWUnOyAvLyByZWFsbHk/XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZEZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgbGV0IHN0YW5kYXJkRGF0ZVByb3BDbnQgPSBPYmplY3Qua2V5cyhzdGFuZGFyZERhdGVQcm9wcykubGVuZ3RoO1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAxICYmIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICByZXR1cm4gKGRhdGUpID0+IChmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KSk7XG4gICAgfVxuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wQ250ID09PSAwICYmIGV4dGVuZGVkU2V0dGluZ3Mud2Vlaykge1xuICAgICAgICByZXR1cm4gKGRhdGUpID0+IChmb3JtYXRXZWVrTnVtYmVyKGNvbnRleHQuY29tcHV0ZVdlZWtOdW1iZXIoZGF0ZS5tYXJrZXIpLCBjb250ZXh0LndlZWtUZXh0LCBjb250ZXh0LndlZWtUZXh0TG9uZywgY29udGV4dC5sb2NhbGUsIGV4dGVuZGVkU2V0dGluZ3Mud2VlaykpO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG59XG5mdW5jdGlvbiBidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgc3RhbmRhcmREYXRlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFuZGFyZERhdGVQcm9wcyk7IC8vIGNvcHlcbiAgICBleHRlbmRlZFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgZXh0ZW5kZWRTZXR0aW5ncyk7IC8vIGNvcHlcbiAgICBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKTtcbiAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZSA9ICdVVEMnOyAvLyB3ZSBsZXZlcmFnZSB0aGUgb25seSBndWFyYW50ZWVkIHRpbWVab25lIGZvciBvdXIgVVRDIG1hcmtlcnNcbiAgICBsZXQgbm9ybWFsRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHN0YW5kYXJkRGF0ZVByb3BzKTtcbiAgICBsZXQgemVyb0Zvcm1hdDsgLy8gbmVlZGVkP1xuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIGxldCB6ZXJvUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFuZGFyZERhdGVQcm9wcyk7XG4gICAgICAgIGRlbGV0ZSB6ZXJvUHJvcHMubWludXRlOyAvLyBzZWNvbmRzIGFuZCBtcyB3ZXJlIGFscmVhZHkgY29uc2lkZXJlZCBpbiBzYW5pdGl6ZVNldHRpbmdzXG4gICAgICAgIHplcm9Gb3JtYXQgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChjb250ZXh0LmxvY2FsZS5jb2RlcywgemVyb1Byb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIChkYXRlKSA9PiB7XG4gICAgICAgIGxldCB7IG1hcmtlciB9ID0gZGF0ZTtcbiAgICAgICAgbGV0IGZvcm1hdDtcbiAgICAgICAgaWYgKHplcm9Gb3JtYXQgJiYgIW1hcmtlci5nZXRVVENNaW51dGVzKCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IHplcm9Gb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBub3JtYWxGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHMgPSBmb3JtYXQuZm9ybWF0KG1hcmtlcik7XG4gICAgICAgIHJldHVybiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplU2V0dGluZ3Moc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MpIHtcbiAgICAvLyBkZWFsIHdpdGggYSBicm93c2VyIGluY29uc2lzdGVuY3kgd2hlcmUgZm9ybWF0dGluZyB0aGUgdGltZXpvbmVcbiAgICAvLyByZXF1aXJlcyB0aGF0IHRoZSBob3VyL21pbnV0ZSBiZSBwcmVzZW50LlxuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUpIHtcbiAgICAgICAgaWYgKCFzdGFuZGFyZERhdGVQcm9wcy5ob3VyKSB7XG4gICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5ob3VyID0gJzItZGlnaXQnO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMubWludXRlKSB7XG4gICAgICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy5taW51dGUgPSAnMi1kaWdpdCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gb25seSBzdXBwb3J0IHNob3J0IHRpbWV6b25lIG5hbWVzXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ2xvbmcnKSB7XG4gICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9ICdzaG9ydCc7XG4gICAgfVxuICAgIC8vIGlmIHJlcXVlc3RpbmcgdG8gZGlzcGxheSBzZWNvbmRzLCBNVVNUIGRpc3BsYXkgbWludXRlc1xuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlICYmIChzdGFuZGFyZERhdGVQcm9wcy5zZWNvbmQgfHwgc3RhbmRhcmREYXRlUHJvcHMubWlsbGlzZWNvbmQpKSB7XG4gICAgICAgIGRlbGV0ZSBleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc3RQcm9jZXNzKHMsIGRhdGUsIHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KSB7XG4gICAgcyA9IHMucmVwbGFjZShMVFJfUkUsICcnKTsgLy8gcmVtb3ZlIGxlZnQtdG8tcmlnaHQgY29udHJvbCBjaGFycy4gZG8gZmlyc3QuIGdvb2QgZm9yIG90aGVyIHJlZ2V4ZXNcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lID09PSAnc2hvcnQnKSB7XG4gICAgICAgIHMgPSBpbmplY3RUem9TdHIocywgKGNvbnRleHQudGltZVpvbmUgPT09ICdVVEMnIHx8IGRhdGUudGltZVpvbmVPZmZzZXQgPT0gbnVsbCkgP1xuICAgICAgICAgICAgJ1VUQycgOiAvLyBpbXBvcnRhbnQgdG8gbm9ybWFsaXplIGZvciBJRSwgd2hpY2ggZG9lcyBcIkdNVFwiXG4gICAgICAgICAgICBmb3JtYXRUaW1lWm9uZU9mZnNldChkYXRlLnRpbWVab25lT2Zmc2V0KSk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRDb21tYXMpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShDT01NQV9SRSwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgaWYgKGV4dGVuZGVkU2V0dGluZ3Mub21pdFplcm9NaW51dGUpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnOjAwJywgJycpOyAvLyB6ZXJvRm9ybWF0IGRvZXNuJ3QgYWx3YXlzIGFjaGlldmUgdGhpc1xuICAgIH1cbiAgICAvLyBeIGRvIGFueXRoaW5nIHRoYXQgbWlnaHQgY3JlYXRlIGFkamFjZW50IHNwYWNlcyBiZWZvcmUgdGhpcyBwb2ludCxcbiAgICAvLyBiZWNhdXNlIE1FUklESUVNX1JFIGxpa2VzIHRvIGVhdCB1cCBsb2FkaW5nIHNwYWNlc1xuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSBmYWxzZSkge1xuICAgICAgICBzID0gcy5yZXBsYWNlKE1FUklESUVNX1JFLCAnJykudHJpbSgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnbmFycm93JykgeyAvLyBhL3BcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wLCBtMSkgPT4gbTEudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdzaG9ydCcpIHsgLy8gYW0vcG1cbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wLCBtMSkgPT4gYCR7bTEudG9Mb2NhbGVMb3dlckNhc2UoKX1tYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdsb3dlcmNhc2UnKSB7IC8vIG90aGVyIG1lcmlkaWVtIHRyYW5zZm9ybWVycyBhbHJlYWR5IGNvbnZlcnRlZCB0byBsb3dlcmNhc2VcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgKG0wKSA9PiBtMC50b0xvY2FsZUxvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgcyA9IHMucmVwbGFjZShNVUxUSV9TUEFDRV9SRSwgJyAnKTtcbiAgICBzID0gcy50cmltKCk7XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBpbmplY3RUem9TdHIocywgdHpvU3RyKSB7XG4gICAgbGV0IHJlcGxhY2VkID0gZmFsc2U7XG4gICAgcyA9IHMucmVwbGFjZShVVENfUkUsICgpID0+IHtcbiAgICAgICAgcmVwbGFjZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHpvU3RyO1xuICAgIH0pO1xuICAgIC8vIElFMTEgZG9lc24ndCBpbmNsdWRlIFVUQy9HTVQgaW4gdGhlIG9yaWdpbmFsIHN0cmluZywgc28gYXBwZW5kIHRvIGVuZFxuICAgIGlmICghcmVwbGFjZWQpIHtcbiAgICAgICAgcyArPSBgICR7dHpvU3RyfWA7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlcihudW0sIHdlZWtUZXh0LCB3ZWVrVGV4dExvbmcsIGxvY2FsZSwgZGlzcGxheSkge1xuICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgIGlmIChkaXNwbGF5ID09PSAnbG9uZycpIHtcbiAgICAgICAgcGFydHMucHVzaCh3ZWVrVGV4dExvbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkaXNwbGF5ID09PSAnc2hvcnQnIHx8IGRpc3BsYXkgPT09ICduYXJyb3cnKSB7XG4gICAgICAgIHBhcnRzLnB1c2god2Vla1RleHQpO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheSA9PT0gJ2xvbmcnIHx8IGRpc3BsYXkgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcGFydHMucHVzaCgnICcpO1xuICAgIH1cbiAgICBwYXJ0cy5wdXNoKGxvY2FsZS5zaW1wbGVOdW1iZXJGb3JtYXQuZm9ybWF0KG51bSkpO1xuICAgIGlmIChsb2NhbGUub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnKSB7IC8vIFRPRE86IHVzZSBjb250cm9sIGNoYXJhY3RlcnMgaW5zdGVhZD9cbiAgICAgICAgcGFydHMucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMuam9pbignJyk7XG59XG4vLyBSYW5nZSBGb3JtYXR0aW5nIFV0aWxzXG4vLyAwID0gZXhhY3RseSB0aGUgc2FtZVxuLy8gMSA9IGRpZmZlcmVudCBieSB0aW1lXG4vLyBhbmQgYmlnZ2VyXG5mdW5jdGlvbiBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KGQwLCBkMSwgY2EpIHtcbiAgICBpZiAoY2EuZ2V0TWFya2VyWWVhcihkMCkgIT09IGNhLmdldE1hcmtlclllYXIoZDEpKSB7XG4gICAgICAgIHJldHVybiA1O1xuICAgIH1cbiAgICBpZiAoY2EuZ2V0TWFya2VyTW9udGgoZDApICE9PSBjYS5nZXRNYXJrZXJNb250aChkMSkpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxuICAgIGlmIChjYS5nZXRNYXJrZXJEYXkoZDApICE9PSBjYS5nZXRNYXJrZXJEYXkoZDEpKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBpZiAodGltZUFzTXMoZDApICE9PSB0aW1lQXNNcyhkMSkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyhvcHRpb25zLCBiaWdnZXN0VW5pdCkge1xuICAgIGxldCBwYXJ0aWFsT3B0aW9ucyA9IHt9O1xuICAgIGZvciAobGV0IG5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAoIShuYW1lIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB8fCAvLyBub3QgYSBkYXRlIHBhcnQgcHJvcCAobGlrZSB0aW1lWm9uZSlcbiAgICAgICAgICAgIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVdIDw9IGJpZ2dlc3RVbml0KSB7XG4gICAgICAgICAgICBwYXJ0aWFsT3B0aW9uc1tuYW1lXSA9IG9wdGlvbnNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpYWxPcHRpb25zO1xufVxuZnVuY3Rpb24gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSkge1xuICAgIGxldCBpMCA9IDA7XG4gICAgd2hpbGUgKGkwIDwgZnVsbDAubGVuZ3RoKSB7XG4gICAgICAgIGxldCBmb3VuZDAgPSBmdWxsMC5pbmRleE9mKHBhcnRpYWwwLCBpMCk7XG4gICAgICAgIGlmIChmb3VuZDAgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgYmVmb3JlMCA9IGZ1bGwwLnN1YnN0cigwLCBmb3VuZDApO1xuICAgICAgICBpMCA9IGZvdW5kMCArIHBhcnRpYWwwLmxlbmd0aDtcbiAgICAgICAgbGV0IGFmdGVyMCA9IGZ1bGwwLnN1YnN0cihpMCk7XG4gICAgICAgIGxldCBpMSA9IDA7XG4gICAgICAgIHdoaWxlIChpMSA8IGZ1bGwxLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGZvdW5kMSA9IGZ1bGwxLmluZGV4T2YocGFydGlhbDEsIGkxKTtcbiAgICAgICAgICAgIGlmIChmb3VuZDEgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYmVmb3JlMSA9IGZ1bGwxLnN1YnN0cigwLCBmb3VuZDEpO1xuICAgICAgICAgICAgaTEgPSBmb3VuZDEgKyBwYXJ0aWFsMS5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIxID0gZnVsbDEuc3Vic3RyKGkxKTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUwID09PSBiZWZvcmUxICYmIGFmdGVyMCA9PT0gYWZ0ZXIxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiBiZWZvcmUwLFxuICAgICAgICAgICAgICAgICAgICBhZnRlcjogYWZ0ZXIwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFpvbmVkTWFya2VyKGRhdGVJbmZvLCBjYWxlbmRhclN5c3RlbSkge1xuICAgIGxldCBhID0gY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShkYXRlSW5mby5tYXJrZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1hcmtlcjogZGF0ZUluZm8ubWFya2VyLFxuICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZUluZm8udGltZVpvbmVPZmZzZXQsXG4gICAgICAgIGFycmF5OiBhLFxuICAgICAgICB5ZWFyOiBhWzBdLFxuICAgICAgICBtb250aDogYVsxXSxcbiAgICAgICAgZGF5OiBhWzJdLFxuICAgICAgICBob3VyOiBhWzNdLFxuICAgICAgICBtaW51dGU6IGFbNF0sXG4gICAgICAgIHNlY29uZDogYVs1XSxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IGFbNl0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgIGxldCBzdGFydEluZm8gPSBleHBhbmRab25lZE1hcmtlcihzdGFydCwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XG4gICAgbGV0IGVuZEluZm8gPSBlbmQgPyBleHBhbmRab25lZE1hcmtlcihlbmQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlOiBzdGFydEluZm8sXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8sXG4gICAgICAgIGVuZDogZW5kSW5mbyxcbiAgICAgICAgdGltZVpvbmU6IGNvbnRleHQudGltZVpvbmUsXG4gICAgICAgIGxvY2FsZUNvZGVzOiBjb250ZXh0LmxvY2FsZS5jb2RlcyxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogYmV0dGVyRGVmYXVsdFNlcGFyYXRvciB8fCBjb250ZXh0LmRlZmF1bHRTZXBhcmF0b3IsXG4gICAgfTtcbn1cblxuLypcblRPRE86IGZpeCB0aGUgdGVybWlub2xvZ3kgb2YgXCJmb3JtYXR0ZXJcIiB2cyBcImZvcm1hdHRpbmcgZnVuY1wiXG4qL1xuLypcbkF0IHRoZSB0aW1lIG9mIGluc3RhbnRpYXRpb24sIHRoaXMgb2JqZWN0IGRvZXMgbm90IGtub3cgd2hpY2ggY21kLWZvcm1hdHRpbmcgc3lzdGVtIGl0IHdpbGwgdXNlLlxuSXQgcmVjZWl2ZXMgdGhpcyBhdCB0aGUgdGltZSBvZiBmb3JtYXR0aW5nLCBhcyBhIHNldHRpbmcuXG4qL1xuY2xhc3MgQ21kRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjbWRTdHIpIHtcbiAgICAgICAgdGhpcy5jbWRTdHIgPSBjbWRTdHI7XG4gICAgfVxuICAgIGZvcm1hdChkYXRlLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xuICAgIH1cbn1cblxuY2xhc3MgRnVuY0Zvcm1hdHRlciB7XG4gICAgY29uc3RydWN0b3IoZnVuYykge1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jKGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG4gICAgZm9ybWF0UmFuZ2Uoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jKGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlcihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ21kRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmNGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLy8gYmFzZSBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS1cbmNvbnN0IEJBU0VfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIG5hdkxpbmtEYXlDbGljazogaWRlbnRpdHksXG4gICAgbmF2TGlua1dlZWtDbGljazogaWRlbnRpdHksXG4gICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGJvb3RzdHJhcEZvbnRBd2Vzb21lOiBpZGVudGl0eSxcbiAgICBidXR0b25JY29uczogaWRlbnRpdHksXG4gICAgY3VzdG9tQnV0dG9uczogaWRlbnRpdHksXG4gICAgZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNjcm9sbFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNjcm9sbFRpbWVSZXNldDogQm9vbGVhbixcbiAgICBzbG90TWluVGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgc2xvdE1heFRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGRheVBvcG92ZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBzbG90RHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNuYXBEdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgaGVhZGVyVG9vbGJhcjogaWRlbnRpdHksXG4gICAgZm9vdGVyVG9vbGJhcjogaWRlbnRpdHksXG4gICAgZGVmYXVsdFJhbmdlU2VwYXJhdG9yOiBTdHJpbmcsXG4gICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIGZvcmNlRXZlbnREdXJhdGlvbjogQm9vbGVhbixcbiAgICBkYXlIZWFkZXJzOiBCb29sZWFuLFxuICAgIGRheUhlYWRlckZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICAgIGRheUhlYWRlckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGRheUhlYWRlckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGRheUhlYWRlckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbENsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGRheUNlbGxDb250ZW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgaW5pdGlhbFZpZXc6IFN0cmluZyxcbiAgICBhc3BlY3RSYXRpbzogTnVtYmVyLFxuICAgIHdlZWtlbmRzOiBCb29sZWFuLFxuICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogaWRlbnRpdHksXG4gICAgd2Vla051bWJlcnM6IEJvb2xlYW4sXG4gICAgd2Vla051bWJlckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJDb250ZW50OiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgZWRpdGFibGU6IEJvb2xlYW4sXG4gICAgdmlld0NsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIHZpZXdEaWRNb3VudDogaWRlbnRpdHksXG4gICAgdmlld1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3I6IEJvb2xlYW4sXG4gICAgbm93SW5kaWNhdG9yQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yQ29udGVudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvcldpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzaG93Tm9uQ3VycmVudERhdGVzOiBCb29sZWFuLFxuICAgIGxhenlGZXRjaGluZzogQm9vbGVhbixcbiAgICBzdGFydFBhcmFtOiBTdHJpbmcsXG4gICAgZW5kUGFyYW06IFN0cmluZyxcbiAgICB0aW1lWm9uZVBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmU6IFN0cmluZyxcbiAgICBsb2NhbGVzOiBpZGVudGl0eSxcbiAgICBsb2NhbGU6IGlkZW50aXR5LFxuICAgIHRoZW1lU3lzdGVtOiBTdHJpbmcsXG4gICAgZHJhZ1JldmVydER1cmF0aW9uOiBOdW1iZXIsXG4gICAgZHJhZ1Njcm9sbDogQm9vbGVhbixcbiAgICBhbGxEYXlNYWludGFpbkR1cmF0aW9uOiBCb29sZWFuLFxuICAgIHVuc2VsZWN0QXV0bzogQm9vbGVhbixcbiAgICBkcm9wQWNjZXB0OiBpZGVudGl0eSxcbiAgICBldmVudE9yZGVyOiBwYXJzZUZpZWxkU3BlY3MsXG4gICAgZXZlbnRPcmRlclN0cmljdDogQm9vbGVhbixcbiAgICBoYW5kbGVXaW5kb3dSZXNpemU6IEJvb2xlYW4sXG4gICAgd2luZG93UmVzaXplRGVsYXk6IE51bWJlcixcbiAgICBsb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIGV2ZW50RHJhZ01pbkRpc3RhbmNlOiBOdW1iZXIsXG4gICAgZXhwYW5kUm93czogQm9vbGVhbixcbiAgICBoZWlnaHQ6IGlkZW50aXR5LFxuICAgIGNvbnRlbnRIZWlnaHQ6IGlkZW50aXR5LFxuICAgIGRpcmVjdGlvbjogU3RyaW5nLFxuICAgIHdlZWtOdW1iZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBldmVudFJlc2l6YWJsZUZyb21TdGFydDogQm9vbGVhbixcbiAgICBkaXNwbGF5RXZlbnRUaW1lOiBCb29sZWFuLFxuICAgIGRpc3BsYXlFdmVudEVuZDogQm9vbGVhbixcbiAgICB3ZWVrVGV4dDogU3RyaW5nLFxuICAgIHdlZWtUZXh0TG9uZzogU3RyaW5nLFxuICAgIHByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmc6IEJvb2xlYW4sXG4gICAgYnVzaW5lc3NIb3VyczogaWRlbnRpdHksXG4gICAgaW5pdGlhbERhdGU6IGlkZW50aXR5LFxuICAgIG5vdzogaWRlbnRpdHksXG4gICAgZXZlbnREYXRhVHJhbnNmb3JtOiBpZGVudGl0eSxcbiAgICBzdGlja3lIZWFkZXJEYXRlczogaWRlbnRpdHksXG4gICAgc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyOiBpZGVudGl0eSxcbiAgICB2aWV3SGVpZ2h0OiBpZGVudGl0eSxcbiAgICBkZWZhdWx0QWxsRGF5OiBCb29sZWFuLFxuICAgIGV2ZW50U291cmNlRmFpbHVyZTogaWRlbnRpdHksXG4gICAgZXZlbnRTb3VyY2VTdWNjZXNzOiBpZGVudGl0eSxcbiAgICBldmVudERpc3BsYXk6IFN0cmluZyxcbiAgICBldmVudFN0YXJ0RWRpdGFibGU6IEJvb2xlYW4sXG4gICAgZXZlbnREdXJhdGlvbkVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGV2ZW50T3ZlcmxhcDogaWRlbnRpdHksXG4gICAgZXZlbnRDb25zdHJhaW50OiBpZGVudGl0eSxcbiAgICBldmVudEFsbG93OiBpZGVudGl0eSxcbiAgICBldmVudEJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgIGV2ZW50Qm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgICBldmVudFRleHRDb2xvcjogU3RyaW5nLFxuICAgIGV2ZW50Q29sb3I6IFN0cmluZyxcbiAgICBldmVudENsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIGV2ZW50Q29udGVudDogaWRlbnRpdHksXG4gICAgZXZlbnREaWRNb3VudDogaWRlbnRpdHksXG4gICAgZXZlbnRXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2VsZWN0Q29uc3RyYWludDogaWRlbnRpdHksXG4gICAgc2VsZWN0T3ZlcmxhcDogaWRlbnRpdHksXG4gICAgc2VsZWN0QWxsb3c6IGlkZW50aXR5LFxuICAgIGRyb3BwYWJsZTogQm9vbGVhbixcbiAgICB1bnNlbGVjdENhbmNlbDogU3RyaW5nLFxuICAgIHNsb3RMYWJlbEZvcm1hdDogaWRlbnRpdHksXG4gICAgc2xvdExhbmVDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBzbG90TGFuZUNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYWJlbENsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIHNsb3RMYWJlbENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYWJlbERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgZGF5TWF4RXZlbnRzOiBpZGVudGl0eSxcbiAgICBkYXlNYXhFdmVudFJvd3M6IGlkZW50aXR5LFxuICAgIGRheU1pbldpZHRoOiBOdW1iZXIsXG4gICAgc2xvdExhYmVsSW50ZXJ2YWw6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGFsbERheVRleHQ6IFN0cmluZyxcbiAgICBhbGxEYXlDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBhbGxEYXlDb250ZW50OiBpZGVudGl0eSxcbiAgICBhbGxEYXlEaWRNb3VudDogaWRlbnRpdHksXG4gICAgYWxsRGF5V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNsb3RNaW5XaWR0aDogTnVtYmVyLFxuICAgIG5hdkxpbmtzOiBCb29sZWFuLFxuICAgIGV2ZW50VGltZUZvcm1hdDogY3JlYXRlRm9ybWF0dGVyLFxuICAgIHJlcmVuZGVyRGVsYXk6IE51bWJlcixcbiAgICBtb3JlTGlua1RleHQ6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rSGludDogaWRlbnRpdHksXG4gICAgc2VsZWN0TWluRGlzdGFuY2U6IE51bWJlcixcbiAgICBzZWxlY3RhYmxlOiBCb29sZWFuLFxuICAgIHNlbGVjdExvbmdQcmVzc0RlbGF5OiBOdW1iZXIsXG4gICAgZXZlbnRMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIHNlbGVjdE1pcnJvcjogQm9vbGVhbixcbiAgICBldmVudE1heFN0YWNrOiBOdW1iZXIsXG4gICAgZXZlbnRNaW5IZWlnaHQ6IE51bWJlcixcbiAgICBldmVudE1pbldpZHRoOiBOdW1iZXIsXG4gICAgZXZlbnRTaG9ydEhlaWdodDogTnVtYmVyLFxuICAgIHNsb3RFdmVudE92ZXJsYXA6IEJvb2xlYW4sXG4gICAgcGx1Z2luczogaWRlbnRpdHksXG4gICAgZmlyc3REYXk6IE51bWJlcixcbiAgICBkYXlDb3VudDogTnVtYmVyLFxuICAgIGRhdGVBbGlnbm1lbnQ6IFN0cmluZyxcbiAgICBkYXRlSW5jcmVtZW50OiBjcmVhdGVEdXJhdGlvbixcbiAgICBoaWRkZW5EYXlzOiBpZGVudGl0eSxcbiAgICBmaXhlZFdlZWtDb3VudDogQm9vbGVhbixcbiAgICB2YWxpZFJhbmdlOiBpZGVudGl0eSxcbiAgICB2aXNpYmxlUmFuZ2U6IGlkZW50aXR5LFxuICAgIHRpdGxlRm9ybWF0OiBpZGVudGl0eSxcbiAgICBldmVudEludGVyYWN0aXZlOiBCb29sZWFuLFxuICAgIC8vIG9ubHkgdXNlZCBieSBsaXN0LXZpZXcsIGJ1dCBsYW5ndWFnZXMgZGVmaW5lIHRoZSB2YWx1ZSwgc28gd2UgbmVlZCBpdCBpbiBiYXNlIG9wdGlvbnNcbiAgICBub0V2ZW50c1RleHQ6IFN0cmluZyxcbiAgICB2aWV3SGludDogaWRlbnRpdHksXG4gICAgbmF2TGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIGNsb3NlSGludDogU3RyaW5nLFxuICAgIHRpbWVIaW50OiBTdHJpbmcsXG4gICAgZXZlbnRIaW50OiBTdHJpbmcsXG4gICAgbW9yZUxpbmtDbGljazogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0NvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rRGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIG1vbnRoU3RhcnRGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICAvLyBmb3IgY29ubmVjdG9yc1xuICAgIC8vIChjYW4ndCBiZSBwYXJ0IG9mIHBsdWdpbiBzeXN0ZW0gYi9jIG11c3QgYmUgcHJvdmlkZWQgYXQgcnVudGltZSlcbiAgICBoYW5kbGVDdXN0b21SZW5kZXJpbmc6IGlkZW50aXR5LFxuICAgIGN1c3RvbVJlbmRlcmluZ01ldGFNYXA6IGlkZW50aXR5LFxuICAgIGN1c3RvbVJlbmRlcmluZ1JlcGxhY2VzOiBCb29sZWFuLFxufTtcbi8vIGRvIE5PVCBnaXZlIGEgdHlwZSBoZXJlLiBuZWVkIGB0eXBlb2YgQkFTRV9PUFRJT05fREVGQVVMVFNgIHRvIGdpdmUgcmVhbCByZXN1bHRzLlxuLy8gcmF3IHZhbHVlcy5cbmNvbnN0IEJBU0VfT1BUSU9OX0RFRkFVTFRTID0ge1xuICAgIGV2ZW50RGlzcGxheTogJ2F1dG8nLFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogJyAtICcsXG4gICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogJyBcXHUyMDEzICcsXG4gICAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogJzAxOjAwOjAwJyxcbiAgICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXk6IDEgfSxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6ICcwMDowMDowMCcsXG4gICAgZGF5SGVhZGVyczogdHJ1ZSxcbiAgICBpbml0aWFsVmlldzogJycsXG4gICAgYXNwZWN0UmF0aW86IDEuMzUsXG4gICAgaGVhZGVyVG9vbGJhcjoge1xuICAgICAgICBzdGFydDogJ3RpdGxlJyxcbiAgICAgICAgY2VudGVyOiAnJyxcbiAgICAgICAgZW5kOiAndG9kYXkgcHJldixuZXh0JyxcbiAgICB9LFxuICAgIHdlZWtlbmRzOiB0cnVlLFxuICAgIHdlZWtOdW1iZXJzOiBmYWxzZSxcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246ICdsb2NhbCcsXG4gICAgZWRpdGFibGU6IGZhbHNlLFxuICAgIG5vd0luZGljYXRvcjogZmFsc2UsXG4gICAgc2Nyb2xsVGltZTogJzA2OjAwOjAwJyxcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IHRydWUsXG4gICAgc2xvdE1pblRpbWU6ICcwMDowMDowMCcsXG4gICAgc2xvdE1heFRpbWU6ICcyNDowMDowMCcsXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogdHJ1ZSxcbiAgICBsYXp5RmV0Y2hpbmc6IHRydWUsXG4gICAgc3RhcnRQYXJhbTogJ3N0YXJ0JyxcbiAgICBlbmRQYXJhbTogJ2VuZCcsXG4gICAgdGltZVpvbmVQYXJhbTogJ3RpbWVab25lJyxcbiAgICB0aW1lWm9uZTogJ2xvY2FsJyxcbiAgICBsb2NhbGVzOiBbXSxcbiAgICBsb2NhbGU6ICcnLFxuICAgIHRoZW1lU3lzdGVtOiAnc3RhbmRhcmQnLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogNTAwLFxuICAgIGRyYWdTY3JvbGw6IHRydWUsXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogZmFsc2UsXG4gICAgdW5zZWxlY3RBdXRvOiB0cnVlLFxuICAgIGRyb3BBY2NlcHQ6ICcqJyxcbiAgICBldmVudE9yZGVyOiAnc3RhcnQsLWR1cmF0aW9uLGFsbERheSx0aXRsZScsXG4gICAgZGF5UG9wb3ZlckZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiAxMDAsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IDEwMDAsXG4gICAgZXZlbnREcmFnTWluRGlzdGFuY2U6IDUsXG4gICAgZXhwYW5kUm93czogZmFsc2UsXG4gICAgbmF2TGlua3M6IGZhbHNlLFxuICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgIGV2ZW50TWluSGVpZ2h0OiAxNSxcbiAgICBldmVudE1pbldpZHRoOiAzMCxcbiAgICBldmVudFNob3J0SGVpZ2h0OiAzMCxcbiAgICBtb250aFN0YXJ0Rm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH0sXG59O1xuLy8gY2FsZW5kYXIgbGlzdGVuZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTID0ge1xuICAgIGRhdGVzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudHNTZXQ6IGlkZW50aXR5LFxuICAgIGV2ZW50QWRkOiBpZGVudGl0eSxcbiAgICBldmVudENoYW5nZTogaWRlbnRpdHksXG4gICAgZXZlbnRSZW1vdmU6IGlkZW50aXR5LFxuICAgIHdpbmRvd1Jlc2l6ZTogaWRlbnRpdHksXG4gICAgZXZlbnRDbGljazogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUVudGVyOiBpZGVudGl0eSxcbiAgICBldmVudE1vdXNlTGVhdmU6IGlkZW50aXR5LFxuICAgIHNlbGVjdDogaWRlbnRpdHksXG4gICAgdW5zZWxlY3Q6IGlkZW50aXR5LFxuICAgIGxvYWRpbmc6IGlkZW50aXR5LFxuICAgIC8vIGludGVybmFsXG4gICAgX3VubW91bnQ6IGlkZW50aXR5LFxuICAgIF9iZWZvcmVwcmludDogaWRlbnRpdHksXG4gICAgX2FmdGVycHJpbnQ6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50RHJvcDogaWRlbnRpdHksXG4gICAgX25vRXZlbnRSZXNpemU6IGlkZW50aXR5LFxuICAgIF9yZXNpemU6IGlkZW50aXR5LFxuICAgIF9zY3JvbGxSZXF1ZXN0OiBpZGVudGl0eSxcbn07XG4vLyBjYWxlbmRhci1zcGVjaWZpYyBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgYnV0dG9uVGV4dDogaWRlbnRpdHksXG4gICAgYnV0dG9uSGludHM6IGlkZW50aXR5LFxuICAgIHZpZXdzOiBpZGVudGl0eSxcbiAgICBwbHVnaW5zOiBpZGVudGl0eSxcbiAgICBpbml0aWFsRXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudHM6IGlkZW50aXR5LFxuICAgIGV2ZW50U291cmNlczogaWRlbnRpdHksXG59O1xuY29uc3QgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMgPSB7XG4gICAgaGVhZGVyVG9vbGJhcjogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBmb290ZXJUb29sYmFyOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGJ1dHRvblRleHQ6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgYnV0dG9uSGludHM6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgYnV0dG9uSWNvbnM6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgZGF0ZUluY3JlbWVudDogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBwbHVnaW5zOiBpc01heWJlQXJyYXlzRXF1YWwsXG4gICAgZXZlbnRzOiBpc01heWJlQXJyYXlzRXF1YWwsXG4gICAgZXZlbnRTb3VyY2VzOiBpc01heWJlQXJyYXlzRXF1YWwsXG4gICAgWydyZXNvdXJjZXMnXTogaXNNYXliZUFycmF5c0VxdWFsLFxufTtcbmZ1bmN0aW9uIGlzTWF5YmVPYmplY3RzRXF1YWwoYSwgYikge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGEgJiYgYikgeyAvLyBib3RoIG5vbi1udWxsIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIGlzUHJvcHNFcXVhbChhLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG5mdW5jdGlvbiBpc01heWJlQXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXlzRXF1YWwoYSwgYik7XG4gICAgfVxuICAgIHJldHVybiBhID09PSBiO1xufVxuLy8gdmlldy1zcGVjaWZpYyBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IFZJRVdfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBjb21wb25lbnQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvblRleHQ6IFN0cmluZyxcbiAgICBidXR0b25UZXh0S2V5OiBTdHJpbmcsXG4gICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogaWRlbnRpdHksXG4gICAgdXNlc01pbk1heFRpbWU6IEJvb2xlYW4sXG4gICAgY2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgY29udGVudDogaWRlbnRpdHksXG4gICAgZGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHdpbGxVbm1vdW50OiBpZGVudGl0eSxcbn07XG4vLyB1dGlsIGZ1bmNzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBtZXJnZVJhd09wdGlvbnMob3B0aW9uU2V0cykge1xuICAgIHJldHVybiBtZXJnZVByb3BzKG9wdGlvblNldHMsIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTKTtcbn1cbmZ1bmN0aW9uIHJlZmluZVByb3BzKGlucHV0LCByZWZpbmVycykge1xuICAgIGxldCByZWZpbmVkID0ge307XG4gICAgbGV0IGV4dHJhID0ge307XG4gICAgZm9yIChsZXQgcHJvcE5hbWUgaW4gcmVmaW5lcnMpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lIGluIGlucHV0KSB7XG4gICAgICAgICAgICByZWZpbmVkW3Byb3BOYW1lXSA9IHJlZmluZXJzW3Byb3BOYW1lXShpbnB1dFtwcm9wTmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IHByb3BOYW1lIGluIGlucHV0KSB7XG4gICAgICAgIGlmICghKHByb3BOYW1lIGluIHJlZmluZXJzKSkge1xuICAgICAgICAgICAgZXh0cmFbcHJvcE5hbWVdID0gaW5wdXRbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlZmluZWQsIGV4dHJhIH07XG59XG5mdW5jdGlvbiBpZGVudGl0eShyYXcpIHtcbiAgICByZXR1cm4gcmF3O1xufVxuXG5jb25zdCB7IGhhc093blByb3BlcnR5IH0gPSBPYmplY3QucHJvdG90eXBlO1xuLy8gTWVyZ2VzIGFuIGFycmF5IG9mIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3QuXG4vLyBUaGUgc2Vjb25kIGFyZ3VtZW50IGFsbG93cyBmb3IgYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgd2hvJ3Mgb2JqZWN0IHZhbHVlcyB3aWxsIGJlIG1lcmdlZCB0b2dldGhlci5cbmZ1bmN0aW9uIG1lcmdlUHJvcHMocHJvcE9ianMsIGNvbXBsZXhQcm9wc01hcCkge1xuICAgIGxldCBkZXN0ID0ge307XG4gICAgaWYgKGNvbXBsZXhQcm9wc01hcCkge1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGNvbXBsZXhQcm9wc01hcCkge1xuICAgICAgICAgICAgaWYgKGNvbXBsZXhQcm9wc01hcFtuYW1lXSA9PT0gaXNNYXliZU9iamVjdHNFcXVhbCkgeyAvLyBpbXBsaWVzIHRoYXQgaXQncyBvYmplY3QtbWVyZ2VhYmxlXG4gICAgICAgICAgICAgICAgbGV0IGNvbXBsZXhPYmpzID0gW107XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsID0gcHJvcE9ianNbaV1bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV4T2Jqcy51bnNoaWZ0KHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RbbmFtZV0gPSB2YWw7IC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB0cmFpbGluZyB2YWx1ZXMgd2VyZSBvYmplY3RzLCB1c2UgdGhlIG1lcmdlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGlmIChjb21wbGV4T2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IG1lcmdlUHJvcHMoY29tcGxleE9ianMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHRoZSBkZXN0aW5hdGlvbiwgZ29pbmcgZnJvbSBsYXN0IHRvIGZpcnN0XG4gICAgZm9yIChsZXQgaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGxldCBwcm9wcyA9IHByb3BPYmpzW2ldO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIGRlc3QpKSB7IC8vIGlmIGFscmVhZHkgYXNzaWduZWQgYnkgcHJldmlvdXMgcHJvcHMgb3IgY29tcGxleCBwcm9wcywgZG9uJ3QgcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gcHJvcHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiBmaWx0ZXJIYXNoKGhhc2gsIGZ1bmMpIHtcbiAgICBsZXQgZmlsdGVyZWQgPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgaW4gaGFzaCkge1xuICAgICAgICBpZiAoZnVuYyhoYXNoW2tleV0sIGtleSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xufVxuZnVuY3Rpb24gbWFwSGFzaChoYXNoLCBmdW5jKSB7XG4gICAgbGV0IG5ld0hhc2ggPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgaW4gaGFzaCkge1xuICAgICAgICBuZXdIYXNoW2tleV0gPSBmdW5jKGhhc2hba2V5XSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0hhc2g7XG59XG5mdW5jdGlvbiBhcnJheVRvSGFzaChhKSB7XG4gICAgbGV0IGhhc2ggPSB7fTtcbiAgICBmb3IgKGxldCBpdGVtIG9mIGEpIHtcbiAgICAgICAgaGFzaFtpdGVtXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufVxuLy8gVE9ETzogcmVhc3Nlc3MgYnJvd3NlciBzdXBwb3J0XG4vLyBodHRwczovL2Nhbml1c2UuY29tLz9zZWFyY2g9b2JqZWN0LnZhbHVlc1xuZnVuY3Rpb24gaGFzaFZhbHVlc1RvQXJyYXkob2JqKSB7XG4gICAgbGV0IGEgPSBbXTtcbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGEucHVzaChvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuZnVuY3Rpb24gaXNQcm9wc0VxdWFsKG9iajAsIG9iajEpIHtcbiAgICBpZiAob2JqMCA9PT0gb2JqMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIG9iajApIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMCwga2V5KSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9iajEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IEhBTkRMRVJfUkUgPSAvXm9uW0EtWl0vO1xuZnVuY3Rpb24gaXNOb25IYW5kbGVyUHJvcHNFcXVhbChvYmowLCBvYmoxKSB7XG4gICAgY29uc3Qga2V5cyA9IGdldFVuZXF1YWxQcm9wcyhvYmowLCBvYmoxKTtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgICBpZiAoIUhBTkRMRVJfUkUudGVzdChrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRVbmVxdWFsUHJvcHMob2JqMCwgb2JqMSkge1xuICAgIGxldCBrZXlzID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIG9iajApIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMCwga2V5KSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9iajEpKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQga2V5IGluIG9iajEpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xuICAgICAgICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBjb21wYXJlT2JqcyhvbGRQcm9wcywgbmV3UHJvcHMsIGVxdWFsaXR5RnVuY3MgPSB7fSkge1xuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGtleSBpbiBuZXdQcm9wcykge1xuICAgICAgICBpZiAoa2V5IGluIG9sZFByb3BzICYmIGlzT2JqVmFsc0VxdWFsKG9sZFByb3BzW2tleV0sIG5ld1Byb3BzW2tleV0sIGVxdWFsaXR5RnVuY3Nba2V5XSkpIDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIHByb3BzIHRoYXQgd2VyZSBvbWl0dGVkIGluIHRoZSBuZXdcbiAgICBmb3IgKGxldCBrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIG5ld1Byb3BzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLypcbmFzc3VtZWQgXCJ0cnVlXCIgZXF1YWxpdHkgZm9yIGhhbmRsZXIgbmFtZXMgbGlrZSBcIm9uUmVjZWl2ZVNvbWV0aGluZ1wiXG4qL1xuZnVuY3Rpb24gaXNPYmpWYWxzRXF1YWwodmFsMCwgdmFsMSwgY29tcGFyYXRvcikge1xuICAgIGlmICh2YWwwID09PSB2YWwxIHx8IGNvbXBhcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJhdG9yKHZhbDAsIHZhbDEpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb2xsZWN0RnJvbUhhc2goaGFzaCwgc3RhcnRJbmRleCA9IDAsIGVuZEluZGV4LCBzdGVwID0gMSkge1xuICAgIGxldCByZXMgPSBbXTtcbiAgICBpZiAoZW5kSW5kZXggPT0gbnVsbCkge1xuICAgICAgICBlbmRJbmRleCA9IE9iamVjdC5rZXlzKGhhc2gpLmxlbmd0aDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSArPSBzdGVwKSB7XG4gICAgICAgIGxldCB2YWwgPSBoYXNoW2ldO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHsgLy8gd2lsbCBkaXNyZWdhcmQgdW5kZWZpbmVkIGZvciBzcGFyc2UgYXJyYXlzXG4gICAgICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmxldCBjYWxlbmRhclN5c3RlbUNsYXNzTWFwID0ge307XG5mdW5jdGlvbiByZWdpc3RlckNhbGVuZGFyU3lzdGVtKG5hbWUsIHRoZUNsYXNzKSB7XG4gICAgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcFtuYW1lXSA9IHRoZUNsYXNzO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FsZW5kYXJTeXN0ZW0obmFtZSkge1xuICAgIHJldHVybiBuZXcgY2FsZW5kYXJTeXN0ZW1DbGFzc01hcFtuYW1lXSgpO1xufVxuY2xhc3MgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ge1xuICAgIGdldE1hcmtlclllYXIoZCkge1xuICAgICAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpO1xuICAgIH1cbiAgICBnZXRNYXJrZXJNb250aChkKSB7XG4gICAgICAgIHJldHVybiBkLmdldFVUQ01vbnRoKCk7XG4gICAgfVxuICAgIGdldE1hcmtlckRheShkKSB7XG4gICAgICAgIHJldHVybiBkLmdldFVUQ0RhdGUoKTtcbiAgICB9XG4gICAgYXJyYXlUb01hcmtlcihhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGFycik7XG4gICAgfVxuICAgIG1hcmtlclRvQXJyYXkobWFya2VyKSB7XG4gICAgICAgIHJldHVybiBkYXRlVG9VdGNBcnJheShtYXJrZXIpO1xuICAgIH1cbn1cbnJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0oJ2dyZWdvcnknLCBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSk7XG5cbmNvbnN0IElTT19SRSA9IC9eXFxzKihcXGR7NH0pKC0/KFxcZHsyfSkoLT8oXFxkezJ9KShbVCBdKFxcZHsyfSk6PyhcXGR7Mn0pKDo/KFxcZHsyfSkoXFwuKFxcZCspKT8pPyhafCgoWy0rXSkoXFxkezJ9KSg6PyhcXGR7Mn0pKT8pKT8pPyk/KT8kLztcbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIGxldCBtID0gSVNPX1JFLmV4ZWMoc3RyKTtcbiAgICBpZiAobSkge1xuICAgICAgICBsZXQgbWFya2VyID0gbmV3IERhdGUoRGF0ZS5VVEMoTnVtYmVyKG1bMV0pLCBtWzNdID8gTnVtYmVyKG1bM10pIC0gMSA6IDAsIE51bWJlcihtWzVdIHx8IDEpLCBOdW1iZXIobVs3XSB8fCAwKSwgTnVtYmVyKG1bOF0gfHwgMCksIE51bWJlcihtWzEwXSB8fCAwKSwgbVsxMl0gPyBOdW1iZXIoYDAuJHttWzEyXX1gKSAqIDEwMDAgOiAwKSk7XG4gICAgICAgIGlmIChpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICAgICAgICBsZXQgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG1bMTNdKSB7XG4gICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSAobVsxNV0gPT09ICctJyA/IC0xIDogMSkgKiAoTnVtYmVyKG1bMTZdIHx8IDApICogNjAgK1xuICAgICAgICAgICAgICAgICAgICBOdW1iZXIobVsxOF0gfHwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIsXG4gICAgICAgICAgICAgICAgaXNUaW1lVW5zcGVjaWZpZWQ6ICFtWzZdLFxuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY2xhc3MgRGF0ZUVudiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IHRpbWVab25lID0gdGhpcy50aW1lWm9uZSA9IHNldHRpbmdzLnRpbWVab25lO1xuICAgICAgICBsZXQgaXNOYW1lZFRpbWVab25lID0gdGltZVpvbmUgIT09ICdsb2NhbCcgJiYgdGltZVpvbmUgIT09ICdVVEMnO1xuICAgICAgICBpZiAoc2V0dGluZ3MubmFtZWRUaW1lWm9uZUltcGwgJiYgaXNOYW1lZFRpbWVab25lKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWVkVGltZVpvbmVJbXBsID0gbmV3IHNldHRpbmdzLm5hbWVkVGltZVpvbmVJbXBsKHRpbWVab25lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbkNvbXB1dGVPZmZzZXQgPSBCb29sZWFuKCFpc05hbWVkVGltZVpvbmUgfHwgdGhpcy5uYW1lZFRpbWVab25lSW1wbCk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0gPSBjcmVhdGVDYWxlbmRhclN5c3RlbShzZXR0aW5ncy5jYWxlbmRhclN5c3RlbSk7XG4gICAgICAgIHRoaXMubG9jYWxlID0gc2V0dGluZ3MubG9jYWxlO1xuICAgICAgICB0aGlzLndlZWtEb3cgPSBzZXR0aW5ncy5sb2NhbGUud2Vlay5kb3c7XG4gICAgICAgIHRoaXMud2Vla0RveSA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRveTtcbiAgICAgICAgaWYgKHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ0lTTycpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IDE7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3kgPSA0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuZmlyc3REYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtEb3cgPSBzZXR0aW5ncy5maXJzdERheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrTnVtYmVyRnVuYyA9IHNldHRpbmdzLndlZWtOdW1iZXJDYWxjdWxhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndlZWtUZXh0ID0gc2V0dGluZ3Mud2Vla1RleHQgIT0gbnVsbCA/IHNldHRpbmdzLndlZWtUZXh0IDogc2V0dGluZ3MubG9jYWxlLm9wdGlvbnMud2Vla1RleHQ7XG4gICAgICAgIHRoaXMud2Vla1RleHRMb25nID0gKHNldHRpbmdzLndlZWtUZXh0TG9uZyAhPSBudWxsID8gc2V0dGluZ3Mud2Vla1RleHRMb25nIDogc2V0dGluZ3MubG9jYWxlLm9wdGlvbnMud2Vla1RleHRMb25nKSB8fCB0aGlzLndlZWtUZXh0O1xuICAgICAgICB0aGlzLmNtZEZvcm1hdHRlciA9IHNldHRpbmdzLmNtZEZvcm1hdHRlcjtcbiAgICAgICAgdGhpcy5kZWZhdWx0U2VwYXJhdG9yID0gc2V0dGluZ3MuZGVmYXVsdFNlcGFyYXRvcjtcbiAgICB9XG4gICAgLy8gQ3JlYXRpbmcgLyBQYXJzaW5nXG4gICAgY3JlYXRlTWFya2VyKGlucHV0KSB7XG4gICAgICAgIGxldCBtZXRhID0gdGhpcy5jcmVhdGVNYXJrZXJNZXRhKGlucHV0KTtcbiAgICAgICAgaWYgKG1ldGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhLm1hcmtlcjtcbiAgICB9XG4gICAgY3JlYXRlTm93TWFya2VyKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5Db21wdXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXBUb01hcmtlcihuZXcgRGF0ZSgpLnZhbHVlT2YoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgY2FuJ3QgY29tcHV0ZSB0aGUgY3VycmVudCBkYXRlIHZhbCBmb3IgYSB0aW1lem9uZSxcbiAgICAgICAgLy8gYmV0dGVyIHRvIGdpdmUgdGhlIGN1cnJlbnQgbG9jYWwgZGF0ZSB2YWxzIHRoYW4gVVRDXG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKCkpKTtcbiAgICB9XG4gICAgY3JlYXRlTWFya2VyTWV0YShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXJrZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyID0gdGhpcy50aW1lc3RhbXBUb01hcmtlcihpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IGFycmF5VG9VdGNEYXRlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyID09PSBudWxsIHx8ICFpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXIsIGlzVGltZVVuc3BlY2lmaWVkOiBmYWxzZSwgZm9yY2VkVHpvOiBudWxsIH07XG4gICAgfVxuICAgIHBhcnNlKHMpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gcGFyc2Uocyk7XG4gICAgICAgIGlmIChwYXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgbWFya2VyIH0gPSBwYXJ0cztcbiAgICAgICAgbGV0IGZvcmNlZFR6byA9IG51bGw7XG4gICAgICAgIGlmIChwYXJ0cy50aW1lWm9uZU9mZnNldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIobWFya2VyLnZhbHVlT2YoKSAtIHBhcnRzLnRpbWVab25lT2Zmc2V0ICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcmNlZFR6byA9IHBhcnRzLnRpbWVab25lT2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IHBhcnRzLmlzVGltZVVuc3BlY2lmaWVkLCBmb3JjZWRUem8gfTtcbiAgICB9XG4gICAgLy8gQWNjZXNzb3JzXG4gICAgZ2V0WWVhcihtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtYXJrZXIpO1xuICAgIH1cbiAgICBnZXRNb250aChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobWFya2VyKTtcbiAgICB9XG4gICAgZ2V0RGF5KG1hcmtlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobWFya2VyKTtcbiAgICB9XG4gICAgLy8gQWRkaW5nIC8gU3VidHJhY3RpbmdcbiAgICBhZGQobWFya2VyLCBkdXIpIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSArPSBkdXIueWVhcnM7XG4gICAgICAgIGFbMV0gKz0gZHVyLm1vbnRocztcbiAgICAgICAgYVsyXSArPSBkdXIuZGF5cztcbiAgICAgICAgYVs2XSArPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChtYXJrZXIsIGR1cikge1xuICAgICAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzBdIC09IGR1ci55ZWFycztcbiAgICAgICAgYVsxXSAtPSBkdXIubW9udGhzO1xuICAgICAgICBhWzJdIC09IGR1ci5kYXlzO1xuICAgICAgICBhWzZdIC09IGR1ci5taWxsaXNlY29uZHM7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfVxuICAgIGFkZFllYXJzKG1hcmtlciwgbikge1xuICAgICAgICBsZXQgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzBdICs9IG47XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfVxuICAgIGFkZE1vbnRocyhtYXJrZXIsIG4pIHtcbiAgICAgICAgbGV0IGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVsxXSArPSBuO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH1cbiAgICAvLyBEaWZmaW5nIFdob2xlIFVuaXRzXG4gICAgZGlmZldob2xlWWVhcnMobTAsIG0xKSB7XG4gICAgICAgIGxldCB7IGNhbGVuZGFyU3lzdGVtIH0gPSB0aGlzO1xuICAgICAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkgJiZcbiAgICAgICAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMSkgJiZcbiAgICAgICAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTEpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMSkgLSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0wKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGlmZldob2xlTW9udGhzKG0wLCBtMSkge1xuICAgICAgICBsZXQgeyBjYWxlbmRhclN5c3RlbSB9ID0gdGhpcztcbiAgICAgICAgaWYgKHRpbWVBc01zKG0wKSA9PT0gdGltZUFzTXMobTEpICYmXG4gICAgICAgICAgICBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJEYXkobTEpKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0wKSkgK1xuICAgICAgICAgICAgICAgIChjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTApKSAqIDEyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBSYW5nZSAvIER1cmF0aW9uXG4gICAgZ3JlYXRlc3RXaG9sZVVuaXQobTAsIG0xKSB7XG4gICAgICAgIGxldCBuID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3llYXInLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21vbnRoJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZldob2xlV2Vla3MobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd3ZWVrJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZIb3VycyhtMCwgbTEpO1xuICAgICAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZk1pbnV0ZXMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZlNlY29uZHMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnc2Vjb25kJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpIH07XG4gICAgfVxuICAgIGNvdW50RHVyYXRpb25zQmV0d2VlbihtMCwgbTEsIGQpIHtcbiAgICAgICAgLy8gVE9ETzogY2FuIHVzZSBncmVhdGVzdFdob2xlVW5pdFxuICAgICAgICBsZXQgZGlmZjtcbiAgICAgICAgaWYgKGQueWVhcnMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZVllYXJzKG0wLCBtMSk7XG4gICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaFllYXJzKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkLm1vbnRocykge1xuICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZldob2xlTW9udGhzKG0wLCBtMSk7XG4gICAgICAgICAgICBpZiAoZGlmZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmIC8gYXNSb3VnaE1vbnRocyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5kYXlzKSB7XG4gICAgICAgICAgICBkaWZmID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hEYXlzKGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvIGFzUm91Z2hNcyhkKTtcbiAgICB9XG4gICAgLy8gU3RhcnQtT2ZcbiAgICAvLyB0aGVzZSBET04nVCByZXR1cm4gem9uZWQtZGF0ZXMuIG9ubHkgVVRDIHN0YXJ0LW9mIGRhdGVzXG4gICAgc3RhcnRPZihtLCB1bml0KSB7XG4gICAgICAgIGlmICh1bml0ID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZZZWFyKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mTW9udGgobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICd3ZWVrJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZldlZWsobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdkYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZkRheShtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ2hvdXInKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZkhvdXIobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdtaW51dGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnRPZk1pbnV0ZShtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ3NlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydE9mU2Vjb25kKG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGFydE9mWWVhcihtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgc3RhcnRPZk1vbnRoKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uYXJyYXlUb01hcmtlcihbXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobSksXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG0pLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgc3RhcnRPZldlZWsobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKFtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtKSxcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobSksXG4gICAgICAgICAgICBtLmdldFVUQ0RhdGUoKSAtICgobS5nZXRVVENEYXkoKSAtIHRoaXMud2Vla0RvdyArIDcpICUgNyksXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICAvLyBXZWVrIE51bWJlclxuICAgIGNvbXB1dGVXZWVrTnVtYmVyKG1hcmtlcikge1xuICAgICAgICBpZiAodGhpcy53ZWVrTnVtYmVyRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2Vla051bWJlckZ1bmModGhpcy50b0RhdGUobWFya2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobWFya2VyLCB0aGlzLndlZWtEb3csIHRoaXMud2Vla0RveSk7XG4gICAgfVxuICAgIC8vIFRPRE86IGNob2tlIG9uIHRpbWVab25lTmFtZTogbG9uZ1xuICAgIGZvcm1hdChtYXJrZXIsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdCh7XG4gICAgICAgICAgICBtYXJrZXIsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKSxcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIGZvcm1hdFJhbmdlKHN0YXJ0LCBlbmQsIGZvcm1hdHRlciwgZGF0ZU9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAoZGF0ZU9wdGlvbnMuaXNFbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZE1zKGVuZCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIuZm9ybWF0UmFuZ2Uoe1xuICAgICAgICAgICAgbWFya2VyOiBzdGFydCxcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byAhPSBudWxsID9cbiAgICAgICAgICAgICAgICBkYXRlT3B0aW9ucy5mb3JjZWRTdGFydFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoc3RhcnQpLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBtYXJrZXI6IGVuZCxcbiAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0OiBkYXRlT3B0aW9ucy5mb3JjZWRFbmRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvIDpcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEZvck1hcmtlcihlbmQpLFxuICAgICAgICB9LCB0aGlzLCBkYXRlT3B0aW9ucy5kZWZhdWx0U2VwYXJhdG9yKTtcbiAgICB9XG4gICAgLypcbiAgICBEVU1COiB0aGUgb21pdFRpbWUgYXJnIGlzIGR1bWIuIGlmIHdlIG9taXQgdGhlIHRpbWUsIHdlIHdhbnQgdG8gb21pdCB0aGUgdGltZXpvbmUgb2Zmc2V0LiBhbmQgaWYgd2UgZG8gdGhhdCxcbiAgICBtaWdodCBhcyB3ZWxsIHVzZSBidWlsZElzb1N0cmluZyBvciBzb21lIG90aGVyIHV0aWwgZGlyZWN0bHlcbiAgICAqL1xuICAgIGZvcm1hdElzbyhtYXJrZXIsIGV4dHJhT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB0aW1lWm9uZU9mZnNldCA9IG51bGw7XG4gICAgICAgIGlmICghZXh0cmFPcHRpb25zLm9taXRUaW1lWm9uZU9mZnNldCkge1xuICAgICAgICAgICAgaWYgKGV4dHJhT3B0aW9ucy5mb3JjZWRUem8gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gZXh0cmFPcHRpb25zLmZvcmNlZFR6bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRpbWVab25lT2Zmc2V0ID0gdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRJc29TdHJpbmcobWFya2VyLCB0aW1lWm9uZU9mZnNldCwgZXh0cmFPcHRpb25zLm9taXRUaW1lKTtcbiAgICB9XG4gICAgLy8gVGltZVpvbmVcbiAgICB0aW1lc3RhbXBUb01hcmtlcihtcykge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGRhdGVUb0xvY2FsQXJyYXkobmV3IERhdGUobXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnIHx8ICF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZSh0aGlzLm5hbWVkVGltZVpvbmVJbXBsLnRpbWVzdGFtcFRvQXJyYXkobXMpKTtcbiAgICB9XG4gICAgb2Zmc2V0Rm9yTWFya2VyKG0pIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiAtYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTsgLy8gY29udmVydCBcImludmVyc2VcIiBvZmZzZXQgdG8gXCJub3JtYWxcIiBvZmZzZXRcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIENvbnZlcnNpb25cbiAgICB0b0RhdGUobSwgZm9yY2VkVHpvKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdVVEMnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkpOyAvLyBtYWtlIHN1cmUgaXQncyBhIGNvcHlcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtIChmb3JjZWRUem8gfHwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShtLnZhbHVlT2YoKSAtXG4gICAgICAgICAgICB0aGlzLm5hbWVkVGltZVpvbmVJbXBsLm9mZnNldEZvckFycmF5KGRhdGVUb1V0Y0FycmF5KG0pKSAqIDEwMDAgKiA2MCk7XG4gICAgfVxufVxuXG5jbGFzcyBUaGVtZSB7XG4gICAgY29uc3RydWN0b3IoY2FsZW5kYXJPcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZU9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZXRJY29uT3ZlcnJpZGUoY2FsZW5kYXJPcHRpb25zW3RoaXMuaWNvbk92ZXJyaWRlT3B0aW9uXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SWNvbk92ZXJyaWRlKGljb25PdmVycmlkZUhhc2gpIHtcbiAgICAgICAgbGV0IGljb25DbGFzc2VzQ29weTtcbiAgICAgICAgbGV0IGJ1dHRvbk5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgaWNvbk92ZXJyaWRlSGFzaCA9PT0gJ29iamVjdCcgJiYgaWNvbk92ZXJyaWRlSGFzaCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgICAgIGljb25DbGFzc2VzQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaWNvbkNsYXNzZXMpO1xuICAgICAgICAgICAgZm9yIChidXR0b25OYW1lIGluIGljb25PdmVycmlkZUhhc2gpIHtcbiAgICAgICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHlbYnV0dG9uTmFtZV0gPSB0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGljb25PdmVycmlkZUhhc2hbYnV0dG9uTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IGljb25DbGFzc2VzQ29weTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpY29uT3ZlcnJpZGVIYXNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGNsYXNzTmFtZSkge1xuICAgICAgICBsZXQgcHJlZml4ID0gdGhpcy5pY29uT3ZlcnJpZGVQcmVmaXg7XG4gICAgICAgIGlmIChwcmVmaXggJiYgY2xhc3NOYW1lLmluZGV4T2YocHJlZml4KSAhPT0gMCkgeyAvLyBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBwcmVmaXggKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZTtcbiAgICB9XG4gICAgZ2V0Q2xhc3Moa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXNba2V5XSB8fCAnJztcbiAgICB9XG4gICAgZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSB7XG4gICAgICAgIGxldCBjbGFzc05hbWU7XG4gICAgICAgIGlmIChpc1J0bCAmJiB0aGlzLnJ0bEljb25DbGFzc2VzKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSB0aGlzLnJ0bEljb25DbGFzc2VzW2J1dHRvbk5hbWVdIHx8IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VJY29uQ2xhc3N9ICR7Y2xhc3NOYW1lfWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXRDdXN0b21CdXR0b25JY29uQ2xhc3MoY3VzdG9tQnV0dG9uUHJvcHMpIHtcbiAgICAgICAgbGV0IGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKHRoaXMuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBjdXN0b21CdXR0b25Qcm9wc1t0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbl07XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMuYmFzZUljb25DbGFzc30gJHt0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGNsYXNzTmFtZSl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7fTtcblRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHt9O1xuVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnJztcblRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnJztcblxuLypcbk5PVEU6IHRoaXMgY2FuIGJlIGEgcHVibGljIEFQSSwgZXNwZWNpYWxseSBjcmVhdGVFbGVtZW50IGZvciBob29rcy5cblNlZSBleGFtcGxlcy90eXBlc2NyaXB0LXNjaGVkdWxlci9zcmMvaW5kZXgudHNcbiovXG5mdW5jdGlvbiBmbHVzaFN5bmMocnVuQmVmb3JlRmx1c2gpIHtcbiAgICBydW5CZWZvcmVGbHVzaCgpO1xuICAgIGxldCBvbGREZWJvdW5jZVJlbmRlcmluZyA9IHByZWFjdC5vcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nOyAvLyBvcmlnXG4gICAgbGV0IGNhbGxiYWNrUSA9IFtdO1xuICAgIGZ1bmN0aW9uIGV4ZWNDYWxsYmFja1N5bmMoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2tRLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA9IGV4ZWNDYWxsYmFja1N5bmM7XG4gICAgcHJlYWN0LnJlbmRlcihwcmVhY3QuY3JlYXRlRWxlbWVudChGYWtlQ29tcG9uZW50LCB7fSksIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpKTtcbiAgICB3aGlsZSAoY2FsbGJhY2tRLmxlbmd0aCkge1xuICAgICAgICBjYWxsYmFja1Euc2hpZnQoKSgpO1xuICAgIH1cbiAgICBwcmVhY3Qub3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA9IG9sZERlYm91bmNlUmVuZGVyaW5nO1xufVxuY2xhc3MgRmFrZUNvbXBvbmVudCBleHRlbmRzIHByZWFjdC5Db21wb25lbnQge1xuICAgIHJlbmRlcigpIHsgcmV0dXJuIHByZWFjdC5jcmVhdGVFbGVtZW50KCdkaXYnLCB7fSk7IH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHsgdGhpcy5zZXRTdGF0ZSh7fSk7IH1cbn1cbi8vIFRPRE86IHVzZSBwcmVhY3QvY29tcGF0IGluc3RlYWQ/XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSkge1xuICAgIGxldCBDb250ZXh0VHlwZSA9IHByZWFjdC5jcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSk7XG4gICAgbGV0IG9yaWdQcm92aWRlciA9IENvbnRleHRUeXBlLlByb3ZpZGVyO1xuICAgIENvbnRleHRUeXBlLlByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsZXQgaXNOZXcgPSAhdGhpcy5nZXRDaGlsZENvbnRleHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IG9yaWdQcm92aWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgIGxldCBzdWJzID0gW107XG4gICAgICAgICAgICB0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IChfcHJvcHMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5jb250ZXh0ID0gX3Byb3BzLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zdWIgPSAoYykgPT4ge1xuICAgICAgICAgICAgICAgIHN1YnMucHVzaChjKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcbiAgICAgICAgICAgICAgICBjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdWJzLnNwbGljZShzdWJzLmluZGV4T2YoYyksIDEpO1xuICAgICAgICAgICAgICAgICAgICBvbGQgJiYgb2xkLmNhbGwoYyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnRleHRUeXBlO1xufVxuXG5jbGFzcyBTY3JvbGxSZXNwb25kZXIge1xuICAgIGNvbnN0cnVjdG9yKGV4ZWNGdW5jLCBlbWl0dGVyLCBzY3JvbGxUaW1lLCBzY3JvbGxUaW1lUmVzZXQpIHtcbiAgICAgICAgdGhpcy5leGVjRnVuYyA9IGV4ZWNGdW5jO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xuICAgICAgICB0aGlzLnNjcm9sbFRpbWUgPSBzY3JvbGxUaW1lO1xuICAgICAgICB0aGlzLnNjcm9sbFRpbWVSZXNldCA9IHNjcm9sbFRpbWVSZXNldDtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucXVldWVkUmVxdWVzdCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucXVldWVkUmVxdWVzdCB8fCB7fSwgcmVxdWVzdCk7XG4gICAgICAgICAgICB0aGlzLmRyYWluKCk7XG4gICAgICAgIH07XG4gICAgICAgIGVtaXR0ZXIub24oJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5maXJlSW5pdGlhbFNjcm9sbCgpO1xuICAgIH1cbiAgICBkZXRhY2goKSB7XG4gICAgICAgIHRoaXMuZW1pdHRlci5vZmYoJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcbiAgICB9XG4gICAgdXBkYXRlKGlzRGF0ZXNOZXcpIHtcbiAgICAgICAgaWYgKGlzRGF0ZXNOZXcgJiYgdGhpcy5zY3JvbGxUaW1lUmVzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZUluaXRpYWxTY3JvbGwoKTsgLy8gd2lsbCBkcmFpblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmFpbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpcmVJbml0aWFsU2Nyb2xsKCkge1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3Qoe1xuICAgICAgICAgICAgdGltZTogdGhpcy5zY3JvbGxUaW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZFJlcXVlc3QgJiYgdGhpcy5leGVjRnVuYyh0aGlzLnF1ZXVlZFJlcXVlc3QpKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZFJlcXVlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBWaWV3Q29udGV4dFR5cGUgPSBjcmVhdGVDb250ZXh0KHt9KTsgLy8gZm9yIENvbXBvbmVudHNcbmZ1bmN0aW9uIGJ1aWxkVmlld0NvbnRleHQodmlld1NwZWMsIHZpZXdBcGksIHZpZXdPcHRpb25zLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgZGF0ZUVudiwgdGhlbWUsIHBsdWdpbkhvb2tzLCBkaXNwYXRjaCwgZ2V0Q3VycmVudERhdGEsIGVtaXR0ZXIsIGNhbGVuZGFyQXBpLCByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LCB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlRW52LFxuICAgICAgICBvcHRpb25zOiB2aWV3T3B0aW9ucyxcbiAgICAgICAgcGx1Z2luSG9va3MsXG4gICAgICAgIGVtaXR0ZXIsXG4gICAgICAgIGRpc3BhdGNoLFxuICAgICAgICBnZXRDdXJyZW50RGF0YSxcbiAgICAgICAgY2FsZW5kYXJBcGksXG4gICAgICAgIHZpZXdTcGVjLFxuICAgICAgICB2aWV3QXBpLFxuICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvcixcbiAgICAgICAgdGhlbWUsXG4gICAgICAgIGlzUnRsOiB2aWV3T3B0aW9ucy5kaXJlY3Rpb24gPT09ICdydGwnLFxuICAgICAgICBhZGRSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ19yZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9mZignX3Jlc2l6ZScsIGhhbmRsZXIpO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVTY3JvbGxSZXNwb25kZXIoZXhlY0Z1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2Nyb2xsUmVzcG9uZGVyKGV4ZWNGdW5jLCBlbWl0dGVyLCBjcmVhdGVEdXJhdGlvbih2aWV3T3B0aW9ucy5zY3JvbGxUaW1lKSwgdmlld09wdGlvbnMuc2Nyb2xsVGltZVJlc2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICAgICAgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxuICAgIH07XG59XG5cbi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogb2ZmICovXG5jbGFzcyBQdXJlQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhnZXRVbmVxdWFsUHJvcHMobmV4dFByb3BzLCB0aGlzLnByb3BzKSwgZ2V0VW5lcXVhbFByb3BzKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhY29tcGFyZU9ianModGhpcy5wcm9wcywgbmV4dFByb3BzLCB0aGlzLnByb3BFcXVhbGl0eSkgfHxcbiAgICAgICAgICAgICFjb21wYXJlT2Jqcyh0aGlzLnN0YXRlLCBuZXh0U3RhdGUsIHRoaXMuc3RhdGVFcXVhbGl0eSk7XG4gICAgfVxuICAgIC8vIEhBQ0sgZm9yIGZyZWFraW4nIFJlYWN0IFN0cmljdE1vZGVcbiAgICBzYWZlU2V0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgaWYgKCFjb21wYXJlT2Jqcyh0aGlzLnN0YXRlLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUpLCBuZXdTdGF0ZSksIHRoaXMuc3RhdGVFcXVhbGl0eSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuUHVyZUNvbXBvbmVudC5hZGRQcm9wc0VxdWFsaXR5ID0gYWRkUHJvcHNFcXVhbGl0eTtcblB1cmVDb21wb25lbnQuYWRkU3RhdGVFcXVhbGl0eSA9IGFkZFN0YXRlRXF1YWxpdHk7XG5QdXJlQ29tcG9uZW50LmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUucHJvcEVxdWFsaXR5ID0ge307XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5ID0ge307XG5jbGFzcyBCYXNlQ29tcG9uZW50IGV4dGVuZHMgUHVyZUNvbXBvbmVudCB7XG59XG5CYXNlQ29tcG9uZW50LmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuZnVuY3Rpb24gYWRkUHJvcHNFcXVhbGl0eShwcm9wRXF1YWxpdHkpIHtcbiAgICBsZXQgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUucHJvcEVxdWFsaXR5KTtcbiAgICBPYmplY3QuYXNzaWduKGhhc2gsIHByb3BFcXVhbGl0eSk7XG4gICAgdGhpcy5wcm90b3R5cGUucHJvcEVxdWFsaXR5ID0gaGFzaDtcbn1cbmZ1bmN0aW9uIGFkZFN0YXRlRXF1YWxpdHkoc3RhdGVFcXVhbGl0eSkge1xuICAgIGxldCBoYXNoID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZS5zdGF0ZUVxdWFsaXR5KTtcbiAgICBPYmplY3QuYXNzaWduKGhhc2gsIHN0YXRlRXF1YWxpdHkpO1xuICAgIHRoaXMucHJvdG90eXBlLnN0YXRlRXF1YWxpdHkgPSBoYXNoO1xufVxuLy8gdXNlIG90aGVyIG9uZVxuZnVuY3Rpb24gc2V0UmVmKHJlZiwgY3VycmVudCkge1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlZihjdXJyZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVmKSB7XG4gICAgICAgIC8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMDI5XG4gICAgICAgIHJlZi5jdXJyZW50ID0gY3VycmVudDtcbiAgICB9XG59XG5cbmNsYXNzIENvbnRlbnRJbmplY3RvciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gZ3VpZCgpO1xuICAgICAgICB0aGlzLnF1ZXVlZERvbU5vZGVzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudERvbU5vZGVzID0gW107XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICAgICAgY29uc3QgeyBnZW5lcmF0b3JOYW1lIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmN1c3RvbVJlbmRlcmluZ1JlcGxhY2VzIHx8ICFoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKGdlbmVyYXRvck5hbWUsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbFJlZihlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlRWxSZWYgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKHRoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHsgY3VzdG9tR2VuZXJhdG9yLCBkZWZhdWx0R2VuZXJhdG9yLCByZW5kZXJQcm9wcyB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gYnVpbGRFbEF0dHJzKHByb3BzLCBbXSwgdGhpcy5oYW5kbGVFbCk7XG4gICAgICAgIGxldCB1c2VEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIGxldCBpbm5lckNvbnRlbnQ7XG4gICAgICAgIGxldCBxdWV1ZWREb21Ob2RlcyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudEdlbmVyYXRvck1ldGE7XG4gICAgICAgIGlmIChjdXN0b21HZW5lcmF0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tR2VuZXJhdG9yUmVzID0gdHlwZW9mIGN1c3RvbUdlbmVyYXRvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgY3VzdG9tR2VuZXJhdG9yKHJlbmRlclByb3BzLCBjcmVhdGVFbGVtZW50KSA6XG4gICAgICAgICAgICAgICAgY3VzdG9tR2VuZXJhdG9yO1xuICAgICAgICAgICAgaWYgKGN1c3RvbUdlbmVyYXRvclJlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHVzZURlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNPYmplY3QgPSBjdXN0b21HZW5lcmF0b3JSZXMgJiYgdHlwZW9mIGN1c3RvbUdlbmVyYXRvclJlcyA9PT0gJ29iamVjdCc7IC8vIG5vbi1udWxsXG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0ICYmICgnaHRtbCcgaW4gY3VzdG9tR2VuZXJhdG9yUmVzKSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRycy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9IHsgX19odG1sOiBjdXN0b21HZW5lcmF0b3JSZXMuaHRtbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdCAmJiAoJ2RvbU5vZGVzJyBpbiBjdXN0b21HZW5lcmF0b3JSZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlZERvbU5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY3VzdG9tR2VuZXJhdG9yUmVzLmRvbU5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgPyBpc1ZhbGlkRWxlbWVudChjdXN0b21HZW5lcmF0b3JSZXMpIC8vIHZkb20gbm9kZVxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBjdXN0b21HZW5lcmF0b3JSZXMgIT09ICdmdW5jdGlvbicgLy8gcHJpbWl0aXZlIHZhbHVlIChsaWtlIHN0cmluZyBvciBudW1iZXIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBpbiB2ZG9tXG4gICAgICAgICAgICAgICAgICAgIGlubmVyQ29udGVudCA9IGN1c3RvbUdlbmVyYXRvclJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGV4b3RpYyBvYmplY3QgZm9yIGhhbmRsZUN1c3RvbVJlbmRlcmluZ1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50R2VuZXJhdG9yTWV0YSA9IGN1c3RvbUdlbmVyYXRvclJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1c2VEZWZhdWx0ID0gIWhhc0N1c3RvbVJlbmRlcmluZ0hhbmRsZXIocHJvcHMuZ2VuZXJhdG9yTmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZURlZmF1bHQgJiYgZGVmYXVsdEdlbmVyYXRvcikge1xuICAgICAgICAgICAgaW5uZXJDb250ZW50ID0gZGVmYXVsdEdlbmVyYXRvcihyZW5kZXJQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWV1ZWREb21Ob2RlcyA9IHF1ZXVlZERvbU5vZGVzO1xuICAgICAgICB0aGlzLmN1cnJlbnRHZW5lcmF0b3JNZXRhID0gY3VycmVudEdlbmVyYXRvck1ldGE7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KHByb3BzLmVsVGFnLCBhdHRycywgaW5uZXJDb250ZW50KTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuYXBwbHlRdWV1ZXVkRG9tTm9kZXMoKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tUmVuZGVyaW5nKHRydWUpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuYXBwbHlRdWV1ZXVkRG9tTm9kZXMoKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tUmVuZGVyaW5nKHRydWUpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyQ3VzdG9tUmVuZGVyaW5nKGZhbHNlKTsgLy8gVE9ETzogZGlmZmVyZW50IEFQSSBmb3IgcmVtb3ZhbD9cbiAgICB9XG4gICAgdHJpZ2dlckN1c3RvbVJlbmRlcmluZyhpc0FjdGl2ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgaGFuZGxlQ3VzdG9tUmVuZGVyaW5nLCBjdXN0b21SZW5kZXJpbmdNZXRhTWFwIH0gPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGlmIChoYW5kbGVDdXN0b21SZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRvck1ldGEgPSAoX2EgPSB0aGlzLmN1cnJlbnRHZW5lcmF0b3JNZXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXN0b21SZW5kZXJpbmdNZXRhTWFwID09PSBudWxsIHx8IGN1c3RvbVJlbmRlcmluZ01ldGFNYXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1c3RvbVJlbmRlcmluZ01ldGFNYXBbcHJvcHMuZ2VuZXJhdG9yTmFtZV07XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdG9yTWV0YSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUN1c3RvbVJlbmRlcmluZyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBpZDogdGhpcy5pZCwgaXNBY3RpdmUsIGNvbnRhaW5lckVsOiB0aGlzLmJhc2UsIHJlcG9ydE5ld0NvbnRhaW5lckVsOiB0aGlzLnVwZGF0ZUVsUmVmLCAvLyBmcm9udC1lbmQgZnJhbWV3b3JrIHRlbGxzIHVzIGFib3V0IG5ldyBjb250YWluZXIgZWxzXG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRvck1ldGEgfSwgcHJvcHMpLCB7IGVsQ2xhc3NlczogKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSkuZmlsdGVyKGlzVHJ1dGh5KSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwbHlRdWV1ZXVkRG9tTm9kZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgcXVldWVkRG9tTm9kZXMsIGN1cnJlbnREb21Ob2RlcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmJhc2U7XG4gICAgICAgIGlmICghaXNBcnJheXNFcXVhbChxdWV1ZWREb21Ob2RlcywgY3VycmVudERvbU5vZGVzKSkge1xuICAgICAgICAgICAgY3VycmVudERvbU5vZGVzLmZvckVhY2gocmVtb3ZlRWxlbWVudCk7XG4gICAgICAgICAgICBmb3IgKGxldCBuZXdOb2RlIG9mIHF1ZXVlZERvbU5vZGVzKSB7XG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREb21Ob2RlcyA9IHF1ZXVlZERvbU5vZGVzO1xuICAgICAgICB9XG4gICAgfVxufVxuQ29udGVudEluamVjdG9yLmFkZFByb3BzRXF1YWxpdHkoe1xuICAgIGVsQ2xhc3NlczogaXNBcnJheXNFcXVhbCxcbiAgICBlbFN0eWxlOiBpc1Byb3BzRXF1YWwsXG4gICAgZWxBdHRyczogaXNOb25IYW5kbGVyUHJvcHNFcXVhbCxcbiAgICByZW5kZXJQcm9wczogaXNQcm9wc0VxdWFsLFxufSk7XG4vLyBVdGlsXG4vKlxuRG9lcyBVSS1mcmFtZXdvcmsgcHJvdmlkZSBjdXN0b20gd2F5IG9mIHJlbmRlcmluZyB0aGF0IGRvZXMgbm90IHVzZSBQcmVhY3QgVkRPTVxuQU5EIGRvZXMgdGhlIGNhbGVuZGFyJ3Mgb3B0aW9ucyBkZWZpbmUgY3VzdG9tIHJlbmRlcmluZz9cbkFLQS4gU2hvdWxkIHdlIE5PVCByZW5kZXIgdGhlIGRlZmF1bHQgY29udGVudD9cbiovXG5mdW5jdGlvbiBoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKGdlbmVyYXRvck5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIEJvb2xlYW4ob3B0aW9ucy5oYW5kbGVDdXN0b21SZW5kZXJpbmcgJiZcbiAgICAgICAgZ2VuZXJhdG9yTmFtZSAmJlxuICAgICAgICAoKF9hID0gb3B0aW9ucy5jdXN0b21SZW5kZXJpbmdNZXRhTWFwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbZ2VuZXJhdG9yTmFtZV0pKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRWxBdHRycyhwcm9wcywgZXh0cmFDbGFzc05hbWVzLCBlbFJlZikge1xuICAgIGNvbnN0IGF0dHJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5lbEF0dHJzKSwgeyByZWY6IGVsUmVmIH0pO1xuICAgIGlmIChwcm9wcy5lbENsYXNzZXMgfHwgZXh0cmFDbGFzc05hbWVzKSB7XG4gICAgICAgIGF0dHJzLmNsYXNzTmFtZSA9IChwcm9wcy5lbENsYXNzZXMgfHwgW10pXG4gICAgICAgICAgICAuY29uY2F0KGV4dHJhQ2xhc3NOYW1lcyB8fCBbXSlcbiAgICAgICAgICAgIC5jb25jYXQoYXR0cnMuY2xhc3NOYW1lIHx8IFtdKVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmVsU3R5bGUpIHtcbiAgICAgICAgYXR0cnMuc3R5bGUgPSBwcm9wcy5lbFN0eWxlO1xuICAgIH1cbiAgICByZXR1cm4gYXR0cnM7XG59XG5mdW5jdGlvbiBpc1RydXRoeSh2YWwpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWwpO1xufVxuXG5jb25zdCBSZW5kZXJJZCA9IGNyZWF0ZUNvbnRleHQoMCk7XG5cbmNsYXNzIENvbnRlbnRDb250YWluZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLklubmVyQ29udGVudCA9IElubmVyQ29udGVudEluamVjdG9yLmJpbmQodW5kZWZpbmVkLCB0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFbCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICAgICAgICAgIGlmIChlbCAmJiB0aGlzLmRpZE1vdW50TWlzZmlyZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZENsYXNzTmFtZXMgPSBnZW5lcmF0ZUNsYXNzTmFtZXMocHJvcHMuY2xhc3NOYW1lR2VuZXJhdG9yLCBwcm9wcy5yZW5kZXJQcm9wcyk7XG4gICAgICAgIGlmIChwcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgY29uc3QgZWxBdHRycyA9IGJ1aWxkRWxBdHRycyhwcm9wcywgZ2VuZXJhdGVkQ2xhc3NOYW1lcywgdGhpcy5oYW5kbGVFbCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuKHRoaXMuSW5uZXJDb250ZW50LCBwcm9wcy5yZW5kZXJQcm9wcywgZWxBdHRycyk7XG4gICAgICAgICAgICBpZiAocHJvcHMuZWxUYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChwcm9wcy5lbFRhZywgZWxBdHRycywgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoKENvbnRlbnRJbmplY3RvciksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpLCB7IGVsUmVmOiB0aGlzLmhhbmRsZUVsLCBlbFRhZzogcHJvcHMuZWxUYWcgfHwgJ2RpdicsIGVsQ2xhc3NlczogKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSkuY29uY2F0KGdlbmVyYXRlZENsYXNzTmFtZXMpLCByZW5kZXJJZDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMucHJvcHMpLmRpZE1vdW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLnJlbmRlclByb3BzKSwgeyBlbDogdGhpcy5lbCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpZE1vdW50TWlzZmlyZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMucHJvcHMpLndpbGxVbm1vdW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzLnJlbmRlclByb3BzKSwgeyBlbDogdGhpcy5lbCB9KSk7XG4gICAgfVxufVxuQ29udGVudENvbnRhaW5lci5jb250ZXh0VHlwZSA9IFJlbmRlcklkO1xuZnVuY3Rpb24gSW5uZXJDb250ZW50SW5qZWN0b3IoY29udGFpbmVyQ29tcG9uZW50LCBwcm9wcykge1xuICAgIGNvbnN0IHBhcmVudFByb3BzID0gY29udGFpbmVyQ29tcG9uZW50LnByb3BzO1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KChDb250ZW50SW5qZWN0b3IpLCBPYmplY3QuYXNzaWduKHsgcmVuZGVyUHJvcHM6IHBhcmVudFByb3BzLnJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBwYXJlbnRQcm9wcy5nZW5lcmF0b3JOYW1lLCBjdXN0b21HZW5lcmF0b3I6IHBhcmVudFByb3BzLmN1c3RvbUdlbmVyYXRvciwgZGVmYXVsdEdlbmVyYXRvcjogcGFyZW50UHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgcmVuZGVySWQ6IGNvbnRhaW5lckNvbXBvbmVudC5jb250ZXh0IH0sIHByb3BzKSk7XG59XG4vLyBVdGlsc1xuZnVuY3Rpb24gZ2VuZXJhdGVDbGFzc05hbWVzKGNsYXNzTmFtZUdlbmVyYXRvciwgcmVuZGVyUHJvcHMpIHtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdHlwZW9mIGNsYXNzTmFtZUdlbmVyYXRvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGNsYXNzTmFtZUdlbmVyYXRvcihyZW5kZXJQcm9wcykgOlxuICAgICAgICBjbGFzc05hbWVHZW5lcmF0b3IgfHwgW107XG4gICAgcmV0dXJuIHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJyA/IFtjbGFzc05hbWVzXSA6IGNsYXNzTmFtZXM7XG59XG5cbmNsYXNzIFZpZXdDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7IHZpZXc6IGNvbnRleHQudmlld0FwaSB9O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMsIHsgZWxUYWc6IHByb3BzLmVsVGFnIHx8ICdkaXYnLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAuLi5idWlsZFZpZXdDbGFzc05hbWVzKHByb3BzLnZpZXdTcGVjKSxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZWxDbGFzc2VzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLnZpZXdDbGFzc05hbWVzLCBnZW5lcmF0b3JOYW1lOiB1bmRlZmluZWQsIGRpZE1vdW50OiBvcHRpb25zLnZpZXdEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMudmlld1dpbGxVbm1vdW50IH0pLCAoKSA9PiBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld0NsYXNzTmFtZXModmlld1NwZWMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBgZmMtJHt2aWV3U3BlYy50eXBlfS12aWV3YCxcbiAgICAgICAgJ2ZjLXZpZXcnLFxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUmFuZ2UoaW5wdXQsIGRhdGVFbnYpIHtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIGxldCBlbmQgPSBudWxsO1xuICAgIGlmIChpbnB1dC5zdGFydCkge1xuICAgICAgICBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGlucHV0LnN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKGlucHV0LmVuZCkge1xuICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbnB1dC5lbmQpO1xuICAgIH1cbiAgICBpZiAoIXN0YXJ0ICYmICFlbmQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChzdGFydCAmJiBlbmQgJiYgZW5kIDwgc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cbi8vIFNJREUtRUZGRUNUOiB3aWxsIG11dGF0ZSByYW5nZXMuXG4vLyBXaWxsIHJldHVybiBhIG5ldyBhcnJheSByZXN1bHQuXG5mdW5jdGlvbiBpbnZlcnRSYW5nZXMocmFuZ2VzLCBjb25zdHJhaW50UmFuZ2UpIHtcbiAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBbXTtcbiAgICBsZXQgeyBzdGFydCB9ID0gY29uc3RyYWludFJhbmdlOyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcbiAgICBsZXQgaTtcbiAgICBsZXQgZGF0ZVJhbmdlO1xuICAgIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cbiAgICByYW5nZXMuc29ydChjb21wYXJlUmFuZ2VzKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGRhdGVSYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYmVmb3JlIHRoZSBldmVudCAoaWYgdGhlcmUgaXMgYW55KVxuICAgICAgICBpZiAoZGF0ZVJhbmdlLnN0YXJ0ID4gc3RhcnQpIHsgLy8gY29tcGFyZSBtaWxsaXNlY29uZCB0aW1lIChza2lwIGFueSBhbWJpZyBsb2dpYylcbiAgICAgICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydCwgZW5kOiBkYXRlUmFuZ2Uuc3RhcnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGVSYW5nZS5lbmQgPiBzdGFydCkge1xuICAgICAgICAgICAgc3RhcnQgPSBkYXRlUmFuZ2UuZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGFmdGVyIHRoZSBsYXN0IGV2ZW50IChpZiB0aGVyZSBpcyBhbnkpXG4gICAgaWYgKHN0YXJ0IDwgY29uc3RyYWludFJhbmdlLmVuZCkgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxuICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZDogY29uc3RyYWludFJhbmdlLmVuZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGludmVydGVkUmFuZ2VzO1xufVxuZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiByYW5nZTAuc3RhcnQudmFsdWVPZigpIC0gcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKTsgLy8gZWFybGllciByYW5nZXMgZ28gZmlyc3Rcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xuICAgIGxldCB7IHN0YXJ0LCBlbmQgfSA9IHJhbmdlMDtcbiAgICBsZXQgbmV3UmFuZ2UgPSBudWxsO1xuICAgIGlmIChyYW5nZTEuc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IHJhbmdlMS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoTWF0aC5tYXgoc3RhcnQudmFsdWVPZigpLCByYW5nZTEuc3RhcnQudmFsdWVPZigpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhbmdlMS5lbmQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoZW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSByYW5nZTEuZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gbmV3IERhdGUoTWF0aC5taW4oZW5kLnZhbHVlT2YoKSwgcmFuZ2UxLmVuZC52YWx1ZU9mKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZW5kID09PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIG5ld1JhbmdlID0geyBzdGFydCwgZW5kIH07XG4gICAgfVxuICAgIHJldHVybiBuZXdSYW5nZTtcbn1cbmZ1bmN0aW9uIHJhbmdlc0VxdWFsKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIChyYW5nZTAuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSkgPT09IChyYW5nZTEuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkgJiZcbiAgICAgICAgKHJhbmdlMC5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLmVuZC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTEuZW5kLnZhbHVlT2YoKSk7XG59XG5mdW5jdGlvbiByYW5nZXNJbnRlcnNlY3QocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gKHJhbmdlMC5lbmQgPT09IG51bGwgfHwgcmFuZ2UxLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMC5lbmQgPiByYW5nZTEuc3RhcnQpICYmXG4gICAgICAgIChyYW5nZTAuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UxLmVuZCA9PT0gbnVsbCB8fCByYW5nZTAuc3RhcnQgPCByYW5nZTEuZW5kKTtcbn1cbmZ1bmN0aW9uIHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSB7XG4gICAgcmV0dXJuIChvdXRlclJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IChpbm5lclJhbmdlLnN0YXJ0ICE9PSBudWxsICYmIGlubmVyUmFuZ2Uuc3RhcnQgPj0gb3V0ZXJSYW5nZS5zdGFydCkpICYmXG4gICAgICAgIChvdXRlclJhbmdlLmVuZCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5lbmQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5lbmQgPD0gb3V0ZXJSYW5nZS5lbmQpKTtcbn1cbmZ1bmN0aW9uIHJhbmdlQ29udGFpbnNNYXJrZXIocmFuZ2UsIGRhdGUpIHtcbiAgICByZXR1cm4gKHJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IGRhdGUgPj0gcmFuZ2Uuc3RhcnQpICYmXG4gICAgICAgIChyYW5nZS5lbmQgPT09IG51bGwgfHwgZGF0ZSA8IHJhbmdlLmVuZCk7XG59XG4vLyBJZiB0aGUgZ2l2ZW4gZGF0ZSBpcyBub3Qgd2l0aGluIHRoZSBnaXZlbiByYW5nZSwgbW92ZSBpdCBpbnNpZGUuXG4vLyAoSWYgaXQncyBwYXN0IHRoZSBlbmQsIG1ha2UgaXQgb25lIG1pbGxpc2Vjb25kIGJlZm9yZSB0aGUgZW5kKS5cbmZ1bmN0aW9uIGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoZGF0ZSwgcmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCAmJiBkYXRlIDwgcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwgJiYgZGF0ZSA+PSByYW5nZS5lbmQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHJhbmdlLmVuZC52YWx1ZU9mKCkgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG59XG5cbi8qIERhdGUgc3R1ZmYgdGhhdCBkb2Vzbid0IGJlbG9uZyBpbiBkYXRlbGliIGNvcmVcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLy8gZ2l2ZW4gYSB0aW1lZCByYW5nZSwgY29tcHV0ZXMgYW4gYWxsLWRheSByYW5nZSB0aGF0IGhhcyB0aGUgc2FtZSBleGFjdCBkdXJhdGlvbixcbi8vIGJ1dCB3aG9zZSBzdGFydCB0aW1lIGlzIGFsaWduZWQgd2l0aCB0aGUgc3RhcnQgb2YgdGhlIGRheS5cbmZ1bmN0aW9uIGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UodGltZWRSYW5nZSkge1xuICAgIGxldCBkYXlDbnQgPSBNYXRoLmZsb29yKGRpZmZEYXlzKHRpbWVkUmFuZ2Uuc3RhcnQsIHRpbWVkUmFuZ2UuZW5kKSkgfHwgMTtcbiAgICBsZXQgc3RhcnQgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpO1xuICAgIGxldCBlbmQgPSBhZGREYXlzKHN0YXJ0LCBkYXlDbnQpO1xuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgYmFzZWQgb24gaG93IGZvciB0aGUgZW5kIGRhdGUgYmxlZWRzIGludG8gdGhlIG5leHQgZGF5XG4vLyBUT0RPOiBnaXZlIG5leHREYXlUaHJlc2hvbGQgYSBkZWZhdWx0IGFyZ1xuZnVuY3Rpb24gY29tcHV0ZVZpc2libGVEYXlSYW5nZSh0aW1lZFJhbmdlLCBuZXh0RGF5VGhyZXNob2xkID0gY3JlYXRlRHVyYXRpb24oMCkpIHtcbiAgICBsZXQgc3RhcnREYXkgPSBudWxsO1xuICAgIGxldCBlbmREYXkgPSBudWxsO1xuICAgIGlmICh0aW1lZFJhbmdlLmVuZCkge1xuICAgICAgICBlbmREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2UuZW5kKTtcbiAgICAgICAgbGV0IGVuZFRpbWVNUyA9IHRpbWVkUmFuZ2UuZW5kLnZhbHVlT2YoKSAtIGVuZERheS52YWx1ZU9mKCk7IC8vICMgb2YgbWlsbGlzZWNvbmRzIGludG8gYGVuZERheWBcbiAgICAgICAgLy8gSWYgdGhlIGVuZCB0aW1lIGlzIGFjdHVhbGx5IGluY2x1c2l2ZWx5IHBhcnQgb2YgdGhlIG5leHQgZGF5IGFuZCBpcyBlcXVhbCB0byBvclxuICAgICAgICAvLyBiZXlvbmQgdGhlIG5leHQgZGF5IHRocmVzaG9sZCwgYWRqdXN0IHRoZSBlbmQgdG8gYmUgdGhlIGV4Y2x1c2l2ZSBlbmQgb2YgYGVuZERheWAuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmluZyBpdCBhcyBpbmNsdXNpdmUgd2lsbCBjYXVzZSBpdCB0byBleGNsdWRlIGBlbmREYXlgLlxuICAgICAgICBpZiAoZW5kVGltZU1TICYmIGVuZFRpbWVNUyA+PSBhc1JvdWdoTXMobmV4dERheVRocmVzaG9sZCkpIHtcbiAgICAgICAgICAgIGVuZERheSA9IGFkZERheXMoZW5kRGF5LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZWRSYW5nZS5zdGFydCkge1xuICAgICAgICBzdGFydERheSA9IHN0YXJ0T2ZEYXkodGltZWRSYW5nZS5zdGFydCk7IC8vIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRheSB0aGUgcmFuZ2Ugc3RhcnRzXG4gICAgICAgIC8vIElmIGVuZCBpcyB3aXRoaW4gYHN0YXJ0RGF5YCBidXQgbm90IHBhc3QgbmV4dERheVRocmVzaG9sZCwgYXNzaWduIHRoZSBkZWZhdWx0IGR1cmF0aW9uIG9mIG9uZSBkYXkuXG4gICAgICAgIGlmIChlbmREYXkgJiYgZW5kRGF5IDw9IHN0YXJ0RGF5KSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKHN0YXJ0RGF5LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGFydDogc3RhcnREYXksIGVuZDogZW5kRGF5IH07XG59XG4vLyBzcGFucyBmcm9tIG9uZSBkYXkgaW50byBhbm90aGVyP1xuZnVuY3Rpb24gaXNNdWx0aURheVJhbmdlKHJhbmdlKSB7XG4gICAgbGV0IHZpc2libGVSYW5nZSA9IGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UocmFuZ2UpO1xuICAgIHJldHVybiBkaWZmRGF5cyh2aXNpYmxlUmFuZ2Uuc3RhcnQsIHZpc2libGVSYW5nZS5lbmQpID4gMTtcbn1cbmZ1bmN0aW9uIGRpZmZEYXRlcyhkYXRlMCwgZGF0ZTEsIGRhdGVFbnYsIGxhcmdlVW5pdCkge1xuICAgIGlmIChsYXJnZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVZZWFycyhkYXRlMCwgZGF0ZTEpLCAneWVhcicpO1xuICAgIH1cbiAgICBpZiAobGFyZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihkYXRlRW52LmRpZmZXaG9sZU1vbnRocyhkYXRlMCwgZGF0ZTEpLCAnbW9udGgnKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZmZEYXlBbmRUaW1lKGRhdGUwLCBkYXRlMSk7IC8vIHJldHVybnMgYSBkdXJhdGlvblxufVxuXG5mdW5jdGlvbiByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmRhdGVNYXJrZXI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbERhdGUob3B0aW9ucywgZGF0ZUVudikge1xuICAgIGxldCBpbml0aWFsRGF0ZUlucHV0ID0gb3B0aW9ucy5pbml0aWFsRGF0ZTtcbiAgICAvLyBjb21wdXRlIHRoZSBpbml0aWFsIGFtYmlnLXRpbWV6b25lIGRhdGVcbiAgICBpZiAoaW5pdGlhbERhdGVJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbml0aWFsRGF0ZUlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vdyhvcHRpb25zLm5vdywgZGF0ZUVudik7IC8vIGdldE5vdyBhbHJlYWR5IHJldHVybnMgdW56b25lZFxufVxuZnVuY3Rpb24gZ2V0Tm93KG5vd0lucHV0LCBkYXRlRW52KSB7XG4gICAgaWYgKHR5cGVvZiBub3dJbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBub3dJbnB1dCA9IG5vd0lucHV0KCk7XG4gICAgfVxuICAgIGlmIChub3dJbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU5vd01hcmtlcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVNYXJrZXIobm93SW5wdXQpO1xufVxuXG5jbGFzcyBEYXRlUHJvZmlsZUdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLm5vd0RhdGUgPSBnZXROb3cocHJvcHMubm93SW5wdXQsIHByb3BzLmRhdGVFbnYpO1xuICAgICAgICB0aGlzLmluaXRIaWRkZW5EYXlzKCk7XG4gICAgfVxuICAgIC8qIERhdGUgUmFuZ2UgQ29tcHV0YXRpb25cbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcInByZXZcIiB2aWV3LlxuICAgIGJ1aWxkUHJldihjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHByZXZEYXRlID0gZGF0ZUVudi5zdWJ0cmFjdChkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxuICAgICAgICBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKHByZXZEYXRlLCAtMSwgZm9yY2VUb1ZhbGlkKTtcbiAgICB9XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwibmV4dFwiIHZpZXcuXG4gICAgYnVpbGROZXh0KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZvcmNlVG9WYWxpZCkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgbmV4dERhdGUgPSBkYXRlRW52LmFkZChkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxuICAgICAgICBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKG5leHREYXRlLCAxLCBmb3JjZVRvVmFsaWQpO1xuICAgIH1cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgaG9sZGluZyBkYXRlcy9yYW5nZXMgZm9yIHJlbmRlcmluZyBhcm91bmQgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gT3B0aW9uYWwgZGlyZWN0aW9uIHBhcmFtIGluZGljYXRlcyB3aGV0aGVyIHRoZSBkYXRlIGlzIGJlaW5nIGluY3JlbWVudGVkL2RlY3JlbWVudGVkXG4gICAgLy8gZnJvbSBpdHMgcHJldmlvdXMgdmFsdWUuIGRlY3JlbWVudGVkID0gLTEsIGluY3JlbWVudGVkID0gMSAoZGVmYXVsdCkuXG4gICAgYnVpbGQoY3VycmVudERhdGUsIGRpcmVjdGlvbiwgZm9yY2VUb1ZhbGlkID0gdHJ1ZSkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHZhbGlkUmFuZ2U7XG4gICAgICAgIGxldCBjdXJyZW50SW5mbztcbiAgICAgICAgbGV0IGlzUmFuZ2VBbGxEYXk7XG4gICAgICAgIGxldCByZW5kZXJSYW5nZTtcbiAgICAgICAgbGV0IGFjdGl2ZVJhbmdlO1xuICAgICAgICBsZXQgaXNWYWxpZDtcbiAgICAgICAgdmFsaWRSYW5nZSA9IHRoaXMuYnVpbGRWYWxpZFJhbmdlKCk7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHZhbGlkUmFuZ2UpO1xuICAgICAgICBpZiAoZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoY3VycmVudERhdGUsIHZhbGlkUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmZvID0gdGhpcy5idWlsZEN1cnJlbnRSYW5nZUluZm8oY3VycmVudERhdGUsIGRpcmVjdGlvbik7XG4gICAgICAgIGlzUmFuZ2VBbGxEYXkgPSAvXih5ZWFyfG1vbnRofHdlZWt8ZGF5KSQvLnRlc3QoY3VycmVudEluZm8udW5pdCk7XG4gICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy5idWlsZFJlbmRlclJhbmdlKHRoaXMudHJpbUhpZGRlbkRheXMoY3VycmVudEluZm8ucmFuZ2UpLCBjdXJyZW50SW5mby51bml0LCBpc1JhbmdlQWxsRGF5KTtcbiAgICAgICAgcmVuZGVyUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHJlbmRlclJhbmdlKTtcbiAgICAgICAgYWN0aXZlUmFuZ2UgPSByZW5kZXJSYW5nZTtcbiAgICAgICAgaWYgKCFwcm9wcy5zaG93Tm9uQ3VycmVudERhdGVzKSB7XG4gICAgICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgY3VycmVudEluZm8ucmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gdGhpcy5hZGp1c3RBY3RpdmVSYW5nZShhY3RpdmVSYW5nZSk7XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGFjdGl2ZVJhbmdlLCB2YWxpZFJhbmdlKTsgLy8gbWlnaHQgcmV0dXJuIG51bGxcbiAgICAgICAgLy8gaXQncyBpbnZhbGlkIGlmIHRoZSBvcmlnaW5hbGx5IHJlcXVlc3RlZCBkYXRlIGlzIG5vdCBjb250YWluZWQsXG4gICAgICAgIC8vIG9yIGlmIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IG91dHNpZGUgb2YgdGhlIHZhbGlkIHJhbmdlLlxuICAgICAgICBpc1ZhbGlkID0gcmFuZ2VzSW50ZXJzZWN0KGN1cnJlbnRJbmZvLnJhbmdlLCB2YWxpZFJhbmdlKTtcbiAgICAgICAgLy8gSEFDSzogY29uc3RyYWluIHRvIHJlbmRlci1yYW5nZSBzbyBgY3VycmVudERhdGVgIGlzIG1vcmUgdXNlZnVsIHRvIHZpZXcgcmVuZGVyaW5nXG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc01hcmtlcihyZW5kZXJSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IHJlbmRlclJhbmdlLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbnQgZm9yIHdoZXJlIHByZXYvbmV4dCBvcGVyYXRpb25zIGNhbiBnbyBhbmQgd2hlcmUgZXZlbnRzIGNhbiBiZSBkcmFnZ2VkL3Jlc2l6ZWQgdG8uXG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YWxpZFJhbmdlLFxuICAgICAgICAgICAgLy8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yLlxuICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgbW9udGggdmlldyBtaWdodCBoYXZlIDFzdC0zMXN0LCBleGNsdWRpbmcgcGFkZGVkIGRhdGVzXG4gICAgICAgICAgICBjdXJyZW50UmFuZ2U6IGN1cnJlbnRJbmZvLnJhbmdlLFxuICAgICAgICAgICAgLy8gbmFtZSBvZiBsYXJnZXN0IHVuaXQgYmVpbmcgZGlzcGxheWVkLCBsaWtlIFwibW9udGhcIiBvciBcIndlZWtcIlxuICAgICAgICAgICAgY3VycmVudFJhbmdlVW5pdDogY3VycmVudEluZm8udW5pdCxcbiAgICAgICAgICAgIGlzUmFuZ2VBbGxEYXksXG4gICAgICAgICAgICAvLyBkYXRlcyB0aGF0IGRpc3BsYXkgZXZlbnRzIGFuZCBhY2NlcHQgZHJhZy1uLWRyb3BcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgYG51bGxgIGlmIG5vIGRhdGVzIGFjY2VwdCBldmVudHNcbiAgICAgICAgICAgIGFjdGl2ZVJhbmdlLFxuICAgICAgICAgICAgLy8gZGF0ZSByYW5nZSB3aXRoIGEgcmVuZGVyZWQgc2tlbGV0b25cbiAgICAgICAgICAgIC8vIGluY2x1ZGVzIG5vdC1hY3RpdmUgZGF5cyB0aGF0IG5lZWQgc29tZSBzb3J0IG9mIERPTVxuICAgICAgICAgICAgcmVuZGVyUmFuZ2UsXG4gICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBmaXJzdCB2aXNpYmxlIHRpbWUgb2YgYW55IGdpdmVuIGRheVxuICAgICAgICAgICAgc2xvdE1pblRpbWU6IHByb3BzLnNsb3RNaW5UaW1lLFxuICAgICAgICAgICAgLy8gRHVyYXRpb24gb2JqZWN0IHRoYXQgZGVub3RlcyB0aGUgZXhjbHVzaXZlIHZpc2libGUgZW5kIHRpbWUgb2YgYW55IGdpdmVuIGRheVxuICAgICAgICAgICAgc2xvdE1heFRpbWU6IHByb3BzLnNsb3RNYXhUaW1lLFxuICAgICAgICAgICAgaXNWYWxpZCxcbiAgICAgICAgICAgIC8vIGhvdyBmYXIgdGhlIGN1cnJlbnQgZGF0ZSB3aWxsIG1vdmUgZm9yIGEgcHJldi9uZXh0IG9wZXJhdGlvblxuICAgICAgICAgICAgZGF0ZUluY3JlbWVudDogdGhpcy5idWlsZERhdGVJbmNyZW1lbnQoY3VycmVudEluZm8uZHVyYXRpb24pLFxuICAgICAgICAgICAgLy8gcGFzcyBhIGZhbGxiYWNrIChtaWdodCBiZSBudWxsKSBeXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydC9lbmQgcHJvcGVydGllcy5cbiAgICAvLyBJbmRpY2F0ZXMgdGhlIG1pbmltdW0vbWF4aW11bSBkYXRlcyB0byBkaXNwbGF5LlxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gICAgYnVpbGRWYWxpZFJhbmdlKCkge1xuICAgICAgICBsZXQgaW5wdXQgPSB0aGlzLnByb3BzLnZhbGlkUmFuZ2VJbnB1dDtcbiAgICAgICAgbGV0IHNpbXBsZUlucHV0ID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGlucHV0LmNhbGwodGhpcy5wcm9wcy5jYWxlbmRhckFwaSwgdGhpcy5ub3dEYXRlKVxuICAgICAgICAgICAgOiBpbnB1dDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmaW5lUmFuZ2Uoc2ltcGxlSW5wdXQpIHx8XG4gICAgICAgICAgICB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTsgLy8gY29tcGxldGVseSBvcGVuLWVuZGVkXG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgdGhlIFwiY3VycmVudFwiIHJhbmdlLCB0aGUgcmFuZ2UgdGhhdCBpc1xuICAgIC8vIGhpZ2hsaWdodGVkIGFzIGJlaW5nIHRoZSBjdXJyZW50IG1vbnRoIGZvciBleGFtcGxlLlxuICAgIC8vIFNlZSBidWlsZCgpIGZvciBhIGRlc2NyaXB0aW9uIG9mIGBkaXJlY3Rpb25gLlxuICAgIC8vIEd1YXJhbnRlZWQgdG8gaGF2ZSBgcmFuZ2VgIGFuZCBgdW5pdGAgcHJvcGVydGllcy4gYGR1cmF0aW9uYCBpcyBvcHRpb25hbC5cbiAgICBidWlsZEN1cnJlbnRSYW5nZUluZm8oZGF0ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZHVyYXRpb24gPSBudWxsO1xuICAgICAgICBsZXQgdW5pdCA9IG51bGw7XG4gICAgICAgIGxldCByYW5nZSA9IG51bGw7XG4gICAgICAgIGxldCBkYXlDb3VudDtcbiAgICAgICAgaWYgKHByb3BzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHByb3BzLmR1cmF0aW9uO1xuICAgICAgICAgICAgdW5pdCA9IHByb3BzLmR1cmF0aW9uVW5pdDtcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChkYXlDb3VudCA9IHRoaXMucHJvcHMuZGF5Q291bnQpKSB7XG4gICAgICAgICAgICB1bml0ID0gJ2RheSc7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EYXlDb3VudChkYXRlLCBkaXJlY3Rpb24sIGRheUNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgocmFuZ2UgPSB0aGlzLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpKSkge1xuICAgICAgICAgICAgdW5pdCA9IHByb3BzLmRhdGVFbnYuZ3JlYXRlc3RXaG9sZVVuaXQocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCkudW5pdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gdGhpcy5nZXRGYWxsYmFja0R1cmF0aW9uKCk7XG4gICAgICAgICAgICB1bml0ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cmF0aW9uKS51bml0O1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZHVyYXRpb24sIHVuaXQsIHJhbmdlIH07XG4gICAgfVxuICAgIGdldEZhbGxiYWNrRHVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheTogMSB9KTtcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhIG5ldyBhY3RpdmVSYW5nZSB0byBoYXZlIHRpbWUgdmFsdWVzICh1bi1hbWJpZ3VhdGUpXG4gICAgLy8gc2xvdE1pblRpbWUgb3Igc2xvdE1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXG4gICAgYWRqdXN0QWN0aXZlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgdXNlc01pbk1heFRpbWUsIHNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcmFuZ2U7XG4gICAgICAgIGlmICh1c2VzTWluTWF4VGltZSkge1xuICAgICAgICAgICAgLy8gZXhwYW5kIGFjdGl2ZSByYW5nZSBpZiBzbG90TWluVGltZSBpcyBuZWdhdGl2ZSAod2h5IG5vdCB3aGVuIHBvc2l0aXZlPylcbiAgICAgICAgICAgIGlmIChhc1JvdWdoRGF5cyhzbG90TWluVGltZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzdGFydE9mRGF5KHN0YXJ0KTsgLy8gbmVjZXNzYXJ5P1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5hZGQoc3RhcnQsIHNsb3RNaW5UaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGV4cGFuZCBhY3RpdmUgcmFuZ2UgaWYgc2xvdE1heFRpbWUgaXMgYmV5b25kIG9uZSBkYXkgKHdoeSBub3Qgd2hlbiBuZWdhdGl2ZT8pXG4gICAgICAgICAgICBpZiAoYXNSb3VnaERheXMoc2xvdE1heFRpbWUpID4gMSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTsgLy8gbmVjZXNzYXJ5P1xuICAgICAgICAgICAgICAgIGVuZCA9IGFkZERheXMoZW5kLCAtMSk7XG4gICAgICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBzbG90TWF4VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xuICAgIH1cbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gaXQgaXMgc3BlY2lmaWVkIGFzIGFuIGV4cGxpY2l0IGR1cmF0aW9uLlxuICAgIC8vIGB1bml0YCBpcyB0aGUgYWxyZWFkeS1jb21wdXRlZCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgdW5pdCBvZiBkdXJhdGlvbi5cbiAgICBidWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgZGF0ZUFsaWdubWVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICAvLyBjb21wdXRlIHdoYXQgdGhlIGFsaWdubWVudCBzaG91bGQgYmVcbiAgICAgICAgaWYgKCFkYXRlQWxpZ25tZW50KSB7XG4gICAgICAgICAgICBsZXQgeyBkYXRlSW5jcmVtZW50IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHNtYWxsZXIgb2YgdGhlIHR3byB1bml0c1xuICAgICAgICAgICAgICAgIGlmIChhc1JvdWdoTXMoZGF0ZUluY3JlbWVudCkgPCBhc1JvdWdoTXMoZHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZGF0ZUluY3JlbWVudCkudW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQgPSB1bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSB2aWV3IGRpc3BsYXlzIGEgc2luZ2xlIGRheSBvciBzbWFsbGVyXG4gICAgICAgIGlmIChhc1JvdWdoRGF5cyhkdXJhdGlvbikgPD0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW5EYXkoc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRPZkRheShzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZVJlcygpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mKGRhdGUsIGRhdGVBbGlnbm1lbnQpO1xuICAgICAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJlcyA9IHsgc3RhcnQsIGVuZCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgLy8gaWYgcmFuZ2UgaXMgY29tcGxldGVseSBlbnZlbG9wZWQgYnkgaGlkZGVuIGRheXMsIGdvIHBhc3QgdGhlIGhpZGRlbiBkYXlzXG4gICAgICAgIGlmICghdGhpcy50cmltSGlkZGVuRGF5cyhyZXMpKSB7XG4gICAgICAgICAgICBkYXRlID0gdGhpcy5za2lwSGlkZGVuRGF5cyhkYXRlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgY29tcHV0ZVJlcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8vIEJ1aWxkcyB0aGUgXCJjdXJyZW50XCIgcmFuZ2Ugd2hlbiBhIGRheUNvdW50IGlzIHNwZWNpZmllZC5cbiAgICBidWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgZGF0ZUFsaWdubWVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHJ1bm5pbmdDb3VudCA9IDA7XG4gICAgICAgIGxldCBzdGFydCA9IGRhdGU7XG4gICAgICAgIGxldCBlbmQ7XG4gICAgICAgIGlmIChkYXRlQWxpZ25tZW50KSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihzdGFydCwgZGF0ZUFsaWdubWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBzdGFydE9mRGF5KHN0YXJ0KTtcbiAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0LCBkaXJlY3Rpb24pO1xuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZW5kID0gYWRkRGF5cyhlbmQsIDEpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuRGF5KGVuZCkpIHtcbiAgICAgICAgICAgICAgICBydW5uaW5nQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAocnVubmluZ0NvdW50IDwgZGF5Q291bnQpO1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgfVxuICAgIC8vIEJ1aWxkcyBhIG5vcm1hbGl6ZWQgcmFuZ2Ugb2JqZWN0IGZvciB0aGUgXCJ2aXNpYmxlXCIgcmFuZ2UsXG4gICAgLy8gd2hpY2ggaXMgYSB3YXkgdG8gZGVmaW5lIHRoZSBjdXJyZW50UmFuZ2UgYW5kIGFjdGl2ZVJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UoZGF0ZSkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGlucHV0ID0gcHJvcHMudmlzaWJsZVJhbmdlSW5wdXQ7XG4gICAgICAgIGxldCBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHByb3BzLmNhbGVuZGFyQXBpLCBwcm9wcy5kYXRlRW52LnRvRGF0ZShkYXRlKSlcbiAgICAgICAgICAgIDogaW5wdXQ7XG4gICAgICAgIGxldCByYW5nZSA9IHRoaXMucmVmaW5lUmFuZ2Uoc2ltcGxlSW5wdXQpO1xuICAgICAgICBpZiAocmFuZ2UgJiYgKHJhbmdlLnN0YXJ0ID09IG51bGwgfHwgcmFuZ2UuZW5kID09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcbiAgICAvLyBidXQgd2hpY2ggbWF5IGhhdmUgdm9pZGVkIGRheXMvdGltZXMuXG4gICAgLy8gbm90IHJlc3BvbnNpYmxlIGZvciB0cmltbWluZyBoaWRkZW4gZGF5cy5cbiAgICBidWlsZFJlbmRlclJhbmdlKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSkge1xuICAgICAgICByZXR1cm4gY3VycmVudFJhbmdlO1xuICAgIH1cbiAgICAvLyBDb21wdXRlIHRoZSBkdXJhdGlvbiB2YWx1ZSB0aGF0IHNob3VsZCBiZSBhZGRlZC9zdWJzdHJhY3RlZCB0byB0aGUgY3VycmVudCBkYXRlXG4gICAgLy8gd2hlbiBhIHByZXYvbmV4dCBvcGVyYXRpb24gaGFwcGVucy5cbiAgICBidWlsZERhdGVJbmNyZW1lbnQoZmFsbGJhY2spIHtcbiAgICAgICAgbGV0IHsgZGF0ZUluY3JlbWVudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IGN1c3RvbUFsaWdubWVudDtcbiAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlSW5jcmVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICgoY3VzdG9tQWxpZ25tZW50ID0gdGhpcy5wcm9wcy5kYXRlQWxpZ25tZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKDEsIGN1c3RvbUFsaWdubWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KTtcbiAgICB9XG4gICAgcmVmaW5lUmFuZ2UocmFuZ2VJbnB1dCkge1xuICAgICAgICBpZiAocmFuZ2VJbnB1dCkge1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gcGFyc2VSYW5nZShyYW5nZUlucHV0LCB0aGlzLnByb3BzLmRhdGVFbnYpO1xuICAgICAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyogSGlkZGVuIERheXNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIC8vIEluaXRpYWxpemVzIGludGVybmFsIHZhcmlhYmxlcyByZWxhdGVkIHRvIGNhbGN1bGF0aW5nIGhpZGRlbiBkYXlzLW9mLXdlZWtcbiAgICBpbml0SGlkZGVuRGF5cygpIHtcbiAgICAgICAgbGV0IGhpZGRlbkRheXMgPSB0aGlzLnByb3BzLmhpZGRlbkRheXMgfHwgW107IC8vIGFycmF5IG9mIGRheS1vZi13ZWVrIGluZGljZXMgdGhhdCBhcmUgaGlkZGVuXG4gICAgICAgIGxldCBpc0hpZGRlbkRheUhhc2ggPSBbXTsgLy8gaXMgdGhlIGRheS1vZi13ZWVrIGhpZGRlbj8gKGhhc2ggd2l0aCBkYXktb2Ytd2Vlay1pbmRleCAtPiBib29sKVxuICAgICAgICBsZXQgZGF5Q250ID0gMDtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLndlZWtlbmRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaGlkZGVuRGF5cy5wdXNoKDAsIDYpOyAvLyAwPXN1bmRheSwgNj1zYXR1cmRheVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghKGlzSGlkZGVuRGF5SGFzaFtpXSA9IGhpZGRlbkRheXMuaW5kZXhPZihpKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgZGF5Q250ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXlDbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBoaWRkZW5EYXlzJyk7IC8vIGFsbCBkYXlzIHdlcmUgaGlkZGVuPyBiYWQuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0hpZGRlbkRheUhhc2ggPSBpc0hpZGRlbkRheUhhc2g7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBkYXlzIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSByYW5nZSB0aGF0IGFyZSBjb21wdXRlZCBhcyBoaWRkZW4uXG4gICAgLy8gSWYgdGhlIHdob2xlIHJhbmdlIGlzIHRyaW1tZWQgb2ZmLCByZXR1cm5zIG51bGxcbiAgICB0cmltSGlkZGVuRGF5cyhyYW5nZSkge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSByYW5nZTtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZW5kLCAtMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwgfHwgZW5kID09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gSXMgdGhlIGN1cnJlbnQgZGF5IGhpZGRlbj9cbiAgICAvLyBgZGF5YCBpcyBhIGRheS1vZi13ZWVrIGluZGV4ICgwLTYpLCBvciBhIERhdGUgKHVzZWQgZm9yIFVUQylcbiAgICBpc0hpZGRlbkRheShkYXkpIHtcbiAgICAgICAgaWYgKGRheSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIGRheSA9IGRheS5nZXRVVENEYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc0hpZGRlbkRheUhhc2hbZGF5XTtcbiAgICB9XG4gICAgLy8gSW5jcmVtZW50aW5nIHRoZSBjdXJyZW50IGRheSB1bnRpbCBpdCBpcyBubyBsb25nZXIgYSBoaWRkZW4gZGF5LCByZXR1cm5pbmcgYSBjb3B5LlxuICAgIC8vIERPRVMgTk9UIENPTlNJREVSIHZhbGlkUmFuZ2UhXG4gICAgLy8gSWYgdGhlIGluaXRpYWwgdmFsdWUgb2YgYGRhdGVgIGlzIG5vdCBhIGhpZGRlbiBkYXksIGRvbid0IGRvIGFueXRoaW5nLlxuICAgIC8vIFBhc3MgYGlzRXhjbHVzaXZlYCBhcyBgdHJ1ZWAgaWYgeW91IGFyZSBkZWFsaW5nIHdpdGggYW4gZW5kIGRhdGUuXG4gICAgLy8gYGluY2AgZGVmYXVsdHMgdG8gYDFgIChpbmNyZW1lbnQgb25lIGRheSBmb3J3YXJkIGVhY2ggdGltZSlcbiAgICBza2lwSGlkZGVuRGF5cyhkYXRlLCBpbmMgPSAxLCBpc0V4Y2x1c2l2ZSA9IGZhbHNlKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLmlzSGlkZGVuRGF5SGFzaFsoZGF0ZS5nZXRVVENEYXkoKSArIChpc0V4Y2x1c2l2ZSA/IGluYyA6IDApICsgNykgJSA3XSkge1xuICAgICAgICAgICAgZGF0ZSA9IGFkZERheXMoZGF0ZSwgaW5jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHJhbmdlLCBmb3JjZWRTdGFydFR6bywgZm9yY2VkRW5kVHpvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFuY2VJZDogZ3VpZCgpLFxuICAgICAgICBkZWZJZCxcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBmb3JjZWRTdGFydFR6byA9PSBudWxsID8gbnVsbCA6IGZvcmNlZFN0YXJ0VHpvLFxuICAgICAgICBmb3JjZWRFbmRUem86IGZvcmNlZEVuZFR6byA9PSBudWxsID8gbnVsbCA6IGZvcmNlZEVuZFR6byxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlY3VycmluZyhyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBkYXRlRW52LCByZWN1cnJpbmdUeXBlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdXJyaW5nVHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHBhcnNlZCA9IHJlY3VycmluZ1R5cGVzW2ldLnBhcnNlKHJlZmluZWQsIGRhdGVFbnYpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICBsZXQgeyBhbGxEYXkgfSA9IHJlZmluZWQ7XG4gICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5O1xuICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXkgPSBwYXJzZWQuYWxsRGF5R3Vlc3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFsbERheSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogcGFyc2VkLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGVEYXRhOiBwYXJzZWQudHlwZURhdGEsXG4gICAgICAgICAgICAgICAgdHlwZUlkOiBpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGV4cGFuZFJlY3VycmluZyhldmVudFN0b3JlLCBmcmFtaW5nUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBwbHVnaW5Ib29rcywgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgLy8gcmVtb3ZlIGV4aXN0aW5nIHJlY3VycmluZyBpbnN0YW5jZXNcbiAgICAvLyBUT0RPOiBiYWQuIGFsd2F5cyBleHBhbmQgZXZlbnRzIGFzIGEgc2Vjb25kIHN0ZXBcbiAgICBpbnN0YW5jZXMgPSBmaWx0ZXJIYXNoKGluc3RhbmNlcywgKGluc3RhbmNlKSA9PiAhZGVmc1tpbnN0YW5jZS5kZWZJZF0ucmVjdXJyaW5nRGVmKTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgIGxldCBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICAgIGxldCB7IGR1cmF0aW9uIH0gPSBkZWYucmVjdXJyaW5nRGVmO1xuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZGVmLmFsbERheSA/XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnRzID0gZXhwYW5kUmVjdXJyaW5nUmFuZ2VzKGRlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcGx1Z2luSG9va3MucmVjdXJyaW5nVHlwZXMpO1xuICAgICAgICAgICAgZm9yIChsZXQgc3RhcnQgb2Ygc3RhcnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWZJZCwge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChzdGFydCwgZHVyYXRpb24pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGRlZnMsIGluc3RhbmNlcyB9O1xufVxuLypcbkV2ZW50IE1VU1QgaGF2ZSBhIHJlY3VycmluZ0RlZlxuKi9cbmZ1bmN0aW9uIGV4cGFuZFJlY3VycmluZ1JhbmdlcyhldmVudERlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICBsZXQgdHlwZURlZiA9IHJlY3VycmluZ1R5cGVzW2V2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlSWRdO1xuICAgIGxldCBtYXJrZXJzID0gdHlwZURlZi5leHBhbmQoZXZlbnREZWYucmVjdXJyaW5nRGVmLnR5cGVEYXRhLCB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnN1YnRyYWN0KGZyYW1pbmdSYW5nZS5zdGFydCwgZHVyYXRpb24pLFxuICAgICAgICBlbmQ6IGZyYW1pbmdSYW5nZS5lbmQsXG4gICAgfSwgZGF0ZUVudik7XG4gICAgLy8gdGhlIHJlY3VycmVuY2UgcGx1Z2lucyBkb24ndCBndWFyYW50ZWUgdGhhdCBhbGwtZGF5IGV2ZW50cyBhcmUgc3RhcnQtb2YtZGF5LCBzbyB3ZSBoYXZlIHRvXG4gICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5tYXAoc3RhcnRPZkRheSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJzO1xufVxuXG5jb25zdCBFVkVOVF9OT05fREFURV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGdyb3VwSWQ6IFN0cmluZyxcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIHVybDogU3RyaW5nLFxuICAgIGludGVyYWN0aXZlOiBCb29sZWFuLFxufTtcbmNvbnN0IEVWRU5UX0RBVEVfUkVGSU5FUlMgPSB7XG4gICAgc3RhcnQ6IGlkZW50aXR5LFxuICAgIGVuZDogaWRlbnRpdHksXG4gICAgZGF0ZTogaWRlbnRpdHksXG4gICAgYWxsRGF5OiBCb29sZWFuLFxufTtcbmNvbnN0IEVWRU5UX1JFRklORVJTID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVWRU5UX05PTl9EQVRFX1JFRklORVJTKSwgRVZFTlRfREFURV9SRUZJTkVSUyksIHsgZXh0ZW5kZWRQcm9wczogaWRlbnRpdHkgfSk7XG5mdW5jdGlvbiBwYXJzZUV2ZW50KHJhdywgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCByZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KSwgZGVmSWRNYXAsIGluc3RhbmNlSWRNYXApIHtcbiAgICBsZXQgeyByZWZpbmVkLCBleHRyYSB9ID0gcmVmaW5lRXZlbnREZWYocmF3LCBjb250ZXh0LCByZWZpbmVycyk7XG4gICAgbGV0IGRlZmF1bHRBbGxEYXkgPSBjb21wdXRlSXNEZWZhdWx0QWxsRGF5KGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICBsZXQgcmVjdXJyaW5nUmVzID0gcGFyc2VSZWN1cnJpbmcocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dC5kYXRlRW52LCBjb250ZXh0LnBsdWdpbkhvb2tzLnJlY3VycmluZ1R5cGVzKTtcbiAgICBpZiAocmVjdXJyaW5nUmVzKSB7XG4gICAgICAgIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBldmVudFNvdXJjZSA/IGV2ZW50U291cmNlLnNvdXJjZUlkIDogJycsIHJlY3VycmluZ1Jlcy5hbGxEYXksIEJvb2xlYW4ocmVjdXJyaW5nUmVzLmR1cmF0aW9uKSwgY29udGV4dCwgZGVmSWRNYXApO1xuICAgICAgICBkZWYucmVjdXJyaW5nRGVmID0ge1xuICAgICAgICAgICAgdHlwZUlkOiByZWN1cnJpbmdSZXMudHlwZUlkLFxuICAgICAgICAgICAgdHlwZURhdGE6IHJlY3VycmluZ1Jlcy50eXBlRGF0YSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiByZWN1cnJpbmdSZXMuZHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRlZiwgaW5zdGFuY2U6IG51bGwgfTtcbiAgICB9XG4gICAgbGV0IHNpbmdsZVJlcyA9IHBhcnNlU2luZ2xlKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQsIGFsbG93T3BlblJhbmdlKTtcbiAgICBpZiAoc2luZ2xlUmVzKSB7XG4gICAgICAgIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlZmluZWQsIGV4dHJhLCBldmVudFNvdXJjZSA/IGV2ZW50U291cmNlLnNvdXJjZUlkIDogJycsIHNpbmdsZVJlcy5hbGxEYXksIHNpbmdsZVJlcy5oYXNFbmQsIGNvbnRleHQsIGRlZklkTWFwKTtcbiAgICAgICAgbGV0IGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIHNpbmdsZVJlcy5yYW5nZSwgc2luZ2xlUmVzLmZvcmNlZFN0YXJ0VHpvLCBzaW5nbGVSZXMuZm9yY2VkRW5kVHpvKTtcbiAgICAgICAgaWYgKGluc3RhbmNlSWRNYXAgJiYgZGVmLnB1YmxpY0lkICYmIGluc3RhbmNlSWRNYXBbZGVmLnB1YmxpY0lkXSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuaW5zdGFuY2VJZCA9IGluc3RhbmNlSWRNYXBbZGVmLnB1YmxpY0lkXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkZWYsIGluc3RhbmNlIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVmaW5lRXZlbnREZWYocmF3LCBjb250ZXh0LCByZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KSkge1xuICAgIHJldHVybiByZWZpbmVQcm9wcyhyYXcsIHJlZmluZXJzKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBFVkVOVF9VSV9SRUZJTkVSUyksIEVWRU5UX1JFRklORVJTKSwgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFJlZmluZXJzKTtcbn1cbi8qXG5XaWxsIE5PVCBwb3B1bGF0ZSBleHRlbmRlZFByb3BzIHdpdGggdGhlIGxlZnRvdmVyIHByb3BlcnRpZXMuXG5XaWxsIE5PVCBwb3B1bGF0ZSBkYXRlLXJlbGF0ZWQgcHJvcHMuXG4qL1xuZnVuY3Rpb24gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgc291cmNlSWQsIGFsbERheSwgaGFzRW5kLCBjb250ZXh0LCBkZWZJZE1hcCkge1xuICAgIGxldCBkZWYgPSB7XG4gICAgICAgIHRpdGxlOiByZWZpbmVkLnRpdGxlIHx8ICcnLFxuICAgICAgICBncm91cElkOiByZWZpbmVkLmdyb3VwSWQgfHwgJycsXG4gICAgICAgIHB1YmxpY0lkOiByZWZpbmVkLmlkIHx8ICcnLFxuICAgICAgICB1cmw6IHJlZmluZWQudXJsIHx8ICcnLFxuICAgICAgICByZWN1cnJpbmdEZWY6IG51bGwsXG4gICAgICAgIGRlZklkOiAoKGRlZklkTWFwICYmIHJlZmluZWQuaWQpID8gZGVmSWRNYXBbcmVmaW5lZC5pZF0gOiAnJykgfHwgZ3VpZCgpLFxuICAgICAgICBzb3VyY2VJZCxcbiAgICAgICAgYWxsRGF5LFxuICAgICAgICBoYXNFbmQsXG4gICAgICAgIGludGVyYWN0aXZlOiByZWZpbmVkLmludGVyYWN0aXZlLFxuICAgICAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICAgICAgZXh0ZW5kZWRQcm9wczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAocmVmaW5lZC5leHRlbmRlZFByb3BzIHx8IHt9KSksIGV4dHJhKSxcbiAgICB9O1xuICAgIGZvciAobGV0IG1lbWJlckFkZGVyIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNZW1iZXJBZGRlcnMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihkZWYsIG1lbWJlckFkZGVyKHJlZmluZWQpKTtcbiAgICB9XG4gICAgLy8gaGVscCBvdXQgRXZlbnRJbXBsIGZyb20gaGF2aW5nIHVzZXIgbW9kaWZ5IHByb3BzXG4gICAgT2JqZWN0LmZyZWV6ZShkZWYudWkuY2xhc3NOYW1lcyk7XG4gICAgT2JqZWN0LmZyZWV6ZShkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIHBhcnNlU2luZ2xlKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQsIGFsbG93T3BlblJhbmdlKSB7XG4gICAgbGV0IHsgYWxsRGF5IH0gPSByZWZpbmVkO1xuICAgIGxldCBzdGFydE1ldGE7XG4gICAgbGV0IHN0YXJ0TWFya2VyID0gbnVsbDtcbiAgICBsZXQgaGFzRW5kID0gZmFsc2U7XG4gICAgbGV0IGVuZE1ldGE7XG4gICAgbGV0IGVuZE1hcmtlciA9IG51bGw7XG4gICAgbGV0IHN0YXJ0SW5wdXQgPSByZWZpbmVkLnN0YXJ0ICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0IDogcmVmaW5lZC5kYXRlO1xuICAgIHN0YXJ0TWV0YSA9IGNvbnRleHQuZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YXJ0SW5wdXQpO1xuICAgIGlmIChzdGFydE1ldGEpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE1ldGEubWFya2VyO1xuICAgIH1cbiAgICBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChyZWZpbmVkLmVuZCAhPSBudWxsKSB7XG4gICAgICAgIGVuZE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShyZWZpbmVkLmVuZCk7XG4gICAgfVxuICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICBpZiAoZGVmYXVsdEFsbERheSAhPSBudWxsKSB7XG4gICAgICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBkYXRlIHByb3BzIExBU1RcbiAgICAgICAgICAgIGFsbERheSA9ICghc3RhcnRNZXRhIHx8IHN0YXJ0TWV0YS5pc1RpbWVVbnNwZWNpZmllZCkgJiZcbiAgICAgICAgICAgICAgICAoIWVuZE1ldGEgfHwgZW5kTWV0YS5pc1RpbWVVbnNwZWNpZmllZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbERheSAmJiBzdGFydE1hcmtlcikge1xuICAgICAgICBzdGFydE1hcmtlciA9IHN0YXJ0T2ZEYXkoc3RhcnRNYXJrZXIpO1xuICAgIH1cbiAgICBpZiAoZW5kTWV0YSkge1xuICAgICAgICBlbmRNYXJrZXIgPSBlbmRNZXRhLm1hcmtlcjtcbiAgICAgICAgaWYgKGFsbERheSkge1xuICAgICAgICAgICAgZW5kTWFya2VyID0gc3RhcnRPZkRheShlbmRNYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIgPD0gc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZE1hcmtlcikge1xuICAgICAgICBoYXNFbmQgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICghYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICAgICAgaGFzRW5kID0gY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgZW5kTWFya2VyID0gY29udGV4dC5kYXRlRW52LmFkZChzdGFydE1hcmtlciwgYWxsRGF5ID9cbiAgICAgICAgICAgIGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA6XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFsbERheSxcbiAgICAgICAgaGFzRW5kLFxuICAgICAgICByYW5nZTogeyBzdGFydDogc3RhcnRNYXJrZXIsIGVuZDogZW5kTWFya2VyIH0sXG4gICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE1ldGEgPyBzdGFydE1ldGEuZm9yY2VkVHpvIDogbnVsbCxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRNZXRhID8gZW5kTWV0YS5mb3JjZWRUem8gOiBudWxsLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wdXRlSXNEZWZhdWx0QWxsRGF5KGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgbGV0IHJlcyA9IG51bGw7XG4gICAgaWYgKGV2ZW50U291cmNlKSB7XG4gICAgICAgIHJlcyA9IGV2ZW50U291cmNlLmRlZmF1bHRBbGxEYXk7XG4gICAgfVxuICAgIGlmIChyZXMgPT0gbnVsbCkge1xuICAgICAgICByZXMgPSBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UsIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKSB7XG4gICAgbGV0IGV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICBsZXQgZXZlbnRSZWZpbmVycyA9IGJ1aWxkRXZlbnRSZWZpbmVycyhjb250ZXh0KTtcbiAgICBmb3IgKGxldCByYXdFdmVudCBvZiByYXdFdmVudHMpIHtcbiAgICAgICAgbGV0IHR1cGxlID0gcGFyc2VFdmVudChyYXdFdmVudCwgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCBldmVudFJlZmluZXJzLCBkZWZJZE1hcCwgaW5zdGFuY2VJZE1hcCk7XG4gICAgICAgIGlmICh0dXBsZSkge1xuICAgICAgICAgICAgZXZlbnRUdXBsZVRvU3RvcmUodHVwbGUsIGV2ZW50U3RvcmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudFN0b3JlO1xufVxuZnVuY3Rpb24gZXZlbnRUdXBsZVRvU3RvcmUodHVwbGUsIGV2ZW50U3RvcmUgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSkge1xuICAgIGV2ZW50U3RvcmUuZGVmc1t0dXBsZS5kZWYuZGVmSWRdID0gdHVwbGUuZGVmO1xuICAgIGlmICh0dXBsZS5pbnN0YW5jZSkge1xuICAgICAgICBldmVudFN0b3JlLmluc3RhbmNlc1t0dXBsZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSA9IHR1cGxlLmluc3RhbmNlO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbi8vIHJldHJpZXZlcyBldmVudHMgdGhhdCBoYXZlIHRoZSBzYW1lIGdyb3VwSWQgYXMgdGhlIGluc3RhbmNlIHNwZWNpZmllZCBieSBgaW5zdGFuY2VJZGBcbi8vIG9yIHRoZXkgYXJlIHRoZSBzYW1lIGFzIHRoZSBpbnN0YW5jZS5cbi8vIHdoeSBtaWdodCBpbnN0YW5jZUlkIG5vdCBiZSBpbiB0aGUgc3RvcmU/IGFuIGV2ZW50IGZyb20gYW5vdGhlciBjYWxlbmRhcj9cbmZ1bmN0aW9uIGdldFJlbGV2YW50RXZlbnRzKGV2ZW50U3RvcmUsIGluc3RhbmNlSWQpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIC8vIGdldCBldmVudHMvaW5zdGFuY2VzIHdpdGggc2FtZSBncm91cFxuICAgICAgICBsZXQgbmV3U3RvcmUgPSBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCAobG9va0RlZikgPT4gaXNFdmVudERlZnNHcm91cGVkKGRlZiwgbG9va0RlZikpO1xuICAgICAgICAvLyBhZGQgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgdXNlIGV2ZW50VHVwbGVUb1N0b3JlIG9yIHNvbWV0aGluZyBsaWtlIGl0XG4gICAgICAgIG5ld1N0b3JlLmRlZnNbZGVmLmRlZklkXSA9IGRlZjtcbiAgICAgICAgbmV3U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdID0gaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBuZXdTdG9yZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xufVxuZnVuY3Rpb24gaXNFdmVudERlZnNHcm91cGVkKGRlZjAsIGRlZjEpIHtcbiAgICByZXR1cm4gQm9vbGVhbihkZWYwLmdyb3VwSWQgJiYgZGVmMC5ncm91cElkID09PSBkZWYxLmdyb3VwSWQpO1xufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCkge1xuICAgIHJldHVybiB7IGRlZnM6IHt9LCBpbnN0YW5jZXM6IHt9IH07XG59XG5mdW5jdGlvbiBtZXJnZUV2ZW50U3RvcmVzKHN0b3JlMCwgc3RvcmUxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdG9yZTAuZGVmcyksIHN0b3JlMS5kZWZzKSxcbiAgICAgICAgaW5zdGFuY2VzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0b3JlMC5pbnN0YW5jZXMpLCBzdG9yZTEuaW5zdGFuY2VzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgZmlsdGVyRnVuYykge1xuICAgIGxldCBkZWZzID0gZmlsdGVySGFzaChldmVudFN0b3JlLmRlZnMsIGZpbHRlckZ1bmMpO1xuICAgIGxldCBpbnN0YW5jZXMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCAoaW5zdGFuY2UpID0+IChkZWZzW2luc3RhbmNlLmRlZklkXSAvLyBzdGlsbCBleGlzdHM/XG4gICAgKSk7XG4gICAgcmV0dXJuIHsgZGVmcywgaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlU3ViRXZlbnRTdG9yZShtYXN0ZXIsIHN1Yikge1xuICAgIGxldCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gbWFzdGVyO1xuICAgIGxldCBmaWx0ZXJlZERlZnMgPSB7fTtcbiAgICBsZXQgZmlsdGVyZWRJbnN0YW5jZXMgPSB7fTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgIGlmICghc3ViLmRlZnNbZGVmSWRdKSB7IC8vIG5vdCBleHBsaWNpdGx5IGV4Y2x1ZGVkXG4gICAgICAgICAgICBmaWx0ZXJlZERlZnNbZGVmSWRdID0gZGVmc1tkZWZJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKCFzdWIuaW5zdGFuY2VzW2luc3RhbmNlSWRdICYmIC8vIG5vdCBleHBsaWNpdGx5IGV4Y2x1ZGVkXG4gICAgICAgICAgICBmaWx0ZXJlZERlZnNbaW5zdGFuY2VzW2luc3RhbmNlSWRdLmRlZklkXSAvLyBkZWYgd2Fzbid0IGZpbHRlcmVkIGF3YXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZEluc3RhbmNlc1tpbnN0YW5jZUlkXSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBmaWx0ZXJlZERlZnMsXG4gICAgICAgIGluc3RhbmNlczogZmlsdGVyZWRJbnN0YW5jZXMsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29uc3RyYWludChpbnB1dCwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VFdmVudHMoaW5wdXQsIG51bGwsIGNvbnRleHQsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gcGFyc2VFdmVudHMoW2lucHV0XSwgbnVsbCwgY29udGV4dCwgdHJ1ZSk7IC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgICB9XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNsYXNzTmFtZXMocmF3KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgICAgICByZXR1cm4gcmF3O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJhdy5zcGxpdCgvXFxzKy8pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbi8vIFRPRE86IGJldHRlciBjYWxsZWQgXCJFdmVudFNldHRpbmdzXCIgb3IgXCJFdmVudENvbmZpZ1wiXG4vLyBUT0RPOiBtb3ZlIHRoaXMgZmlsZSBpbnRvIHN0cnVjdHNcbi8vIFRPRE86IHNlcGFyYXRlIGNvbnN0cmFpbnQvb3ZlcmxhcC9hbGxvdywgYmVjYXVzZSBzZWxlY3Rpb24gdXNlcyBvbmx5IHRoYXQsIG5vdCBvdGhlciBwcm9wc1xuY29uc3QgRVZFTlRfVUlfUkVGSU5FUlMgPSB7XG4gICAgZGlzcGxheTogU3RyaW5nLFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHN0YXJ0RWRpdGFibGU6IEJvb2xlYW4sXG4gICAgZHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBjb25zdHJhaW50OiBpZGVudGl0eSxcbiAgICBvdmVybGFwOiBpZGVudGl0eSxcbiAgICBhbGxvdzogaWRlbnRpdHksXG4gICAgY2xhc3NOYW1lOiBwYXJzZUNsYXNzTmFtZXMsXG4gICAgY2xhc3NOYW1lczogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgYmFja2dyb3VuZENvbG9yOiBTdHJpbmcsXG4gICAgYm9yZGVyQ29sb3I6IFN0cmluZyxcbiAgICB0ZXh0Q29sb3I6IFN0cmluZyxcbn07XG5jb25zdCBFTVBUWV9FVkVOVF9VSSA9IHtcbiAgICBkaXNwbGF5OiBudWxsLFxuICAgIHN0YXJ0RWRpdGFibGU6IG51bGwsXG4gICAgZHVyYXRpb25FZGl0YWJsZTogbnVsbCxcbiAgICBjb25zdHJhaW50czogW10sXG4gICAgb3ZlcmxhcDogbnVsbCxcbiAgICBhbGxvd3M6IFtdLFxuICAgIGJhY2tncm91bmRDb2xvcjogJycsXG4gICAgYm9yZGVyQ29sb3I6ICcnLFxuICAgIHRleHRDb2xvcjogJycsXG4gICAgY2xhc3NOYW1lczogW10sXG59O1xuZnVuY3Rpb24gY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSB7XG4gICAgbGV0IGNvbnN0cmFpbnQgPSBub3JtYWxpemVDb25zdHJhaW50KHJlZmluZWQuY29uc3RyYWludCwgY29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheTogcmVmaW5lZC5kaXNwbGF5IHx8IG51bGwsXG4gICAgICAgIHN0YXJ0RWRpdGFibGU6IHJlZmluZWQuc3RhcnRFZGl0YWJsZSAhPSBudWxsID8gcmVmaW5lZC5zdGFydEVkaXRhYmxlIDogcmVmaW5lZC5lZGl0YWJsZSxcbiAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogcmVmaW5lZC5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwgPyByZWZpbmVkLmR1cmF0aW9uRWRpdGFibGUgOiByZWZpbmVkLmVkaXRhYmxlLFxuICAgICAgICBjb25zdHJhaW50czogY29uc3RyYWludCAhPSBudWxsID8gW2NvbnN0cmFpbnRdIDogW10sXG4gICAgICAgIG92ZXJsYXA6IHJlZmluZWQub3ZlcmxhcCAhPSBudWxsID8gcmVmaW5lZC5vdmVybGFwIDogbnVsbCxcbiAgICAgICAgYWxsb3dzOiByZWZpbmVkLmFsbG93ICE9IG51bGwgPyBbcmVmaW5lZC5hbGxvd10gOiBbXSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZpbmVkLmJhY2tncm91bmRDb2xvciB8fCByZWZpbmVkLmNvbG9yIHx8ICcnLFxuICAgICAgICBib3JkZXJDb2xvcjogcmVmaW5lZC5ib3JkZXJDb2xvciB8fCByZWZpbmVkLmNvbG9yIHx8ICcnLFxuICAgICAgICB0ZXh0Q29sb3I6IHJlZmluZWQudGV4dENvbG9yIHx8ICcnLFxuICAgICAgICBjbGFzc05hbWVzOiAocmVmaW5lZC5jbGFzc05hbWUgfHwgW10pLmNvbmNhdChyZWZpbmVkLmNsYXNzTmFtZXMgfHwgW10pLCAvLyBqb2luIHNpbmd1bGFyIGFuZCBwbHVyYWxcbiAgICB9O1xufVxuLy8gVE9ETzogcHJldmVudCBhZ2FpbnN0IHByb2JsZW1zIHdpdGggPDIgYXJncyFcbmZ1bmN0aW9uIGNvbWJpbmVFdmVudFVpcyh1aXMpIHtcbiAgICByZXR1cm4gdWlzLnJlZHVjZShjb21iaW5lVHdvRXZlbnRVaXMsIEVNUFRZX0VWRU5UX1VJKTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVUd29FdmVudFVpcyhpdGVtMCwgaXRlbTEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNwbGF5OiBpdGVtMS5kaXNwbGF5ICE9IG51bGwgPyBpdGVtMS5kaXNwbGF5IDogaXRlbTAuZGlzcGxheSxcbiAgICAgICAgc3RhcnRFZGl0YWJsZTogaXRlbTEuc3RhcnRFZGl0YWJsZSAhPSBudWxsID8gaXRlbTEuc3RhcnRFZGl0YWJsZSA6IGl0ZW0wLnN0YXJ0RWRpdGFibGUsXG4gICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IGl0ZW0xLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IGl0ZW0xLmR1cmF0aW9uRWRpdGFibGUgOiBpdGVtMC5kdXJhdGlvbkVkaXRhYmxlLFxuICAgICAgICBjb25zdHJhaW50czogaXRlbTAuY29uc3RyYWludHMuY29uY2F0KGl0ZW0xLmNvbnN0cmFpbnRzKSxcbiAgICAgICAgb3ZlcmxhcDogdHlwZW9mIGl0ZW0xLm92ZXJsYXAgPT09ICdib29sZWFuJyA/IGl0ZW0xLm92ZXJsYXAgOiBpdGVtMC5vdmVybGFwLFxuICAgICAgICBhbGxvd3M6IGl0ZW0wLmFsbG93cy5jb25jYXQoaXRlbTEuYWxsb3dzKSxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBpdGVtMS5iYWNrZ3JvdW5kQ29sb3IgfHwgaXRlbTAuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBib3JkZXJDb2xvcjogaXRlbTEuYm9yZGVyQ29sb3IgfHwgaXRlbTAuYm9yZGVyQ29sb3IsXG4gICAgICAgIHRleHRDb2xvcjogaXRlbTEudGV4dENvbG9yIHx8IGl0ZW0wLnRleHRDb2xvcixcbiAgICAgICAgY2xhc3NOYW1lczogaXRlbTAuY2xhc3NOYW1lcy5jb25jYXQoaXRlbTEuY2xhc3NOYW1lcyksXG4gICAgfTtcbn1cblxuY29uc3QgRVZFTlRfU09VUkNFX1JFRklORVJTID0ge1xuICAgIGlkOiBTdHJpbmcsXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICB1cmw6IFN0cmluZyxcbiAgICBmb3JtYXQ6IFN0cmluZyxcbiAgICBldmVudHM6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgLy8gZm9yIGFueSBuZXR3b3JrLXJlbGF0ZWQgc291cmNlc1xuICAgIHN1Y2Nlc3M6IGlkZW50aXR5LFxuICAgIGZhaWx1cmU6IGlkZW50aXR5LFxufTtcbmZ1bmN0aW9uIHBhcnNlRXZlbnRTb3VyY2UocmF3LCBjb250ZXh0LCByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KSkge1xuICAgIGxldCByYXdPYmo7XG4gICAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJhd09iaiA9IHsgdXJsOiByYXcgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICAgICAgcmF3T2JqID0geyBldmVudHM6IHJhdyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnb2JqZWN0JyAmJiByYXcpIHsgLy8gbm90IG51bGxcbiAgICAgICAgcmF3T2JqID0gcmF3O1xuICAgIH1cbiAgICBpZiAocmF3T2JqKSB7XG4gICAgICAgIGxldCB7IHJlZmluZWQsIGV4dHJhIH0gPSByZWZpbmVQcm9wcyhyYXdPYmosIHJlZmluZXJzKTtcbiAgICAgICAgbGV0IG1ldGFSZXMgPSBidWlsZEV2ZW50U291cmNlTWV0YShyZWZpbmVkLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKG1ldGFSZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3JhdzogcmF3LFxuICAgICAgICAgICAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhdGVzdEZldGNoSWQ6ICcnLFxuICAgICAgICAgICAgICAgIGZldGNoUmFuZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEFsbERheTogcmVmaW5lZC5kZWZhdWx0QWxsRGF5LFxuICAgICAgICAgICAgICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogcmVmaW5lZC5ldmVudERhdGFUcmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVmaW5lZC5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIGZhaWx1cmU6IHJlZmluZWQuZmFpbHVyZSxcbiAgICAgICAgICAgICAgICBwdWJsaWNJZDogcmVmaW5lZC5pZCB8fCAnJyxcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogZ3VpZCgpLFxuICAgICAgICAgICAgICAgIHNvdXJjZURlZklkOiBtZXRhUmVzLnNvdXJjZURlZklkLFxuICAgICAgICAgICAgICAgIG1ldGE6IG1ldGFSZXMubWV0YSxcbiAgICAgICAgICAgICAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICBleHRlbmRlZFByb3BzOiBleHRyYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRVZFTlRfVUlfUkVGSU5FUlMpLCBFVkVOVF9TT1VSQ0VfUkVGSU5FUlMpLCBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlUmVmaW5lcnMpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZU1ldGEocmF3LCBjb250ZXh0KSB7XG4gICAgbGV0IGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICBmb3IgKGxldCBpID0gZGVmcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkgeyAvLyBsYXRlci1hZGRlZCBwbHVnaW5zIHRha2UgcHJlY2VkZW5jZVxuICAgICAgICBsZXQgZGVmID0gZGVmc1tpXTtcbiAgICAgICAgbGV0IG1ldGEgPSBkZWYucGFyc2VNZXRhKHJhdyk7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzb3VyY2VEZWZJZDogaSwgbWV0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGFjdGlvbiwgZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOiAvLyByYXdcbiAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlc1thY3Rpb24uc291cmNlSWRdLCBhY3Rpb24uZmV0Y2hJZCwgYWN0aW9uLmZldGNoUmFuZ2UsIGFjdGlvbi5yYXdFdmVudHMsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRVNFVF9SQVdfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiByZXNldFJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSwgYWN0aW9uLnJhd0V2ZW50cywgZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdBRERfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQsIGJ1dCBub3QgZXhwYW5kZWRcbiAgICAgICAgICAgIHJldHVybiBhZGRFdmVudChldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSwgLy8gbmV3IG9uZXNcbiAgICAgICAgICAgIGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVTRVRfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnTUVSR0VfRVZFTlRTJzogLy8gYWxyZWFkeSBwYXJzZWQgYW5kIGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2VFdmVudFN0b3JlcyhldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XG4gICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudFN0b3JlO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRTJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlU3ViRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24uZXZlbnRTdG9yZSk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgKGV2ZW50RGVmKSA9PiAoIWV2ZW50RGVmLnNvdXJjZUlkIC8vIG9ubHkga2VlcCBldmVudHMgd2l0aCBubyBzb3VyY2UgaWRcbiAgICAgICAgICAgICkpO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWNlaXZlUmF3RXZlbnRzKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLCBmZXRjaElkLCBmZXRjaFJhbmdlLCByYXdFdmVudHMsIGNvbnRleHQpIHtcbiAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkIC8vIFRPRE86IHdpc2ggdGhpcyBsb2dpYyB3YXMgYWx3YXlzIGluIGV2ZW50LXNvdXJjZXNcbiAgICApIHtcbiAgICAgICAgbGV0IHN1YnNldCA9IHBhcnNlRXZlbnRzKHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSwgZXZlbnRTb3VyY2UsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZmV0Y2hSYW5nZSkge1xuICAgICAgICAgICAgc3Vic2V0ID0gZXhwYW5kUmVjdXJyaW5nKHN1YnNldCwgZmV0Y2hSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXhjbHVkZUV2ZW50c0J5U291cmNlSWQoZXZlbnRTdG9yZSwgZXZlbnRTb3VyY2Uuc291cmNlSWQpLCBzdWJzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gZXZlbnRTdG9yZTtcbn1cbmZ1bmN0aW9uIHJlc2V0UmF3RXZlbnRzKGV4aXN0aW5nRXZlbnRTdG9yZSwgZXZlbnRTb3VyY2UsIHJhd0V2ZW50cywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwIH0gPSBidWlsZFB1YmxpY0lkTWFwcyhleGlzdGluZ0V2ZW50U3RvcmUpO1xuICAgIGxldCBuZXdFdmVudFN0b3JlID0gcGFyc2VFdmVudHModHJhbnNmb3JtUmF3RXZlbnRzKHJhd0V2ZW50cywgZXZlbnRTb3VyY2UsIGNvbnRleHQpLCBldmVudFNvdXJjZSwgY29udGV4dCwgZmFsc2UsIGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwKTtcbiAgICByZXR1cm4gZXhwYW5kUmVjdXJyaW5nKG5ld0V2ZW50U3RvcmUsIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVJhd0V2ZW50cyhyYXdFdmVudHMsIGV2ZW50U291cmNlLCBjb250ZXh0KSB7XG4gICAgbGV0IGNhbEVhY2hUcmFuc2Zvcm0gPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnREYXRhVHJhbnNmb3JtO1xuICAgIGxldCBzb3VyY2VFYWNoVHJhbnNmb3JtID0gZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5ldmVudERhdGFUcmFuc2Zvcm0gOiBudWxsO1xuICAgIGlmIChzb3VyY2VFYWNoVHJhbnNmb3JtKSB7XG4gICAgICAgIHJhd0V2ZW50cyA9IHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIHNvdXJjZUVhY2hUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoY2FsRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBjYWxFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhd0V2ZW50cztcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUVhY2hSYXdFdmVudChyYXdFdmVudHMsIGZ1bmMpIHtcbiAgICBsZXQgcmVmaW5lZEV2ZW50cztcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgICAgcmVmaW5lZEV2ZW50cyA9IHJhd0V2ZW50cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcmF3RXZlbnQgb2YgcmF3RXZlbnRzKSB7XG4gICAgICAgICAgICBsZXQgcmVmaW5lZEV2ZW50ID0gZnVuYyhyYXdFdmVudCk7XG4gICAgICAgICAgICBpZiAocmVmaW5lZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJlZmluZWRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVkRXZlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyYXdFdmVudCk7XG4gICAgICAgICAgICB9IC8vIGlmIGEgZGlmZmVyZW50IGZhbHN5IHZhbHVlLCBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZmluZWRFdmVudHM7XG59XG5mdW5jdGlvbiBhZGRFdmVudChldmVudFN0b3JlLCBzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KSB7XG4gICAgaWYgKGV4cGFuZFJhbmdlKSB7XG4gICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgc3Vic2V0KTtcbn1cbmZ1bmN0aW9uIHJlem9uZUV2ZW50U3RvcmVEYXRlcyhldmVudFN0b3JlLCBvbGREYXRlRW52LCBuZXdEYXRlRW52KSB7XG4gICAgbGV0IHsgZGVmcyB9ID0gZXZlbnRTdG9yZTtcbiAgICBsZXQgaW5zdGFuY2VzID0gbWFwSGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgKGluc3RhbmNlKSA9PiB7XG4gICAgICAgIGxldCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgaWYgKGRlZi5hbGxEYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTsgLy8gaXNuJ3QgZGVwZW5kZW50IG9uIHRpbWV6b25lXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaW5zdGFuY2UpLCB7IHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IG5ld0RhdGVFbnYuY3JlYXRlTWFya2VyKG9sZERhdGVFbnYudG9EYXRlKGluc3RhbmNlLnJhbmdlLnN0YXJ0LCBpbnN0YW5jZS5mb3JjZWRTdGFydFR6bykpLFxuICAgICAgICAgICAgICAgIGVuZDogbmV3RGF0ZUVudi5jcmVhdGVNYXJrZXIob2xkRGF0ZUVudi50b0RhdGUoaW5zdGFuY2UucmFuZ2UuZW5kLCBpbnN0YW5jZS5mb3JjZWRFbmRUem8pKSxcbiAgICAgICAgICAgIH0sIGZvcmNlZFN0YXJ0VHpvOiBuZXdEYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQgPyBudWxsIDogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sIGZvcmNlZEVuZFR6bzogbmV3RGF0ZUVudi5jYW5Db21wdXRlT2Zmc2V0ID8gbnVsbCA6IGluc3RhbmNlLmZvcmNlZEVuZFR6byB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBkZWZzLCBpbnN0YW5jZXMgfTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIHNvdXJjZUlkKSB7XG4gICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIChldmVudERlZikgPT4gZXZlbnREZWYuc291cmNlSWQgIT09IHNvdXJjZUlkKTtcbn1cbi8vIFFVRVNUSU9OOiB3aHkgbm90IGp1c3QgcmV0dXJuIGluc3RhbmNlcz8gZG8gYSBnZW5lcmFsIG9iamVjdC1wcm9wZXJ0eS1leGNsdXNpb24gdXRpbFxuZnVuY3Rpb24gZXhjbHVkZUluc3RhbmNlcyhldmVudFN0b3JlLCByZW1vdmFscykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IGV2ZW50U3RvcmUuZGVmcyxcbiAgICAgICAgaW5zdGFuY2VzOiBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuaW5zdGFuY2VzLCAoaW5zdGFuY2UpID0+ICFyZW1vdmFsc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUHVibGljSWRNYXBzKGV2ZW50U3RvcmUpIHtcbiAgICBjb25zdCB7IGRlZnMsIGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICBjb25zdCBkZWZJZE1hcCA9IHt9O1xuICAgIGNvbnN0IGluc3RhbmNlSWRNYXAgPSB7fTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgIGNvbnN0IGRlZiA9IGRlZnNbZGVmSWRdO1xuICAgICAgICBjb25zdCB7IHB1YmxpY0lkIH0gPSBkZWY7XG4gICAgICAgIGlmIChwdWJsaWNJZCkge1xuICAgICAgICAgICAgZGVmSWRNYXBbcHVibGljSWRdID0gZGVmSWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIGNvbnN0IGRlZiA9IGRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICBjb25zdCB7IHB1YmxpY0lkIH0gPSBkZWY7XG4gICAgICAgIGlmIChwdWJsaWNJZCkge1xuICAgICAgICAgICAgaW5zdGFuY2VJZE1hcFtwdWJsaWNJZF0gPSBpbnN0YW5jZUlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGRlZklkTWFwLCBpbnN0YW5jZUlkTWFwIH07XG59XG5cbmNsYXNzIEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMudGhpc0NvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgICBzZXRUaGlzQ29udGV4dCh0aGlzQ29udGV4dCkge1xuICAgICAgICB0aGlzLnRoaXNDb250ZXh0ID0gdGhpc0NvbnRleHQ7XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIGFkZFRvSGFzaCh0aGlzLmhhbmRsZXJzLCB0eXBlLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgb2ZmKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgcmVtb3ZlRnJvbUhhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIHRyaWdnZXIodHlwZSwgLi4uYXJncykge1xuICAgICAgICBsZXQgYXR0YWNoZWRIYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbdHlwZV0gfHwgW107XG4gICAgICAgIGxldCBvcHRpb25IYW5kbGVyID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXTtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0gW10uY29uY2F0KG9wdGlvbkhhbmRsZXIgfHwgW10sIGF0dGFjaGVkSGFuZGxlcnMpO1xuICAgICAgICBmb3IgKGxldCBoYW5kbGVyIG9mIGhhbmRsZXJzKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMudGhpc0NvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0hhbmRsZXJzKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHRoaXMuaGFuZGxlcnNbdHlwZV0gJiYgdGhpcy5oYW5kbGVyc1t0eXBlXS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1t0eXBlXSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFRvSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgKGhhc2hbdHlwZV0gfHwgKGhhc2hbdHlwZV0gPSBbXSkpXG4gICAgICAgIC5wdXNoKGhhbmRsZXIpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRnJvbUhhc2goaGFzaCwgdHlwZSwgaGFuZGxlcikge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYXNoW3R5cGVdKSB7XG4gICAgICAgICAgICBoYXNoW3R5cGVdID0gaGFzaFt0eXBlXS5maWx0ZXIoKGZ1bmMpID0+IGZ1bmMgIT09IGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWxldGUgaGFzaFt0eXBlXTsgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyIGZ1bmNzIGZvciB0aGlzIHR5cGVcbiAgICB9XG59XG5cbmNvbnN0IERFRl9ERUZBVUxUUyA9IHtcbiAgICBzdGFydFRpbWU6ICcwOTowMCcsXG4gICAgZW5kVGltZTogJzE3OjAwJyxcbiAgICBkYXlzT2ZXZWVrOiBbMSwgMiwgMywgNCwgNV0sXG4gICAgZGlzcGxheTogJ2ludmVyc2UtYmFja2dyb3VuZCcsXG4gICAgY2xhc3NOYW1lczogJ2ZjLW5vbi1idXNpbmVzcycsXG4gICAgZ3JvdXBJZDogJ19idXNpbmVzc0hvdXJzJywgLy8gc28gbXVsdGlwbGUgZGVmcyBnZXQgZ3JvdXBlZFxufTtcbi8qXG5UT0RPOiBwYXNzIGFyb3VuZCBhcyBFdmVudERlZkhhc2ghISFcbiovXG5mdW5jdGlvbiBwYXJzZUJ1c2luZXNzSG91cnMoaW5wdXQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gcGFyc2VFdmVudHMocmVmaW5lSW5wdXRzKGlucHV0KSwgbnVsbCwgY29udGV4dCk7XG59XG5mdW5jdGlvbiByZWZpbmVJbnB1dHMoaW5wdXQpIHtcbiAgICBsZXQgcmF3RGVmcztcbiAgICBpZiAoaW5wdXQgPT09IHRydWUpIHtcbiAgICAgICAgcmF3RGVmcyA9IFt7fV07IC8vIHdpbGwgZ2V0IERFRl9ERUZBVUxUUyB2ZXJiYXRpbVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAvLyBpZiBzcGVjaWZ5aW5nIGFuIGFycmF5LCBldmVyeSBzdWItZGVmaW5pdGlvbiBORUVEUyBhIGRheS1vZi13ZWVrXG4gICAgICAgIHJhd0RlZnMgPSBpbnB1dC5maWx0ZXIoKHJhd0RlZikgPT4gcmF3RGVmLmRheXNPZldlZWspO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByYXdEZWZzID0gW2lucHV0XTtcbiAgICB9XG4gICAgZWxzZSB7IC8vIGlzIHByb2JhYmx5IGZhbHNlXG4gICAgICAgIHJhd0RlZnMgPSBbXTtcbiAgICB9XG4gICAgcmF3RGVmcyA9IHJhd0RlZnMubWFwKChyYXdEZWYpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRl9ERUZBVUxUUyksIHJhd0RlZikpKTtcbiAgICByZXR1cm4gcmF3RGVmcztcbn1cblxuZnVuY3Rpb24gdHJpZ2dlckRhdGVTZWxlY3Qoc2VsZWN0aW9uLCBwZXYsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignc2VsZWN0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc2VsZWN0aW9uLCBjb250ZXh0KSksIHsganNFdmVudDogcGV2ID8gcGV2Lm9yaWdFdmVudCA6IG51bGwsIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcgfSkpO1xufVxuZnVuY3Rpb24gdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcigndW5zZWxlY3QnLCB7XG4gICAgICAgIGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KGRhdGVTcGFuLCBjb250ZXh0KSB7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgZm9yIChsZXQgdHJhbnNmb3JtIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVNwYW5UcmFuc2Zvcm1zKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIHRyYW5zZm9ybShkYXRlU3BhbiwgY29udGV4dCkpO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHByb3BzLCBidWlsZERhdGVTcGFuQXBpKGRhdGVTcGFuLCBjb250ZXh0LmRhdGVFbnYpKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG4vLyBHaXZlbiBhbiBldmVudCdzIGFsbERheSBzdGF0dXMgYW5kIHN0YXJ0IGRhdGUsIHJldHVybiB3aGF0IGl0cyBmYWxsYmFjayBlbmQgZGF0ZSBzaG91bGQgYmUuXG4vLyBUT0RPOiByZW5hbWUgdG8gY29tcHV0ZURlZmF1bHRFdmVudEVuZFxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV2ZW50RW5kKGFsbERheSwgbWFya2VyLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgZW5kID0gbWFya2VyO1xuICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgZW5kID0gc3RhcnRPZkRheShlbmQpO1xuICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBhcHBsaWVzIHRoZSBtdXRhdGlvbiB0byBBTEwgZGVmcy9pbnN0YW5jZXMgd2l0aGluIHRoZSBldmVudCBzdG9yZVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudENvbmZpZ0Jhc2UsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IGV2ZW50Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50Q29uZmlnQmFzZSk7XG4gICAgbGV0IGRlc3QgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFN0b3JlLmRlZnMpIHtcbiAgICAgICAgbGV0IGRlZiA9IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF07XG4gICAgICAgIGRlc3QuZGVmc1tkZWZJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudERlZihkZWYsIGV2ZW50Q29uZmlnc1tkZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBldmVudFN0b3JlLmluc3RhbmNlcykge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBldmVudFN0b3JlLmluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgbGV0IGRlZiA9IGRlc3QuZGVmc1tpbnN0YW5jZS5kZWZJZF07IC8vIGltcG9ydGFudCB0byBncmFiIHRoZSBuZXdseSBtb2RpZmllZCBkZWZcbiAgICAgICAgZGVzdC5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBhcHBseU11dGF0aW9uVG9FdmVudEluc3RhbmNlKGluc3RhbmNlLCBkZWYsIGV2ZW50Q29uZmlnc1tpbnN0YW5jZS5kZWZJZF0sIG11dGF0aW9uLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiBhcHBseU11dGF0aW9uVG9FdmVudERlZihldmVudERlZiwgZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IHN0YW5kYXJkUHJvcHMgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzIHx8IHt9O1xuICAgIC8vIGlmIGhhc0VuZCBoYXMgbm90IGJlZW4gc3BlY2lmaWVkLCBndWVzcyBhIGdvb2QgdmFsdWUgYmFzZWQgb24gZGVsdGFzLlxuICAgIC8vIGlmIGR1cmF0aW9uIHdpbGwgY2hhbmdlLCB0aGVyZSdzIG5vIHdheSB0aGUgZGVmYXVsdCBkdXJhdGlvbiB3aWxsIHBlcnNpc3QsXG4gICAgLy8gYW5kIHRodXMsIHdlIG5lZWQgdG8gbWFyayB0aGUgZXZlbnQgYXMgaGF2aW5nIGEgcmVhbCBlbmRcbiAgICBpZiAoc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT0gbnVsbCAmJlxuICAgICAgICBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlICYmXG4gICAgICAgIChtdXRhdGlvbi5zdGFydERlbHRhIHx8IG11dGF0aW9uLmVuZERlbHRhKSkge1xuICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IHRydWU7IC8vIFRPRE86IGlzIHRoaXMgbXV0YXRpb24gb2theT9cbiAgICB9XG4gICAgbGV0IGNvcHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYpLCBzdGFuZGFyZFByb3BzKSwgeyB1aTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudERlZi51aSksIHN0YW5kYXJkUHJvcHMudWkpIH0pO1xuICAgIGlmIChtdXRhdGlvbi5leHRlbmRlZFByb3BzKSB7XG4gICAgICAgIGNvcHkuZXh0ZW5kZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29weS5leHRlbmRlZFByb3BzKSwgbXV0YXRpb24uZXh0ZW5kZWRQcm9wcyk7XG4gICAgfVxuICAgIGZvciAobGV0IGFwcGxpZXIgb2YgY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpIHtcbiAgICAgICAgYXBwbGllcihjb3B5LCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICghY29weS5oYXNFbmQgJiYgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbikge1xuICAgICAgICBjb3B5Lmhhc0VuZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShldmVudEluc3RhbmNlLCBldmVudERlZiwgLy8gbXVzdCBmaXJzdCBiZSBtb2RpZmllZCBieSBhcHBseU11dGF0aW9uVG9FdmVudERlZlxuZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgZGF0ZUVudiB9ID0gY29udGV4dDtcbiAgICBsZXQgZm9yY2VBbGxEYXkgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuYWxsRGF5ID09PSB0cnVlO1xuICAgIGxldCBjbGVhckVuZCA9IG11dGF0aW9uLnN0YW5kYXJkUHJvcHMgJiYgbXV0YXRpb24uc3RhbmRhcmRQcm9wcy5oYXNFbmQgPT09IGZhbHNlO1xuICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRJbnN0YW5jZSk7XG4gICAgaWYgKGZvcmNlQWxsRGF5KSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSBjb21wdXRlQWxpZ25lZERheVJhbmdlKGNvcHkucmFuZ2UpO1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24uZGF0ZXNEZWx0YSAmJiBldmVudENvbmZpZy5zdGFydEVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5zdGFydCwgbXV0YXRpb24uZGF0ZXNEZWx0YSksXG4gICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2UuZW5kLCBtdXRhdGlvbi5kYXRlc0RlbHRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLnN0YXJ0RGVsdGEgJiYgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2Uuc3RhcnQsIG11dGF0aW9uLnN0YXJ0RGVsdGEpLFxuICAgICAgICAgICAgZW5kOiBjb3B5LnJhbmdlLmVuZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG11dGF0aW9uLmVuZERlbHRhICYmIGV2ZW50Q29uZmlnLmR1cmF0aW9uRWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBjb3B5LnJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLmVuZCwgbXV0YXRpb24uZW5kRGVsdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY2xlYXJFbmQpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBjb3B5LnJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBnZXREZWZhdWx0RXZlbnRFbmQoZXZlbnREZWYuYWxsRGF5LCBjb3B5LnJhbmdlLnN0YXJ0LCBjb250ZXh0KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gaW4gY2FzZSBldmVudCB3YXMgYWxsLWRheSBidXQgdGhlIHN1cHBsaWVkIGRlbHRhcyB3ZXJlIG5vdFxuICAgIC8vIGJldHRlciB1dGlsIGZvciB0aGlzP1xuICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydE9mRGF5KGNvcHkucmFuZ2Uuc3RhcnQpLFxuICAgICAgICAgICAgZW5kOiBzdGFydE9mRGF5KGNvcHkucmFuZ2UuZW5kKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIGludmFsaWQgZHVyYXRpb25zXG4gICAgaWYgKGNvcHkucmFuZ2UuZW5kIDwgY29weS5yYW5nZS5zdGFydCkge1xuICAgICAgICBjb3B5LnJhbmdlLmVuZCA9IGdldERlZmF1bHRFdmVudEVuZChldmVudERlZi5hbGxEYXksIGNvcHkucmFuZ2Uuc3RhcnQsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cblxuY2xhc3MgRXZlbnRTb3VyY2VJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBpbnRlcm5hbEV2ZW50U291cmNlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZSA9IGludGVybmFsRXZlbnRTb3VyY2U7XG4gICAgfVxuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWZldGNoKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0ZFVENIX0VWRU5UX1NPVVJDRVMnLFxuICAgICAgICAgICAgc291cmNlSWRzOiBbdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSxcbiAgICAgICAgICAgIGlzUmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5wdWJsaWNJZDtcbiAgICB9XG4gICAgZ2V0IHVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5tZXRhLnVybDtcbiAgICB9XG4gICAgZ2V0IGZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5tZXRhLmZvcm1hdDsgLy8gVE9ETzogYmFkLiBub3QgZ3VhcmFudGVlZFxuICAgIH1cbn1cblxuY2xhc3MgRXZlbnRJbXBsIHtcbiAgICAvLyBpbnN0YW5jZSB3aWxsIGJlIG51bGwgaWYgZXhwcmVzc2luZyBhIHJlY3VycmluZyBldmVudCB0aGF0IGhhcyBubyBjdXJyZW50IGluc3RhbmNlcyxcbiAgICAvLyBPUiBpZiB0cnlpbmcgdG8gdmFsaWRhdGUgYW4gaW5jb21pbmcgZXh0ZXJuYWwgZXZlbnQgdGhhdCBoYXMgbm8gZGF0ZXMgYXNzaWduZWRcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBkZWYsIGluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdGFuY2UgfHwgbnVsbDtcbiAgICB9XG4gICAgLypcbiAgICBUT0RPOiBtYWtlIGV2ZW50IHN0cnVjdCBtb3JlIHJlc3BvbnNpYmxlIGZvciB0aGlzXG4gICAgKi9cbiAgICBzZXRQcm9wKG5hbWUsIHZhbCkge1xuICAgICAgICBpZiAobmFtZSBpbiBFVkVOVF9EQVRFX1JFRklORVJTKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBzZXQgZGF0ZS1yZWxhdGVkIHByb3AgXFwnbmFtZVxcJy4gVXNlIG9uZSBvZiB0aGUgZGF0ZS1yZWxhdGVkIG1ldGhvZHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgcHJvcGVyIGFsaWFzaW5nIHN5c3RlbT9cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnaWQnKSB7XG4gICAgICAgICAgICB2YWwgPSBFVkVOVF9OT05fREFURV9SRUZJTkVSU1tuYW1lXSh2YWwpO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHM6IHsgcHVibGljSWQ6IHZhbCB9LCAvLyBoYXJkY29kZWQgaW50ZXJuYWwgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9OT05fREFURV9SRUZJTkVSUykge1xuICAgICAgICAgICAgdmFsID0gRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzOiB7IFtuYW1lXTogdmFsIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lIGluIEVWRU5UX1VJX1JFRklORVJTKSB7XG4gICAgICAgICAgICBsZXQgdWkgPSBFVkVOVF9VSV9SRUZJTkVSU1tuYW1lXSh2YWwpO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgYmFja2dyb3VuZENvbG9yOiB2YWwsIGJvcmRlckNvbG9yOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdlZGl0YWJsZScpIHtcbiAgICAgICAgICAgICAgICB1aSA9IHsgc3RhcnRFZGl0YWJsZTogdmFsLCBkdXJhdGlvbkVkaXRhYmxlOiB2YWwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVpID0geyBbbmFtZV06IHZhbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHM6IHsgdWkgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3Qgc2V0IHByb3AgJyR7bmFtZX0nLiBVc2Ugc2V0RXh0ZW5kZWRQcm9wIGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RXh0ZW5kZWRQcm9wKG5hbWUsIHZhbCkge1xuICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICBleHRlbmRlZFByb3BzOiB7IFtuYW1lXTogdmFsIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXRTdGFydChzdGFydElucHV0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgbGV0IHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoc3RhcnRJbnB1dCk7XG4gICAgICAgIGlmIChzdGFydCAmJiB0aGlzLl9pbnN0YW5jZSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZVJhbmdlID0gdGhpcy5faW5zdGFuY2UucmFuZ2U7XG4gICAgICAgICAgICBsZXQgc3RhcnREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLnN0YXJ0LCBzdGFydCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7IC8vIHdoYXQgaWYgcGFyc2VkIGJhZCE/XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYWludGFpbkR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBzdGFydERlbHRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEVuZChlbmRJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBlbmQ7XG4gICAgICAgIGlmIChlbmRJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihlbmRJbnB1dCk7XG4gICAgICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZERlbHRhID0gZGlmZkRhdGVzKHRoaXMuX2luc3RhbmNlLnJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFuZGFyZFByb3BzOiB7IGhhc0VuZDogZmFsc2UgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXREYXRlcyhzdGFydElucHV0LCBlbmRJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYgfSA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBzdGFuZGFyZFByb3BzID0geyBhbGxEYXk6IG9wdGlvbnMuYWxsRGF5IH07XG4gICAgICAgIGxldCBzdGFydCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKHN0YXJ0SW5wdXQpO1xuICAgICAgICBsZXQgZW5kO1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihlbmRJbnB1dCk7XG4gICAgICAgICAgICBpZiAoIWVuZCkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2VSYW5nZSA9IHRoaXMuX2luc3RhbmNlLnJhbmdlO1xuICAgICAgICAgICAgLy8gd2hlbiBjb21wdXRpbmcgdGhlIGRpZmYgZm9yIGFuIGV2ZW50IGJlaW5nIGNvbnZlcnRlZCB0byBhbGwtZGF5LFxuICAgICAgICAgICAgLy8gY29tcHV0ZSBkaWZmIG9mZiBvZiB0aGUgYWxsLWRheSB2YWx1ZXMgdGhlIHdheSBldmVudC1tdXRhdGlvbiBkb2VzLlxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsRGF5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VSYW5nZSA9IGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UoaW5zdGFuY2VSYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RhcnREZWx0YSA9IGRpZmZEYXRlcyhpbnN0YW5jZVJhbmdlLnN0YXJ0LCBzdGFydCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XG4gICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2UuZW5kLCBlbmQsIGRhdGVFbnYsIG9wdGlvbnMuZ3JhbnVsYXJpdHkpO1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbnNFcXVhbChzdGFydERlbHRhLCBlbmREZWx0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBkYXRlc0RlbHRhOiBzdGFydERlbHRhLCBzdGFuZGFyZFByb3BzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhLCBlbmREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gbWVhbnMgXCJjbGVhciB0aGUgZW5kXCJcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlU3RhcnQoZGVsdGFJbnB1dCkge1xuICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFydERlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3ZlRW5kKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgbGV0IGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBUT0RPOiB3YXJuaW5nIGlmIHBhcnNlZCBiYWRcbiAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZW5kRGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmVEYXRlcyhkZWx0YUlucHV0KSB7XG4gICAgICAgIGxldCBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEFsbERheShhbGxEYXksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5IH07XG4gICAgICAgIGxldCB7IG1haW50YWluRHVyYXRpb24gfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChtYWludGFpbkR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIG1haW50YWluRHVyYXRpb24gPSB0aGlzLl9jb250ZXh0Lm9wdGlvbnMuYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVmLmFsbERheSAhPT0gYWxsRGF5KSB7XG4gICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IG1haW50YWluRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFuZGFyZFByb3BzIH0pO1xuICAgIH1cbiAgICBmb3JtYXRSYW5nZShmb3JtYXRJbnB1dCkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgbGV0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihmb3JtYXRJbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UucmFuZ2UuZW5kLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgICAgICAgICAgZm9yY2VkRW5kVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGZvcm1hdHRlciwge1xuICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11dGF0ZShtdXRhdGlvbikge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBsZXQgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICAgICAgbGV0IHsgZXZlbnRTdG9yZSB9ID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoZXZlbnRTdG9yZSwgaW5zdGFuY2UuaW5zdGFuY2VJZCk7XG4gICAgICAgICAgICBsZXQgZXZlbnRDb25maWdCYXNlID0ge1xuICAgICAgICAgICAgICAgICcnOiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICcnLFxuICAgICAgICAgICAgICAgICAgICBzdGFydEVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50czogW10sXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93czogW10sXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJycsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dENvbG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lczogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWxldmFudEV2ZW50cyA9IGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUocmVsZXZhbnRFdmVudHMsIGV2ZW50Q29uZmlnQmFzZSwgbXV0YXRpb24sIGNvbnRleHQpO1xuICAgICAgICAgICAgbGV0IG9sZEV2ZW50ID0gbmV3IEV2ZW50SW1wbChjb250ZXh0LCBkZWYsIGluc3RhbmNlKTsgLy8gc25hcHNob3RcbiAgICAgICAgICAgIHRoaXMuX2RlZiA9IHJlbGV2YW50RXZlbnRzLmRlZnNbZGVmLmRlZklkXTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gcmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2luc3RhbmNlLmluc3RhbmNlSWRdO1xuICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBvbGRFdmVudCxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcyxcbiAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhyZWxldmFudEV2ZW50cywgY29udGV4dCwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVTRVRfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50U3RvcmUsIC8vIHRoZSBPUklHSU5BTCBzdG9yZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICAgIGxldCBhc1N0b3JlID0gZXZlbnRBcGlUb1N0b3JlKHRoaXMpO1xuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGFzU3RvcmUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnRSZW1vdmUnLCB7XG4gICAgICAgICAgICBldmVudDogdGhpcyxcbiAgICAgICAgICAgIHJlbGF0ZWRFdmVudHM6IFtdLFxuICAgICAgICAgICAgcmV2ZXJ0KCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYXNTdG9yZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgICBsZXQgeyBzb3VyY2VJZCB9ID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoc291cmNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VJbXBsKHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQuZ2V0Q3VycmVudERhdGEoKS5ldmVudFNvdXJjZXNbc291cmNlSWRdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgP1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5kYXRlRW52LnRvRGF0ZSh0aGlzLl9pbnN0YW5jZS5yYW5nZS5zdGFydCkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgZ2V0IGVuZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9kZWYuaGFzRW5kKSA/XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LmRhdGVFbnYudG9EYXRlKHRoaXMuX2luc3RhbmNlLnJhbmdlLmVuZCkgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0U3RyKCkge1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5kYXRlRW52LmZvcm1hdElzbyhpbnN0YW5jZS5yYW5nZS5zdGFydCwge1xuICAgICAgICAgICAgICAgIG9taXRUaW1lOiB0aGlzLl9kZWYuYWxsRGF5LFxuICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGdldCBlbmRTdHIoKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2UuZW5kLCB7XG4gICAgICAgICAgICAgICAgb21pdFRpbWU6IHRoaXMuX2RlZi5hbGxEYXksXG4gICAgICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIC8vIGNvbXB1dGFibGUgcHJvcHMgdGhhdCBhbGwgYWNjZXNzIHRoZSBkZWZcbiAgICAvLyBUT0RPOiBmaW5kIGEgVHlwZVNjcmlwdC1jb21wYXRpYmxlIHdheSB0byBkbyB0aGlzIGF0IHNjYWxlXG4gICAgZ2V0IGlkKCkgeyByZXR1cm4gdGhpcy5fZGVmLnB1YmxpY0lkOyB9XG4gICAgZ2V0IGdyb3VwSWQoKSB7IHJldHVybiB0aGlzLl9kZWYuZ3JvdXBJZDsgfVxuICAgIGdldCBhbGxEYXkoKSB7IHJldHVybiB0aGlzLl9kZWYuYWxsRGF5OyB9XG4gICAgZ2V0IHRpdGxlKCkgeyByZXR1cm4gdGhpcy5fZGVmLnRpdGxlOyB9XG4gICAgZ2V0IHVybCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51cmw7IH1cbiAgICBnZXQgZGlzcGxheSgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5kaXNwbGF5IHx8ICdhdXRvJzsgfSAvLyBiYWQuIGp1c3Qgbm9ybWFsaXplIHRoZSB0eXBlIGVhcmxpZXJcbiAgICBnZXQgc3RhcnRFZGl0YWJsZSgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5zdGFydEVkaXRhYmxlOyB9XG4gICAgZ2V0IGR1cmF0aW9uRWRpdGFibGUoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuZHVyYXRpb25FZGl0YWJsZTsgfVxuICAgIGdldCBjb25zdHJhaW50KCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmNvbnN0cmFpbnRzWzBdIHx8IG51bGw7IH1cbiAgICBnZXQgb3ZlcmxhcCgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5vdmVybGFwOyB9XG4gICAgZ2V0IGFsbG93KCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmFsbG93c1swXSB8fCBudWxsOyB9XG4gICAgZ2V0IGJhY2tncm91bmRDb2xvcigpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5iYWNrZ3JvdW5kQ29sb3I7IH1cbiAgICBnZXQgYm9yZGVyQ29sb3IoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYm9yZGVyQ29sb3I7IH1cbiAgICBnZXQgdGV4dENvbG9yKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLnRleHRDb2xvcjsgfVxuICAgIC8vIE5PVEU6IHVzZXIgY2FuJ3QgbW9kaWZ5IHRoZXNlIGJlY2F1c2UgT2JqZWN0LmZyZWV6ZSB3YXMgY2FsbGVkIGluIGV2ZW50LWRlZiBwYXJzaW5nXG4gICAgZ2V0IGNsYXNzTmFtZXMoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuY2xhc3NOYW1lczsgfVxuICAgIGdldCBleHRlbmRlZFByb3BzKCkgeyByZXR1cm4gdGhpcy5fZGVmLmV4dGVuZGVkUHJvcHM7IH1cbiAgICB0b1BsYWluT2JqZWN0KHNldHRpbmdzID0ge30pIHtcbiAgICAgICAgbGV0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgbGV0IHsgdWkgfSA9IGRlZjtcbiAgICAgICAgbGV0IHsgc3RhcnRTdHIsIGVuZFN0ciB9ID0gdGhpcztcbiAgICAgICAgbGV0IHJlcyA9IHtcbiAgICAgICAgICAgIGFsbERheTogZGVmLmFsbERheSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlZi50aXRsZSkge1xuICAgICAgICAgICAgcmVzLnRpdGxlID0gZGVmLnRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFN0cikge1xuICAgICAgICAgICAgcmVzLnN0YXJ0ID0gc3RhcnRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFN0cikge1xuICAgICAgICAgICAgcmVzLmVuZCA9IGVuZFN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnB1YmxpY0lkKSB7XG4gICAgICAgICAgICByZXMuaWQgPSBkZWYucHVibGljSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICByZXMuZ3JvdXBJZCA9IGRlZi5ncm91cElkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYudXJsKSB7XG4gICAgICAgICAgICByZXMudXJsID0gZGVmLnVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWkuZGlzcGxheSAmJiB1aS5kaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHJlcy5kaXNwbGF5ID0gdWkuZGlzcGxheTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHJlY3VycmluZy1ldmVudCBwcm9wZXJ0aWVzPz8/XG4gICAgICAgIC8vIFRPRE86IGluY2x1ZGUgc3RhcnRFZGl0YWJsZS9kdXJhdGlvbkVkaXRhYmxlL2NvbnN0cmFpbnQvb3ZlcmxhcC9hbGxvd1xuICAgICAgICBpZiAoc2V0dGluZ3MuY29sbGFwc2VDb2xvciAmJiB1aS5iYWNrZ3JvdW5kQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yID09PSB1aS5ib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgcmVzLmNvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHVpLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgIHJlcy5iYWNrZ3JvdW5kQ29sb3IgPSB1aS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodWkuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuYm9yZGVyQ29sb3IgPSB1aS5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodWkudGV4dENvbG9yKSB7XG4gICAgICAgICAgICByZXMudGV4dENvbG9yID0gdWkudGV4dENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1aS5jbGFzc05hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzLmNsYXNzTmFtZXMgPSB1aS5jbGFzc05hbWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkZWYuZXh0ZW5kZWRQcm9wcykubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuY29sbGFwc2VFeHRlbmRlZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXMsIGRlZi5leHRlbmRlZFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcy5leHRlbmRlZFByb3BzID0gZGVmLmV4dGVuZGVkUHJvcHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1BsYWluT2JqZWN0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSB7XG4gICAgbGV0IGRlZiA9IGV2ZW50QXBpLl9kZWY7XG4gICAgbGV0IGluc3RhbmNlID0gZXZlbnRBcGkuX2luc3RhbmNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IHsgW2RlZi5kZWZJZF06IGRlZiB9LFxuICAgICAgICBpbnN0YW5jZXM6IGluc3RhbmNlXG4gICAgICAgICAgICA/IHsgW2luc3RhbmNlLmluc3RhbmNlSWRdOiBpbnN0YW5jZSB9XG4gICAgICAgICAgICA6IHt9LFxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50QXBpcyhldmVudFN0b3JlLCBjb250ZXh0LCBleGNsdWRlSW5zdGFuY2UpIHtcbiAgICBsZXQgeyBkZWZzLCBpbnN0YW5jZXMgfSA9IGV2ZW50U3RvcmU7XG4gICAgbGV0IGV2ZW50QXBpcyA9IFtdO1xuICAgIGxldCBleGNsdWRlSW5zdGFuY2VJZCA9IGV4Y2x1ZGVJbnN0YW5jZSA/IGV4Y2x1ZGVJbnN0YW5jZS5pbnN0YW5jZUlkIDogJyc7XG4gICAgZm9yIChsZXQgaWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpZF07XG4gICAgICAgIGxldCBkZWYgPSBkZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgaWYgKGluc3RhbmNlLmluc3RhbmNlSWQgIT09IGV4Y2x1ZGVJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICBldmVudEFwaXMucHVzaChuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRBcGlzO1xufVxuXG4vKlxuU3BlY2lmeWluZyBuZXh0RGF5VGhyZXNob2xkIHNpZ25hbHMgdGhhdCBhbGwtZGF5IHJhbmdlcyBzaG91bGQgYmUgc2xpY2VkLlxuKi9cbmZ1bmN0aW9uIHNsaWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBldmVudFVpQmFzZXMsIGZyYW1pbmdSYW5nZSwgbmV4dERheVRocmVzaG9sZCkge1xuICAgIGxldCBpbnZlcnNlQmdCeUdyb3VwSWQgPSB7fTtcbiAgICBsZXQgaW52ZXJzZUJnQnlEZWZJZCA9IHt9O1xuICAgIGxldCBkZWZCeUdyb3VwSWQgPSB7fTtcbiAgICBsZXQgYmdSYW5nZXMgPSBbXTtcbiAgICBsZXQgZmdSYW5nZXMgPSBbXTtcbiAgICBsZXQgZXZlbnRVaXMgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudFVpQmFzZXMpO1xuICAgIGZvciAobGV0IGRlZklkIGluIGV2ZW50U3RvcmUuZGVmcykge1xuICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2RlZklkXTtcbiAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgaWYgKHVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmdyb3VwSWQpIHtcbiAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeUdyb3VwSWRbZGVmLmdyb3VwSWRdID0gW107XG4gICAgICAgICAgICAgICAgaWYgKCFkZWZCeUdyb3VwSWRbZGVmLmdyb3VwSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZkJ5R3JvdXBJZFtkZWYuZ3JvdXBJZF0gPSBkZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlEZWZJZFtkZWZJZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpbnN0YW5jZUlkIGluIGV2ZW50U3RvcmUuaW5zdGFuY2VzKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgICAgICBsZXQgZGVmID0gZXZlbnRTdG9yZS5kZWZzW2luc3RhbmNlLmRlZklkXTtcbiAgICAgICAgbGV0IHVpID0gZXZlbnRVaXNbZGVmLmRlZklkXTtcbiAgICAgICAgbGV0IG9yaWdSYW5nZSA9IGluc3RhbmNlLnJhbmdlO1xuICAgICAgICBsZXQgbm9ybWFsUmFuZ2UgPSAoIWRlZi5hbGxEYXkgJiYgbmV4dERheVRocmVzaG9sZCkgP1xuICAgICAgICAgICAgY29tcHV0ZVZpc2libGVEYXlSYW5nZShvcmlnUmFuZ2UsIG5leHREYXlUaHJlc2hvbGQpIDpcbiAgICAgICAgICAgIG9yaWdSYW5nZTtcbiAgICAgICAgbGV0IHNsaWNlZFJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKG5vcm1hbFJhbmdlLCBmcmFtaW5nUmFuZ2UpO1xuICAgICAgICBpZiAoc2xpY2VkUmFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh1aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeUdyb3VwSWRbZGVmLmdyb3VwSWRdLnB1c2goc2xpY2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJzZUJnQnlEZWZJZFtpbnN0YW5jZS5kZWZJZF0ucHVzaChzbGljZWRSYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodWkuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgKHVpLmRpc3BsYXkgPT09ICdiYWNrZ3JvdW5kJyA/IGJnUmFuZ2VzIDogZmdSYW5nZXMpLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBkZWYsXG4gICAgICAgICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBub3JtYWxSYW5nZS5zdGFydCAmJiBub3JtYWxSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IG5vcm1hbFJhbmdlLmVuZCAmJiBub3JtYWxSYW5nZS5lbmQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5lbmQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGdyb3VwSWQgaW4gaW52ZXJzZUJnQnlHcm91cElkKSB7IC8vIEJZIEdST1VQXG4gICAgICAgIGxldCByYW5nZXMgPSBpbnZlcnNlQmdCeUdyb3VwSWRbZ3JvdXBJZF07XG4gICAgICAgIGxldCBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgIGZvciAobGV0IGludmVydGVkUmFuZ2Ugb2YgaW52ZXJ0ZWRSYW5nZXMpIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBkZWZCeUdyb3VwSWRbZ3JvdXBJZF07XG4gICAgICAgICAgICBsZXQgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdO1xuICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGVmLFxuICAgICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBpbnZlcnRlZFJhbmdlLFxuICAgICAgICAgICAgICAgIGlzU3RhcnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzRW5kOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGRlZklkIGluIGludmVyc2VCZ0J5RGVmSWQpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IGludmVyc2VCZ0J5RGVmSWRbZGVmSWRdO1xuICAgICAgICBsZXQgaW52ZXJ0ZWRSYW5nZXMgPSBpbnZlcnRSYW5nZXMocmFuZ2VzLCBmcmFtaW5nUmFuZ2UpO1xuICAgICAgICBmb3IgKGxldCBpbnZlcnRlZFJhbmdlIG9mIGludmVydGVkUmFuZ2VzKSB7XG4gICAgICAgICAgICBiZ1Jhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkZWY6IGV2ZW50U3RvcmUuZGVmc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgdWk6IGV2ZW50VWlzW2RlZklkXSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICByYW5nZTogaW52ZXJ0ZWRSYW5nZSxcbiAgICAgICAgICAgICAgICBpc1N0YXJ0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0VuZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBiZzogYmdSYW5nZXMsIGZnOiBmZ1JhbmdlcyB9O1xufVxuZnVuY3Rpb24gaGFzQmdSZW5kZXJpbmcoZGVmKSB7XG4gICAgcmV0dXJuIGRlZi51aS5kaXNwbGF5ID09PSAnYmFja2dyb3VuZCcgfHwgZGVmLnVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnO1xufVxuZnVuY3Rpb24gc2V0RWxTZWcoZWwsIHNlZykge1xuICAgIGVsLmZjU2VnID0gc2VnO1xufVxuZnVuY3Rpb24gZ2V0RWxTZWcoZWwpIHtcbiAgICByZXR1cm4gZWwuZmNTZWcgfHxcbiAgICAgICAgZWwucGFyZW50Tm9kZS5mY1NlZyB8fCAvLyBmb3IgdGhlIGhhcm5lc3NcbiAgICAgICAgbnVsbDtcbn1cbi8vIGV2ZW50IHVpIGNvbXB1dGF0aW9uXG5mdW5jdGlvbiBjb21waWxlRXZlbnRVaXMoZXZlbnREZWZzLCBldmVudFVpQmFzZXMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChldmVudERlZnMsIChldmVudERlZikgPT4gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykpO1xufVxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWkoZXZlbnREZWYsIGV2ZW50VWlCYXNlcykge1xuICAgIGxldCB1aXMgPSBbXTtcbiAgICBpZiAoZXZlbnRVaUJhc2VzWycnXSkge1xuICAgICAgICB1aXMucHVzaChldmVudFVpQmFzZXNbJyddKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzW2V2ZW50RGVmLmRlZklkXSk7XG4gICAgfVxuICAgIHVpcy5wdXNoKGV2ZW50RGVmLnVpKTtcbiAgICByZXR1cm4gY29tYmluZUV2ZW50VWlzKHVpcyk7XG59XG5mdW5jdGlvbiBzb3J0RXZlbnRTZWdzKHNlZ3MsIGV2ZW50T3JkZXJTcGVjcykge1xuICAgIGxldCBvYmpzID0gc2Vncy5tYXAoYnVpbGRTZWdDb21wYXJlT2JqKTtcbiAgICBvYmpzLnNvcnQoKG9iajAsIG9iajEpID0+IGNvbXBhcmVCeUZpZWxkU3BlY3Mob2JqMCwgb2JqMSwgZXZlbnRPcmRlclNwZWNzKSk7XG4gICAgcmV0dXJuIG9ianMubWFwKChjKSA9PiBjLl9zZWcpO1xufVxuLy8gcmV0dXJucyBhIG9iamVjdCB3aXRoIGFsbCBwcmltaXRpdmUgcHJvcHMgdGhhdCBjYW4gYmUgY29tcGFyZWRcbmZ1bmN0aW9uIGJ1aWxkU2VnQ29tcGFyZU9iaihzZWcpIHtcbiAgICBsZXQgeyBldmVudFJhbmdlIH0gPSBzZWc7XG4gICAgbGV0IGV2ZW50RGVmID0gZXZlbnRSYW5nZS5kZWY7XG4gICAgbGV0IHJhbmdlID0gZXZlbnRSYW5nZS5pbnN0YW5jZSA/IGV2ZW50UmFuZ2UuaW5zdGFuY2UucmFuZ2UgOiBldmVudFJhbmdlLnJhbmdlO1xuICAgIGxldCBzdGFydCA9IHJhbmdlLnN0YXJ0ID8gcmFuZ2Uuc3RhcnQudmFsdWVPZigpIDogMDsgLy8gVE9ETzogYmV0dGVyIHN1cHBvcnQgZm9yIG9wZW4tcmFuZ2UgZXZlbnRzXG4gICAgbGV0IGVuZCA9IHJhbmdlLmVuZCA/IHJhbmdlLmVuZC52YWx1ZU9mKCkgOiAwOyAvLyBcIlxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnREZWYuZXh0ZW5kZWRQcm9wcyksIGV2ZW50RGVmKSwgeyBpZDogZXZlbnREZWYucHVibGljSWQsIHN0YXJ0LFxuICAgICAgICBlbmQsIGR1cmF0aW9uOiBlbmQgLSBzdGFydCwgYWxsRGF5OiBOdW1iZXIoZXZlbnREZWYuYWxsRGF5KSwgX3NlZzogc2VnIH0pO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ0RyYWdnYWJsZShzZWcsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBwbHVnaW5Ib29rcyB9ID0gY29udGV4dDtcbiAgICBsZXQgdHJhbnNmb3JtZXJzID0gcGx1Z2luSG9va3MuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM7XG4gICAgbGV0IHsgZGVmLCB1aSB9ID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgbGV0IHZhbCA9IHVpLnN0YXJ0RWRpdGFibGU7XG4gICAgZm9yIChsZXQgdHJhbnNmb3JtZXIgb2YgdHJhbnNmb3JtZXJzKSB7XG4gICAgICAgIHZhbCA9IHRyYW5zZm9ybWVyKHZhbCwgZGVmLCB1aSwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc1N0YXJ0ICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGUgJiYgY29udGV4dC5vcHRpb25zLmV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZShzZWcsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2VnLmlzRW5kICYmIHNlZy5ldmVudFJhbmdlLnVpLmR1cmF0aW9uRWRpdGFibGU7XG59XG5mdW5jdGlvbiBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsIC8vIGRlZmF1bHRzIHRvIHRydWVcbmRlZmF1bHREaXNwbGF5RXZlbnRFbmQsIC8vIGRlZmF1bHRzIHRvIHRydWVcbnN0YXJ0T3ZlcnJpZGUsIGVuZE92ZXJyaWRlKSB7XG4gICAgbGV0IHsgZGF0ZUVudiwgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBsZXQgeyBkaXNwbGF5RXZlbnRUaW1lLCBkaXNwbGF5RXZlbnRFbmQgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGV2ZW50RGVmID0gc2VnLmV2ZW50UmFuZ2UuZGVmO1xuICAgIGxldCBldmVudEluc3RhbmNlID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgaWYgKGRpc3BsYXlFdmVudFRpbWUgPT0gbnVsbCkge1xuICAgICAgICBkaXNwbGF5RXZlbnRUaW1lID0gZGVmYXVsdERpc3BsYXlFdmVudFRpbWUgIT09IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGxheUV2ZW50RW5kID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheUV2ZW50RW5kID0gZGVmYXVsdERpc3BsYXlFdmVudEVuZCAhPT0gZmFsc2U7XG4gICAgfVxuICAgIGxldCB3aG9sZUV2ZW50U3RhcnQgPSBldmVudEluc3RhbmNlLnJhbmdlLnN0YXJ0O1xuICAgIGxldCB3aG9sZUV2ZW50RW5kID0gZXZlbnRJbnN0YW5jZS5yYW5nZS5lbmQ7XG4gICAgbGV0IHNlZ1N0YXJ0ID0gc3RhcnRPdmVycmlkZSB8fCBzZWcuc3RhcnQgfHwgc2VnLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQ7XG4gICAgbGV0IHNlZ0VuZCA9IGVuZE92ZXJyaWRlIHx8IHNlZy5lbmQgfHwgc2VnLmV2ZW50UmFuZ2UucmFuZ2UuZW5kO1xuICAgIGxldCBpc1N0YXJ0RGF5ID0gc3RhcnRPZkRheSh3aG9sZUV2ZW50U3RhcnQpLnZhbHVlT2YoKSA9PT0gc3RhcnRPZkRheShzZWdTdGFydCkudmFsdWVPZigpO1xuICAgIGxldCBpc0VuZERheSA9IHN0YXJ0T2ZEYXkoYWRkTXMod2hvbGVFdmVudEVuZCwgLTEpKS52YWx1ZU9mKCkgPT09IHN0YXJ0T2ZEYXkoYWRkTXMoc2VnRW5kLCAtMSkpLnZhbHVlT2YoKTtcbiAgICBpZiAoZGlzcGxheUV2ZW50VGltZSAmJiAhZXZlbnREZWYuYWxsRGF5ICYmIChpc1N0YXJ0RGF5IHx8IGlzRW5kRGF5KSkge1xuICAgICAgICBzZWdTdGFydCA9IGlzU3RhcnREYXkgPyB3aG9sZUV2ZW50U3RhcnQgOiBzZWdTdGFydDtcbiAgICAgICAgc2VnRW5kID0gaXNFbmREYXkgPyB3aG9sZUV2ZW50RW5kIDogc2VnRW5kO1xuICAgICAgICBpZiAoZGlzcGxheUV2ZW50RW5kICYmIGV2ZW50RGVmLmhhc0VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2Uoc2VnU3RhcnQsIHNlZ0VuZCwgdGltZUZvcm1hdCwge1xuICAgICAgICAgICAgICAgIGZvcmNlZFN0YXJ0VHpvOiBzdGFydE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgICAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRPdmVycmlkZSA/IG51bGwgOiBldmVudEluc3RhbmNlLmZvcmNlZEVuZFR6byxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChzZWdTdGFydCwgdGltZUZvcm1hdCwge1xuICAgICAgICAgICAgZm9yY2VkVHpvOiBzdGFydE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sIC8vIG5vb29vbywgc2FtZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufVxuZnVuY3Rpb24gZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UsIG5vd0RhdGUpIHtcbiAgICBsZXQgc2VnUmFuZ2UgPSBzZWcuZXZlbnRSYW5nZS5yYW5nZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc1Bhc3Q6IHNlZ1JhbmdlLmVuZCA8PSAobm93RGF0ZSB8fCB0b2RheVJhbmdlLnN0YXJ0KSxcbiAgICAgICAgaXNGdXR1cmU6IHNlZ1JhbmdlLnN0YXJ0ID49IChub3dEYXRlIHx8IHRvZGF5UmFuZ2UuZW5kKSxcbiAgICAgICAgaXNUb2RheTogdG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIHNlZ1JhbmdlLnN0YXJ0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRDbGFzc05hbWVzKHByb3BzKSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbJ2ZjLWV2ZW50J107XG4gICAgaWYgKHByb3BzLmlzTWlycm9yKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0RyYWdnYWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnYWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydFJlc2l6YWJsZSB8fCBwcm9wcy5pc0VuZFJlc2l6YWJsZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6YWJsZScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2luZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWRyYWdnaW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1Jlc2l6aW5nKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcmVzaXppbmcnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zZWxlY3RlZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNTdGFydCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXN0YXJ0Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0VuZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWVuZCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNQYXN0KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtcGFzdCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNUb2RheSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXRvZGF5Jyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc0Z1dHVyZSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LWZ1dHVyZScpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRSYW5nZUtleShldmVudFJhbmdlKSB7XG4gICAgcmV0dXJuIGV2ZW50UmFuZ2UuaW5zdGFuY2VcbiAgICAgICAgPyBldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRcbiAgICAgICAgOiBgJHtldmVudFJhbmdlLmRlZi5kZWZJZH06JHtldmVudFJhbmdlLnJhbmdlLnN0YXJ0LnRvSVNPU3RyaW5nKCl9YDtcbiAgICAvLyBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzIGRvbid0IGhhdmUgc3BlY2lmaWMgaW5zdGFuY2VzLiBUT0RPOiBiZXR0ZXIgc29sdXRpb25cbn1cbmZ1bmN0aW9uIGdldFNlZ0FuY2hvckF0dHJzKHNlZywgY29udGV4dCkge1xuICAgIGxldCB7IGRlZiwgaW5zdGFuY2UgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIGxldCB7IHVybCB9ID0gZGVmO1xuICAgIGlmICh1cmwpIHtcbiAgICAgICAgcmV0dXJuIHsgaHJlZjogdXJsIH07XG4gICAgfVxuICAgIGxldCB7IGVtaXR0ZXIsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZXZlbnRJbnRlcmFjdGl2ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBkZWYuaW50ZXJhY3RpdmU7XG4gICAgICAgIGlmIChldmVudEludGVyYWN0aXZlID09IG51bGwpIHtcbiAgICAgICAgICAgIGV2ZW50SW50ZXJhY3RpdmUgPSBCb29sZWFuKGVtaXR0ZXIuaGFzSGFuZGxlcnMoJ2V2ZW50Q2xpY2snKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbW9jayB3aGF0IGhhcHBlbnMgaW4gRXZlbnRDbGlja2luZ1xuICAgIGlmIChldmVudEludGVyYWN0aXZlKSB7XG4gICAgICAgIC8vIG9ubHkgYXR0YWNoIGtleWJvYXJkLXJlbGF0ZWQgaGFuZGxlcnMgYmVjYXVzZSBjbGljayBoYW5kbGVyIGlzIGFscmVhZHkgZG9uZSBpbiBFdmVudENsaWNraW5nXG4gICAgICAgIHJldHVybiBjcmVhdGVBcmlhS2V5Ym9hcmRBdHRycygoZXYpID0+IHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRDbGljaycsIHtcbiAgICAgICAgICAgICAgICBlbDogZXYudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuXG5jb25zdCBTVEFOREFSRF9QUk9QUyA9IHtcbiAgICBzdGFydDogaWRlbnRpdHksXG4gICAgZW5kOiBpZGVudGl0eSxcbiAgICBhbGxEYXk6IEJvb2xlYW4sXG59O1xuZnVuY3Rpb24gcGFyc2VEYXRlU3BhbihyYXcsIGRhdGVFbnYsIGRlZmF1bHREdXJhdGlvbikge1xuICAgIGxldCBzcGFuID0gcGFyc2VPcGVuRGF0ZVNwYW4ocmF3LCBkYXRlRW52KTtcbiAgICBsZXQgeyByYW5nZSB9ID0gc3BhbjtcbiAgICBpZiAoIXJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJhbmdlLmVuZCkge1xuICAgICAgICBpZiAoZGVmYXVsdER1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlLmVuZCA9IGRhdGVFbnYuYWRkKHJhbmdlLnN0YXJ0LCBkZWZhdWx0RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gc3Bhbjtcbn1cbi8qXG5UT0RPOiBzb21laG93IGNvbWJpbmUgd2l0aCBwYXJzZVJhbmdlP1xuV2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgc3RhcnQvZW5kIHByb3BzIHdlcmUgcHJlc2VudCBidXQgcGFyc2VkIGludmFsaWRseS5cbiovXG5mdW5jdGlvbiBwYXJzZU9wZW5EYXRlU3BhbihyYXcsIGRhdGVFbnYpIHtcbiAgICBsZXQgeyByZWZpbmVkOiBzdGFuZGFyZFByb3BzLCBleHRyYSB9ID0gcmVmaW5lUHJvcHMocmF3LCBTVEFOREFSRF9QUk9QUyk7XG4gICAgbGV0IHN0YXJ0TWV0YSA9IHN0YW5kYXJkUHJvcHMuc3RhcnQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5zdGFydCkgOiBudWxsO1xuICAgIGxldCBlbmRNZXRhID0gc3RhbmRhcmRQcm9wcy5lbmQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5lbmQpIDogbnVsbDtcbiAgICBsZXQgeyBhbGxEYXkgfSA9IHN0YW5kYXJkUHJvcHM7XG4gICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgIGFsbERheSA9IChzdGFydE1ldGEgJiYgc3RhcnRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKSAmJlxuICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHJhbmdlOiB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRNZXRhID8gc3RhcnRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgICAgICBlbmQ6IGVuZE1ldGEgPyBlbmRNZXRhLm1hcmtlciA6IG51bGwsXG4gICAgICAgIH0sIGFsbERheSB9LCBleHRyYSk7XG59XG5mdW5jdGlvbiBpc0RhdGVTcGFuc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgIHJldHVybiByYW5nZXNFcXVhbChzcGFuMC5yYW5nZSwgc3BhbjEucmFuZ2UpICYmXG4gICAgICAgIHNwYW4wLmFsbERheSA9PT0gc3BhbjEuYWxsRGF5ICYmXG4gICAgICAgIGlzU3BhblByb3BzRXF1YWwoc3BhbjAsIHNwYW4xKTtcbn1cbi8vIHRoZSBOT04tREFURS1SRUxBVEVEIHByb3BzXG5mdW5jdGlvbiBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHNwYW4xKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gJ3JhbmdlJyAmJiBwcm9wTmFtZSAhPT0gJ2FsbERheScpIHtcbiAgICAgICAgICAgIGlmIChzcGFuMFtwcm9wTmFtZV0gIT09IHNwYW4xW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhcmUgdGhlcmUgYW55IHByb3BzIHRoYXQgc3BhbjAgaGFzIHRoYXQgc3BhbjEgRE9FU04nVCBoYXZlP1xuICAgIC8vIGJvdGggaGF2ZSByYW5nZS9hbGxEYXksIHNvIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlLlxuICAgIGZvciAobGV0IHByb3BOYW1lIGluIHNwYW4wKSB7XG4gICAgICAgIGlmICghKHByb3BOYW1lIGluIHNwYW4xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaShzcGFuLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGRSYW5nZUFwaShzcGFuLnJhbmdlLCBkYXRlRW52LCBzcGFuLmFsbERheSkpLCB7IGFsbERheTogc3Bhbi5hbGxEYXkgfSk7XG59XG5mdW5jdGlvbiBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkUmFuZ2VBcGkocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSksIHsgdGltZVpvbmU6IGRhdGVFbnYudGltZVpvbmUgfSk7XG59XG5mdW5jdGlvbiBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnRvRGF0ZShyYW5nZS5zdGFydCksXG4gICAgICAgIGVuZDogZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgc3RhcnRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0LCB7IG9taXRUaW1lIH0pLFxuICAgICAgICBlbmRTdHI6IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLmVuZCwgeyBvbWl0VGltZSB9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KSB7XG4gICAgbGV0IHJlcyA9IHJlZmluZUV2ZW50RGVmKHsgZWRpdGFibGU6IGZhbHNlIH0sIGNvbnRleHQpO1xuICAgIGxldCBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlcy5yZWZpbmVkLCByZXMuZXh0cmEsICcnLCAvLyBzb3VyY2VJZFxuICAgIGRhdGVTcGFuLmFsbERheSwgdHJ1ZSwgLy8gaGFzRW5kXG4gICAgY29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmLFxuICAgICAgICB1aTogY29tcGlsZUV2ZW50VWkoZGVmLCBldmVudFVpQmFzZXMpLFxuICAgICAgICBpbnN0YW5jZTogY3JlYXRlRXZlbnRJbnN0YW5jZShkZWYuZGVmSWQsIGRhdGVTcGFuLnJhbmdlKSxcbiAgICAgICAgcmFuZ2U6IGRhdGVTcGFuLnJhbmdlLFxuICAgICAgICBpc1N0YXJ0OiB0cnVlLFxuICAgICAgICBpc0VuZDogdHJ1ZSxcbiAgICB9O1xufVxuXG4vKlxuZ2l2ZW4gYSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIGEgcmVzdWx0IGFzeW5jaHJvbm91c2x5LlxudGhlIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY2FsbCBwYXNzZWQtaW4gc3VjY2VzcyBhbmQgZmFpbHVyZSBjYWxsYmFja3MsXG5vciBpdCBjYW4gcmV0dXJuIGEgcHJvbWlzZS5cbmlmIHlvdSBuZWVkIHRvIHBhc3MgYWRkaXRpb25hbCBwYXJhbXMgdG8gZnVuYywgYmluZCB0aGVtIGZpcnN0LlxuKi9cbmZ1bmN0aW9uIHVucHJvbWlzaWZ5KGZ1bmMsIG5vcm1hbGl6ZWRTdWNjZXNzQ2FsbGJhY2ssIG5vcm1hbGl6ZWRGYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAvLyBndWFyZCBhZ2FpbnN0IHN1Y2Nlc3MvZmFpbHVyZSBjYWxsYmFja3MgYmVpbmcgY2FsbGVkIG1vcmUgdGhhbiBvbmNlXG4gICAgLy8gYW5kIGd1YXJkIGFnYWluc3QgYSBwcm9taXNlIEFORCBjYWxsYmFjayBiZWluZyB1c2VkIHRvZ2V0aGVyLlxuICAgIGxldCBpc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgbGV0IHdyYXBwZWRTdWNjZXNzID0gZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWlzUmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgbm9ybWFsaXplZFN1Y2Nlc3NDYWxsYmFjayhyZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgd3JhcHBlZEZhaWx1cmUgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRGYWlsdXJlQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgcmVzID0gZnVuYyh3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpO1xuICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy50aGVuKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XG4gICAgfVxufVxuXG5jbGFzcyBKc29uUmVxdWVzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlc3BvbnNlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVxdWVzdEpzb24obWV0aG9kLCB1cmwsIHBhcmFtcykge1xuICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kLFxuICAgIH07XG4gICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgK1xuICAgICAgICAgICAgbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmV0Y2hPcHRpb25zLmJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyk7XG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpLnRoZW4oKGZldGNoUmVzKSA9PiB7XG4gICAgICAgIGlmIChmZXRjaFJlcy5vaykge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoUmVzLmpzb24oKS50aGVuKChwYXJzZWRSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBbcGFyc2VkUmVzcG9uc2UsIGZldGNoUmVzXTtcbiAgICAgICAgICAgIH0sICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSnNvblJlcXVlc3RFcnJvcignRmFpbHVyZSBwYXJzaW5nIEpTT04nLCBmZXRjaFJlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uUmVxdWVzdEVycm9yKCdSZXF1ZXN0IGZhaWxlZCcsIGZldGNoUmVzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5sZXQgY2FuVkdyb3dXaXRoaW5DZWxsO1xuZnVuY3Rpb24gZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIGlmIChjYW5WR3Jvd1dpdGhpbkNlbGwgPT0gbnVsbCkge1xuICAgICAgICBjYW5WR3Jvd1dpdGhpbkNlbGwgPSBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgfVxuICAgIHJldHVybiBjYW5WR3Jvd1dpdGhpbkNlbGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQ2FuVkdyb3dXaXRoaW5DZWxsKCkge1xuICAgIC8vIGZvciBTU1IsIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBjYWxsIGltbWVkaWF0ZWx5IGF0IHRvcC1sZXZlbFxuICAgIC8vIFRPRE86IGp1c3QgbWFrZSB0aGlzIGxvZ2ljIGV4ZWN1dGUgdG9wLWxldmVsLCBpbW1lZGlhdGVseSwgaW5zdGVhZCBvZiBkb2luZyBsYXppbHlcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGVsLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICBlbC5pbm5lckhUTUwgPSAnPHRhYmxlPjx0cj48dGQ+PGRpdj48L2Rpdj48L3RkPjwvdHI+PC90YWJsZT4nO1xuICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgbGV0IGRpdiA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2RpdicpO1xuICAgIGxldCBwb3NzaWJsZSA9IGRpdi5vZmZzZXRIZWlnaHQgPiAwO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIHJldHVybiBwb3NzaWJsZTtcbn1cblxuY2xhc3MgQ2FsZW5kYXJSb290IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmb3JQcmludDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUFmdGVyUHJpbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB7IGZvclByaW50IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBsZXQgaXNIZWlnaHRBdXRvID0gZm9yUHJpbnQgfHwgb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLmNvbnRlbnRIZWlnaHQgPT09ICdhdXRvJztcbiAgICAgICAgbGV0IGhlaWdodCA9ICghaXNIZWlnaHRBdXRvICYmIG9wdGlvbnMuaGVpZ2h0ICE9IG51bGwpID8gb3B0aW9ucy5oZWlnaHQgOiAnJztcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICAnZmMnLFxuICAgICAgICAgICAgZm9yUHJpbnQgPyAnZmMtbWVkaWEtcHJpbnQnIDogJ2ZjLW1lZGlhLXNjcmVlbicsXG4gICAgICAgICAgICBgZmMtZGlyZWN0aW9uLSR7b3B0aW9ucy5kaXJlY3Rpb259YCxcbiAgICAgICAgICAgIHByb3BzLnRoZW1lLmdldENsYXNzKCdyb290JyksXG4gICAgICAgIF07XG4gICAgICAgIGlmICghZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtbGlxdWlkLWhhY2snKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oY2xhc3NOYW1lcywgaGVpZ2h0LCBpc0hlaWdodEF1dG8sIGZvclByaW50KTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGxldCB7IGVtaXR0ZXIgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGVtaXR0ZXIub24oJ19iZWZvcmVwcmludCcsIHRoaXMuaGFuZGxlQmVmb3JlUHJpbnQpO1xuICAgICAgICBlbWl0dGVyLm9uKCdfYWZ0ZXJwcmludCcsIHRoaXMuaGFuZGxlQWZ0ZXJQcmludCk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBsZXQgeyBlbWl0dGVyIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBlbWl0dGVyLm9mZignX2JlZm9yZXByaW50JywgdGhpcy5oYW5kbGVCZWZvcmVQcmludCk7XG4gICAgICAgIGVtaXR0ZXIub2ZmKCdfYWZ0ZXJwcmludCcsIHRoaXMuaGFuZGxlQWZ0ZXJQcmludCk7XG4gICAgfVxufVxuXG5jbGFzcyBJbnRlcmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBzZXR0aW5ncy5jb21wb25lbnQ7XG4gICAgICAgIHRoaXMuaXNIaXRDb21ib0FsbG93ZWQgPSBzZXR0aW5ncy5pc0hpdENvbWJvQWxsb3dlZCB8fCBudWxsO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50LFxuICAgICAgICBlbDogaW5wdXQuZWwsXG4gICAgICAgIHVzZUV2ZW50Q2VudGVyOiBpbnB1dC51c2VFdmVudENlbnRlciAhPSBudWxsID8gaW5wdXQudXNlRXZlbnRDZW50ZXIgOiB0cnVlLFxuICAgICAgICBpc0hpdENvbWJvQWxsb3dlZDogaW5wdXQuaXNIaXRDb21ib0FsbG93ZWQgfHwgbnVsbCxcbiAgICB9O1xufVxuZnVuY3Rpb24gaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBbc2V0dGluZ3MuY29tcG9uZW50LnVpZF06IHNldHRpbmdzLFxuICAgIH07XG59XG4vLyBnbG9iYWwgc3RhdGVcbmNvbnN0IGludGVyYWN0aW9uU2V0dGluZ3NTdG9yZSA9IHt9O1xuXG5jbGFzcyBDYWxlbmRhckltcGwge1xuICAgIGdldEN1cnJlbnREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIuZ2V0Q3VycmVudERhdGEoKTtcbiAgICB9XG4gICAgZGlzcGF0Y2goYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmRpc3BhdGNoKGFjdGlvbik7XG4gICAgfVxuICAgIGdldCB2aWV3KCkgeyByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdBcGk7IH1cbiAgICBiYXRjaFJlbmRlcmluZyhjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICB1cGRhdGVTaXplKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ19yZXNpemUnLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gT3B0aW9uc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc2V0T3B0aW9uKG5hbWUsIHZhbCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdTRVRfT1BUSU9OJyxcbiAgICAgICAgICAgIG9wdGlvbk5hbWU6IG5hbWUsXG4gICAgICAgICAgICByYXdPcHRpb25WYWx1ZTogdmFsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0T3B0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtuYW1lXTtcbiAgICB9XG4gICAgZ2V0QXZhaWxhYmxlTG9jYWxlQ29kZXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEN1cnJlbnREYXRhKCkuYXZhaWxhYmxlUmF3TG9jYWxlcyk7XG4gICAgfVxuICAgIC8vIFRyaWdnZXJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIG9uKGhhbmRsZXJOYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIGxldCB7IGN1cnJlbnREYXRhTWFuYWdlciB9ID0gdGhpcztcbiAgICAgICAgaWYgKGN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnNbaGFuZGxlck5hbWVdKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0YU1hbmFnZXIuZW1pdHRlci5vbihoYW5kbGVyTmFtZSwgaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gbGlzdGVuZXIgbmFtZSAnJHtoYW5kbGVyTmFtZX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIub2ZmKGhhbmRsZXJOYW1lLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gbm90IG1lYW50IGZvciBwdWJsaWMgdXNlXG4gICAgdHJpZ2dlcihoYW5kbGVyTmFtZSwgLi4uYXJncykge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLnRyaWdnZXIoaGFuZGxlck5hbWUsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvLyBWaWV3XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjaGFuZ2VWaWV3KHZpZXdUeXBlLCBkYXRlT3JSYW5nZSkge1xuICAgICAgICB0aGlzLmJhdGNoUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZS5zdGFydCAmJiBkYXRlT3JSYW5nZS5lbmQpIHsgLy8gYSByYW5nZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25OYW1lOiAndmlzaWJsZVJhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd09wdGlvblZhbHVlOiBkYXRlT3JSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlRW52LmNyZWF0ZU1hcmtlcihkYXRlT3JSYW5nZSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gRm9yY2VzIG5hdmlnYXRpb24gdG8gYSB2aWV3IGZvciB0aGUgZ2l2ZW4gZGF0ZS5cbiAgICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cbiAgICAvLyBuZWVkcyB0byBjaGFuZ2VcbiAgICB6b29tVG8oZGF0ZU1hcmtlciwgdmlld1R5cGUpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgc3BlYztcbiAgICAgICAgdmlld1R5cGUgPSB2aWV3VHlwZSB8fCAnZGF5JzsgLy8gZGF5IGlzIGRlZmF1bHQgem9vbVxuICAgICAgICBzcGVjID0gc3RhdGUudmlld1NwZWNzW3ZpZXdUeXBlXSB8fCB0aGlzLmdldFVuaXRWaWV3U3BlYyh2aWV3VHlwZSk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgaWYgKHNwZWMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICB2aWV3VHlwZTogc3BlYy50eXBlLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cbiAgICAvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXG4gICAgZ2V0VW5pdFZpZXdTcGVjKHVuaXQpIHtcbiAgICAgICAgbGV0IHsgdmlld1NwZWNzLCB0b29sYmFyQ29uZmlnIH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCB2aWV3VHlwZXMgPSBbXS5jb25jYXQodG9vbGJhckNvbmZpZy5oZWFkZXIgPyB0b29sYmFyQ29uZmlnLmhlYWRlci52aWV3c1dpdGhCdXR0b25zIDogW10sIHRvb2xiYXJDb25maWcuZm9vdGVyID8gdG9vbGJhckNvbmZpZy5mb290ZXIudmlld3NXaXRoQnV0dG9ucyA6IFtdKTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBzcGVjO1xuICAgICAgICBmb3IgKGxldCB2aWV3VHlwZSBpbiB2aWV3U3BlY3MpIHtcbiAgICAgICAgICAgIHZpZXdUeXBlcy5wdXNoKHZpZXdUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlld1R5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBzcGVjID0gdmlld1NwZWNzW3ZpZXdUeXBlc1tpXV07XG4gICAgICAgICAgICBpZiAoc3BlYykge1xuICAgICAgICAgICAgICAgIGlmIChzcGVjLnNpbmdsZVVuaXQgPT09IHVuaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNwZWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDdXJyZW50IERhdGVcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHByZXYoKSB7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdQUkVWJyB9KTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ05FWFQnIH0pO1xuICAgIH1cbiAgICBwcmV2WWVhcigpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIC0xKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5leHRZZWFyKCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGRZZWFycyhzdGF0ZS5jdXJyZW50RGF0ZSwgMSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b2RheSgpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IGdldE5vdyhzdGF0ZS5jYWxlbmRhck9wdGlvbnMubm93LCBzdGF0ZS5kYXRlRW52KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdvdG9EYXRlKHpvbmVkRGF0ZUlucHV0KSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICBkYXRlTWFya2VyOiBzdGF0ZS5kYXRlRW52LmNyZWF0ZU1hcmtlcih6b25lZERhdGVJbnB1dCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmNyZW1lbnREYXRlKGRlbHRhSW5wdXQpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBsZXQgZGVsdGEgPSBjcmVhdGVEdXJhdGlvbihkZWx0YUlucHV0KTtcbiAgICAgICAgaWYgKGRlbHRhKSB7IC8vIGVsc2UsIHdhcm4gYWJvdXQgaW52YWxpZCBpbnB1dD9cbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfREFURScsXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGQoc3RhdGUuY3VycmVudERhdGUsIGRlbHRhKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldERhdGUoKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmRhdGVFbnYudG9EYXRlKHN0YXRlLmN1cnJlbnREYXRlKTtcbiAgICB9XG4gICAgLy8gRGF0ZSBGb3JtYXR0aW5nIFV0aWxzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBmb3JtYXREYXRlKGQsIGZvcm1hdHRlcikge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdChkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgY3JlYXRlRm9ybWF0dGVyKGZvcm1hdHRlcikpO1xuICAgIH1cbiAgICAvLyBgc2V0dGluZ3NgIGlzIGZvciBmb3JtYXR0ZXIgQU5EIGlzRW5kRXhjbHVzaXZlXG4gICAgZm9ybWF0UmFuZ2UoZDAsIGQxLCBzZXR0aW5ncykge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKGRhdGVFbnYuY3JlYXRlTWFya2VyKGQwKSwgZGF0ZUVudi5jcmVhdGVNYXJrZXIoZDEpLCBjcmVhdGVGb3JtYXR0ZXIoc2V0dGluZ3MpLCBzZXR0aW5ncyk7XG4gICAgfVxuICAgIGZvcm1hdElzbyhkLCBvbWl0VGltZSkge1xuICAgICAgICBsZXQgeyBkYXRlRW52IH0gPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmZvcm1hdElzbyhkYXRlRW52LmNyZWF0ZU1hcmtlcihkKSwgeyBvbWl0VGltZSB9KTtcbiAgICB9XG4gICAgLy8gRGF0ZSBTZWxlY3Rpb24gLyBFdmVudCBTZWxlY3Rpb24gLyBEYXlDbGlja1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc2VsZWN0KGRhdGVPck9iaiwgZW5kRGF0ZSkge1xuICAgICAgICBsZXQgc2VsZWN0aW9uSW5wdXQ7XG4gICAgICAgIGlmIChlbmREYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChkYXRlT3JPYmouc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0gZGF0ZU9yT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZERhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHBhcnNlRGF0ZVNwYW4oc2VsZWN0aW9uSW5wdXQsIHN0YXRlLmRhdGVFbnYsIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KSk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHsgLy8gdGhyb3cgcGFyc2UgZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdTRUxFQ1RfREFURVMnLCBzZWxlY3Rpb24gfSk7XG4gICAgICAgICAgICB0cmlnZ2VyRGF0ZVNlbGVjdChzZWxlY3Rpb24sIG51bGwsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnNlbGVjdChwZXYpIHtcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBpZiAoc3RhdGUuZGF0ZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9EQVRFUycgfSk7XG4gICAgICAgICAgICB0cmlnZ2VyRGF0ZVVuc2VsZWN0KHBldiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFB1YmxpYyBFdmVudHMgQVBJXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBhZGRFdmVudChldmVudElucHV0LCBzb3VyY2VJbnB1dCkge1xuICAgICAgICBpZiAoZXZlbnRJbnB1dCBpbnN0YW5jZW9mIEV2ZW50SW1wbCkge1xuICAgICAgICAgICAgbGV0IGRlZiA9IGV2ZW50SW5wdXQuX2RlZjtcbiAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGV2ZW50SW5wdXQuX2luc3RhbmNlO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnREYXRhLmV2ZW50U3RvcmUuZGVmc1tkZWYuZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUoeyBkZWYsIGluc3RhbmNlIH0pLCAvLyBUT0RPOiBiZXR0ZXIgdXRpbCBmb3IgdHdvIGFyZ3M/XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQoZXZlbnRJbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBldmVudFNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VJbXBsKSB7XG4gICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUlucHV0LmludGVybmFsRXZlbnRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNvdXJjZUlucHV0ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VJbnB1dCkgeyAvLyB0cnVlLiBwYXJ0IG9mIHRoZSBmaXJzdCBldmVudCBzb3VyY2VcbiAgICAgICAgICAgICAgICBbZXZlbnRTb3VyY2VdID0gaGFzaFZhbHVlc1RvQXJyYXkoc3RhdGUuZXZlbnRTb3VyY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3VyY2VJbnB1dCAhPSBudWxsKSB7IC8vIGFuIElELiBhY2NlcHRzIGEgbnVtYmVyIHRvb1xuICAgICAgICAgICAgbGV0IHNvdXJjZUFwaSA9IHRoaXMuZ2V0RXZlbnRTb3VyY2VCeUlkKHNvdXJjZUlucHV0KTsgLy8gVE9ETzogdXNlIGFuIGludGVybmFsIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIXNvdXJjZUFwaSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgYW4gZXZlbnQgc291cmNlIHdpdGggSUQgXCIke3NvdXJjZUlucHV0fVwiYCk7IC8vIFRPRE86IHRlc3RcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlQXBpLmludGVybmFsRXZlbnRTb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR1cGxlID0gcGFyc2VFdmVudChldmVudElucHV0LCBldmVudFNvdXJjZSwgc3RhdGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKHR1cGxlKSB7XG4gICAgICAgICAgICBsZXQgbmV3RXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKHN0YXRlLCB0dXBsZS5kZWYsIHR1cGxlLmRlZi5yZWN1cnJpbmdEZWYgPyBudWxsIDogdHVwbGUuaW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQobmV3RXZlbnRBcGkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50QXBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0cmlnZ2VyRXZlbnRBZGQoZXZlbnRBcGkpIHtcbiAgICAgICAgbGV0IHsgZW1pdHRlciB9ID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50QWRkJywge1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogW10sXG4gICAgICAgICAgICByZXZlcnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudEFwaVRvU3RvcmUoZXZlbnRBcGkpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRPRE86IG9wdGltaXplXG4gICAgZ2V0RXZlbnRCeUlkKGlkKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBzdGF0ZS5ldmVudFN0b3JlO1xuICAgICAgICBpZCA9IFN0cmluZyhpZCk7XG4gICAgICAgIGZvciAobGV0IGRlZklkIGluIGRlZnMpIHtcbiAgICAgICAgICAgIGxldCBkZWYgPSBkZWZzW2RlZklkXTtcbiAgICAgICAgICAgIGlmIChkZWYucHVibGljSWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdmVudEltcGwoc3RhdGUsIGRlZiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmRlZklkID09PSBkZWYuZGVmSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRJbXBsKHN0YXRlLCBkZWYsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0RXZlbnRzKCkge1xuICAgICAgICBsZXQgY3VycmVudERhdGEgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBidWlsZEV2ZW50QXBpcyhjdXJyZW50RGF0YS5ldmVudFN0b3JlLCBjdXJyZW50RGF0YSk7XG4gICAgfVxuICAgIHJlbW92ZUFsbEV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQUxMX0VWRU5UUycgfSk7XG4gICAgfVxuICAgIC8vIFB1YmxpYyBFdmVudCBTb3VyY2VzIEFQSVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZ2V0RXZlbnRTb3VyY2VzKCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzO1xuICAgICAgICBsZXQgc291cmNlQXBpcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbnRlcm5hbElkIGluIHNvdXJjZUhhc2gpIHtcbiAgICAgICAgICAgIHNvdXJjZUFwaXMucHVzaChuZXcgRXZlbnRTb3VyY2VJbXBsKHN0YXRlLCBzb3VyY2VIYXNoW2ludGVybmFsSWRdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZUFwaXM7XG4gICAgfVxuICAgIGdldEV2ZW50U291cmNlQnlJZChpZCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGxldCBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzO1xuICAgICAgICBpZCA9IFN0cmluZyhpZCk7XG4gICAgICAgIGZvciAobGV0IHNvdXJjZUlkIGluIHNvdXJjZUhhc2gpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VIYXNoW3NvdXJjZUlkXS5wdWJsaWNJZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgc291cmNlSGFzaFtzb3VyY2VJZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhZGRFdmVudFNvdXJjZShzb3VyY2VJbnB1dCkge1xuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGlmIChzb3VyY2VJbnB1dCBpbnN0YW5jZW9mIEV2ZW50U291cmNlSW1wbCkge1xuICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmV2ZW50U291cmNlc1tzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VzOiBbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZV0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc291cmNlSW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50U291cmNlID0gcGFyc2VFdmVudFNvdXJjZShzb3VyY2VJbnB1dCwgc3RhdGUpO1xuICAgICAgICBpZiAoZXZlbnRTb3VyY2UpIHsgLy8gVE9ETzogZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsIHNvdXJjZXM6IFtldmVudFNvdXJjZV0gfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlSW1wbChzdGF0ZSwgZXZlbnRTb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZW1vdmVBbGxFdmVudFNvdXJjZXMoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJyB9KTtcbiAgICB9XG4gICAgcmVmZXRjaEV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJywgaXNSZWZldGNoOiB0cnVlIH0pO1xuICAgIH1cbiAgICAvLyBTY3JvbGxcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNjcm9sbFRvVGltZSh0aW1lSW5wdXQpIHtcbiAgICAgICAgbGV0IHRpbWUgPSBjcmVhdGVEdXJhdGlvbih0aW1lSW5wdXQpO1xuICAgICAgICBpZiAodGltZSkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdfc2Nyb2xsUmVxdWVzdCcsIHsgdGltZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9pbnRJbnNpZGVSZWN0KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHBvaW50LmxlZnQgPj0gcmVjdC5sZWZ0ICYmXG4gICAgICAgIHBvaW50LmxlZnQgPCByZWN0LnJpZ2h0ICYmXG4gICAgICAgIHBvaW50LnRvcCA+PSByZWN0LnRvcCAmJlxuICAgICAgICBwb2ludC50b3AgPCByZWN0LmJvdHRvbTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXG5mdW5jdGlvbiBpbnRlcnNlY3RSZWN0cyhyZWN0MSwgcmVjdDIpIHtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcbiAgICAgICAgcmlnaHQ6IE1hdGgubWluKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5tYXgocmVjdDEudG9wLCByZWN0Mi50b3ApLFxuICAgICAgICBib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKSxcbiAgICB9O1xuICAgIGlmIChyZXMubGVmdCA8IHJlcy5yaWdodCAmJiByZXMudG9wIDwgcmVzLmJvdHRvbSkge1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVSZWN0KHJlY3QsIGRlbHRhWCwgZGVsdGFZKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgZGVsdGFYLFxuICAgICAgICByaWdodDogcmVjdC5yaWdodCArIGRlbHRhWCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIGRlbHRhWSxcbiAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSArIGRlbHRhWSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIG5ldyBwb2ludCB0aGF0IHdpbGwgaGF2ZSBiZWVuIG1vdmVkIHRvIHJlc2lkZSB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZVxuZnVuY3Rpb24gY29uc3RyYWluUG9pbnQocG9pbnQsIHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBNYXRoLm1pbihNYXRoLm1heChwb2ludC5sZWZ0LCByZWN0LmxlZnQpLCByZWN0LnJpZ2h0KSxcbiAgICAgICAgdG9wOiBNYXRoLm1pbihNYXRoLm1heChwb2ludC50b3AsIHJlY3QudG9wKSwgcmVjdC5ib3R0b20pLFxuICAgIH07XG59XG4vLyBSZXR1cm5zIGEgcG9pbnQgdGhhdCBpcyB0aGUgY2VudGVyIG9mIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGdldFJlY3RDZW50ZXIocmVjdCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIsXG4gICAgICAgIHRvcDogKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMixcbiAgICB9O1xufVxuLy8gU3VidHJhY3RzIHBvaW50MidzIGNvb3JkaW5hdGVzIGZyb20gcG9pbnQxJ3MgY29vcmRpbmF0ZXMsIHJldHVybmluZyBhIGRlbHRhXG5mdW5jdGlvbiBkaWZmUG9pbnRzKHBvaW50MSwgcG9pbnQyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcbiAgICAgICAgdG9wOiBwb2ludDEudG9wIC0gcG9pbnQyLnRvcCxcbiAgICB9O1xufVxuXG5jb25zdCBFTVBUWV9FVkVOVF9TVE9SRSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpOyAvLyBmb3IgcHVyZWNvbXBvbmVudHMuIFRPRE86IGtlZXAgZWxzZXdoZXJlXG5jbGFzcyBTcGxpdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyA9IG1lbW9pemUodGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyk7XG4gICAgICAgIHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uID0gbWVtb2l6ZSh0aGlzLl9zcGxpdERhdGVTcGFuKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50U3RvcmUgPSBtZW1vaXplKHRoaXMuX3NwbGl0RXZlbnRTdG9yZSk7XG4gICAgICAgIHRoaXMuc3BsaXRJbmRpdmlkdWFsVWkgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW5kaXZpZHVhbFVpKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc3BsaXRJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc3BsaXRJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuZXZlbnRVaUJ1aWxkZXJzID0ge307IC8vIFRPRE86IHR5cGVzY3JpcHQgcHJvdGVjdGlvblxuICAgIH1cbiAgICBzcGxpdFByb3BzKHByb3BzKSB7XG4gICAgICAgIGxldCBrZXlJbmZvcyA9IHRoaXMuZ2V0S2V5SW5mbyhwcm9wcyk7XG4gICAgICAgIGxldCBkZWZLZXlzID0gdGhpcy5nZXRLZXlzRm9yRXZlbnREZWZzKHByb3BzLmV2ZW50U3RvcmUpO1xuICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvbnMgPSB0aGlzLnNwbGl0RGF0ZVNlbGVjdGlvbihwcm9wcy5kYXRlU2VsZWN0aW9uKTtcbiAgICAgICAgbGV0IGluZGl2aWR1YWxVaSA9IHRoaXMuc3BsaXRJbmRpdmlkdWFsVWkocHJvcHMuZXZlbnRVaUJhc2VzLCBkZWZLZXlzKTsgLy8gdGhlIGluZGl2aWR1YWwgKmJhc2VzKlxuICAgICAgICBsZXQgZXZlbnRTdG9yZXMgPSB0aGlzLnNwbGl0RXZlbnRTdG9yZShwcm9wcy5ldmVudFN0b3JlLCBkZWZLZXlzKTtcbiAgICAgICAgbGV0IGV2ZW50RHJhZ3MgPSB0aGlzLnNwbGl0RXZlbnREcmFnKHByb3BzLmV2ZW50RHJhZyk7XG4gICAgICAgIGxldCBldmVudFJlc2l6ZXMgPSB0aGlzLnNwbGl0RXZlbnRSZXNpemUocHJvcHMuZXZlbnRSZXNpemUpO1xuICAgICAgICBsZXQgc3BsaXRQcm9wcyA9IHt9O1xuICAgICAgICB0aGlzLmV2ZW50VWlCdWlsZGVycyA9IG1hcEhhc2goa2V5SW5mb3MsIChpbmZvLCBrZXkpID0+IHRoaXMuZXZlbnRVaUJ1aWxkZXJzW2tleV0gfHwgbWVtb2l6ZShidWlsZEV2ZW50VWlGb3JLZXkpKTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGtleUluZm9zKSB7XG4gICAgICAgICAgICBsZXQga2V5SW5mbyA9IGtleUluZm9zW2tleV07XG4gICAgICAgICAgICBsZXQgZXZlbnRTdG9yZSA9IGV2ZW50U3RvcmVzW2tleV0gfHwgRU1QVFlfRVZFTlRfU1RPUkU7XG4gICAgICAgICAgICBsZXQgYnVpbGRFdmVudFVpID0gdGhpcy5ldmVudFVpQnVpbGRlcnNba2V5XTtcbiAgICAgICAgICAgIHNwbGl0UHJvcHNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICBidXNpbmVzc0hvdXJzOiBrZXlJbmZvLmJ1c2luZXNzSG91cnMgfHwgcHJvcHMuYnVzaW5lc3NIb3VycyxcbiAgICAgICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBkYXRlU2VsZWN0aW9uc1trZXldIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZXZlbnRTdG9yZSxcbiAgICAgICAgICAgICAgICBldmVudFVpQmFzZXM6IGJ1aWxkRXZlbnRVaShwcm9wcy5ldmVudFVpQmFzZXNbJyddLCBrZXlJbmZvLnVpLCBpbmRpdmlkdWFsVWlba2V5XSksXG4gICAgICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246IGV2ZW50U3RvcmUuaW5zdGFuY2VzW3Byb3BzLmV2ZW50U2VsZWN0aW9uXSA/IHByb3BzLmV2ZW50U2VsZWN0aW9uIDogJycsXG4gICAgICAgICAgICAgICAgZXZlbnREcmFnOiBldmVudERyYWdzW2tleV0gfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVzW2tleV0gfHwgbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0UHJvcHM7XG4gICAgfVxuICAgIF9zcGxpdERhdGVTcGFuKGRhdGVTcGFuKSB7XG4gICAgICAgIGxldCBkYXRlU3BhbnMgPSB7fTtcbiAgICAgICAgaWYgKGRhdGVTcGFuKSB7XG4gICAgICAgICAgICBsZXQga2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgZGF0ZVNwYW5zW2tleV0gPSBkYXRlU3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZVNwYW5zO1xuICAgIH1cbiAgICBfZ2V0S2V5c0ZvckV2ZW50RGVmcyhldmVudFN0b3JlKSB7XG4gICAgICAgIHJldHVybiBtYXBIYXNoKGV2ZW50U3RvcmUuZGVmcywgKGV2ZW50RGVmKSA9PiB0aGlzLmdldEtleXNGb3JFdmVudERlZihldmVudERlZikpO1xuICAgIH1cbiAgICBfc3BsaXRFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGRlZktleXMpIHtcbiAgICAgICAgbGV0IHsgZGVmcywgaW5zdGFuY2VzIH0gPSBldmVudFN0b3JlO1xuICAgICAgICBsZXQgc3BsaXRTdG9yZXMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIGRlZktleXNbZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0b3Jlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0gPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XS5kZWZzW2RlZklkXSA9IGRlZnNbZGVmSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgZGVmS2V5c1tpbnN0YW5jZS5kZWZJZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRTdG9yZXNba2V5XSkgeyAvLyBtdXN0IGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XS5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RvcmVzO1xuICAgIH1cbiAgICBfc3BsaXRJbmRpdmlkdWFsVWkoZXZlbnRVaUJhc2VzLCBkZWZLZXlzKSB7XG4gICAgICAgIGxldCBzcGxpdEhhc2hlcyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBkZWZJZCBpbiBldmVudFVpQmFzZXMpIHtcbiAgICAgICAgICAgIGlmIChkZWZJZCkgeyAvLyBub3QgdGhlICcnIGtleVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGtleSBvZiBkZWZLZXlzW2RlZklkXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwbGl0SGFzaGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0SGFzaGVzW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldW2RlZklkXSA9IGV2ZW50VWlCYXNlc1tkZWZJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdEhhc2hlcztcbiAgICB9XG4gICAgX3NwbGl0SW50ZXJhY3Rpb24oaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgbGV0IHNwbGl0U3RhdGVzID0ge307XG4gICAgICAgIGlmIChpbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgbGV0IGFmZmVjdGVkU3RvcmVzID0gdGhpcy5fc3BsaXRFdmVudFN0b3JlKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLCB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzKSk7XG4gICAgICAgICAgICAvLyBjYW4ndCByZWx5IG9uIGRlZktleXMgYmVjYXVzZSBldmVudCBkYXRhIGlzIG11dGF0ZWRcbiAgICAgICAgICAgIGxldCBtdXRhdGVkS2V5c0J5RGVmSWQgPSB0aGlzLl9nZXRLZXlzRm9yRXZlbnREZWZzKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMpO1xuICAgICAgICAgICAgbGV0IG11dGF0ZWRTdG9yZXMgPSB0aGlzLl9zcGxpdEV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgbXV0YXRlZEtleXNCeURlZklkKTtcbiAgICAgICAgICAgIGxldCBwb3B1bGF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXNwbGl0U3RhdGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdGF0ZXNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBhZmZlY3RlZFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbXV0YXRlZFN0b3Jlc1trZXldIHx8IEVNUFRZX0VWRU5UX1NUT1JFLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIGFmZmVjdGVkU3RvcmVzKSB7XG4gICAgICAgICAgICAgICAgcG9wdWxhdGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGtleSBpbiBtdXRhdGVkU3RvcmVzKSB7XG4gICAgICAgICAgICAgICAgcG9wdWxhdGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRTdGF0ZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpRm9yS2V5KGFsbFVpLCBldmVudFVpRm9yS2V5LCBpbmRpdmlkdWFsVWkpIHtcbiAgICBsZXQgYmFzZVBhcnRzID0gW107XG4gICAgaWYgKGFsbFVpKSB7XG4gICAgICAgIGJhc2VQYXJ0cy5wdXNoKGFsbFVpKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50VWlGb3JLZXkpIHtcbiAgICAgICAgYmFzZVBhcnRzLnB1c2goZXZlbnRVaUZvcktleSk7XG4gICAgfVxuICAgIGxldCBzdHVmZiA9IHtcbiAgICAgICAgJyc6IGNvbWJpbmVFdmVudFVpcyhiYXNlUGFydHMpLFxuICAgIH07XG4gICAgaWYgKGluZGl2aWR1YWxVaSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHN0dWZmLCBpbmRpdmlkdWFsVWkpO1xuICAgIH1cbiAgICByZXR1cm4gc3R1ZmY7XG59XG5cbmZ1bmN0aW9uIGdldERhdGVNZXRhKGRhdGUsIHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGRhdGVQcm9maWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZG93OiBkYXRlLmdldFVUQ0RheSgpLFxuICAgICAgICBpc0Rpc2FibGVkOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzT3RoZXI6IEJvb2xlYW4oZGF0ZVByb2ZpbGUgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzVG9kYXk6IEJvb2xlYW4odG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIGRhdGUpKSxcbiAgICAgICAgaXNQYXN0OiBCb29sZWFuKG5vd0RhdGUgPyAoZGF0ZSA8IG5vd0RhdGUpIDogdG9kYXlSYW5nZSA/IChkYXRlIDwgdG9kYXlSYW5nZS5zdGFydCkgOiBmYWxzZSksXG4gICAgICAgIGlzRnV0dXJlOiBCb29sZWFuKG5vd0RhdGUgPyAoZGF0ZSA+IG5vd0RhdGUpIDogdG9kYXlSYW5nZSA/IChkYXRlID49IHRvZGF5UmFuZ2UuZW5kKSA6IGZhbHNlKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RGF5Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtZGF5JyxcbiAgICAgICAgYGZjLWRheS0ke0RBWV9JRFNbbWV0YS5kb3ddfWAsXG4gICAgXTtcbiAgICBpZiAobWV0YS5pc0Rpc2FibGVkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS10b2RheScpO1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKHRoZW1lLmdldENsYXNzKCd0b2RheScpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5pc1Bhc3QpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LXBhc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5pc0Z1dHVyZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktZnV0dXJlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNPdGhlcikge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktb3RoZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIGdldFNsb3RDbGFzc05hbWVzKG1ldGEsIHRoZW1lKSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1zbG90JyxcbiAgICAgICAgYGZjLXNsb3QtJHtEQVlfSURTW21ldGEuZG93XX1gLFxuICAgIF07XG4gICAgaWYgKG1ldGEuaXNEaXNhYmxlZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZGlzYWJsZWQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC10b2RheScpO1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKHRoZW1lLmdldENsYXNzKCd0b2RheScpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5pc1Bhc3QpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1wYXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNGdXR1cmUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2xvdC1mdXR1cmUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cblxuY29uc3QgREFZX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfSk7XG5jb25zdCBXRUVLX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICdsb25nJyB9KTtcbmZ1bmN0aW9uIGJ1aWxkTmF2TGlua0F0dHJzKGNvbnRleHQsIGRhdGVNYXJrZXIsIHZpZXdUeXBlID0gJ2RheScsIGlzVGFiYmFibGUgPSB0cnVlKSB7XG4gICAgY29uc3QgeyBkYXRlRW52LCBvcHRpb25zLCBjYWxlbmRhckFwaSB9ID0gY29udGV4dDtcbiAgICBsZXQgZGF0ZVN0ciA9IGRhdGVFbnYuZm9ybWF0KGRhdGVNYXJrZXIsIHZpZXdUeXBlID09PSAnd2VlaycgPyBXRUVLX0ZPUk1BVCA6IERBWV9GT1JNQVQpO1xuICAgIGlmIChvcHRpb25zLm5hdkxpbmtzKSB7XG4gICAgICAgIGxldCB6b25lZERhdGUgPSBkYXRlRW52LnRvRGF0ZShkYXRlTWFya2VyKTtcbiAgICAgICAgY29uc3QgaGFuZGxlSW50ZXJhY3Rpb24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCBjdXN0b21BY3Rpb24gPSB2aWV3VHlwZSA9PT0gJ2RheScgPyBvcHRpb25zLm5hdkxpbmtEYXlDbGljayA6XG4gICAgICAgICAgICAgICAgdmlld1R5cGUgPT09ICd3ZWVrJyA/IG9wdGlvbnMubmF2TGlua1dlZWtDbGljayA6IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGN1c3RvbUFjdGlvbi5jYWxsKGNhbGVuZGFyQXBpLCBkYXRlRW52LnRvRGF0ZShkYXRlTWFya2VyKSwgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlID0gY3VzdG9tQWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaS56b29tVG8oZGF0ZU1hcmtlciwgdmlld1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHRpdGxlOiBmb3JtYXRXaXRoT3JkaW5hbHMob3B0aW9ucy5uYXZMaW5rSGludCwgW2RhdGVTdHIsIHpvbmVkRGF0ZV0sIGRhdGVTdHIpLCAnZGF0YS1uYXZsaW5rJzogJycgfSwgKGlzVGFiYmFibGVcbiAgICAgICAgICAgID8gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlSW50ZXJhY3Rpb24pXG4gICAgICAgICAgICA6IHsgb25DbGljazogaGFuZGxlSW50ZXJhY3Rpb24gfSkpO1xuICAgIH1cbiAgICByZXR1cm4geyAnYXJpYS1sYWJlbCc6IGRhdGVTdHIgfTtcbn1cblxubGV0IF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IG51bGw7XG5mdW5jdGlvbiBnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICBpZiAoX2lzUnRsU2Nyb2xsYmFyT25MZWZ0ID09PSBudWxsKSB7XG4gICAgICAgIF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9IGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpO1xuICAgIH1cbiAgICByZXR1cm4gX2lzUnRsU2Nyb2xsYmFyT25MZWZ0O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzUnRsU2Nyb2xsYmFyT25MZWZ0KCkge1xuICAgIGxldCBvdXRlckVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYXBwbHlTdHlsZShvdXRlckVsLCB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB0b3A6IC0xMDAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcbiAgICAgICAgZGlyZWN0aW9uOiAncnRsJyxcbiAgICB9KTtcbiAgICBvdXRlckVsLmlubmVySFRNTCA9ICc8ZGl2PjwvZGl2Pic7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlckVsKTtcbiAgICBsZXQgaW5uZXJFbCA9IG91dGVyRWwuZmlyc3RDaGlsZDtcbiAgICBsZXQgcmVzID0gaW5uZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID4gb3V0ZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIHJlbW92ZUVsZW1lbnQob3V0ZXJFbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxubGV0IF9zY3JvbGxiYXJXaWR0aHM7XG5mdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgaWYgKCFfc2Nyb2xsYmFyV2lkdGhzKSB7XG4gICAgICAgIF9zY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzKCk7XG4gICAgfVxuICAgIHJldHVybiBfc2Nyb2xsYmFyV2lkdGhzO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpIHtcbiAgICBsZXQgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5zdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnO1xuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbC5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG4gICAgZWwuc3R5bGUubGVmdCA9ICctOTk5OXB4JztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgICBsZXQgcmVzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8gV0FSTklORzogd2lsbCBpbmNsdWRlIGJvcmRlclxuZnVuY3Rpb24gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZWwub2Zmc2V0SGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0LFxuICAgICAgICB5OiBlbC5vZmZzZXRXaWR0aCAtIGVsLmNsaWVudFdpZHRoLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFZGdlcyhlbCwgZ2V0UGFkZGluZyA9IGZhbHNlKSB7XG4gICAgbGV0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgbGV0IGJvcmRlckxlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCwgMTApIHx8IDA7XG4gICAgbGV0IGJvcmRlclJpZ2h0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoLCAxMCkgfHwgMDtcbiAgICBsZXQgYm9yZGVyVG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCwgMTApIHx8IDA7XG4gICAgbGV0IGJvcmRlckJvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwKSB8fCAwO1xuICAgIGxldCBiYWRTY3JvbGxiYXJXaWR0aHMgPSBjb21wdXRlU2Nyb2xsYmFyV2lkdGhzRm9yRWwoZWwpOyAvLyBpbmNsdWRlcyBib3JkZXIhXG4gICAgbGV0IHNjcm9sbGJhckxlZnRSaWdodCA9IGJhZFNjcm9sbGJhcldpZHRocy55IC0gYm9yZGVyTGVmdCAtIGJvcmRlclJpZ2h0O1xuICAgIGxldCBzY3JvbGxiYXJCb3R0b20gPSBiYWRTY3JvbGxiYXJXaWR0aHMueCAtIGJvcmRlclRvcCAtIGJvcmRlckJvdHRvbTtcbiAgICBsZXQgcmVzID0ge1xuICAgICAgICBib3JkZXJMZWZ0LFxuICAgICAgICBib3JkZXJSaWdodCxcbiAgICAgICAgYm9yZGVyVG9wLFxuICAgICAgICBib3JkZXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckJvdHRvbSxcbiAgICAgICAgc2Nyb2xsYmFyTGVmdDogMCxcbiAgICAgICAgc2Nyb2xsYmFyUmlnaHQ6IDAsXG4gICAgfTtcbiAgICBpZiAoZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSAmJiBjb21wdXRlZFN0eWxlLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHsgLy8gaXMgdGhlIHNjcm9sbGJhciBvbiB0aGUgbGVmdCBzaWRlP1xuICAgICAgICByZXMuc2Nyb2xsYmFyTGVmdCA9IHNjcm9sbGJhckxlZnRSaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcy5zY3JvbGxiYXJSaWdodCA9IHNjcm9sbGJhckxlZnRSaWdodDtcbiAgICB9XG4gICAgaWYgKGdldFBhZGRpbmcpIHtcbiAgICAgICAgcmVzLnBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nUmlnaHQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCwgMTApIHx8IDA7XG4gICAgICAgIHJlcy5wYWRkaW5nVG9wID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nVG9wLCAxMCkgfHwgMDtcbiAgICAgICAgcmVzLnBhZGRpbmdCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdCb3R0b20sIDEwKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY29tcHV0ZUlubmVyUmVjdChlbCwgZ29XaXRoaW5QYWRkaW5nID0gZmFsc2UsIGRvRnJvbVdpbmRvd1ZpZXdwb3J0KSB7XG4gICAgbGV0IG91dGVyUmVjdCA9IGRvRnJvbVdpbmRvd1ZpZXdwb3J0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBjb21wdXRlUmVjdChlbCk7XG4gICAgbGV0IGVkZ2VzID0gY29tcHV0ZUVkZ2VzKGVsLCBnb1dpdGhpblBhZGRpbmcpO1xuICAgIGxldCByZXMgPSB7XG4gICAgICAgIGxlZnQ6IG91dGVyUmVjdC5sZWZ0ICsgZWRnZXMuYm9yZGVyTGVmdCArIGVkZ2VzLnNjcm9sbGJhckxlZnQsXG4gICAgICAgIHJpZ2h0OiBvdXRlclJlY3QucmlnaHQgLSBlZGdlcy5ib3JkZXJSaWdodCAtIGVkZ2VzLnNjcm9sbGJhclJpZ2h0LFxuICAgICAgICB0b3A6IG91dGVyUmVjdC50b3AgKyBlZGdlcy5ib3JkZXJUb3AsXG4gICAgICAgIGJvdHRvbTogb3V0ZXJSZWN0LmJvdHRvbSAtIGVkZ2VzLmJvcmRlckJvdHRvbSAtIGVkZ2VzLnNjcm9sbGJhckJvdHRvbSxcbiAgICB9O1xuICAgIGlmIChnb1dpdGhpblBhZGRpbmcpIHtcbiAgICAgICAgcmVzLmxlZnQgKz0gZWRnZXMucGFkZGluZ0xlZnQ7XG4gICAgICAgIHJlcy5yaWdodCAtPSBlZGdlcy5wYWRkaW5nUmlnaHQ7XG4gICAgICAgIHJlcy50b3AgKz0gZWRnZXMucGFkZGluZ1RvcDtcbiAgICAgICAgcmVzLmJvdHRvbSAtPSBlZGdlcy5wYWRkaW5nQm90dG9tO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY29tcHV0ZVJlY3QoZWwpIHtcbiAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICB0b3A6IHJlY3QudG9wICsgd2luZG93LnNjcm9sbFksXG4gICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0ICsgd2luZG93LnNjcm9sbFgsXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyB3aW5kb3cuc2Nyb2xsWSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0KGVsKSB7XG4gICAgbGV0IGNsaXBwaW5nUGFyZW50cyA9IGdldENsaXBwaW5nUGFyZW50cyhlbCk7XG4gICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBmb3IgKGxldCBjbGlwcGluZ1BhcmVudCBvZiBjbGlwcGluZ1BhcmVudHMpIHtcbiAgICAgICAgbGV0IGludGVyc2VjdGlvbiA9IGludGVyc2VjdFJlY3RzKHJlY3QsIGNsaXBwaW5nUGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgcmVjdCA9IGludGVyc2VjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWN0O1xufVxuLy8gZG9lcyBub3QgcmV0dXJuIHdpbmRvd1xuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKSB7XG4gICAgbGV0IHBhcmVudHMgPSBbXTtcbiAgICB3aGlsZSAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyB3aWxsIHN0b3Agd2hlbiBnZXRzIHRvIGRvY3VtZW50IG9yIG51bGxcbiAgICAgICAgbGV0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIGlmIChjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKC8oYXV0b3xzY3JvbGwpLykudGVzdChjb21wdXRlZFN0eWxlLm92ZXJmbG93ICsgY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1kgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbn1cblxuLypcblJlY29yZHMgb2Zmc2V0IGluZm9ybWF0aW9uIGZvciBhIHNldCBvZiBlbGVtZW50cywgcmVsYXRpdmUgdG8gYW4gb3JpZ2luIGVsZW1lbnQuXG5DYW4gcmVjb3JkIHRoZSBsZWZ0L3JpZ2h0IE9SIHRoZSB0b3AvYm90dG9tIE9SIGJvdGguXG5Qcm92aWRlcyBtZXRob2RzIGZvciBxdWVyeWluZyB0aGUgY2FjaGUgYnkgcG9zaXRpb24uXG4qL1xuY2xhc3MgUG9zaXRpb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luRWwsIGVscywgaXNIb3Jpem9udGFsLCBpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHRoaXMuZWxzID0gZWxzO1xuICAgICAgICBsZXQgb3JpZ2luQ2xpZW50UmVjdCA9IHRoaXMub3JpZ2luQ2xpZW50UmVjdCA9IG9yaWdpbkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3AtbGVmdFxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxIb3Jpem9udGFscyhvcmlnaW5DbGllbnRSZWN0LmxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxWZXJ0aWNhbHMob3JpZ2luQ2xpZW50UmVjdC50b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyB0aGUgbGVmdC9yaWdodCBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuICAgIGJ1aWxkRWxIb3Jpem9udGFscyhvcmlnaW5DbGllbnRMZWZ0KSB7XG4gICAgICAgIGxldCBsZWZ0cyA9IFtdO1xuICAgICAgICBsZXQgcmlnaHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGVsIG9mIHRoaXMuZWxzKSB7XG4gICAgICAgICAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgbGVmdHMucHVzaChyZWN0LmxlZnQgLSBvcmlnaW5DbGllbnRMZWZ0KTtcbiAgICAgICAgICAgIHJpZ2h0cy5wdXNoKHJlY3QucmlnaHQgLSBvcmlnaW5DbGllbnRMZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnRzID0gbGVmdHM7XG4gICAgICAgIHRoaXMucmlnaHRzID0gcmlnaHRzO1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgdGhlIHRvcC9ib3R0b20gaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcbiAgICBidWlsZEVsVmVydGljYWxzKG9yaWdpbkNsaWVudFRvcCkge1xuICAgICAgICBsZXQgdG9wcyA9IFtdO1xuICAgICAgICBsZXQgYm90dG9tcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBlbCBvZiB0aGlzLmVscykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRvcHMucHVzaChyZWN0LnRvcCAtIG9yaWdpbkNsaWVudFRvcCk7XG4gICAgICAgICAgICBib3R0b21zLnB1c2gocmVjdC5ib3R0b20gLSBvcmlnaW5DbGllbnRUb3ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9wcyA9IHRvcHM7XG4gICAgICAgIHRoaXMuYm90dG9tcyA9IGJvdHRvbXM7XG4gICAgfVxuICAgIC8vIEdpdmVuIGEgbGVmdCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IGhvcml6b250YWxseSBpbnRlcnNlY3RzLlxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICBsZWZ0VG9JbmRleChsZWZ0UG9zaXRpb24pIHtcbiAgICAgICAgbGV0IHsgbGVmdHMsIHJpZ2h0cyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxlbiA9IGxlZnRzLmxlbmd0aDtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGxlZnRQb3NpdGlvbiA+PSBsZWZ0c1tpXSAmJiBsZWZ0UG9zaXRpb24gPCByaWdodHNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBUT0RPOiBiZXR0ZXJcbiAgICB9XG4gICAgLy8gR2l2ZW4gYSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IHZlcnRpY2FsbHkgaW50ZXJzZWN0cy5cbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgdG9wVG9JbmRleCh0b3BQb3NpdGlvbikge1xuICAgICAgICBsZXQgeyB0b3BzLCBib3R0b21zIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbGVuID0gdG9wcy5sZW5ndGg7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh0b3BQb3NpdGlvbiA+PSB0b3BzW2ldICYmIHRvcFBvc2l0aW9uIDwgYm90dG9tc1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIFRPRE86IGJldHRlclxuICAgIH1cbiAgICAvLyBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICBnZXRXaWR0aChsZWZ0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLmxlZnRzW2xlZnRJbmRleF07XG4gICAgfVxuICAgIC8vIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICBnZXRIZWlnaHQodG9wSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLnRvcHNbdG9wSW5kZXhdO1xuICAgIH1cbiAgICBzaW1pbGFyVG8ob3RoZXJDYWNoZSkge1xuICAgICAgICByZXR1cm4gc2ltaWxhck51bUFycmF5cyh0aGlzLnRvcHMgfHwgW10sIG90aGVyQ2FjaGUudG9wcyB8fCBbXSkgJiZcbiAgICAgICAgICAgIHNpbWlsYXJOdW1BcnJheXModGhpcy5ib3R0b21zIHx8IFtdLCBvdGhlckNhY2hlLmJvdHRvbXMgfHwgW10pICYmXG4gICAgICAgICAgICBzaW1pbGFyTnVtQXJyYXlzKHRoaXMubGVmdHMgfHwgW10sIG90aGVyQ2FjaGUubGVmdHMgfHwgW10pICYmXG4gICAgICAgICAgICBzaW1pbGFyTnVtQXJyYXlzKHRoaXMucmlnaHRzIHx8IFtdLCBvdGhlckNhY2hlLnJpZ2h0cyB8fCBbXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2ltaWxhck51bUFycmF5cyhhLCBiKSB7XG4gICAgY29uc3QgbGVuID0gYS5sZW5ndGg7XG4gICAgaWYgKGxlbiAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChNYXRoLnJvdW5kKGFbaV0pICE9PSBNYXRoLnJvdW5kKGJbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qIGVzbGludCBtYXgtY2xhc3Nlcy1wZXItZmlsZTogXCJvZmZcIiAqL1xuLypcbkFuIG9iamVjdCBmb3IgZ2V0dGluZy9zZXR0aW5nIHNjcm9sbC1yZWxhdGVkIGluZm9ybWF0aW9uIGZvciBhbiBlbGVtZW50LlxuSW50ZXJuYWxseSwgdGhpcyBpcyBkb25lIHZlcnkgZGlmZmVyZW50bHkgZm9yIHdpbmRvdyB2ZXJzdXMgRE9NIGVsZW1lbnQsXG5zbyB0aGlzIG9iamVjdCBzZXJ2ZXMgYXMgYSBjb21tb24gaW50ZXJmYWNlLlxuKi9cbmNsYXNzIFNjcm9sbENvbnRyb2xsZXIge1xuICAgIGdldE1heFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KCkgLSB0aGlzLmdldENsaWVudEhlaWdodCgpO1xuICAgIH1cbiAgICBnZXRNYXhTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxXaWR0aCgpIC0gdGhpcy5nZXRDbGllbnRXaWR0aCgpO1xuICAgIH1cbiAgICBjYW5TY3JvbGxWZXJ0aWNhbGx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXhTY3JvbGxUb3AoKSA+IDA7XG4gICAgfVxuICAgIGNhblNjcm9sbEhvcml6b250YWxseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsTGVmdCgpID4gMDtcbiAgICB9XG4gICAgY2FuU2Nyb2xsVXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpID4gMDtcbiAgICB9XG4gICAgY2FuU2Nyb2xsRG93bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsVG9wKCkgPCB0aGlzLmdldE1heFNjcm9sbFRvcCgpO1xuICAgIH1cbiAgICBjYW5TY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxMZWZ0KCkgPiAwO1xuICAgIH1cbiAgICBjYW5TY3JvbGxSaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCk7XG4gICAgfVxufVxuY2xhc3MgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgZXh0ZW5kcyBTY3JvbGxDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgfVxuICAgIGdldFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsVG9wO1xuICAgIH1cbiAgICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgICBzZXRTY3JvbGxUb3AodG9wKSB7XG4gICAgICAgIHRoaXMuZWwuc2Nyb2xsVG9wID0gdG9wO1xuICAgIH1cbiAgICBzZXRTY3JvbGxMZWZ0KGxlZnQpIHtcbiAgICAgICAgdGhpcy5lbC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbFdpZHRoO1xuICAgIH1cbiAgICBnZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbEhlaWdodDtcbiAgICB9XG4gICAgZ2V0Q2xpZW50SGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jbGllbnRIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jbGllbnRXaWR0aDtcbiAgICB9XG59XG5jbGFzcyBXaW5kb3dTY3JvbGxDb250cm9sbGVyIGV4dGVuZHMgU2Nyb2xsQ29udHJvbGxlciB7XG4gICAgZ2V0U2Nyb2xsVG9wKCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFk7XG4gICAgfVxuICAgIGdldFNjcm9sbExlZnQoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsWDtcbiAgICB9XG4gICAgc2V0U2Nyb2xsVG9wKG4pIHtcbiAgICAgICAgd2luZG93LnNjcm9sbCh3aW5kb3cuc2Nyb2xsWCwgbik7XG4gICAgfVxuICAgIHNldFNjcm9sbExlZnQobikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsKG4sIHdpbmRvdy5zY3JvbGxZKTtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgfVxuICAgIGdldFNjcm9sbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgfVxuICAgIGdldENsaWVudFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIH1cbn1cblxuLypcbmFuIElOVEVSQUNUQUJMRSBkYXRlIGNvbXBvbmVudFxuXG5QVVJQT1NFUzpcbi0gaG9vayB1cCB0byBmZywgZmlsbCwgYW5kIG1pcnJvciByZW5kZXJlcnNcbi0gaW50ZXJmYWNlIGZvciBkcmFnZ2luZyBhbmQgaGl0c1xuKi9cbmNsYXNzIERhdGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy51aWQgPSBndWlkKCk7XG4gICAgfVxuICAgIC8vIEhpdCBTeXN0ZW1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHByZXBhcmVIaXRzKCkge1xuICAgIH1cbiAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBzaG91bGQgYmUgYWJzdHJhY3RcbiAgICB9XG4gICAgLy8gUG9pbnRlciBJbnRlcmFjdGlvbiBVdGlsc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaXNWYWxpZFNlZ0Rvd25FbChlbCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucHJvcHMuZXZlbnREcmFnICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICF0aGlzLnByb3BzLmV2ZW50UmVzaXplICYmIC8vIEhBQ0tcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudC1taXJyb3InKTtcbiAgICB9XG4gICAgaXNWYWxpZERhdGVEb3duRWwoZWwpIHtcbiAgICAgICAgcmV0dXJuICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1ldmVudDpub3QoLmZjLWJnLWV2ZW50KScpICYmXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtbW9yZS1saW5rJykgJiYgLy8gYSBcIm1vcmUuLlwiIGxpbmtcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJ2FbZGF0YS1uYXZsaW5rXScpICYmIC8vIGEgY2xpY2thYmxlIG5hdiBsaW5rXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtcG9wb3ZlcicpOyAvLyBoYWNrXG4gICAgfVxufVxuXG5jbGFzcyBOYW1lZFRpbWVab25lSW1wbCB7XG4gICAgY29uc3RydWN0b3IodGltZVpvbmVOYW1lKSB7XG4gICAgICAgIHRoaXMudGltZVpvbmVOYW1lID0gdGltZVpvbmVOYW1lO1xuICAgIH1cbn1cblxuY2xhc3MgU2VnSGllcmFyY2h5IHtcbiAgICBjb25zdHJ1Y3RvcihnZXRFbnRyeVRoaWNrbmVzcyA9IChlbnRyeSkgPT4ge1xuICAgICAgICAvLyBpZiBubyB0aGlja25lc3Mga25vd24sIGFzc3VtZSAxIChpZiAwLCBzbyBzbWFsbCBpdCBhbHdheXMgZml0cylcbiAgICAgICAgcmV0dXJuIGVudHJ5LnRoaWNrbmVzcyB8fCAxO1xuICAgIH0pIHtcbiAgICAgICAgdGhpcy5nZXRFbnRyeVRoaWNrbmVzcyA9IGdldEVudHJ5VGhpY2tuZXNzO1xuICAgICAgICAvLyBzZXR0aW5nc1xuICAgICAgICB0aGlzLnN0cmljdE9yZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb3dSZXNsaWNpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXhDb29yZCA9IC0xOyAvLyAtMSBtZWFucyBubyBtYXhcbiAgICAgICAgdGhpcy5tYXhTdGFja0NudCA9IC0xOyAvLyAtMSBtZWFucyBubyBtYXhcbiAgICAgICAgdGhpcy5sZXZlbENvb3JkcyA9IFtdOyAvLyBvcmRlcmVkXG4gICAgICAgIHRoaXMuZW50cmllc0J5TGV2ZWwgPSBbXTsgLy8gcGFyYWxsZWwgd2l0aCBsZXZlbENvb3Jkc1xuICAgICAgICB0aGlzLnN0YWNrQ250cyA9IHt9OyAvLyBUT0RPOiB1c2UgYmV0dGVyIHRlY2huaXF1ZSE/XG4gICAgfVxuICAgIGFkZFNlZ3MoaW5wdXRzKSB7XG4gICAgICAgIGxldCBoaWRkZW5FbnRyaWVzID0gW107XG4gICAgICAgIGZvciAobGV0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeShpbnB1dCwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZGRlbkVudHJpZXM7XG4gICAgfVxuICAgIGluc2VydEVudHJ5KGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIGxldCBpbnNlcnRpb24gPSB0aGlzLmZpbmRJbnNlcnRpb24oZW50cnkpO1xuICAgICAgICBpZiAodGhpcy5pc0luc2VydGlvblZhbGlkKGluc2VydGlvbiwgZW50cnkpKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5QXQoZW50cnksIGluc2VydGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNJbnNlcnRpb25WYWxpZChpbnNlcnRpb24sIGVudHJ5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5tYXhDb29yZCA9PT0gLTEgfHwgaW5zZXJ0aW9uLmxldmVsQ29vcmQgKyB0aGlzLmdldEVudHJ5VGhpY2tuZXNzKGVudHJ5KSA8PSB0aGlzLm1heENvb3JkKSAmJlxuICAgICAgICAgICAgKHRoaXMubWF4U3RhY2tDbnQgPT09IC0xIHx8IGluc2VydGlvbi5zdGFja0NudCA8IHRoaXMubWF4U3RhY2tDbnQpO1xuICAgIH1cbiAgICBoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcgJiYgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZGRlbkVudHJ5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnRyeSksIHsgc3BhbjogaW50ZXJzZWN0U3BhbnMoZW50cnkuc3BhbiwgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnkuc3BhbikgfSk7XG4gICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goaGlkZGVuRW50cnkpO1xuICAgICAgICAgICAgdGhpcy5zcGxpdEVudHJ5KGVudHJ5LCBpbnNlcnRpb24udG91Y2hpbmdFbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoaWRkZW5FbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgRG9lcyBOT1QgYWRkIHdoYXQgaGl0IHRoZSBgYmFycmllcmAgaW50byBoaWRkZW5FbnRyaWVzLiBTaG91bGQgYWxyZWFkeSBiZSBkb25lLlxuICAgICovXG4gICAgc3BsaXRFbnRyeShlbnRyeSwgYmFycmllciwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBsZXQgZW50cnlTcGFuID0gZW50cnkuc3BhbjtcbiAgICAgICAgbGV0IGJhcnJpZXJTcGFuID0gYmFycmllci5zcGFuO1xuICAgICAgICBpZiAoZW50cnlTcGFuLnN0YXJ0IDwgYmFycmllclNwYW4uc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RW50cnkoe1xuICAgICAgICAgICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcbiAgICAgICAgICAgICAgICB0aGlja25lc3M6IGVudHJ5LnRoaWNrbmVzcyxcbiAgICAgICAgICAgICAgICBzcGFuOiB7IHN0YXJ0OiBlbnRyeVNwYW4uc3RhcnQsIGVuZDogYmFycmllclNwYW4uc3RhcnQgfSxcbiAgICAgICAgICAgIH0sIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeVNwYW4uZW5kID4gYmFycmllclNwYW4uZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogYmFycmllclNwYW4uZW5kLCBlbmQ6IGVudHJ5U3Bhbi5lbmQgfSxcbiAgICAgICAgICAgIH0sIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluc2VydEVudHJ5QXQoZW50cnksIGluc2VydGlvbikge1xuICAgICAgICBsZXQgeyBlbnRyaWVzQnlMZXZlbCwgbGV2ZWxDb29yZHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChpbnNlcnRpb24ubGF0ZXJhbCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBsZXZlbFxuICAgICAgICAgICAgaW5zZXJ0QXQobGV2ZWxDb29yZHMsIGluc2VydGlvbi5sZXZlbCwgaW5zZXJ0aW9uLmxldmVsQ29vcmQpO1xuICAgICAgICAgICAgaW5zZXJ0QXQoZW50cmllc0J5TGV2ZWwsIGluc2VydGlvbi5sZXZlbCwgW2VudHJ5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbnNlcnQgaW50byBleGlzdGluZyBsZXZlbFxuICAgICAgICAgICAgaW5zZXJ0QXQoZW50cmllc0J5TGV2ZWxbaW5zZXJ0aW9uLmxldmVsXSwgaW5zZXJ0aW9uLmxhdGVyYWwsIGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YWNrQ250c1tidWlsZEVudHJ5S2V5KGVudHJ5KV0gPSBpbnNlcnRpb24uc3RhY2tDbnQ7XG4gICAgfVxuICAgIC8qXG4gICAgZG9lcyBub3QgY2FyZSBhYm91dCBsaW1pdHNcbiAgICAqL1xuICAgIGZpbmRJbnNlcnRpb24obmV3RW50cnkpIHtcbiAgICAgICAgbGV0IHsgbGV2ZWxDb29yZHMsIGVudHJpZXNCeUxldmVsLCBzdHJpY3RPcmRlciwgc3RhY2tDbnRzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbGV2ZWxDbnQgPSBsZXZlbENvb3Jkcy5sZW5ndGg7XG4gICAgICAgIGxldCBjYW5kaWRhdGVDb29yZCA9IDA7XG4gICAgICAgIGxldCB0b3VjaGluZ0xldmVsID0gLTE7XG4gICAgICAgIGxldCB0b3VjaGluZ0xhdGVyYWwgPSAtMTtcbiAgICAgICAgbGV0IHRvdWNoaW5nRW50cnkgPSBudWxsO1xuICAgICAgICBsZXQgc3RhY2tDbnQgPSAwO1xuICAgICAgICBmb3IgKGxldCB0cmFja2luZ0xldmVsID0gMDsgdHJhY2tpbmdMZXZlbCA8IGxldmVsQ250OyB0cmFja2luZ0xldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNraW5nQ29vcmQgPSBsZXZlbENvb3Jkc1t0cmFja2luZ0xldmVsXTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIHBhc3QgdGhlIHBsYWNlZCBlbnRyeSwgd2UgaGF2ZSBmb3VuZCBhIGdvb2QgZW1wdHkgc3BhY2UgYW5kIGNhbiBzdG9wLlxuICAgICAgICAgICAgLy8gaWYgc3RyaWN0T3JkZXIsIGtlZXAgZmluZGluZyBtb3JlIGxhdGVyYWwgaW50ZXJzZWN0aW9ucy5cbiAgICAgICAgICAgIGlmICghc3RyaWN0T3JkZXIgJiYgdHJhY2tpbmdDb29yZCA+PSBjYW5kaWRhdGVDb29yZCArIHRoaXMuZ2V0RW50cnlUaGlja25lc3MobmV3RW50cnkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHJhY2tpbmdFbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbdHJhY2tpbmdMZXZlbF07XG4gICAgICAgICAgICBsZXQgdHJhY2tpbmdFbnRyeTtcbiAgICAgICAgICAgIGxldCBzZWFyY2hSZXMgPSBiaW5hcnlTZWFyY2godHJhY2tpbmdFbnRyaWVzLCBuZXdFbnRyeS5zcGFuLnN0YXJ0LCBnZXRFbnRyeVNwYW5FbmQpOyAvLyBmaW5kIGZpcnN0IGVudHJ5IGFmdGVyIG5ld0VudHJ5J3MgZW5kXG4gICAgICAgICAgICBsZXQgbGF0ZXJhbEluZGV4ID0gc2VhcmNoUmVzWzBdICsgc2VhcmNoUmVzWzFdOyAvLyBpZiBleGFjdCBtYXRjaCAod2hpY2ggZG9lc24ndCBjb2xsaWRlKSwgZ28gdG8gbmV4dCBvbmVcbiAgICAgICAgICAgIHdoaWxlICggLy8gbG9vcCB0aHJvdWdoIGVudHJpZXMgdGhhdCBob3Jpem9udGFsbHkgaW50ZXJzZWN0XG4gICAgICAgICAgICAodHJhY2tpbmdFbnRyeSA9IHRyYWNraW5nRW50cmllc1tsYXRlcmFsSW5kZXhdKSAmJiAvLyBidXQgbm90IHBhc3QgdGhlIHdob2xlIGVudHJ5IGxpc3RcbiAgICAgICAgICAgICAgICB0cmFja2luZ0VudHJ5LnNwYW4uc3RhcnQgPCBuZXdFbnRyeS5zcGFuLmVuZCAvLyBhbmQgbm90IGVudGlyZWx5IHBhc3QgbmV3RW50cnlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGxldCB0cmFja2luZ0VudHJ5Qm90dG9tID0gdHJhY2tpbmdDb29yZCArIHRoaXMuZ2V0RW50cnlUaGlja25lc3ModHJhY2tpbmdFbnRyeSk7XG4gICAgICAgICAgICAgICAgLy8gaW50ZXJzZWN0cyBpbnRvIHRoZSB0b3Agb2YgdGhlIGNhbmRpZGF0ZT9cbiAgICAgICAgICAgICAgICBpZiAodHJhY2tpbmdFbnRyeUJvdHRvbSA+IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZUNvb3JkID0gdHJhY2tpbmdFbnRyeUJvdHRvbTtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdFbnRyeSA9IHRyYWNraW5nRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nTGV2ZWwgPSB0cmFja2luZ0xldmVsO1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0xhdGVyYWwgPSBsYXRlcmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGJ1dHRzIHVwIGFnYWluc3QgdG9wIG9mIGNhbmRpZGF0ZT8gKHdpbGwgaGFwcGVuIGlmIGp1c3QgaW50ZXJzZWN0ZWQgYXMgd2VsbClcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tpbmdFbnRyeUJvdHRvbSA9PT0gY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjdW11bGF0ZSB0aGUgaGlnaGVzdCBwb3NzaWJsZSBzdGFja0NudCBvZiB0aGUgdHJhY2tpbmdFbnRyaWVzIHRoYXQgYnV0dCB1cFxuICAgICAgICAgICAgICAgICAgICBzdGFja0NudCA9IE1hdGgubWF4KHN0YWNrQ250LCBzdGFja0NudHNbYnVpbGRFbnRyeUtleSh0cmFja2luZ0VudHJ5KV0gKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGF0ZXJhbEluZGV4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGRlc3RpbmF0aW9uIGxldmVsIHdpbGwgYmUgYWZ0ZXIgdG91Y2hpbmdFbnRyeSdzIGxldmVsLiBmaW5kIGl0XG4gICAgICAgIGxldCBkZXN0TGV2ZWwgPSAwO1xuICAgICAgICBpZiAodG91Y2hpbmdFbnRyeSkge1xuICAgICAgICAgICAgZGVzdExldmVsID0gdG91Y2hpbmdMZXZlbCArIDE7XG4gICAgICAgICAgICB3aGlsZSAoZGVzdExldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbZGVzdExldmVsXSA8IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICAgICAgZGVzdExldmVsICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYWRkaW5nIHRvIGFuIGV4aXN0aW5nIGxldmVsLCBmaW5kIHdoZXJlIHRvIGluc2VydFxuICAgICAgICBsZXQgZGVzdExhdGVyYWwgPSAtMTtcbiAgICAgICAgaWYgKGRlc3RMZXZlbCA8IGxldmVsQ250ICYmIGxldmVsQ29vcmRzW2Rlc3RMZXZlbF0gPT09IGNhbmRpZGF0ZUNvb3JkKSB7XG4gICAgICAgICAgICBkZXN0TGF0ZXJhbCA9IGJpbmFyeVNlYXJjaChlbnRyaWVzQnlMZXZlbFtkZXN0TGV2ZWxdLCBuZXdFbnRyeS5zcGFuLmVuZCwgZ2V0RW50cnlTcGFuRW5kKVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG91Y2hpbmdMZXZlbCxcbiAgICAgICAgICAgIHRvdWNoaW5nTGF0ZXJhbCxcbiAgICAgICAgICAgIHRvdWNoaW5nRW50cnksXG4gICAgICAgICAgICBzdGFja0NudCxcbiAgICAgICAgICAgIGxldmVsQ29vcmQ6IGNhbmRpZGF0ZUNvb3JkLFxuICAgICAgICAgICAgbGV2ZWw6IGRlc3RMZXZlbCxcbiAgICAgICAgICAgIGxhdGVyYWw6IGRlc3RMYXRlcmFsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBzb3J0ZWQgYnkgbGV2ZWxDb29yZCAobG93ZXN0IHRvIGhpZ2hlc3QpXG4gICAgdG9SZWN0cygpIHtcbiAgICAgICAgbGV0IHsgZW50cmllc0J5TGV2ZWwsIGxldmVsQ29vcmRzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgbGV2ZWxDbnQgPSBlbnRyaWVzQnlMZXZlbC5sZW5ndGg7XG4gICAgICAgIGxldCByZWN0cyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgbGV2ZWxDbnQ7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBlbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdO1xuICAgICAgICAgICAgbGV0IGxldmVsQ29vcmQgPSBsZXZlbENvb3Jkc1tsZXZlbF07XG4gICAgICAgICAgICBmb3IgKGxldCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgcmVjdHMucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVudHJ5KSwgeyB0aGlja25lc3M6IHRoaXMuZ2V0RW50cnlUaGlja25lc3MoZW50cnkpLCBsZXZlbENvb3JkIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVjdHM7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RW50cnlTcGFuRW5kKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LnNwYW4uZW5kO1xufVxuZnVuY3Rpb24gYnVpbGRFbnRyeUtleShlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5pbmRleCArICc6JyArIGVudHJ5LnNwYW4uc3RhcnQ7XG59XG4vLyByZXR1cm5zIGdyb3VwcyB3aXRoIGVudHJpZXMgc29ydGVkIGJ5IGlucHV0IG9yZGVyXG5mdW5jdGlvbiBncm91cEludGVyc2VjdGluZ0VudHJpZXMoZW50cmllcykge1xuICAgIGxldCBtZXJnZXMgPSBbXTtcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGxldCBmaWx0ZXJlZE1lcmdlcyA9IFtdO1xuICAgICAgICBsZXQgaHVuZ3J5TWVyZ2UgPSB7XG4gICAgICAgICAgICBzcGFuOiBlbnRyeS5zcGFuLFxuICAgICAgICAgICAgZW50cmllczogW2VudHJ5XSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgbWVyZ2Ugb2YgbWVyZ2VzKSB7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0U3BhbnMobWVyZ2Uuc3BhbiwgaHVuZ3J5TWVyZ2Uuc3BhbikpIHtcbiAgICAgICAgICAgICAgICBodW5ncnlNZXJnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllczogbWVyZ2UuZW50cmllcy5jb25jYXQoaHVuZ3J5TWVyZ2UuZW50cmllcyksXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IGpvaW5TcGFucyhtZXJnZS5zcGFuLCBodW5ncnlNZXJnZS5zcGFuKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRNZXJnZXMucHVzaChtZXJnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyZWRNZXJnZXMucHVzaChodW5ncnlNZXJnZSk7XG4gICAgICAgIG1lcmdlcyA9IGZpbHRlcmVkTWVyZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VzO1xufVxuZnVuY3Rpb24gam9pblNwYW5zKHNwYW4wLCBzcGFuMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBNYXRoLm1pbihzcGFuMC5zdGFydCwgc3BhbjEuc3RhcnQpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KHNwYW4wLmVuZCwgc3BhbjEuZW5kKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0U3BhbnMoc3BhbjAsIHNwYW4xKSB7XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoc3BhbjAuc3RhcnQsIHNwYW4xLnN0YXJ0KTtcbiAgICBsZXQgZW5kID0gTWF0aC5taW4oc3BhbjAuZW5kLCBzcGFuMS5lbmQpO1xuICAgIGlmIChzdGFydCA8IGVuZCkge1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gZ2VuZXJhbCB1dGlsXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGluc2VydEF0KGFyciwgaW5kZXgsIGl0ZW0pIHtcbiAgICBhcnIuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhLCBzZWFyY2hWYWwsIGdldEl0ZW1WYWwpIHtcbiAgICBsZXQgc3RhcnRJbmRleCA9IDA7XG4gICAgbGV0IGVuZEluZGV4ID0gYS5sZW5ndGg7IC8vIGV4Y2x1c2l2ZVxuICAgIGlmICghZW5kSW5kZXggfHwgc2VhcmNoVmFsIDwgZ2V0SXRlbVZhbChhW3N0YXJ0SW5kZXhdKSkgeyAvLyBubyBpdGVtcyBPUiBiZWZvcmUgZmlyc3QgaXRlbVxuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cbiAgICBpZiAoc2VhcmNoVmFsID4gZ2V0SXRlbVZhbChhW2VuZEluZGV4IC0gMV0pKSB7IC8vIGFmdGVyIGxhc3QgaXRlbVxuICAgICAgICByZXR1cm4gW2VuZEluZGV4LCAwXTtcbiAgICB9XG4gICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICBsZXQgbWlkZGxlSW5kZXggPSBNYXRoLmZsb29yKHN0YXJ0SW5kZXggKyAoZW5kSW5kZXggLSBzdGFydEluZGV4KSAvIDIpO1xuICAgICAgICBsZXQgbWlkZGxlVmFsID0gZ2V0SXRlbVZhbChhW21pZGRsZUluZGV4XSk7XG4gICAgICAgIGlmIChzZWFyY2hWYWwgPCBtaWRkbGVWYWwpIHtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gbWlkZGxlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VhcmNoVmFsID4gbWlkZGxlVmFsKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gbWlkZGxlSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBlcXVhbCFcbiAgICAgICAgICAgIHJldHVybiBbbWlkZGxlSW5kZXgsIDFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbc3RhcnRJbmRleCwgMF07XG59XG5cbi8qXG5BbiBhYnN0cmFjdGlvbiBmb3IgYSBkcmFnZ2luZyBpbnRlcmFjdGlvbiBvcmlnaW5hdGluZyBvbiBhbiBldmVudC5cbkRvZXMgaGlnaGVyLWxldmVsIHRoaW5ncyB0aGFuIFBvaW50ZXJEcmFnZ2VyLCBzdWNoIGFzIHBvc3NpYmx5OlxuLSBhIFwibWlycm9yXCIgdGhhdCBtb3ZlcyB3aXRoIHRoZSBwb2ludGVyXG4tIGEgbWluaW11bSBudW1iZXIgb2YgcGl4ZWxzIG9yIG90aGVyIGNyaXRlcmlhIGZvciBhIHRydWUgZHJhZyB0byBiZWdpblxuXG5zdWJjbGFzc2VzIG11c3QgZW1pdDpcbi0gcG9pbnRlcmRvd25cbi0gZHJhZ3N0YXJ0XG4tIGRyYWdtb3ZlXG4tIHBvaW50ZXJ1cFxuLSBkcmFnZW5kXG4qL1xuY2xhc3MgRWxlbWVudERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICB9XG4gICAgc2V0TWlycm9ySXNWaXNpYmxlKGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWwgaWYgc3ViY2xhc3MgZG9lc24ndCB3YW50IHRvIHN1cHBvcnQgYSBtaXJyb3JcbiAgICB9XG4gICAgc2V0TWlycm9yTmVlZHNSZXZlcnQoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbCBpZiBzdWJjbGFzcyBkb2Vzbid0IHdhbnQgdG8gc3VwcG9ydCBhIG1pcnJvclxuICAgIH1cbiAgICBzZXRBdXRvU2Nyb2xsRW5hYmxlZChib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsXG4gICAgfVxufVxuXG4vLyBUT0RPOiBnZXQgcmlkIG9mIHRoaXMgaW4gZmF2b3Igb2Ygb3B0aW9ucyBzeXN0ZW0sXG4vLyB0aG8gaXQncyByZWFsbHkgZWFzeSB0byBhY2Nlc3MgdGhpcyBnbG9iYWxseSByYXRoZXIgdGhhbiBwYXNzIHRocnUgb3B0aW9ucy5cbmNvbnN0IGNvbmZpZyA9IHt9O1xuXG4vKlxuSW5mb3JtYXRpb24gYWJvdXQgd2hhdCB3aWxsIGhhcHBlbiB3aGVuIGFuIGV4dGVybmFsIGVsZW1lbnQgaXMgZHJhZ2dlZC1hbmQtZHJvcHBlZFxub250byBhIGNhbGVuZGFyLiBDb250YWlucyBpbmZvcm1hdGlvbiBmb3IgY3JlYXRpbmcgYW4gZXZlbnQuXG4qL1xuY29uc3QgRFJBR19NRVRBX1JFRklORVJTID0ge1xuICAgIHN0YXJ0VGltZTogY3JlYXRlRHVyYXRpb24sXG4gICAgZHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGNyZWF0ZTogQm9vbGVhbixcbiAgICBzb3VyY2VJZDogU3RyaW5nLFxufTtcbmZ1bmN0aW9uIHBhcnNlRHJhZ01ldGEocmF3KSB7XG4gICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZVByb3BzKHJhdywgRFJBR19NRVRBX1JFRklORVJTKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydFRpbWU6IHJlZmluZWQuc3RhcnRUaW1lIHx8IG51bGwsXG4gICAgICAgIGR1cmF0aW9uOiByZWZpbmVkLmR1cmF0aW9uIHx8IG51bGwsXG4gICAgICAgIGNyZWF0ZTogcmVmaW5lZC5jcmVhdGUgIT0gbnVsbCA/IHJlZmluZWQuY3JlYXRlIDogdHJ1ZSxcbiAgICAgICAgc291cmNlSWQ6IHJlZmluZWQuc291cmNlSWQsXG4gICAgICAgIGxlZnRvdmVyUHJvcHM6IGV4dHJhLFxuICAgIH07XG59XG5cbi8vIENvbXB1dGVzIGEgZGVmYXVsdCBjb2x1bW4gaGVhZGVyIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGBjb2xGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcbmZ1bmN0aW9uIGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF5Q250KSB7XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSB3ZWVrIHJvdywgb3IgaWYgdGhlcmUgYXJlIGEgbG90IG9mIGNvbHVtbnMgd2l0aCBub3QgbXVjaCBzcGFjZSxcbiAgICAvLyBwdXQganVzdCB0aGUgZGF5IG51bWJlcnMgd2lsbCBiZSBpbiBlYWNoIGNlbGxcbiAgICBpZiAoIWRhdGVzUmVwRGlzdGluY3REYXlzIHx8IGRheUNudCA+IDEwKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnc2hvcnQnIH0pOyAvLyBcIlNhdFwiXG4gICAgfVxuICAgIGlmIChkYXlDbnQgPiAxKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ251bWVyaWMnLCBkYXk6ICdudW1lcmljJywgb21pdENvbW1hczogdHJ1ZSB9KTsgLy8gXCJTYXQgMTEvMTJcIlxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ2xvbmcnIH0pOyAvLyBcIlNhdHVyZGF5XCJcbn1cblxuY29uc3QgQ0xBU1NfTkFNRSA9ICdmYy1jb2wtaGVhZGVyLWNlbGwnOyAvLyBkbyB0aGUgY3VzaGlvbiB0b28/IG5vXG5mdW5jdGlvbiByZW5kZXJJbm5lciQxKHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIHJlbmRlclByb3BzLnRleHQ7XG59XG5cbi8vIEJBRCBuYW1lIGZvciB0aGlzIGNsYXNzIG5vdy4gdXNlZCBpbiB0aGUgSGVhZGVyXG5jbGFzcyBUYWJsZURhdGVDZWxsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zLCB0aGVtZSwgdmlld0FwaSB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZSwgZGF0ZVByb2ZpbGUgfSA9IHByb3BzO1xuICAgICAgICBsZXQgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRhdGUsIHByb3BzLnRvZGF5UmFuZ2UsIG51bGwsIGRhdGVQcm9maWxlKTtcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbQ0xBU1NfTkFNRV0uY29uY2F0KGdldERheUNsYXNzTmFtZXMoZGF5TWV0YSwgdGhlbWUpKTtcbiAgICAgICAgbGV0IHRleHQgPSBkYXRlRW52LmZvcm1hdChkYXRlLCBwcm9wcy5kYXlIZWFkZXJGb3JtYXQpO1xuICAgICAgICAvLyBpZiBjb2xDbnQgaXMgMSwgd2UgYXJlIGFscmVhZHkgaW4gYSBkYXktdmlldyBhbmQgZG9uJ3QgbmVlZCBhIG5hdmxpbmtcbiAgICAgICAgbGV0IG5hdkxpbmtBdHRycyA9ICghZGF5TWV0YS5pc0Rpc2FibGVkICYmIHByb3BzLmNvbENudCA+IDEpXG4gICAgICAgICAgICA/IGJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgZGF0ZSlcbiAgICAgICAgICAgIDoge307XG4gICAgICAgIGxldCByZW5kZXJQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgZGF0ZTogZGF0ZUVudi50b0RhdGUoZGF0ZSksIHZpZXc6IHZpZXdBcGkgfSwgcHJvcHMuZXh0cmFSZW5kZXJQcm9wcyksIHsgdGV4dCB9KSwgZGF5TWV0YSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRoXCIsIGVsQ2xhc3NlczogY2xhc3NOYW1lcywgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdjb2x1bW5oZWFkZXInLCBjb2xTcGFuOiBwcm9wcy5jb2xTcGFuLCAnZGF0YS1kYXRlJzogIWRheU1ldGEuaXNEaXNhYmxlZCA/IGZvcm1hdERheVN0cmluZyhkYXRlKSA6IHVuZGVmaW5lZCB9LCBwcm9wcy5leHRyYURhdGFBdHRycyksIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJkYXlIZWFkZXJDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lciQxLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLmRheUhlYWRlcldpbGxVbm1vdW50IH0sIChJbm5lckNvbnRhaW5lcikgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSwgIWRheU1ldGEuaXNEaXNhYmxlZCAmJiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRhaW5lciwgeyBlbFRhZzogXCJhXCIsIGVsQXR0cnM6IG5hdkxpbmtBdHRycywgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICBwcm9wcy5pc1N0aWNreSAmJiAnZmMtc3RpY2t5JyxcbiAgICAgICAgICAgIF0gfSkpKSkpKTtcbiAgICB9XG59XG5cbmNvbnN0IFdFRUtEQVlfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ2xvbmcnIH0pO1xuY2xhc3MgVGFibGVEb3dDZWxsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZUVudiwgdGhlbWUsIHZpZXdBcGksIG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGRhdGUgPSBhZGREYXlzKG5ldyBEYXRlKDI1OTIwMDAwMCksIHByb3BzLmRvdyk7IC8vIHN0YXJ0IHdpdGggU3VuLCAwNCBKYW4gMTk3MCAwMDowMDowMCBHTVRcbiAgICAgICAgbGV0IGRhdGVNZXRhID0ge1xuICAgICAgICAgICAgZG93OiBwcm9wcy5kb3csXG4gICAgICAgICAgICBpc0Rpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzRnV0dXJlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUGFzdDogZmFsc2UsXG4gICAgICAgICAgICBpc1RvZGF5OiBmYWxzZSxcbiAgICAgICAgICAgIGlzT3RoZXI6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIHByb3BzLmRheUhlYWRlckZvcm1hdCk7XG4gICAgICAgIGxldCByZW5kZXJQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyAvLyBUT0RPOiBtYWtlIHRoaXMgcHVibGljP1xuICAgICAgICAgICAgZGF0ZSB9LCBkYXRlTWV0YSksIHsgdmlldzogdmlld0FwaSB9KSwgcHJvcHMuZXh0cmFSZW5kZXJQcm9wcyksIHsgdGV4dCB9KTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwidGhcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgQ0xBU1NfTkFNRSxcbiAgICAgICAgICAgICAgICAuLi5nZXREYXlDbGFzc05hbWVzKGRhdGVNZXRhLCB0aGVtZSksXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKHsgcm9sZTogJ2NvbHVtbmhlYWRlcicsIGNvbFNwYW46IHByb3BzLmNvbFNwYW4gfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZGF5SGVhZGVyQ29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXIkMSwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250ZW50KSA9PiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiYVwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuaXNTdGlja3kgJiYgJ2ZjLXN0aWNreScsXG4gICAgICAgICAgICAgICAgXSwgZWxBdHRyczoge1xuICAgICAgICAgICAgICAgICAgICAnYXJpYS1sYWJlbCc6IGRhdGVFbnYuZm9ybWF0KGRhdGUsIFdFRUtEQVlfRk9STUFUKSxcbiAgICAgICAgICAgICAgICB9IH0pKSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIE5vd1RpbWVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgPSBnZXROb3coY29udGV4dC5vcHRpb25zLm5vdywgY29udGV4dC5kYXRlRW52KTtcbiAgICAgICAgdGhpcy5pbml0aWFsTm93UXVlcmllZE1zID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmNvbXB1dGVUaW1pbmcoKS5jdXJyZW50U3RhdGU7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4oc3RhdGUubm93RGF0ZSwgc3RhdGUudG9kYXlSYW5nZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLnVuaXQgIT09IHRoaXMucHJvcHMudW5pdCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgIH1cbiAgICBjb21wdXRlVGltaW5nKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHVucm91bmRlZE5vdyA9IGFkZE1zKHRoaXMuaW5pdGlhbE5vd0RhdGUsIG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKTtcbiAgICAgICAgbGV0IGN1cnJlbnRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuc3RhcnRPZih1bnJvdW5kZWROb3csIHByb3BzLnVuaXQpO1xuICAgICAgICBsZXQgbmV4dFVuaXRTdGFydCA9IGNvbnRleHQuZGF0ZUVudi5hZGQoY3VycmVudFVuaXRTdGFydCwgY3JlYXRlRHVyYXRpb24oMSwgcHJvcHMudW5pdCkpO1xuICAgICAgICBsZXQgd2FpdE1zID0gbmV4dFVuaXRTdGFydC52YWx1ZU9mKCkgLSB1bnJvdW5kZWROb3cudmFsdWVPZigpO1xuICAgICAgICAvLyB0aGVyZSBpcyBhIG1heCBzZXRUaW1lb3V0IG1zIHZhbHVlIChodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ2ODY1MC85NjM0MilcbiAgICAgICAgLy8gZW5zdXJlIG5vIGxvbmdlciB0aGFuIGEgZGF5XG4gICAgICAgIHdhaXRNcyA9IE1hdGgubWluKDEwMDAgKiA2MCAqIDYwICogMjQsIHdhaXRNcyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGU6IHsgbm93RGF0ZTogY3VycmVudFVuaXRTdGFydCwgdG9kYXlSYW5nZTogYnVpbGREYXlSYW5nZShjdXJyZW50VW5pdFN0YXJ0KSB9LFxuICAgICAgICAgICAgbmV4dFN0YXRlOiB7IG5vd0RhdGU6IG5leHRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UobmV4dFVuaXRTdGFydCkgfSxcbiAgICAgICAgICAgIHdhaXRNcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0VGltZW91dCgpIHtcbiAgICAgICAgbGV0IHsgbmV4dFN0YXRlLCB3YWl0TXMgfSA9IHRoaXMuY29tcHV0ZVRpbWluZygpO1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRpbWVvdXQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB3YWl0TXMpO1xuICAgIH1cbiAgICBjbGVhclRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbk5vd1RpbWVyLmNvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuZnVuY3Rpb24gYnVpbGREYXlSYW5nZShkYXRlKSB7XG4gICAgbGV0IHN0YXJ0ID0gc3RhcnRPZkRheShkYXRlKTtcbiAgICBsZXQgZW5kID0gYWRkRGF5cyhzdGFydCwgMSk7XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xufVxuXG5jbGFzcyBEYXlIZWFkZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIgPSBtZW1vaXplKGNyZWF0ZURheUhlYWRlckZvcm1hdHRlcik7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZXMsIGRhdGVQcm9maWxlLCBkYXRlc1JlcERpc3RpbmN0RGF5cywgcmVuZGVySW50cm8gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCBkYXlIZWFkZXJGb3JtYXQgPSB0aGlzLmNyZWF0ZURheUhlYWRlckZvcm1hdHRlcihjb250ZXh0Lm9wdGlvbnMuZGF5SGVhZGVyRm9ybWF0LCBkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZXMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IFwiZGF5XCIgfSwgKG5vd0RhdGUsIHRvZGF5UmFuZ2UpID0+IChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInJvd1wiIH0sXG4gICAgICAgICAgICByZW5kZXJJbnRybyAmJiByZW5kZXJJbnRybygnZGF5JyksXG4gICAgICAgICAgICBkYXRlcy5tYXAoKGRhdGUpID0+IChkYXRlc1JlcERpc3RpbmN0RGF5cyA/IChjcmVhdGVFbGVtZW50KFRhYmxlRGF0ZUNlbGwsIHsga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksIGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgY29sQ250OiBkYXRlcy5sZW5ndGgsIGRheUhlYWRlckZvcm1hdDogZGF5SGVhZGVyRm9ybWF0IH0pKSA6IChjcmVhdGVFbGVtZW50KFRhYmxlRG93Q2VsbCwgeyBrZXk6IGRhdGUuZ2V0VVRDRGF5KCksIGRvdzogZGF0ZS5nZXRVVENEYXkoKSwgZGF5SGVhZGVyRm9ybWF0OiBkYXlIZWFkZXJGb3JtYXQgfSkpKSkpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZURheUhlYWRlckZvcm1hdHRlcihleHBsaWNpdEZvcm1hdCwgZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVDbnQpIHtcbiAgICByZXR1cm4gZXhwbGljaXRGb3JtYXQgfHwgY29tcHV0ZUZhbGxiYWNrSGVhZGVyRm9ybWF0KGRhdGVzUmVwRGlzdGluY3REYXlzLCBkYXRlQ250KTtcbn1cblxuY2xhc3MgRGF5U2VyaWVzTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgICAgICBsZXQgZGF0ZSA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICBsZXQgeyBlbmQgfSA9IHJhbmdlO1xuICAgICAgICBsZXQgaW5kaWNlcyA9IFtdO1xuICAgICAgICBsZXQgZGF0ZXMgPSBbXTtcbiAgICAgICAgbGV0IGRheUluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlIChkYXRlIDwgZW5kKSB7IC8vIGxvb3AgZWFjaCBkYXkgZnJvbSBzdGFydCB0byBlbmRcbiAgICAgICAgICAgIGlmIChkYXRlUHJvZmlsZUdlbmVyYXRvci5pc0hpZGRlbkRheShkYXRlKSkge1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChkYXlJbmRleCArIDAuNSk7IC8vIG1hcmsgdGhhdCBpdCdzIGJldHdlZW4gaW5kaWNlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF5SW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2goZGF5SW5kZXgpO1xuICAgICAgICAgICAgICAgIGRhdGVzLnB1c2goZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRlID0gYWRkRGF5cyhkYXRlLCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGVzID0gZGF0ZXM7XG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IGluZGljZXM7XG4gICAgICAgIHRoaXMuY250ID0gZGF0ZXMubGVuZ3RoO1xuICAgIH1cbiAgICBzbGljZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCBmaXJzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgocmFuZ2Uuc3RhcnQpOyAvLyBpbmNsdXNpdmUgZmlyc3QgaW5kZXhcbiAgICAgICAgbGV0IGxhc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KGFkZERheXMocmFuZ2UuZW5kLCAtMSkpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuICAgICAgICBsZXQgY2xpcHBlZEZpcnN0SW5kZXggPSBNYXRoLm1heCgwLCBmaXJzdEluZGV4KTtcbiAgICAgICAgbGV0IGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLm1pbih0aGlzLmNudCAtIDEsIGxhc3RJbmRleCk7XG4gICAgICAgIC8vIGRlYWwgd2l0aCBpbi1iZXR3ZWVuIGluZGljZXNcbiAgICAgICAgY2xpcHBlZEZpcnN0SW5kZXggPSBNYXRoLmNlaWwoY2xpcHBlZEZpcnN0SW5kZXgpOyAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcbiAgICAgICAgY2xpcHBlZExhc3RJbmRleCA9IE1hdGguZmxvb3IoY2xpcHBlZExhc3RJbmRleCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcbiAgICAgICAgaWYgKGNsaXBwZWRGaXJzdEluZGV4IDw9IGNsaXBwZWRMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmlyc3RJbmRleDogY2xpcHBlZEZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4OiBjbGlwcGVkTGFzdEluZGV4LFxuICAgICAgICAgICAgICAgIGlzU3RhcnQ6IGZpcnN0SW5kZXggPT09IGNsaXBwZWRGaXJzdEluZGV4LFxuICAgICAgICAgICAgICAgIGlzRW5kOiBsYXN0SW5kZXggPT09IGNsaXBwZWRMYXN0SW5kZXgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBHaXZlbiBhIGRhdGUsIHJldHVybnMgaXRzIGNocm9ub2xvY2lhbCBjZWxsLWluZGV4IGZyb20gdGhlIGZpcnN0IGNlbGwgb2YgdGhlIGdyaWQuXG4gICAgLy8gSWYgdGhlIGRhdGUgbGllcyBiZXR3ZWVuIGNlbGxzIChiZWNhdXNlIG9mIGhpZGRlbkRheXMpLCByZXR1cm5zIGEgZmxvYXRpbmctcG9pbnQgdmFsdWUgYmV0d2VlbiBvZmZzZXRzLlxuICAgIC8vIElmIGJlZm9yZSB0aGUgZmlyc3Qgb2Zmc2V0LCByZXR1cm5zIGEgbmVnYXRpdmUgbnVtYmVyLlxuICAgIC8vIElmIGFmdGVyIHRoZSBsYXN0IG9mZnNldCwgcmV0dXJucyBhbiBvZmZzZXQgcGFzdCB0aGUgbGFzdCBjZWxsIG9mZnNldC5cbiAgICAvLyBPbmx5IHdvcmtzIGZvciAqc3RhcnQqIGRhdGVzIG9mIGNlbGxzLiBXaWxsIG5vdCB3b3JrIGZvciBleGNsdXNpdmUgZW5kIGRhdGVzIGZvciBjZWxscy5cbiAgICBnZXREYXRlRGF5SW5kZXgoZGF0ZSkge1xuICAgICAgICBsZXQgeyBpbmRpY2VzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGF5T2Zmc2V0ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aGlzLmRhdGVzWzBdLCBkYXRlKSk7XG4gICAgICAgIGlmIChkYXlPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNlc1swXSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheU9mZnNldCA+PSBpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGljZXNbZGF5T2Zmc2V0XTtcbiAgICB9XG59XG5cbmNsYXNzIERheVRhYmxlTW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKGRheVNlcmllcywgYnJlYWtPbldlZWtzKSB7XG4gICAgICAgIGxldCB7IGRhdGVzIH0gPSBkYXlTZXJpZXM7XG4gICAgICAgIGxldCBkYXlzUGVyUm93O1xuICAgICAgICBsZXQgZmlyc3REYXk7XG4gICAgICAgIGxldCByb3dDbnQ7XG4gICAgICAgIGlmIChicmVha09uV2Vla3MpIHtcbiAgICAgICAgICAgIC8vIGNvdW50IGNvbHVtbnMgdW50aWwgdGhlIGRheS1vZi13ZWVrIHJlcGVhdHNcbiAgICAgICAgICAgIGZpcnN0RGF5ID0gZGF0ZXNbMF0uZ2V0VVRDRGF5KCk7XG4gICAgICAgICAgICBmb3IgKGRheXNQZXJSb3cgPSAxOyBkYXlzUGVyUm93IDwgZGF0ZXMubGVuZ3RoOyBkYXlzUGVyUm93ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZXNbZGF5c1BlclJvd10uZ2V0VVRDRGF5KCkgPT09IGZpcnN0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd0NudCA9IE1hdGguY2VpbChkYXRlcy5sZW5ndGggLyBkYXlzUGVyUm93KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvd0NudCA9IDE7XG4gICAgICAgICAgICBkYXlzUGVyUm93ID0gZGF0ZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm93Q250ID0gcm93Q250O1xuICAgICAgICB0aGlzLmNvbENudCA9IGRheXNQZXJSb3c7XG4gICAgICAgIHRoaXMuZGF5U2VyaWVzID0gZGF5U2VyaWVzO1xuICAgICAgICB0aGlzLmNlbGxzID0gdGhpcy5idWlsZENlbGxzKCk7XG4gICAgICAgIHRoaXMuaGVhZGVyRGF0ZXMgPSB0aGlzLmJ1aWxkSGVhZGVyRGF0ZXMoKTtcbiAgICB9XG4gICAgYnVpbGRDZWxscygpIHtcbiAgICAgICAgbGV0IHJvd3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dDbnQ7IHJvdyArPSAxKSB7XG4gICAgICAgICAgICBsZXQgY2VsbHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNlbGxzLnB1c2godGhpcy5idWlsZENlbGwocm93LCBjb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJvd3MucHVzaChjZWxscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvd3M7XG4gICAgfVxuICAgIGJ1aWxkQ2VsbChyb3csIGNvbCkge1xuICAgICAgICBsZXQgZGF0ZSA9IHRoaXMuZGF5U2VyaWVzLmRhdGVzW3JvdyAqIHRoaXMuY29sQ250ICsgY29sXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogZGF0ZS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRIZWFkZXJEYXRlcygpIHtcbiAgICAgICAgbGV0IGRhdGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgZGF0ZXMucHVzaCh0aGlzLmNlbGxzWzBdW2NvbF0uZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVzO1xuICAgIH1cbiAgICBzbGljZVJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGxldCB7IGNvbENudCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHNlcmllc1NlZyA9IHRoaXMuZGF5U2VyaWVzLnNsaWNlUmFuZ2UocmFuZ2UpO1xuICAgICAgICBsZXQgc2VncyA9IFtdO1xuICAgICAgICBpZiAoc2VyaWVzU2VnKSB7XG4gICAgICAgICAgICBsZXQgeyBmaXJzdEluZGV4LCBsYXN0SW5kZXggfSA9IHNlcmllc1NlZztcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGZpcnN0SW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPD0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgbGV0IHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyBjb2xDbnQpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0SW5kZXggPSBNYXRoLm1pbigocm93ICsgMSkgKiBjb2xDbnQsIGxhc3RJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RDb2w6IGluZGV4ICUgY29sQ250LFxuICAgICAgICAgICAgICAgICAgICBsYXN0Q29sOiAobmV4dEluZGV4IC0gMSkgJSBjb2xDbnQsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlcmllc1NlZy5pc1N0YXJ0ICYmIGluZGV4ID09PSBmaXJzdEluZGV4LFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VyaWVzU2VnLmlzRW5kICYmIChuZXh0SW5kZXggLSAxKSA9PT0gbGFzdEluZGV4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH1cbn1cblxuY2xhc3MgU2xpY2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zbGljZUJ1c2luZXNzSG91cnMgPSBtZW1vaXplKHRoaXMuX3NsaWNlQnVzaW5lc3NIb3Vycyk7XG4gICAgICAgIHRoaXMuc2xpY2VEYXRlU2VsZWN0aW9uID0gbWVtb2l6ZSh0aGlzLl9zbGljZURhdGVTcGFuKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50U3RvcmUgPSBtZW1vaXplKHRoaXMuX3NsaWNlRXZlbnRTdG9yZSk7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudERyYWcgPSBtZW1vaXplKHRoaXMuX3NsaWNlSW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnRSZXNpemUgPSBtZW1vaXplKHRoaXMuX3NsaWNlSW50ZXJhY3Rpb24pO1xuICAgICAgICB0aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSA9IGZhbHNlOyAvLyBoYWNrXG4gICAgfVxuICAgIHNsaWNlUHJvcHMocHJvcHMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgbGV0IHsgZXZlbnRVaUJhc2VzIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGV2ZW50U2VncyA9IHRoaXMuc2xpY2VFdmVudFN0b3JlKHByb3BzLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uU2VnczogdGhpcy5zbGljZURhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbiwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGV2ZW50VWlCYXNlcywgY29udGV4dCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91clNlZ3M6IHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzKHByb3BzLmJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpLFxuICAgICAgICAgICAgZmdFdmVudFNlZ3M6IGV2ZW50U2Vncy5mZyxcbiAgICAgICAgICAgIGJnRXZlbnRTZWdzOiBldmVudFNlZ3MuYmcsXG4gICAgICAgICAgICBldmVudERyYWc6IHRoaXMuc2xpY2VFdmVudERyYWcocHJvcHMuZXZlbnREcmFnLCBldmVudFVpQmFzZXMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCAuLi5leHRyYUFyZ3MpLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHRoaXMuc2xpY2VFdmVudFJlc2l6ZShwcm9wcy5ldmVudFJlc2l6ZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcbiAgICAgICAgfTsgLy8gVE9ETzogZ2l2ZSBpbnRlcmFjdGlvblNlZ3M/XG4gICAgfVxuICAgIHNsaWNlTm93RGF0ZSgvLyBkb2VzIG5vdCBtZW1vaXplXG4gICAgZGF0ZSwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIC4uLmV4dHJhQXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2xpY2VEYXRlU3Bhbih7IHJhbmdlOiB7IHN0YXJ0OiBkYXRlLCBlbmQ6IGFkZE1zKGRhdGUsIDEpIH0sIGFsbERheTogZmFsc2UgfSwgLy8gYWRkIDEgbXMsIHByb3RlY3QgYWdhaW5zdCBudWxsIHJhbmdlXG4gICAgICAgIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCB7fSwgY29udGV4dCwgLi4uZXh0cmFBcmdzKTtcbiAgICB9XG4gICAgX3NsaWNlQnVzaW5lc3NIb3VycyhidXNpbmVzc0hvdXJzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGlmICghYnVzaW5lc3NIb3Vycykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zbGljZUV2ZW50U3RvcmUoZXhwYW5kUmVjdXJyaW5nKGJ1c2luZXNzSG91cnMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIGNvbnRleHQpLCB7fSwgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQsIC4uLmV4dHJhQXJncykuYmc7XG4gICAgfVxuICAgIF9zbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGlmIChldmVudFN0b3JlKSB7XG4gICAgICAgICAgICBsZXQgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmc6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5iZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgICAgICBmZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmZnLCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBiZzogW10sIGZnOiBbXSB9O1xuICAgIH1cbiAgICBfc2xpY2VJbnRlcmFjdGlvbihpbnRlcmFjdGlvbiwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgLi4uZXh0cmFBcmdzKSB7XG4gICAgICAgIGlmICghaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCByYW5nZVJlcyA9IHNsaWNlRXZlbnRTdG9yZShpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzLCBldmVudFVpQmFzZXMsIGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSksIG5leHREYXlUaHJlc2hvbGQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VnczogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmZnLCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgYWZmZWN0ZWRJbnN0YW5jZXM6IGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLmluc3RhbmNlcyxcbiAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9zbGljZURhdGVTcGFuKGRhdGVTcGFuLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgZXZlbnRVaUJhc2VzLCBjb250ZXh0LCAuLi5leHRyYUFyZ3MpIHtcbiAgICAgICAgaWYgKCFkYXRlU3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY3RpdmVSYW5nZSA9IGNvbXB1dGVBY3RpdmVSYW5nZShkYXRlUHJvZmlsZSwgQm9vbGVhbihuZXh0RGF5VGhyZXNob2xkKSk7XG4gICAgICAgIGxldCBhY3RpdmVEYXRlU3BhblJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGRhdGVTcGFuLnJhbmdlLCBhY3RpdmVSYW5nZSk7XG4gICAgICAgIGlmIChhY3RpdmVEYXRlU3BhblJhbmdlKSB7XG4gICAgICAgICAgICBkYXRlU3BhbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0ZVNwYW4pLCB7IHJhbmdlOiBhY3RpdmVEYXRlU3BhblJhbmdlIH0pO1xuICAgICAgICAgICAgbGV0IGV2ZW50UmFuZ2UgPSBmYWJyaWNhdGVFdmVudFJhbmdlKGRhdGVTcGFuLCBldmVudFVpQmFzZXMsIGNvbnRleHQpO1xuICAgICAgICAgICAgbGV0IHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2UoZGF0ZVNwYW4ucmFuZ2UsIC4uLmV4dHJhQXJncyk7XG4gICAgICAgICAgICBmb3IgKGxldCBzZWcgb2Ygc2Vncykge1xuICAgICAgICAgICAgICAgIHNlZy5ldmVudFJhbmdlID0gZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLypcbiAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcbiAgICAqL1xuICAgIHNsaWNlRXZlbnRSYW5nZXMoZXZlbnRSYW5nZXMsIGV4dHJhQXJncykge1xuICAgICAgICBsZXQgc2VncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBldmVudFJhbmdlIG9mIGV2ZW50UmFuZ2VzKSB7XG4gICAgICAgICAgICBzZWdzLnB1c2goLi4udGhpcy5zbGljZUV2ZW50UmFuZ2UoZXZlbnRSYW5nZSwgZXh0cmFBcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxuICAgIC8qXG4gICAgXCJjb21wbGV0ZVwiIHNlZyBtZWFucyBpdCBoYXMgY29tcG9uZW50IGFuZCBldmVudFJhbmdlXG4gICAgKi9cbiAgICBzbGljZUV2ZW50UmFuZ2UoZXZlbnRSYW5nZSwgZXh0cmFBcmdzKSB7XG4gICAgICAgIGxldCBkYXRlUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xuICAgICAgICAvLyBoYWNrIHRvIG1ha2UgbXVsdGktZGF5IGV2ZW50cyB0aGF0IGFyZSBiZWluZyBmb3JjZS1kaXNwbGF5ZWQgYXMgbGlzdC1pdGVtcyB0byB0YWtlIHVwIG9ubHkgb25lIGRheVxuICAgICAgICBpZiAodGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gJiYgZXZlbnRSYW5nZS51aS5kaXNwbGF5ID09PSAnbGlzdC1pdGVtJykge1xuICAgICAgICAgICAgZGF0ZVJhbmdlID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBhZGREYXlzKGRhdGVSYW5nZS5zdGFydCwgMSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWdzID0gdGhpcy5zbGljZVJhbmdlKGRhdGVSYW5nZSwgLi4uZXh0cmFBcmdzKTtcbiAgICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgICAgIHNlZy5ldmVudFJhbmdlID0gZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIHNlZy5pc1N0YXJ0ID0gZXZlbnRSYW5nZS5pc1N0YXJ0ICYmIHNlZy5pc1N0YXJ0O1xuICAgICAgICAgICAgc2VnLmlzRW5kID0gZXZlbnRSYW5nZS5pc0VuZCAmJiBzZWcuaXNFbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxufVxuLypcbmZvciBpbmNvcnBvcmF0aW5nIHNsb3RNaW5UaW1lL3Nsb3RNYXhUaW1lIGlmIGFwcHJvcHJpYXRlXG5UT0RPOiBzaG91bGQgYmUgcGFydCBvZiBEYXRlUHJvZmlsZSFcblRpbWVsaW5lRGF0ZVByb2ZpbGUgYWxyZWFkeSBkb2VzIHRoaXMgYnR3XG4qL1xuZnVuY3Rpb24gY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBpc0NvbXBvbmVudEFsbERheSkge1xuICAgIGxldCByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xuICAgIGlmIChpc0NvbXBvbmVudEFsbERheSkge1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBhZGRNcyhyYW5nZS5zdGFydCwgZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUubWlsbGlzZWNvbmRzKSxcbiAgICAgICAgZW5kOiBhZGRNcyhyYW5nZS5lbmQsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lLm1pbGxpc2Vjb25kcyAtIDg2NGU1KSwgLy8gODY0ZTUgPSBtcyBpbiBhIGRheVxuICAgIH07XG59XG5cbi8vIGhpZ2gtbGV2ZWwgc2VnbWVudGluZy1hd2FyZSB0ZXN0ZXIgZnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBpbnN0YW5jZXMgfSA9IGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHM7XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKCFyYW5nZUNvbnRhaW5zUmFuZ2UoZGF0ZVByb2ZpbGUudmFsaWRSYW5nZSwgaW5zdGFuY2VzW2luc3RhbmNlSWRdLnJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBldmVudERyYWc6IGludGVyYWN0aW9uIH0sIGNvbnRleHQpOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcbn1cbmZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblZhbGlkKGRhdGVTZWxlY3Rpb24sIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFyYW5nZUNvbnRhaW5zUmFuZ2UoZGF0ZVByb2ZpbGUudmFsaWRSYW5nZSwgZGF0ZVNlbGVjdGlvbi5yYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZGF0ZVNlbGVjdGlvbiB9LCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzTmV3UHJvcHNWYWxpZChuZXdQcm9wcywgY29udGV4dCkge1xuICAgIGxldCBjYWxlbmRhclN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgIGxldCBwcm9wcyA9IE9iamVjdC5hc3NpZ24oeyBidXNpbmVzc0hvdXJzOiBjYWxlbmRhclN0YXRlLmJ1c2luZXNzSG91cnMsIGRhdGVTZWxlY3Rpb246ICcnLCBldmVudFN0b3JlOiBjYWxlbmRhclN0YXRlLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogY2FsZW5kYXJTdGF0ZS5ldmVudFVpQmFzZXMsIGV2ZW50U2VsZWN0aW9uOiAnJywgZXZlbnREcmFnOiBudWxsLCBldmVudFJlc2l6ZTogbnVsbCB9LCBuZXdQcm9wcyk7XG4gICAgcmV0dXJuIChjb250ZXh0LnBsdWdpbkhvb2tzLmlzUHJvcHNWYWxpZCB8fCBpc1Byb3BzVmFsaWQpKHByb3BzLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhID0ge30sIGZpbHRlckNvbmZpZykge1xuICAgIGlmIChzdGF0ZS5ldmVudERyYWcgJiYgIWlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuZGF0ZVNlbGVjdGlvbiAmJiAhaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBNb3ZpbmcgRXZlbnQgVmFsaWRhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpc0ludGVyYWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpIHtcbiAgICBsZXQgY3VycmVudFN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgIGxldCBpbnRlcmFjdGlvbiA9IHN0YXRlLmV2ZW50RHJhZzsgLy8gSEFDSzogdGhlIGV2ZW50RHJhZyBwcm9wcyBpcyB1c2VkIGZvciBBTEwgaW50ZXJhY3Rpb25zXG4gICAgbGV0IHN1YmplY3RFdmVudFN0b3JlID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cztcbiAgICBsZXQgc3ViamVjdERlZnMgPSBzdWJqZWN0RXZlbnRTdG9yZS5kZWZzO1xuICAgIGxldCBzdWJqZWN0SW5zdGFuY2VzID0gc3ViamVjdEV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIGxldCBzdWJqZWN0Q29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhzdWJqZWN0RGVmcywgaW50ZXJhY3Rpb24uaXNFdmVudCA/XG4gICAgICAgIHN0YXRlLmV2ZW50VWlCYXNlcyA6XG4gICAgICAgIHsgJyc6IGN1cnJlbnRTdGF0ZS5zZWxlY3Rpb25Db25maWcgfSk7XG4gICAgaWYgKGZpbHRlckNvbmZpZykge1xuICAgICAgICBzdWJqZWN0Q29uZmlncyA9IG1hcEhhc2goc3ViamVjdENvbmZpZ3MsIGZpbHRlckNvbmZpZyk7XG4gICAgfVxuICAgIC8vIGV4Y2x1ZGUgdGhlIHN1YmplY3QgZXZlbnRzLiBUT0RPOiBleGNsdWRlIGRlZnMgdG9vP1xuICAgIGxldCBvdGhlckV2ZW50U3RvcmUgPSBleGNsdWRlSW5zdGFuY2VzKHN0YXRlLmV2ZW50U3RvcmUsIGludGVyYWN0aW9uLmFmZmVjdGVkRXZlbnRzLmluc3RhbmNlcyk7XG4gICAgbGV0IG90aGVyRGVmcyA9IG90aGVyRXZlbnRTdG9yZS5kZWZzO1xuICAgIGxldCBvdGhlckluc3RhbmNlcyA9IG90aGVyRXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgbGV0IG90aGVyQ29uZmlncyA9IGNvbXBpbGVFdmVudFVpcyhvdGhlckRlZnMsIHN0YXRlLmV2ZW50VWlCYXNlcyk7XG4gICAgZm9yIChsZXQgc3ViamVjdEluc3RhbmNlSWQgaW4gc3ViamVjdEluc3RhbmNlcykge1xuICAgICAgICBsZXQgc3ViamVjdEluc3RhbmNlID0gc3ViamVjdEluc3RhbmNlc1tzdWJqZWN0SW5zdGFuY2VJZF07XG4gICAgICAgIGxldCBzdWJqZWN0UmFuZ2UgPSBzdWJqZWN0SW5zdGFuY2UucmFuZ2U7XG4gICAgICAgIGxldCBzdWJqZWN0Q29uZmlnID0gc3ViamVjdENvbmZpZ3Nbc3ViamVjdEluc3RhbmNlLmRlZklkXTtcbiAgICAgICAgbGV0IHN1YmplY3REZWYgPSBzdWJqZWN0RGVmc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAvLyBjb25zdHJhaW50XG4gICAgICAgIGlmICghYWxsQ29uc3RyYWludHNQYXNzKHN1YmplY3RDb25maWcuY29uc3RyYWludHMsIHN1YmplY3RSYW5nZSwgb3RoZXJFdmVudFN0b3JlLCBzdGF0ZS5idXNpbmVzc0hvdXJzLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG92ZXJsYXBcbiAgICAgICAgbGV0IHsgZXZlbnRPdmVybGFwIH0gPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGxldCBldmVudE92ZXJsYXBGdW5jID0gdHlwZW9mIGV2ZW50T3ZlcmxhcCA9PT0gJ2Z1bmN0aW9uJyA/IGV2ZW50T3ZlcmxhcCA6IG51bGw7XG4gICAgICAgIGZvciAobGV0IG90aGVySW5zdGFuY2VJZCBpbiBvdGhlckluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IG90aGVySW5zdGFuY2UgPSBvdGhlckluc3RhbmNlc1tvdGhlckluc3RhbmNlSWRdO1xuICAgICAgICAgICAgLy8gaW50ZXJzZWN0ISBldmFsdWF0ZVxuICAgICAgICAgICAgaWYgKHJhbmdlc0ludGVyc2VjdChzdWJqZWN0UmFuZ2UsIG90aGVySW5zdGFuY2UucmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG90aGVyT3ZlcmxhcCA9IG90aGVyQ29uZmlnc1tvdGhlckluc3RhbmNlLmRlZklkXS5vdmVybGFwO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBvdGhlciBldmVudCdzIG92ZXJsYXAuIG9ubHkgZG8gdGhpcyBpZiB0aGUgc3ViamVjdCBldmVudCBpcyBhIFwicmVhbFwiIGV2ZW50XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyT3ZlcmxhcCA9PT0gZmFsc2UgJiYgaW50ZXJhY3Rpb24uaXNFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdWJqZWN0Q29uZmlnLm92ZXJsYXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50T3ZlcmxhcEZ1bmMgJiYgIWV2ZW50T3ZlcmxhcEZ1bmMobmV3IEV2ZW50SW1wbChjb250ZXh0LCBvdGhlckRlZnNbb3RoZXJJbnN0YW5jZS5kZWZJZF0sIG90aGVySW5zdGFuY2UpLCAvLyBzdGlsbCBldmVudFxuICAgICAgICAgICAgICAgIG5ldyBFdmVudEltcGwoY29udGV4dCwgc3ViamVjdERlZiwgc3ViamVjdEluc3RhbmNlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhbGxvdyAoYSBmdW5jdGlvbilcbiAgICAgICAgbGV0IGNhbGVuZGFyRXZlbnRTdG9yZSA9IGN1cnJlbnRTdGF0ZS5ldmVudFN0b3JlOyAvLyBuZWVkIGdsb2JhbC10by1jYWxlbmRhciwgbm90IGxvY2FsIHRvIGNvbXBvbmVudCAoc3BsaXR0YWJsZSlzdGF0ZVxuICAgICAgICBmb3IgKGxldCBzdWJqZWN0QWxsb3cgb2Ygc3ViamVjdENvbmZpZy5hbGxvd3MpIHtcbiAgICAgICAgICAgIGxldCBzdWJqZWN0RGF0ZVNwYW4gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGVTcGFuTWV0YSksIHsgcmFuZ2U6IHN1YmplY3RJbnN0YW5jZS5yYW5nZSwgYWxsRGF5OiBzdWJqZWN0RGVmLmFsbERheSB9KTtcbiAgICAgICAgICAgIGxldCBvcmlnRGVmID0gY2FsZW5kYXJFdmVudFN0b3JlLmRlZnNbc3ViamVjdERlZi5kZWZJZF07XG4gICAgICAgICAgICBsZXQgb3JpZ0luc3RhbmNlID0gY2FsZW5kYXJFdmVudFN0b3JlLmluc3RhbmNlc1tzdWJqZWN0SW5zdGFuY2VJZF07XG4gICAgICAgICAgICBsZXQgZXZlbnRBcGk7XG4gICAgICAgICAgICBpZiAob3JpZ0RlZikgeyAvLyB3YXMgcHJldmlvdXNseSBpbiB0aGUgY2FsZW5kYXJcbiAgICAgICAgICAgICAgICBldmVudEFwaSA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgb3JpZ0RlZiwgb3JpZ0luc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyB3YXMgYW4gZXh0ZXJuYWwgZXZlbnRcbiAgICAgICAgICAgICAgICBldmVudEFwaSA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgc3ViamVjdERlZik7IC8vIG5vIGluc3RhbmNlLCBiZWNhdXNlIGhhZCBubyBkYXRlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdWJqZWN0QWxsb3coYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KHN1YmplY3REYXRlU3BhbiwgY29udGV4dCksIGV2ZW50QXBpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIERhdGUgU2VsZWN0aW9uIFZhbGlkYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gaXNEYXRlU2VsZWN0aW9uUHJvcHNWYWxpZChzdGF0ZSwgY29udGV4dCwgZGF0ZVNwYW5NZXRhLCBmaWx0ZXJDb25maWcpIHtcbiAgICBsZXQgcmVsZXZhbnRFdmVudFN0b3JlID0gc3RhdGUuZXZlbnRTdG9yZTtcbiAgICBsZXQgcmVsZXZhbnREZWZzID0gcmVsZXZhbnRFdmVudFN0b3JlLmRlZnM7XG4gICAgbGV0IHJlbGV2YW50SW5zdGFuY2VzID0gcmVsZXZhbnRFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICBsZXQgc2VsZWN0aW9uID0gc3RhdGUuZGF0ZVNlbGVjdGlvbjtcbiAgICBsZXQgc2VsZWN0aW9uUmFuZ2UgPSBzZWxlY3Rpb24ucmFuZ2U7XG4gICAgbGV0IHsgc2VsZWN0aW9uQ29uZmlnIH0gPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgaWYgKGZpbHRlckNvbmZpZykge1xuICAgICAgICBzZWxlY3Rpb25Db25maWcgPSBmaWx0ZXJDb25maWcoc2VsZWN0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgLy8gY29uc3RyYWludFxuICAgIGlmICghYWxsQ29uc3RyYWludHNQYXNzKHNlbGVjdGlvbkNvbmZpZy5jb25zdHJhaW50cywgc2VsZWN0aW9uUmFuZ2UsIHJlbGV2YW50RXZlbnRTdG9yZSwgc3RhdGUuYnVzaW5lc3NIb3VycywgY29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBvdmVybGFwXG4gICAgbGV0IHsgc2VsZWN0T3ZlcmxhcCB9ID0gY29udGV4dC5vcHRpb25zO1xuICAgIGxldCBzZWxlY3RPdmVybGFwRnVuYyA9IHR5cGVvZiBzZWxlY3RPdmVybGFwID09PSAnZnVuY3Rpb24nID8gc2VsZWN0T3ZlcmxhcCA6IG51bGw7XG4gICAgZm9yIChsZXQgcmVsZXZhbnRJbnN0YW5jZUlkIGluIHJlbGV2YW50SW5zdGFuY2VzKSB7XG4gICAgICAgIGxldCByZWxldmFudEluc3RhbmNlID0gcmVsZXZhbnRJbnN0YW5jZXNbcmVsZXZhbnRJbnN0YW5jZUlkXTtcbiAgICAgICAgLy8gaW50ZXJzZWN0ISBldmFsdWF0ZVxuICAgICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHNlbGVjdGlvblJhbmdlLCByZWxldmFudEluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkNvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RPdmVybGFwRnVuYyAmJiAhc2VsZWN0T3ZlcmxhcEZ1bmMobmV3IEV2ZW50SW1wbChjb250ZXh0LCByZWxldmFudERlZnNbcmVsZXZhbnRJbnN0YW5jZS5kZWZJZF0sIHJlbGV2YW50SW5zdGFuY2UpLCBudWxsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhbGxvdyAoYSBmdW5jdGlvbilcbiAgICBmb3IgKGxldCBzZWxlY3Rpb25BbGxvdyBvZiBzZWxlY3Rpb25Db25maWcuYWxsb3dzKSB7XG4gICAgICAgIGxldCBmdWxsRGF0ZVNwYW4gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGVTcGFuTWV0YSksIHNlbGVjdGlvbik7XG4gICAgICAgIGlmICghc2VsZWN0aW9uQWxsb3coYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KGZ1bGxEYXRlU3BhbiwgY29udGV4dCksIG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBDb25zdHJhaW50IFV0aWxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGFsbENvbnN0cmFpbnRzUGFzcyhjb25zdHJhaW50cywgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBjb250ZXh0KSB7XG4gICAgZm9yIChsZXQgY29uc3RyYWludCBvZiBjb25zdHJhaW50cykge1xuICAgICAgICBpZiAoIWFueVJhbmdlc0NvbnRhaW5SYW5nZShjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBjb250ZXh0KSwgc3ViamVjdFJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY29uc3RyYWludFRvUmFuZ2VzKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgLy8gZm9yIGV4cGFuZGluZyBhIHJlY3VycmluZyBjb25zdHJhaW50LCBvciBleHBhbmRpbmcgYnVzaW5lc3MgaG91cnNcbm90aGVyRXZlbnRTdG9yZSwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgYW4gZXZlbiBncm91cCBJRFxuYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIC8vIGZvciBpZiBjb25zdHJhaW50IGlzICdidXNpbmVzc0hvdXJzJ1xuY29udGV4dCkge1xuICAgIGlmIChjb25zdHJhaW50ID09PSAnYnVzaW5lc3NIb3VycycpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIHN1YmplY3RSYW5nZSwgY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdzdHJpbmcnKSB7IC8vIGFuIGdyb3VwIElEXG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZmlsdGVyRXZlbnRTdG9yZURlZnMob3RoZXJFdmVudFN0b3JlLCAoZXZlbnREZWYpID0+IGV2ZW50RGVmLmdyb3VwSWQgPT09IGNvbnN0cmFpbnQpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnb2JqZWN0JyAmJiBjb25zdHJhaW50KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdOyAvLyBpZiBpdCdzIGZhbHNlXG59XG4vLyBUT0RPOiBtb3ZlIHRvIGV2ZW50LXN0b3JlIGZpbGU/XG5mdW5jdGlvbiBldmVudFN0b3JlVG9SYW5nZXMoZXZlbnRTdG9yZSkge1xuICAgIGxldCB7IGluc3RhbmNlcyB9ID0gZXZlbnRTdG9yZTtcbiAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goaW5zdGFuY2VzW2luc3RhbmNlSWRdLnJhbmdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbi8vIFRPRE86IG1vdmUgdG8gZ2VvbSBmaWxlP1xuZnVuY3Rpb24gYW55UmFuZ2VzQ29udGFpblJhbmdlKG91dGVyUmFuZ2VzLCBpbm5lclJhbmdlKSB7XG4gICAgZm9yIChsZXQgb3V0ZXJSYW5nZSBvZiBvdXRlclJhbmdlcykge1xuICAgICAgICBpZiAocmFuZ2VDb250YWluc1JhbmdlKG91dGVyUmFuZ2UsIGlubmVyUmFuZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IFZJU0lCTEVfSElEREVOX1JFID0gL14odmlzaWJsZXxoaWRkZW4pJC87XG5jbGFzcyBTY3JvbGxlciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBsaXF1aWQsIGxpcXVpZElzQWJzb2x1dGUgfSA9IHByb3BzO1xuICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IGxpcXVpZCAmJiBsaXF1aWRJc0Fic29sdXRlO1xuICAgICAgICBsZXQgY2xhc3NOYW1lID0gWydmYy1zY3JvbGxlciddO1xuICAgICAgICBpZiAobGlxdWlkKSB7XG4gICAgICAgICAgICBpZiAobGlxdWlkSXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZS5wdXNoKCdmYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZS5wdXNoKCdmYy1zY3JvbGxlci1saXF1aWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMuaGFuZGxlRWwsIGNsYXNzTmFtZTogY2xhc3NOYW1lLmpvaW4oJyAnKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1g6IHByb3BzLm92ZXJmbG93WCxcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1k6IHByb3BzLm92ZXJmbG93WSxcbiAgICAgICAgICAgICAgICBsZWZ0OiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVSaWdodCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lQm90dG9tIHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUxlZnQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lQm90dG9tIHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IHByb3BzLm1heEhlaWdodCB8fCAnJyxcbiAgICAgICAgICAgIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgbmVlZHNYU2Nyb2xsaW5nKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0aW5nIHNjcm9sbFdpZHRoPmNsaWVudFdpZHRoIGlzIHVucmVsaWFibGUgY3Jvc3MtYnJvd3NlciB3aGVuIHBpeGVsIGhlaWdodHMgYXJlbid0IGludGVnZXJzLlxuICAgICAgICAvLyBtdWNoIG1vcmUgcmVsaWFibGUgdG8gc2VlIGlmIGNoaWxkcmVuIGFyZSB0YWxsZXIgdGhhbiB0aGUgc2Nyb2xsZXIsIGV2ZW4gdGhvIGRvZXNuJ3QgYWNjb3VudCBmb3JcbiAgICAgICAgLy8gaW5uZXItY2hpbGQgbWFyZ2lucyBhbmQgYWJzb2x1dGUgcG9zaXRpb25pbmdcbiAgICAgICAgbGV0IHsgZWwgfSA9IHRoaXM7XG4gICAgICAgIGxldCByZWFsQ2xpZW50V2lkdGggPSB0aGlzLmVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gdGhpcy5nZXRZU2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgICAgbGV0IHsgY2hpbGRyZW4gfSA9IGVsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRFbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPiByZWFsQ2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG5lZWRzWVNjcm9sbGluZygpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1kpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdGluZyBzY3JvbGxIZWlnaHQ+Y2xpZW50SGVpZ2h0IGlzIHVucmVsaWFibGUgY3Jvc3MtYnJvd3NlciB3aGVuIHBpeGVsIGhlaWdodHMgYXJlbid0IGludGVnZXJzLlxuICAgICAgICAvLyBtdWNoIG1vcmUgcmVsaWFibGUgdG8gc2VlIGlmIGNoaWxkcmVuIGFyZSB0YWxsZXIgdGhhbiB0aGUgc2Nyb2xsZXIsIGV2ZW4gdGhvIGRvZXNuJ3QgYWNjb3VudCBmb3JcbiAgICAgICAgLy8gaW5uZXItY2hpbGQgbWFyZ2lucyBhbmQgYWJzb2x1dGUgcG9zaXRpb25pbmdcbiAgICAgICAgbGV0IHsgZWwgfSA9IHRoaXM7XG4gICAgICAgIGxldCByZWFsQ2xpZW50SGVpZ2h0ID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgLSB0aGlzLmdldFhTY3JvbGxiYXJXaWR0aCgpO1xuICAgICAgICBsZXQgeyBjaGlsZHJlbiB9ID0gZWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZEVsID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgPiByZWFsQ2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRYU2Nyb2xsYmFyV2lkdGgoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZWwub2Zmc2V0SGVpZ2h0IC0gdGhpcy5lbC5jbGllbnRIZWlnaHQ7IC8vIG9ubHkgd29ya3MgYmVjYXVzZSB3ZSBndWFyYW50ZWUgbm8gYm9yZGVycy4gVE9ETzogYWRkIHRvIENTUyB3aXRoIGltcG9ydGFudD9cbiAgICB9XG4gICAgZ2V0WVNjcm9sbGJhcldpZHRoKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmVsLm9mZnNldFdpZHRoIC0gdGhpcy5lbC5jbGllbnRXaWR0aDsgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xuICAgIH1cbn1cblxuLypcblRPRE86IHNvbWVob3cgaW5mZXIgT3RoZXJBcmdzIGZyb20gbWFzdGVyQ2FsbGJhY2s/XG5UT0RPOiBpbmZlciBSZWZUeXBlIGZyb20gbWFzdGVyQ2FsbGJhY2sgaWYgcHJvdmlkZWRcbiovXG5jbGFzcyBSZWZNYXAge1xuICAgIGNvbnN0cnVjdG9yKG1hc3RlckNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubWFzdGVyQ2FsbGJhY2sgPSBtYXN0ZXJDYWxsYmFjaztcbiAgICAgICAgdGhpcy5jdXJyZW50TWFwID0ge307XG4gICAgICAgIHRoaXMuZGVwdGhzID0ge307XG4gICAgICAgIHRoaXMuY2FsbGJhY2tNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZSA9ICh2YWwsIGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZGVwdGhzLCBjdXJyZW50TWFwIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGZvciBidWcuLi4gQUNUVUFMTFk6IGNhbiBwcm9iYWJseSBkbyBhd2F5IHdpdGggdGhpcyBub3cgdGhhdCBjYWxsZXJzIGRvbid0IHNoYXJlIG51bWVyaWMgaW5kaWNlcyBhbnltb3JlXG4gICAgICAgICAgICAgICAgcmVtb3ZlZCA9IChrZXkgaW4gY3VycmVudE1hcCk7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcFtrZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIGRlcHRoc1trZXldID0gKGRlcHRoc1trZXldIHx8IDApICsgMTtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXB0aHNba2V5XSAtPSAxO1xuICAgICAgICAgICAgICAgIGlmICghZGVwdGhzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRNYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tNYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWFzdGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hc3RlckNhbGxiYWNrKG51bGwsIFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFkZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFzdGVyQ2FsbGJhY2sodmFsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVSZWYoa2V5KSB7XG4gICAgICAgIGxldCByZWZDYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tNYXBba2V5XTtcbiAgICAgICAgaWYgKCFyZWZDYWxsYmFjaykge1xuICAgICAgICAgICAgcmVmQ2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrTWFwW2tleV0gPSAodmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZSh2YWwsIFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZkNhbGxiYWNrO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjaGVjayBjYWxsZXJzIHRoYXQgZG9uJ3QgY2FyZSBhYm91dCBvcmRlci4gc2hvdWxkIHVzZSBnZXRBbGwgaW5zdGVhZFxuICAgIC8vIE5PVEU6IHRoaXMgbWV0aG9kIGhhcyBiZWNvbWUgbGVzcyB2YWx1YWJsZSBub3cgdGhhdCB3ZSBhcmUgZW5jb3VyYWdlZCB0byBtYXAgb3JkZXIgYnkgc29tZSBvdGhlciBpbmRleFxuICAgIC8vIFRPRE86IHByb3ZpZGUgT05FIGFycmF5LWV4cG9ydCBmdW5jdGlvbiwgYnVpbGRBcnJheSwgd2hpY2ggZmFpbHMgb24gbm9uLW51bWVyaWMgaW5kZXhlcy4gY2FsbGVyIGNhbiBtYW5pcHVsYXRlIGFuZCBcImNvbGxlY3RcIlxuICAgIGNvbGxlY3Qoc3RhcnRJbmRleCwgZW5kSW5kZXgsIHN0ZXApIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3RGcm9tSGFzaCh0aGlzLmN1cnJlbnRNYXAsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKTtcbiAgICB9XG4gICAgZ2V0QWxsKCkge1xuICAgICAgICByZXR1cm4gaGFzaFZhbHVlc1RvQXJyYXkodGhpcy5jdXJyZW50TWFwKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTaHJpbmtXaWR0aChjaHVua0Vscykge1xuICAgIGxldCBzaHJpbmtDZWxscyA9IGZpbmRFbGVtZW50cyhjaHVua0VscywgJy5mYy1zY3JvbGxncmlkLXNocmluaycpO1xuICAgIGxldCBsYXJnZXN0V2lkdGggPSAwO1xuICAgIGZvciAobGV0IHNocmlua0NlbGwgb2Ygc2hyaW5rQ2VsbHMpIHtcbiAgICAgICAgbGFyZ2VzdFdpZHRoID0gTWF0aC5tYXgobGFyZ2VzdFdpZHRoLCBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGgoc2hyaW5rQ2VsbCkpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5jZWlsKGxhcmdlc3RXaWR0aCk7IC8vIDx0YWJsZT4gZWxlbWVudHMgd29yayBiZXN0IHdpdGggaW50ZWdlcnMuIHJvdW5kIHVwIHRvIGVuc3VyZSBjb250ZW50cyBmaXRzXG59XG5mdW5jdGlvbiBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKSB7XG4gICAgcmV0dXJuIHByb3BzLmxpcXVpZCAmJiBzZWN0aW9uQ29uZmlnLmxpcXVpZDsgLy8gZG9lcyB0aGUgc2VjdGlvbiBkbyBsaXF1aWQtaGVpZ2h0PyAobmVlZCB0byBoYXZlIHdob2xlIHNjcm9sbGdyaWQgbGlxdWlkLWhlaWdodCBhcyB3ZWxsKVxufVxuZnVuY3Rpb24gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKSB7XG4gICAgcmV0dXJuIHNlY3Rpb25Db25maWcubWF4SGVpZ2h0ICE9IG51bGwgfHwgLy8gaWYgaXRzIHBvc3NpYmxlIGZvciB0aGUgaGVpZ2h0IHRvIG1heCBvdXQsIHdlIG1pZ2h0IG5lZWQgc2Nyb2xsYmFyc1xuICAgICAgICBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gaWYgdGhlIHNlY3Rpb24gaXMgbGlxdWlkIGhlaWdodCwgaXQgbWlnaHQgY29uZGVuc2UgZW5vdWdoIHRvIHJlcXVpcmUgc2Nyb2xsYmFyc1xufVxuLy8gVE9ETzogT05MWSB1c2UgYGFyZ2AuIGZvcmNlIG91dCBpbnRlcm5hbCBmdW5jdGlvbiB0byB1c2Ugc2FtZSBBUElcbmZ1bmN0aW9uIHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywgYXJnLCBpc0hlYWRlcikge1xuICAgIGxldCB7IGV4cGFuZFJvd3MgfSA9IGFyZztcbiAgICBsZXQgY29udGVudCA9IHR5cGVvZiBjaHVua0NvbmZpZy5jb250ZW50ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgY2h1bmtDb25maWcuY29udGVudChhcmcpIDpcbiAgICAgICAgY3JlYXRlRWxlbWVudCgndGFibGUnLCB7XG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICAgIGNodW5rQ29uZmlnLnRhYmxlQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25Db25maWcuc3luY1Jvd0hlaWdodHMgPyAnZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlJyA6ICcnLFxuICAgICAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IGFyZy5jbGllbnRIZWlnaHQgOiAnJywgLy8gY3NzIGBoZWlnaHRgIG9uIGEgPHRhYmxlPiBzZXJ2ZXMgYXMgYSBtaW4taGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBhcmcudGFibGVDb2xHcm91cE5vZGUsIGNyZWF0ZUVsZW1lbnQoaXNIZWFkZXIgPyAndGhlYWQnIDogJ3Rib2R5Jywge1xuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgIH0sIHR5cGVvZiBjaHVua0NvbmZpZy5yb3dDb250ZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQoYXJnKVxuICAgICAgICAgICAgOiBjaHVua0NvbmZpZy5yb3dDb250ZW50KSk7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG59XG5mdW5jdGlvbiBpc0NvbFByb3BzRXF1YWwoY29sczAsIGNvbHMxKSB7XG4gICAgcmV0dXJuIGlzQXJyYXlzRXF1YWwoY29sczAsIGNvbHMxLCBpc1Byb3BzRXF1YWwpO1xufVxuZnVuY3Rpb24gcmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzaHJpbmtXaWR0aCkge1xuICAgIGxldCBjb2xOb2RlcyA9IFtdO1xuICAgIC8qXG4gICAgZm9yIENvbFByb3BzIHdpdGggc3BhbnMsIGl0IHdvdWxkIGhhdmUgYmVlbiBncmVhdCB0byBtYWtlIGEgc2luZ2xlIDxjb2wgc3Bhbj1cIlwiPlxuICAgIEhPV0VWRVIsIENocm9tZSB3YXMgZ2V0dGluZyBtZXNzaW5nIHVwIGRpc3RyaWJ1dGluZyB0aGUgd2lkdGggdG8gPHRkPi88dGg+IGVsZW1lbnRzIHdpdGggY29sc3BhbnMuXG4gICAgU09MVVRJT046IG1ha2luZyBpbmRpdmlkdWFsIDxjb2w+IGVsZW1lbnRzIG1ha2VzIENocm9tZSBiZWhhdmUuXG4gICAgKi9cbiAgICBmb3IgKGxldCBjb2xQcm9wcyBvZiBjb2xzKSB7XG4gICAgICAgIGxldCBzcGFuID0gY29sUHJvcHMuc3BhbiB8fCAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW47IGkgKz0gMSkge1xuICAgICAgICAgICAgY29sTm9kZXMucHVzaChjcmVhdGVFbGVtZW50KFwiY29sXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbFByb3BzLndpZHRoID09PSAnc2hyaW5rJyA/IHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGgpIDogKGNvbFByb3BzLndpZHRoIHx8ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IGNvbFByb3BzLm1pbldpZHRoIHx8ICcnLFxuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdjb2xncm91cCcsIHt9LCAuLi5jb2xOb2Rlcyk7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSB7XG4gICAgLyogd2h5IDQ/IGlmIHdlIGRvIDAsIGl0IHdpbGwga2lsbCBhbnkgYm9yZGVyLCB3aGljaCBhcmUgbmVlZGVkIGZvciBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGhcbiAgICA0IGFjY291bnRzIGZvciAyIDItcGl4ZWwgYm9yZGVycy4gVE9ETzogYmV0dGVyIHNvbHV0aW9uPyAqL1xuICAgIHJldHVybiBzaHJpbmtXaWR0aCA9PSBudWxsID8gNCA6IHNocmlua1dpZHRoO1xufVxuZnVuY3Rpb24gaGFzU2hyaW5rV2lkdGgoY29scykge1xuICAgIGZvciAobGV0IGNvbCBvZiBjb2xzKSB7XG4gICAgICAgIGlmIChjb2wud2lkdGggPT09ICdzaHJpbmsnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyhsaXF1aWQsIGNvbnRleHQpIHtcbiAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXNjcm9sbGdyaWQnLFxuICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxuICAgIF07XG4gICAgaWYgKGxpcXVpZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtbGlxdWlkJyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgd2hvbGVUYWJsZVZHcm93KSB7XG4gICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1zY3JvbGxncmlkLXNlY3Rpb24nLFxuICAgICAgICBgZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLSR7c2VjdGlvbkNvbmZpZy50eXBlfWAsXG4gICAgICAgIHNlY3Rpb25Db25maWcuY2xhc3NOYW1lLCAvLyB1c2VkP1xuICAgIF07XG4gICAgaWYgKHdob2xlVGFibGVWR3JvdyAmJiBzZWN0aW9uQ29uZmlnLmxpcXVpZCAmJiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLWxpcXVpZCcpO1xuICAgIH1cbiAgICBpZiAoc2VjdGlvbkNvbmZpZy5pc1N0aWNreSkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtc2VjdGlvbi1zdGlja3knKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiByZW5kZXJTY3JvbGxTaGltKGFyZykge1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN0aWNreS1zaGltXCIsIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgbWluV2lkdGg6IGFyZy50YWJsZU1pbldpZHRoLFxuICAgICAgICB9IH0pKTtcbn1cbmZ1bmN0aW9uIGdldFN0aWNreUhlYWRlckRhdGVzKG9wdGlvbnMpIHtcbiAgICBsZXQgeyBzdGlja3lIZWFkZXJEYXRlcyB9ID0gb3B0aW9ucztcbiAgICBpZiAoc3RpY2t5SGVhZGVyRGF0ZXMgPT0gbnVsbCB8fCBzdGlja3lIZWFkZXJEYXRlcyA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHN0aWNreUhlYWRlckRhdGVzID0gb3B0aW9ucy5oZWlnaHQgPT09ICdhdXRvJyB8fCBvcHRpb25zLnZpZXdIZWlnaHQgPT09ICdhdXRvJztcbiAgICB9XG4gICAgcmV0dXJuIHN0aWNreUhlYWRlckRhdGVzO1xufVxuZnVuY3Rpb24gZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKG9wdGlvbnMpIHtcbiAgICBsZXQgeyBzdGlja3lGb290ZXJTY3JvbGxiYXIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHN0aWNreUZvb3RlclNjcm9sbGJhciA9PSBudWxsIHx8IHN0aWNreUZvb3RlclNjcm9sbGJhciA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIHN0aWNreUZvb3RlclNjcm9sbGJhciA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBzdGlja3lGb290ZXJTY3JvbGxiYXI7XG59XG5cbmNsYXNzIFNpbXBsZVNjcm9sbEdyaWQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzQ29scyA9IG1lbW9pemUoKGEpID0+IGEsIGlzQ29sUHJvcHNFcXVhbCk7IC8vIHNvIHdlIGdldCBzYW1lIGBjb2xzYCBwcm9wcyBldmVyeSB0aW1lXG4gICAgICAgIC8vIHl1Y2t5IHRvIG1lbW9pemUgVk5vZGVzLCBidXQgbXVjaCBtb3JlIGVmZmljaWVudCBmb3IgY29uc3VtZXJzXG4gICAgICAgIHRoaXMucmVuZGVyTWljcm9Db2xHcm91cCA9IG1lbW9pemUocmVuZGVyTWljcm9Db2xHcm91cCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsZXJSZWZzID0gbmV3IFJlZk1hcCgpO1xuICAgICAgICB0aGlzLnNjcm9sbGVyRWxSZWZzID0gbmV3IFJlZk1hcCh0aGlzLl9oYW5kbGVTY3JvbGxlckVsLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2hyaW5rV2lkdGg6IG51bGwsXG4gICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzOiBmYWxzZSxcbiAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzOiB7fSxcbiAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czoge30sXG4gICAgICAgIH07XG4gICAgICAgIC8vIFRPRE86IGNhbiBkbyBhIHJlYWxseSBzaW1wbGUgcHJpbnQtdmlldy4gZG9udCBuZWVkIHRvIGpvaW4gcm93c1xuICAgICAgICB0aGlzLmhhbmRsZVNpemluZyA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2FmZVNldFN0YXRlKE9iamVjdC5hc3NpZ24oeyBzaHJpbmtXaWR0aDogdGhpcy5jb21wdXRlU2hyaW5rV2lkdGgoKSB9LCB0aGlzLmNvbXB1dGVTY3JvbGxlckRpbXMoKSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHNlY3Rpb25Db25maWdzID0gcHJvcHMuc2VjdGlvbnMgfHwgW107XG4gICAgICAgIGxldCBjb2xzID0gdGhpcy5wcm9jZXNzQ29scyhwcm9wcy5jb2xzKTtcbiAgICAgICAgbGV0IG1pY3JvQ29sR3JvdXBOb2RlID0gdGhpcy5yZW5kZXJNaWNyb0NvbEdyb3VwKGNvbHMsIHN0YXRlLnNocmlua1dpZHRoKTtcbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyhwcm9wcy5saXF1aWQsIGNvbnRleHQpO1xuICAgICAgICBpZiAocHJvcHMuY29sbGFwc2libGVXaWR0aCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLWNvbGxhcHNpYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogbWFrZSBEUllcbiAgICAgICAgbGV0IGNvbmZpZ0NudCA9IHNlY3Rpb25Db25maWdzLmxlbmd0aDtcbiAgICAgICAgbGV0IGNvbmZpZ0kgPSAwO1xuICAgICAgICBsZXQgY3VycmVudENvbmZpZztcbiAgICAgICAgbGV0IGhlYWRTZWN0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IGJvZHlTZWN0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IGZvb3RTZWN0aW9uTm9kZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2hlYWRlcicpIHtcbiAgICAgICAgICAgIGhlYWRTZWN0aW9uTm9kZXMucHVzaCh0aGlzLnJlbmRlclNlY3Rpb24oY3VycmVudENvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHRydWUpKTtcbiAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY29uZmlnSSA8IGNvbmZpZ0NudCAmJiAoY3VycmVudENvbmZpZyA9IHNlY3Rpb25Db25maWdzW2NvbmZpZ0ldKS50eXBlID09PSAnYm9keScpIHtcbiAgICAgICAgICAgIGJvZHlTZWN0aW9uTm9kZXMucHVzaCh0aGlzLnJlbmRlclNlY3Rpb24oY3VycmVudENvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIGZhbHNlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2Zvb3RlcicpIHtcbiAgICAgICAgICAgIGZvb3RTZWN0aW9uTm9kZXMucHVzaCh0aGlzLnJlbmRlclNlY3Rpb24oY3VycmVudENvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHRydWUpKTtcbiAgICAgICAgICAgIGNvbmZpZ0kgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaXJlZm94IGJ1Zzogd2hlbiBzZXR0aW5nIGhlaWdodCBvbiB0YWJsZSBhbmQgdGhlcmUgaXMgYSB0aGVhZCBvciB0Zm9vdCxcbiAgICAgICAgLy8gdGhlIG5lY2Vzc2FyeSBoZWlnaHQ6MTAwJSBvbiB0aGUgbGlxdWlkLWhlaWdodCBib2R5IHNlY3Rpb24gZm9yY2VzIHRoZSAqd2hvbGUqIHRhYmxlIHRvIGJlIHRhbGxlci4gKGJ1ZyAjNTUyNClcbiAgICAgICAgLy8gdXNlIGdldENhblZHcm93V2l0aGluQ2VsbCBhcyBhIHdheSB0byBkZXRlY3QgdGFibGUtc3R1cGlkIGZpcmVmb3guXG4gICAgICAgIC8vIGlmIHNvLCB1c2UgYSBzaW1wbGVyIGRvbSBzdHJ1Y3R1cmUsIGphbSBldmVyeXRoaW5nIGludG8gYSBsb25lIHRib2R5LlxuICAgICAgICBsZXQgaXNCdWdneSA9ICFnZXRDYW5WR3Jvd1dpdGhpbkNlbGwoKTtcbiAgICAgICAgY29uc3Qgcm9sZUF0dHJzID0geyByb2xlOiAncm93Z3JvdXAnIH07XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCd0YWJsZScsIHtcbiAgICAgICAgICAgIHJvbGU6ICdncmlkJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksXG4gICAgICAgICAgICBzdHlsZTogeyBoZWlnaHQ6IHByb3BzLmhlaWdodCB9LFxuICAgICAgICB9LCBCb29sZWFuKCFpc0J1Z2d5ICYmIGhlYWRTZWN0aW9uTm9kZXMubGVuZ3RoKSAmJiBjcmVhdGVFbGVtZW50KCd0aGVhZCcsIHJvbGVBdHRycywgLi4uaGVhZFNlY3Rpb25Ob2RlcyksIEJvb2xlYW4oIWlzQnVnZ3kgJiYgYm9keVNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIGNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jywgcm9sZUF0dHJzLCAuLi5ib2R5U2VjdGlvbk5vZGVzKSwgQm9vbGVhbighaXNCdWdneSAmJiBmb290U2VjdGlvbk5vZGVzLmxlbmd0aCkgJiYgY3JlYXRlRWxlbWVudCgndGZvb3QnLCByb2xlQXR0cnMsIC4uLmZvb3RTZWN0aW9uTm9kZXMpLCBpc0J1Z2d5ICYmIGNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jywgcm9sZUF0dHJzLCAuLi5oZWFkU2VjdGlvbk5vZGVzLCAuLi5ib2R5U2VjdGlvbk5vZGVzLCAuLi5mb290U2VjdGlvbk5vZGVzKSk7XG4gICAgfVxuICAgIHJlbmRlclNlY3Rpb24oc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIGlzSGVhZGVyKSB7XG4gICAgICAgIGlmICgnb3V0ZXJDb250ZW50JyBpbiBzZWN0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHsga2V5OiBzZWN0aW9uQ29uZmlnLmtleSB9LCBzZWN0aW9uQ29uZmlnLm91dGVyQ29udGVudCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRyXCIsIHsga2V5OiBzZWN0aW9uQ29uZmlnLmtleSwgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBnZXRTZWN0aW9uQ2xhc3NOYW1lcyhzZWN0aW9uQ29uZmlnLCB0aGlzLnByb3BzLmxpcXVpZCkuam9pbignICcpIH0sIHRoaXMucmVuZGVyQ2h1bmtUZChzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgc2VjdGlvbkNvbmZpZy5jaHVuaywgaXNIZWFkZXIpKSk7XG4gICAgfVxuICAgIHJlbmRlckNodW5rVGQoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIGNodW5rQ29uZmlnLCBpc0hlYWRlcikge1xuICAgICAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gY2h1bmtDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBjaHVua0NvbmZpZy5vdXRlckNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGZvcmNlWVNjcm9sbGJhcnMsIHNjcm9sbGVyQ2xpZW50V2lkdGhzLCBzY3JvbGxlckNsaWVudEhlaWdodHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBuZWVkc1lTY3JvbGxpbmcgPSBnZXRBbGxvd1lTY3JvbGxpbmcocHJvcHMsIHNlY3Rpb25Db25maWcpOyAvLyBUT0RPOiBkbyBsYXppbHkuIGRvIGluIHNlY3Rpb24gY29uZmlnP1xuICAgICAgICBsZXQgaXNMaXF1aWQgPSBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0KHByb3BzLCBzZWN0aW9uQ29uZmlnKTtcbiAgICAgICAgLy8gZm9yIGAhcHJvcHMubGlxdWlkYCAtIGlzIFdIT0xFIHNjcm9sbGdyaWQgbmF0dXJhbCBoZWlnaHQ/XG4gICAgICAgIC8vIFRPRE86IGRvIHNhbWUgdGhpbmcgaW4gYWR2YW5jZWQgc2Nyb2xsZ3JpZD8gcHJvbGx5IG5vdCBiL2MgYWx3YXlzIGhhcyBob3Jpem9udGFsIHNjcm9sbGJhcnNcbiAgICAgICAgbGV0IG92ZXJmbG93WSA9ICFwcm9wcy5saXF1aWQgPyAndmlzaWJsZScgOlxuICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA/ICdzY3JvbGwnIDpcbiAgICAgICAgICAgICAgICAhbmVlZHNZU2Nyb2xsaW5nID8gJ2hpZGRlbicgOlxuICAgICAgICAgICAgICAgICAgICAnYXV0byc7XG4gICAgICAgIGxldCBzZWN0aW9uS2V5ID0gc2VjdGlvbkNvbmZpZy5rZXk7XG4gICAgICAgIGxldCBjb250ZW50ID0gcmVuZGVyQ2h1bmtDb250ZW50KHNlY3Rpb25Db25maWcsIGNodW5rQ29uZmlnLCB7XG4gICAgICAgICAgICB0YWJsZUNvbEdyb3VwTm9kZTogbWljcm9Db2xHcm91cE5vZGUsXG4gICAgICAgICAgICB0YWJsZU1pbldpZHRoOiAnJyxcbiAgICAgICAgICAgIGNsaWVudFdpZHRoOiAoIXByb3BzLmNvbGxhcHNpYmxlV2lkdGggJiYgc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCkgPyBzY3JvbGxlckNsaWVudFdpZHRoc1tzZWN0aW9uS2V5XSA6IG51bGwsXG4gICAgICAgICAgICBjbGllbnRIZWlnaHQ6IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSAhPT0gdW5kZWZpbmVkID8gc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldIDogbnVsbCxcbiAgICAgICAgICAgIGV4cGFuZFJvd3M6IHNlY3Rpb25Db25maWcuZXhwYW5kUm93cyxcbiAgICAgICAgICAgIHN5bmNSb3dIZWlnaHRzOiBmYWxzZSxcbiAgICAgICAgICAgIHJvd1N5bmNIZWlnaHRzOiBbXSxcbiAgICAgICAgICAgIHJlcG9ydFJvd0hlaWdodENoYW5nZTogKCkgPT4geyB9LFxuICAgICAgICB9LCBpc0hlYWRlcik7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KGlzSGVhZGVyID8gJ3RoJyA6ICd0ZCcsIHtcbiAgICAgICAgICAgIHJlZjogY2h1bmtDb25maWcuZWxSZWYsXG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgfSwgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogYGZjLXNjcm9sbGVyLWhhcm5lc3Mke2lzTGlxdWlkID8gJyBmYy1zY3JvbGxlci1oYXJuZXNzLWxpcXVpZCcgOiAnJ31gIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbGVyLCB7IHJlZjogdGhpcy5zY3JvbGxlclJlZnMuY3JlYXRlUmVmKHNlY3Rpb25LZXkpLCBlbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmcy5jcmVhdGVSZWYoc2VjdGlvbktleSksIG92ZXJmbG93WTogb3ZlcmZsb3dZLCBvdmVyZmxvd1g6ICFwcm9wcy5saXF1aWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJyAvKiBuYXR1cmFsIGhlaWdodD8gKi8sIG1heEhlaWdodDogc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQsIGxpcXVpZDogaXNMaXF1aWQsIGxpcXVpZElzQWJzb2x1dGUgLy8gYmVjYXVzZSBpdHMgd2l0aGluIGEgaGFybmVzc1xuICAgICAgICAgICAgICAgIDogdHJ1ZSB9LCBjb250ZW50KSkpO1xuICAgIH1cbiAgICBfaGFuZGxlU2Nyb2xsZXJFbChzY3JvbGxlckVsLCBrZXkpIHtcbiAgICAgICAgbGV0IHNlY3Rpb24gPSBnZXRTZWN0aW9uQnlLZXkodGhpcy5wcm9wcy5zZWN0aW9ucywga2V5KTtcbiAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIHNldFJlZihzZWN0aW9uLmNodW5rLnNjcm9sbGVyRWxSZWYsIHNjcm9sbGVyRWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLmhhbmRsZVNpemluZygpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVNpemluZyk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy8gVE9ETzogbmVlZCBiZXR0ZXIgc29sdXRpb24gd2hlbiBzdGF0ZSBjb250YWlucyBub24tc2l6aW5nIHRoaW5nc1xuICAgICAgICB0aGlzLmhhbmRsZVNpemluZygpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xuICAgIH1cbiAgICBjb21wdXRlU2hyaW5rV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBoYXNTaHJpbmtXaWR0aCh0aGlzLnByb3BzLmNvbHMpXG4gICAgICAgICAgICA/IGNvbXB1dGVTaHJpbmtXaWR0aCh0aGlzLnNjcm9sbGVyRWxSZWZzLmdldEFsbCgpKVxuICAgICAgICAgICAgOiAwO1xuICAgIH1cbiAgICBjb21wdXRlU2Nyb2xsZXJEaW1zKCkge1xuICAgICAgICBsZXQgc2Nyb2xsYmFyV2lkdGggPSBnZXRTY3JvbGxiYXJXaWR0aHMoKTtcbiAgICAgICAgbGV0IHsgc2Nyb2xsZXJSZWZzLCBzY3JvbGxlckVsUmVmcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGZvcmNlWVNjcm9sbGJhcnMgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNjcm9sbGVyQ2xpZW50V2lkdGhzID0ge307XG4gICAgICAgIGxldCBzY3JvbGxlckNsaWVudEhlaWdodHMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgc2VjdGlvbktleSBpbiBzY3JvbGxlclJlZnMuY3VycmVudE1hcCkge1xuICAgICAgICAgICAgbGV0IHNjcm9sbGVyID0gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXBbc2VjdGlvbktleV07XG4gICAgICAgICAgICBpZiAoc2Nyb2xsZXIgJiYgc2Nyb2xsZXIubmVlZHNZU2Nyb2xsaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBmb3JjZVlTY3JvbGxiYXJzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBzZWN0aW9uIG9mIHRoaXMucHJvcHMuc2VjdGlvbnMpIHtcbiAgICAgICAgICAgIGxldCBzZWN0aW9uS2V5ID0gc2VjdGlvbi5rZXk7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsZXJFbCA9IHNjcm9sbGVyRWxSZWZzLmN1cnJlbnRNYXBbc2VjdGlvbktleV07XG4gICAgICAgICAgICBpZiAoc2Nyb2xsZXJFbCkge1xuICAgICAgICAgICAgICAgIGxldCBoYXJuZXNzRWwgPSBzY3JvbGxlckVsLnBhcmVudE5vZGU7IC8vIFRPRE86IHdlaXJkIHdheSB0byBnZXQgdGhpcy4gbmVlZCBoYXJuZXNzIGIvYyBkb2Vzbid0IGluY2x1ZGUgdGFibGUgYm9yZGVyc1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldID0gTWF0aC5mbG9vcihoYXJuZXNzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSAoZm9yY2VZU2Nyb2xsYmFyc1xuICAgICAgICAgICAgICAgICAgICA/IHNjcm9sbGJhcldpZHRoLnkgLy8gdXNlIGdsb2JhbCBiZWNhdXNlIHNjcm9sbGVyIG1pZ2h0IG5vdCBoYXZlIHNjcm9sbGJhcnMgeWV0IGJ1dCB3aWxsIG5lZWQgdGhlbSBpbiBmdXR1cmVcbiAgICAgICAgICAgICAgICAgICAgOiAwKSk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldID0gTWF0aC5mbG9vcihoYXJuZXNzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH07XG4gICAgfVxufVxuU2ltcGxlU2Nyb2xsR3JpZC5hZGRTdGF0ZUVxdWFsaXR5KHtcbiAgICBzY3JvbGxlckNsaWVudFdpZHRoczogaXNQcm9wc0VxdWFsLFxuICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czogaXNQcm9wc0VxdWFsLFxufSk7XG5mdW5jdGlvbiBnZXRTZWN0aW9uQnlLZXkoc2VjdGlvbnMsIGtleSkge1xuICAgIGZvciAobGV0IHNlY3Rpb24gb2Ygc2VjdGlvbnMpIHtcbiAgICAgICAgaWYgKHNlY3Rpb24ua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5jbGFzcyBFdmVudENvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhbmRsZUVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICBzZXRFbFNlZyhlbCwgdGhpcy5wcm9wcy5zZWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgY29uc3QgeyBzZWcgfSA9IHByb3BzO1xuICAgICAgICBjb25zdCB7IGV2ZW50UmFuZ2UgfSA9IHNlZztcbiAgICAgICAgY29uc3QgeyB1aSB9ID0gZXZlbnRSYW5nZTtcbiAgICAgICAgY29uc3QgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICB0aW1lVGV4dDogcHJvcHMudGltZVRleHQsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IHVpLnRleHRDb2xvcixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdWkuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHVpLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgaXNEcmFnZ2FibGU6ICFwcm9wcy5kaXNhYmxlRHJhZ2dpbmcgJiYgY29tcHV0ZVNlZ0RyYWdnYWJsZShzZWcsIGNvbnRleHQpLFxuICAgICAgICAgICAgaXNTdGFydFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnU3RhcnRSZXNpemFibGUoc2VnLCBjb250ZXh0KSxcbiAgICAgICAgICAgIGlzRW5kUmVzaXphYmxlOiAhcHJvcHMuZGlzYWJsZVJlc2l6aW5nICYmIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnKSxcbiAgICAgICAgICAgIGlzTWlycm9yOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcgfHwgcHJvcHMuaXNSZXNpemluZyB8fCBwcm9wcy5pc0RhdGVTZWxlY3RpbmcpLFxuICAgICAgICAgICAgaXNTdGFydDogQm9vbGVhbihzZWcuaXNTdGFydCksXG4gICAgICAgICAgICBpc0VuZDogQm9vbGVhbihzZWcuaXNFbmQpLFxuICAgICAgICAgICAgaXNQYXN0OiBCb29sZWFuKHByb3BzLmlzUGFzdCksXG4gICAgICAgICAgICBpc0Z1dHVyZTogQm9vbGVhbihwcm9wcy5pc0Z1dHVyZSksXG4gICAgICAgICAgICBpc1RvZGF5OiBCb29sZWFuKHByb3BzLmlzVG9kYXkpLFxuICAgICAgICAgICAgaXNTZWxlY3RlZDogQm9vbGVhbihwcm9wcy5pc1NlbGVjdGVkKSxcbiAgICAgICAgICAgIGlzRHJhZ2dpbmc6IEJvb2xlYW4ocHJvcHMuaXNEcmFnZ2luZyksXG4gICAgICAgICAgICBpc1Jlc2l6aW5nOiBCb29sZWFuKHByb3BzLmlzUmVzaXppbmcpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogY29udGFpbnMgY2hpbGRyZW4gKi8sIHsgZWxSZWY6IHRoaXMuaGFuZGxlRWwsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgIC4uLmdldEV2ZW50Q2xhc3NOYW1lcyhyZW5kZXJQcm9wcyksXG4gICAgICAgICAgICAgICAgLi4uc2VnLmV2ZW50UmFuZ2UudWkuY2xhc3NOYW1lcyxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZWxDbGFzc2VzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJldmVudENvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmV2ZW50Q29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcHJvcHMuZGVmYXVsdEdlbmVyYXRvciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmV2ZW50Q2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZXZlbnREaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZXZlbnRXaWxsVW5tb3VudCB9KSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLmVsICYmIHRoaXMucHJvcHMuc2VnICE9PSBwcmV2UHJvcHMuc2VnKSB7XG4gICAgICAgICAgICBzZXRFbFNlZyh0aGlzLmVsLCB0aGlzLnByb3BzLnNlZyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIHNob3VsZCBub3QgYmUgYSBwdXJlY29tcG9uZW50XG5jbGFzcyBTdGFuZGFyZEV2ZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgc2VnIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHsgdWkgfSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICBsZXQgdGltZUZvcm1hdCA9IG9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IHByb3BzLmRlZmF1bHRUaW1lRm9ybWF0O1xuICAgICAgICBsZXQgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRXZlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGVsUmVmICovLCB7IGVsVGFnOiBcImFcIiwgZWxTdHlsZToge1xuICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiB1aS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHVpLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIH0sIGVsQXR0cnM6IGdldFNlZ0FuY2hvckF0dHJzKHNlZywgY29udGV4dCksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCQxLCB0aW1lVGV4dDogdGltZVRleHQgfSksIChJbm5lckNvbnRlbnQsIGV2ZW50Q29udGVudEFyZykgPT4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLWV2ZW50LW1haW4nXSwgZWxTdHlsZTogeyBjb2xvcjogZXZlbnRDb250ZW50QXJnLnRleHRDb2xvciB9IH0pLFxuICAgICAgICAgICAgQm9vbGVhbihldmVudENvbnRlbnRBcmcuaXNTdGFydFJlc2l6YWJsZSkgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtcmVzaXplciBmYy1ldmVudC1yZXNpemVyLXN0YXJ0XCIgfSkpLFxuICAgICAgICAgICAgQm9vbGVhbihldmVudENvbnRlbnRBcmcuaXNFbmRSZXNpemFibGUpICYmIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1lbmRcIiB9KSkpKSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudCQxKGlubmVyUHJvcHMpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtbWFpbi1mcmFtZVwiIH0sXG4gICAgICAgIGlubmVyUHJvcHMudGltZVRleHQgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGltZVwiIH0sIGlubmVyUHJvcHMudGltZVRleHQpKSxcbiAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZS1jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZSBmYy1zdGlja3lcIiB9LCBpbm5lclByb3BzLmV2ZW50LnRpdGxlIHx8IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKSkpKSk7XG59XG5cbmNvbnN0IE5vd0luZGljYXRvckNvbnRhaW5lciA9IChwcm9wcykgPT4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICBpc0F4aXM6IHByb3BzLmlzQXhpcyxcbiAgICAgICAgZGF0ZTogY29udGV4dC5kYXRlRW52LnRvRGF0ZShwcm9wcy5kYXRlKSxcbiAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgIH07XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzIC8qIGluY2x1ZGVzIGNoaWxkcmVuICovLCB7IGVsVGFnOiBwcm9wcy5lbFRhZyB8fCAnZGl2JywgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcIm5vd0luZGljYXRvckNvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLm5vd0luZGljYXRvckNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5ub3dJbmRpY2F0b3JDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5ub3dJbmRpY2F0b3JEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yV2lsbFVubW91bnQgfSkpKTtcbn0pKTtcblxuY29uc3QgREFZX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyBkYXk6ICdudW1lcmljJyB9KTtcbmNsYXNzIERheUNlbGxDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZWZpbmVSZW5kZXJQcm9wcyA9IG1lbW9pemVPYmpBcmcocmVmaW5lUmVuZGVyUHJvcHMpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB0aGlzLnJlZmluZVJlbmRlclByb3BzKHtcbiAgICAgICAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLFxuICAgICAgICAgICAgaXNNb250aFN0YXJ0OiBwcm9wcy5pc01vbnRoU3RhcnQgfHwgZmFsc2UsXG4gICAgICAgICAgICBzaG93RGF5TnVtYmVyOiBwcm9wcy5zaG93RGF5TnVtYmVyLFxuICAgICAgICAgICAgZXh0cmFSZW5kZXJQcm9wczogcHJvcHMuZXh0cmFSZW5kZXJQcm9wcyxcbiAgICAgICAgICAgIHZpZXdBcGk6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIGRhdGVFbnY6IGNvbnRleHQuZGF0ZUVudixcbiAgICAgICAgICAgIG1vbnRoU3RhcnRGb3JtYXQ6IG9wdGlvbnMubW9udGhTdGFydEZvcm1hdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcyAvKiBpbmNsdWRlcyBjaGlsZHJlbiAqLywgeyBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAuLi5nZXREYXlDbGFzc05hbWVzKHJlbmRlclByb3BzLCBjb250ZXh0LnRoZW1lKSxcbiAgICAgICAgICAgICAgICAuLi4ocHJvcHMuZWxDbGFzc2VzIHx8IFtdKSxcbiAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZWxBdHRycyksIChyZW5kZXJQcm9wcy5pc0Rpc2FibGVkID8ge30gOiB7ICdkYXRhLWRhdGUnOiBmb3JtYXREYXlTdHJpbmcocHJvcHMuZGF0ZSkgfSkpLCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiZGF5Q2VsbENvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLmRheUNlbGxDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiBwcm9wcy5kZWZhdWx0R2VuZXJhdG9yLCBjbGFzc05hbWVHZW5lcmF0b3I6IFxuICAgICAgICAgICAgLy8gZG9uJ3QgdXNlIGN1c3RvbSBjbGFzc05hbWVzIGlmIGRpc2FibGVkXG4gICAgICAgICAgICByZW5kZXJQcm9wcy5pc0Rpc2FibGVkID8gdW5kZWZpbmVkIDogb3B0aW9ucy5kYXlDZWxsQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGF5Q2VsbERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlDZWxsV2lsbFVubW91bnQgfSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDdXN0b21EYXlDZWxsQ29udGVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4ob3B0aW9ucy5kYXlDZWxsQ29udGVudCB8fCBoYXNDdXN0b21SZW5kZXJpbmdIYW5kbGVyKCdkYXlDZWxsQ29udGVudCcsIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIHJlZmluZVJlbmRlclByb3BzKHJhdykge1xuICAgIGxldCB7IGRhdGUsIGRhdGVFbnYsIGRhdGVQcm9maWxlLCBpc01vbnRoU3RhcnQgfSA9IHJhdztcbiAgICBsZXQgZGF5TWV0YSA9IGdldERhdGVNZXRhKGRhdGUsIHJhdy50b2RheVJhbmdlLCBudWxsLCBkYXRlUHJvZmlsZSk7XG4gICAgbGV0IGRheU51bWJlclRleHQgPSByYXcuc2hvd0RheU51bWJlciA/IChkYXRlRW52LmZvcm1hdChkYXRlLCBpc01vbnRoU3RhcnQgPyByYXcubW9udGhTdGFydEZvcm1hdCA6IERBWV9OVU1fRk9STUFUKSkgOiAnJztcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSwgdmlldzogcmF3LnZpZXdBcGkgfSwgZGF5TWV0YSksIHsgaXNNb250aFN0YXJ0LFxuICAgICAgICBkYXlOdW1iZXJUZXh0IH0pLCByYXcuZXh0cmFSZW5kZXJQcm9wcyk7XG59XG5cbmNsYXNzIEJnRXZlbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBzZWcgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRXZlbnRDb250YWluZXIsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1iZy1ldmVudCddLCBlbFN0eWxlOiB7IGJhY2tncm91bmRDb2xvcjogc2VnLmV2ZW50UmFuZ2UudWkuYmFja2dyb3VuZENvbG9yIH0sIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCwgc2VnOiBzZWcsIHRpbWVUZXh0OiBcIlwiLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGZhbHNlLCBpc1Bhc3Q6IHByb3BzLmlzUGFzdCwgaXNGdXR1cmU6IHByb3BzLmlzRnV0dXJlLCBpc1RvZGF5OiBwcm9wcy5pc1RvZGF5LCBkaXNhYmxlRHJhZ2dpbmc6IHRydWUsIGRpc2FibGVSZXNpemluZzogdHJ1ZSB9KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzKSB7XG4gICAgbGV0IHsgdGl0bGUgfSA9IHByb3BzLmV2ZW50O1xuICAgIHJldHVybiB0aXRsZSAmJiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZVwiIH0sIHByb3BzLmV2ZW50LnRpdGxlKSk7XG59XG5mdW5jdGlvbiByZW5kZXJGaWxsKGZpbGxUeXBlKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBgZmMtJHtmaWxsVHlwZX1gIH0pKTtcbn1cblxuY29uc3QgV2Vla051bWJlckNvbnRhaW5lciA9IChwcm9wcykgPT4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xuICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHsgZGF0ZSB9ID0gcHJvcHM7XG4gICAgbGV0IGZvcm1hdCA9IG9wdGlvbnMud2Vla051bWJlckZvcm1hdCB8fCBwcm9wcy5kZWZhdWx0Rm9ybWF0O1xuICAgIGxldCBudW0gPSBkYXRlRW52LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUpOyAvLyBUT0RPOiBzb21laG93IHVzZSBmb3IgZm9ybWF0dGluZyBhcyB3ZWxsP1xuICAgIGxldCB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgZm9ybWF0KTtcbiAgICBsZXQgcmVuZGVyUHJvcHMgPSB7IG51bSwgdGV4dCwgZGF0ZSB9O1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyIC8vIHdoeSBpc24ndCBXZWVrTnVtYmVyQ29udGVudEFyZyBiZWluZyBhdXRvLWRldGVjdGVkP1xuICAgICwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMgLyogaW5jbHVkZXMgY2hpbGRyZW4gKi8sIHsgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcIndlZWtOdW1iZXJDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy53ZWVrTnVtYmVyQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy53ZWVrTnVtYmVyQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMud2Vla051bWJlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy53ZWVrTnVtYmVyV2lsbFVubW91bnQgfSkpKTtcbn0pKTtcbmZ1bmN0aW9uIHJlbmRlcklubmVyKGlubmVyUHJvcHMpIHtcbiAgICByZXR1cm4gaW5uZXJQcm9wcy50ZXh0O1xufVxuXG5jb25zdCBQQURESU5HX0ZST01fVklFV1BPUlQgPSAxMDtcbmNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHRpdGxlSWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvb3RFbCA9IGVsO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKmFueXdoZXJlKiBpbiB0aGUgZG9jdW1lbnQsIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZVxuICAgICAgICB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICAvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldik7XG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vdEVsLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlQ2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VDbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9uQ2xvc2UgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAob25DbG9zZSkge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyB0aGVtZSwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLXBvcG92ZXInLFxuICAgICAgICAgICAgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXInKSxcbiAgICAgICAgXS5jb25jYXQocHJvcHMuZXh0cmFDbGFzc05hbWVzIHx8IFtdKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLmV4dHJhQXR0cnMsIHsgaWQ6IHByb3BzLmlkLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBcImFyaWEtbGFiZWxsZWRieVwiOiBzdGF0ZS50aXRsZUlkLCByZWY6IHRoaXMuaGFuZGxlUm9vdEVsIH0pLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItaGVhZGVyICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckhlYWRlcicpIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiZmMtcG9wb3Zlci10aXRsZVwiLCBpZDogc3RhdGUudGl0bGVJZCB9LCBwcm9wcy50aXRsZSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWNsb3NlICcgKyB0aGVtZS5nZXRJY29uQ2xhc3MoJ2Nsb3NlJyksIHRpdGxlOiBvcHRpb25zLmNsb3NlSGludCwgb25DbGljazogdGhpcy5oYW5kbGVDbG9zZUNsaWNrIH0pKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy1wb3BvdmVyLWJvZHkgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyQ29udGVudCcpIH0sIHByb3BzLmNoaWxkcmVuKSksIHByb3BzLnBhcmVudEVsKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZURvd24pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24pO1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZURvd24pO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24pO1xuICAgIH1cbiAgICB1cGRhdGVTaXplKCkge1xuICAgICAgICBsZXQgeyBpc1J0bCB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBhbGlnbm1lbnRFbCwgYWxpZ25HcmlkVG9wIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyByb290RWwgfSA9IHRoaXM7XG4gICAgICAgIGxldCBhbGlnbm1lbnRSZWN0ID0gY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0KGFsaWdubWVudEVsKTtcbiAgICAgICAgaWYgKGFsaWdubWVudFJlY3QpIHtcbiAgICAgICAgICAgIGxldCBwb3BvdmVyRGltcyA9IHJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHZpZXdwb3J0XG4gICAgICAgICAgICBsZXQgcG9wb3ZlclRvcCA9IGFsaWduR3JpZFRvcFxuICAgICAgICAgICAgICAgID8gZWxlbWVudENsb3Nlc3QoYWxpZ25tZW50RWwsICcuZmMtc2Nyb2xsZ3JpZCcpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICAgICAgICAgICAgICAgIDogYWxpZ25tZW50UmVjdC50b3A7XG4gICAgICAgICAgICBsZXQgcG9wb3ZlckxlZnQgPSBpc1J0bCA/IGFsaWdubWVudFJlY3QucmlnaHQgLSBwb3BvdmVyRGltcy53aWR0aCA6IGFsaWdubWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpblxuICAgICAgICAgICAgcG9wb3ZlclRvcCA9IE1hdGgubWF4KHBvcG92ZXJUb3AsIFBBRERJTkdfRlJPTV9WSUVXUE9SVCk7XG4gICAgICAgICAgICBwb3BvdmVyTGVmdCA9IE1hdGgubWluKHBvcG92ZXJMZWZ0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLSBQQURESU5HX0ZST01fVklFV1BPUlQgLSBwb3BvdmVyRGltcy53aWR0aCk7XG4gICAgICAgICAgICBwb3BvdmVyTGVmdCA9IE1hdGgubWF4KHBvcG92ZXJMZWZ0LCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xuICAgICAgICAgICAgbGV0IG9yaWdpbiA9IHJvb3RFbC5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBhcHBseVN0eWxlKHJvb3RFbCwge1xuICAgICAgICAgICAgICAgIHRvcDogcG9wb3ZlclRvcCAtIG9yaWdpbi50b3AsXG4gICAgICAgICAgICAgICAgbGVmdDogcG9wb3ZlckxlZnQgLSBvcmlnaW4ubGVmdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBNb3JlUG9wb3ZlciBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhbmRsZVJvb3RFbCA9IChyb290RWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgICAgdXNlRXZlbnRDZW50ZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBvcHRpb25zLCBkYXRlRW52IH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBzdGFydERhdGUsIHRvZGF5UmFuZ2UsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IHRpdGxlID0gZGF0ZUVudi5mb3JtYXQoc3RhcnREYXRlLCBvcHRpb25zLmRheVBvcG92ZXJGb3JtYXQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwsIGRhdGU6IHN0YXJ0RGF0ZSwgZGF0ZVByb2ZpbGU6IGRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlIH0sIChJbm5lckNvbnRlbnQsIHJlbmRlclByb3BzLCBlbEF0dHJzKSA9PiAoY3JlYXRlRWxlbWVudChQb3BvdmVyLCB7IGVsUmVmOiBlbEF0dHJzLnJlZiwgaWQ6IHByb3BzLmlkLCB0aXRsZTogdGl0bGUsIGV4dHJhQ2xhc3NOYW1lczogWydmYy1tb3JlLXBvcG92ZXInXS5jb25jYXQoZWxBdHRycy5jbGFzc05hbWUgfHwgW10pLCBleHRyYUF0dHJzOiBlbEF0dHJzIC8qIFRPRE86IG1ha2UgdGhlc2UgdGltZS1iYXNlZCB3aGVuIG5vdCB3aG9sZS1kYXk/ICovLCBwYXJlbnRFbDogcHJvcHMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIG9uQ2xvc2U6IHByb3BzLm9uQ2xvc2UgfSxcbiAgICAgICAgICAgIGhhc0N1c3RvbURheUNlbGxDb250ZW50KG9wdGlvbnMpICYmIChjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBbJ2ZjLW1vcmUtcG9wb3Zlci1taXNjJ10gfSkpLFxuICAgICAgICAgICAgcHJvcHMuY2hpbGRyZW4pKSkpO1xuICAgIH1cbiAgICBxdWVyeUhpdChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xuICAgICAgICBsZXQgeyByb290RWwsIHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocG9zaXRpb25MZWZ0ID49IDAgJiYgcG9zaXRpb25MZWZ0IDwgZWxXaWR0aCAmJlxuICAgICAgICAgICAgcG9zaXRpb25Ub3AgPj0gMCAmJiBwb3NpdGlvblRvcCA8IGVsSGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgICAgICBkYXRlU3BhbjogT2JqZWN0LmFzc2lnbih7IGFsbERheTogIXByb3BzLmZvcmNlVGltZWQsIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJvcHMuc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBwcm9wcy5lbmREYXRlLFxuICAgICAgICAgICAgICAgICAgICB9IH0sIHByb3BzLmV4dHJhRGF0ZVNwYW4pLFxuICAgICAgICAgICAgICAgIGRheUVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBlbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBib3R0b206IGVsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5ZXI6IDEsIC8vIGltcG9ydGFudCB3aGVuIGNvbXBhcmluZyB3aXRoIGhpdHMgZnJvbSBvdGhlciBjb21wb25lbnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuY2xhc3MgTW9yZUxpbmtDb250YWluZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGlzUG9wb3Zlck9wZW46IGZhbHNlLFxuICAgICAgICAgICAgcG9wb3ZlcklkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUxpbmtFbCA9IChsaW5rRWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlua0VsID0gbGlua0VsO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYodGhpcy5wcm9wcy5lbFJlZiwgbGlua0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDbGljayA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgeyBtb3JlTGlua0NsaWNrIH0gPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgICAgICBsZXQgZGF0ZSA9IGNvbXB1dGVSYW5nZShwcm9wcykuc3RhcnQ7XG4gICAgICAgICAgICBmdW5jdGlvbiBidWlsZFB1YmxpY1NlZyhzZWcpIHtcbiAgICAgICAgICAgICAgICBsZXQgeyBkZWYsIGluc3RhbmNlLCByYW5nZSB9ID0gc2VnLmV2ZW50UmFuZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgZGVmLCBpbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHJhbmdlLnN0YXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnLmlzRW5kLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1vcmVMaW5rQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtb3JlTGlua0NsaWNrID0gbW9yZUxpbmtDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICAgICAgICAgIGFsbERheTogQm9vbGVhbihwcm9wcy5hbGxEYXlEYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgYWxsU2VnczogcHJvcHMuYWxsU2Vncy5tYXAoYnVpbGRQdWJsaWNTZWcpLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW5TZWdzOiBwcm9wcy5oaWRkZW5TZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1vcmVMaW5rQ2xpY2sgfHwgbW9yZUxpbmtDbGljayA9PT0gJ3BvcG92ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGlzUG9wb3Zlck9wZW46IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW9yZUxpbmtDbGljayA9PT0gJ3N0cmluZycpIHsgLy8gYSB2aWV3IG5hbWVcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnpvb21UbyhkYXRlLCBtb3JlTGlua0NsaWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3BvdmVyQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgaXNQb3BvdmVyT3BlbjogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgbGV0IHsgdmlld0FwaSwgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XG4gICAgICAgICAgICBsZXQgeyBtb3JlTGlua1RleHQgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBsZXQgeyBtb3JlQ250IH0gPSBwcm9wcztcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGNvbXB1dGVSYW5nZShwcm9wcyk7XG4gICAgICAgICAgICBsZXQgdGV4dCA9IHR5cGVvZiBtb3JlTGlua1RleHQgPT09ICdmdW5jdGlvbicgLy8gVE9ETzogZXZlbnR1YWxseSB1c2UgZm9ybWF0V2l0aE9yZGluYWxzXG4gICAgICAgICAgICAgICAgPyBtb3JlTGlua1RleHQuY2FsbChjYWxlbmRhckFwaSwgbW9yZUNudClcbiAgICAgICAgICAgICAgICA6IGArJHttb3JlQ250fSAke21vcmVMaW5rVGV4dH1gO1xuICAgICAgICAgICAgbGV0IGhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHMob3B0aW9ucy5tb3JlTGlua0hpbnQsIFttb3JlQ250XSwgdGV4dCk7XG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgbnVtOiBtb3JlQ250LFxuICAgICAgICAgICAgICAgIHNob3J0VGV4dDogYCske21vcmVDbnR9YCxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgIEJvb2xlYW4ocHJvcHMubW9yZUNudCkgJiYgKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogcHJvcHMuZWxUYWcgfHwgJ2EnLCBlbFJlZjogdGhpcy5oYW5kbGVMaW5rRWwsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHByb3BzLmVsQ2xhc3NlcyB8fCBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtbW9yZS1saW5rJyxcbiAgICAgICAgICAgICAgICAgICAgXSwgZWxTdHlsZTogcHJvcHMuZWxTdHlsZSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3BzLmVsQXR0cnMpLCBjcmVhdGVBcmlhQ2xpY2tBdHRycyh0aGlzLmhhbmRsZUNsaWNrKSksIHsgdGl0bGU6IGhpbnQsICdhcmlhLWV4cGFuZGVkJzogc3RhdGUuaXNQb3BvdmVyT3BlbiwgJ2FyaWEtY29udHJvbHMnOiBzdGF0ZS5pc1BvcG92ZXJPcGVuID8gc3RhdGUucG9wb3ZlcklkIDogJycgfSksIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJtb3JlTGlua0NvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLm1vcmVMaW5rQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcHJvcHMuZGVmYXVsdEdlbmVyYXRvciB8fCByZW5kZXJNb3JlTGlua0lubmVyLCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMubW9yZUxpbmtDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5tb3JlTGlua0RpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5tb3JlTGlua1dpbGxVbm1vdW50IH0sIHByb3BzLmNoaWxkcmVuKSksXG4gICAgICAgICAgICAgICAgc3RhdGUuaXNQb3BvdmVyT3BlbiAmJiAoY3JlYXRlRWxlbWVudChNb3JlUG9wb3ZlciwgeyBpZDogc3RhdGUucG9wb3ZlcklkLCBzdGFydERhdGU6IHJhbmdlLnN0YXJ0LCBlbmREYXRlOiByYW5nZS5lbmQsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgZXh0cmFEYXRlU3BhbjogcHJvcHMuZXh0cmFEYXRlU3BhbiwgcGFyZW50RWw6IHRoaXMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbFJlZiA/XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wcy5hbGlnbm1lbnRFbFJlZi5jdXJyZW50IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlua0VsLCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgZm9yY2VUaW1lZDogcHJvcHMuZm9yY2VUaW1lZCwgb25DbG9zZTogdGhpcy5oYW5kbGVQb3BvdmVyQ2xvc2UgfSwgcHJvcHMucG9wb3ZlckNvbnRlbnQoKSkpKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUGFyZW50RWwoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudEVsKCk7XG4gICAgfVxuICAgIHVwZGF0ZVBhcmVudEVsKCkge1xuICAgICAgICBpZiAodGhpcy5saW5rRWwpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RWwgPSBlbGVtZW50Q2xvc2VzdCh0aGlzLmxpbmtFbCwgJy5mYy12aWV3LWhhcm5lc3MnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbmRlck1vcmVMaW5rSW5uZXIocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSYW5nZShwcm9wcykge1xuICAgIGlmIChwcm9wcy5hbGxEYXlEYXRlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogcHJvcHMuYWxsRGF5RGF0ZSxcbiAgICAgICAgICAgIGVuZDogYWRkRGF5cyhwcm9wcy5hbGxEYXlEYXRlLCAxKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHsgaGlkZGVuU2VncyB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KGhpZGRlblNlZ3MpLFxuICAgICAgICBlbmQ6IGNvbXB1dGVMYXRlc3RTZWdFbmQoaGlkZGVuU2VncyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0KHNlZ3MpIHtcbiAgICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0VhcmxpZXN0U3RhcnQpLmV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQ7XG59XG5mdW5jdGlvbiBwaWNrRWFybGllc3RTdGFydChzZWcwLCBzZWcxKSB7XG4gICAgcmV0dXJuIHNlZzAuZXZlbnRSYW5nZS5yYW5nZS5zdGFydCA8IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5zdGFydCA/IHNlZzAgOiBzZWcxO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxhdGVzdFNlZ0VuZChzZWdzKSB7XG4gICAgcmV0dXJuIHNlZ3MucmVkdWNlKHBpY2tMYXRlc3RFbmQpLmV2ZW50UmFuZ2UucmFuZ2UuZW5kO1xufVxuZnVuY3Rpb24gcGlja0xhdGVzdEVuZChzZWcwLCBzZWcxKSB7XG4gICAgcmV0dXJuIHNlZzAuZXZlbnRSYW5nZS5yYW5nZS5lbmQgPiBzZWcxLmV2ZW50UmFuZ2UucmFuZ2UuZW5kID8gc2VnMCA6IHNlZzE7XG59XG5cbmNsYXNzIFN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZm9yIChsZXQgaGFuZGxlciBvZiB0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYW5kbGVyKHRoaXMuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLypcblN1YnNjcmliZXJzIHdpbGwgZ2V0IGEgTElTVCBvZiBDdXN0b21SZW5kZXJpbmdzXG4qL1xuY2xhc3MgQ3VzdG9tUmVuZGVyaW5nU3RvcmUgZXh0ZW5kcyBTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvLyBmb3IgY29uc2lzdGVudCBvcmRlclxuICAgIGhhbmRsZShjdXN0b21SZW5kZXJpbmcpIHtcbiAgICAgICAgY29uc3QgeyBtYXAgfSA9IHRoaXM7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChjdXN0b21SZW5kZXJpbmcuaXNBY3RpdmUpIHtcbiAgICAgICAgICAgIG1hcC5zZXQoY3VzdG9tUmVuZGVyaW5nLmlkLCBjdXN0b21SZW5kZXJpbmcpO1xuICAgICAgICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFwLmhhcyhjdXN0b21SZW5kZXJpbmcuaWQpKSB7XG4gICAgICAgICAgICBtYXAuZGVsZXRlKGN1c3RvbVJlbmRlcmluZy5pZCk7XG4gICAgICAgICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlZCkge1xuICAgICAgICAgICAgdGhpcy5zZXQobWFwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgZWxlbWVudENsb3Nlc3QgYXMgJCwgbWVtb2l6ZU9iakFyZyBhcyBBLCBCYXNlQ29tcG9uZW50IGFzIEIsIENvbnRlbnRDb250YWluZXIgYXMgQywgRGVsYXllZFJ1bm5lciBhcyBELCBpc1Byb3BzRXF1YWwgYXMgRSwgRW1pdHRlciBhcyBGLCBnZXRJbml0aWFsRGF0ZSBhcyBHLCByYW5nZUNvbnRhaW5zTWFya2VyIGFzIEgsIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSBhcyBJLCByZWR1Y2VDdXJyZW50RGF0ZSBhcyBKLCByZWR1Y2VFdmVudFN0b3JlIGFzIEssIHJlem9uZUV2ZW50U3RvcmVEYXRlcyBhcyBMLCBtZXJnZVJhd09wdGlvbnMgYXMgTSwgQkFTRV9PUFRJT05fUkVGSU5FUlMgYXMgTiwgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMgYXMgTywgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTIGFzIFAsIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTIGFzIFEsIFZJRVdfT1BUSU9OX1JFRklORVJTIGFzIFIsIERhdGVFbnYgYXMgUywgVGhlbWUgYXMgVCwgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgYXMgVSwgVmlld0NvbnRleHRUeXBlIGFzIFYsIGNyZWF0ZUV2ZW50VWkgYXMgVywgcGFyc2VCdXNpbmVzc0hvdXJzIGFzIFgsIHNldFJlZiBhcyBZLCBJbnRlcmFjdGlvbiBhcyBaLCBnZXRFbFNlZyBhcyBfLCBtYXBIYXNoIGFzIGEsIGdldFNsb3RDbGFzc05hbWVzIGFzIGEkLCBFdmVudEltcGwgYXMgYTAsIGxpc3RlbkJ5U2VsZWN0b3IgYXMgYTEsIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yIGFzIGEyLCBQdXJlQ29tcG9uZW50IGFzIGEzLCBidWlsZFZpZXdDb250ZXh0IGFzIGE0LCBnZXRVbmlxdWVEb21JZCBhcyBhNSwgcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzIGFzIGE2LCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgYXMgYTcsIGdldE5vdyBhcyBhOCwgQ2FsZW5kYXJJbXBsIGFzIGE5LCBkaWZmRGF0ZXMgYXMgYUEsIHJlbW92ZUV4YWN0IGFzIGFCLCBtZW1vaXplQXJyYXlsaWtlIGFzIGFDLCBtZW1vaXplSGFzaGxpa2UgYXMgYUQsIGludGVyc2VjdFJlY3RzIGFzIGFFLCBwb2ludEluc2lkZVJlY3QgYXMgYUYsIGNvbnN0cmFpblBvaW50IGFzIGFHLCBnZXRSZWN0Q2VudGVyIGFzIGFILCBkaWZmUG9pbnRzIGFzIGFJLCB0cmFuc2xhdGVSZWN0IGFzIGFKLCBjb21wYXJlT2JqcyBhcyBhSywgY29sbGVjdEZyb21IYXNoIGFzIGFMLCBmaW5kRWxlbWVudHMgYXMgYU0sIGZpbmREaXJlY3RDaGlsZHJlbiBhcyBhTiwgcmVtb3ZlRWxlbWVudCBhcyBhTywgYXBwbHlTdHlsZSBhcyBhUCwgZWxlbWVudE1hdGNoZXMgYXMgYVEsIGdldEV2ZW50VGFyZ2V0VmlhUm9vdCBhcyBhUiwgcGFyc2VDbGFzc05hbWVzIGFzIGFTLCBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgYXMgYVQsIG1lcmdlRXZlbnRTdG9yZXMgYXMgYVUsIGdldFJlbGV2YW50RXZlbnRzIGFzIGFWLCBldmVudFR1cGxlVG9TdG9yZSBhcyBhVywgY29tYmluZUV2ZW50VWlzIGFzIGFYLCBTcGxpdHRlciBhcyBhWSwgZ2V0RGF5Q2xhc3NOYW1lcyBhcyBhWiwgZ2V0RGF0ZU1ldGEgYXMgYV8sIGZsdXNoU3luYyBhcyBhYSwgQ2FsZW5kYXJSb290IGFzIGFiLCBSZW5kZXJJZCBhcyBhYywgZW5zdXJlRWxIYXNTdHlsZXMgYXMgYWQsIGFwcGx5U3R5bGVQcm9wIGFzIGFlLCBzbGljZUV2ZW50U3RvcmUgYXMgYWYsIEpzb25SZXF1ZXN0RXJyb3IgYXMgYWcsIGNyZWF0ZUNvbnRleHQgYXMgYWgsIHJlZmluZVByb3BzIGFzIGFpLCBjcmVhdGVFdmVudEluc3RhbmNlIGFzIGFqLCBwYXJzZUV2ZW50RGVmIGFzIGFrLCByZWZpbmVFdmVudERlZiBhcyBhbCwgcGFkU3RhcnQgYXMgYW0sIGlzSW50IGFzIGFuLCBwYXJzZUZpZWxkU3BlY3MgYXMgYW8sIGNvbXBhcmVCeUZpZWxkU3BlY3MgYXMgYXAsIGZsZXhpYmxlQ29tcGFyZSBhcyBhcSwgcHJldmVudFNlbGVjdGlvbiBhcyBhciwgYWxsb3dTZWxlY3Rpb24gYXMgYXMsIHByZXZlbnRDb250ZXh0TWVudSBhcyBhdCwgYWxsb3dDb250ZXh0TWVudSBhcyBhdSwgY29tcGFyZU51bWJlcnMgYXMgYXYsIGVuYWJsZUN1cnNvciBhcyBhdywgZGlzYWJsZUN1cnNvciBhcyBheCwgY29tcHV0ZVZpc2libGVEYXlSYW5nZSBhcyBheSwgaXNNdWx0aURheVJhbmdlIGFzIGF6LCBidWlsZFZpZXdDbGFzc05hbWVzIGFzIGIsIFNpbXBsZVNjcm9sbEdyaWQgYXMgYiQsIGJ1aWxkTmF2TGlua0F0dHJzIGFzIGIwLCBwcmV2ZW50RGVmYXVsdCBhcyBiMSwgd2hlblRyYW5zaXRpb25Eb25lIGFzIGIyLCBjb21wdXRlSW5uZXJSZWN0IGFzIGIzLCBjb21wdXRlRWRnZXMgYXMgYjQsIGdldENsaXBwaW5nUGFyZW50cyBhcyBiNSwgY29tcHV0ZVJlY3QgYXMgYjYsIHJhbmdlc0VxdWFsIGFzIGI3LCByYW5nZXNJbnRlcnNlY3QgYXMgYjgsIHJhbmdlQ29udGFpbnNSYW5nZSBhcyBiOSwgU2VnSGllcmFyY2h5IGFzIGJBLCBidWlsZEVudHJ5S2V5IGFzIGJCLCBnZXRFbnRyeVNwYW5FbmQgYXMgYkMsIGJpbmFyeVNlYXJjaCBhcyBiRCwgZ3JvdXBJbnRlcnNlY3RpbmdFbnRyaWVzIGFzIGJFLCBpbnRlcnNlY3RTcGFucyBhcyBiRiwgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUgYXMgYkcsIEVsZW1lbnREcmFnZ2luZyBhcyBiSCwgY29uZmlnIGFzIGJJLCBwYXJzZURyYWdNZXRhIGFzIGJKLCBEYXlIZWFkZXIgYXMgYkssIGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCBhcyBiTCwgVGFibGVEYXRlQ2VsbCBhcyBiTSwgVGFibGVEb3dDZWxsIGFzIGJOLCBEYXlTZXJpZXNNb2RlbCBhcyBiTywgaGFzQmdSZW5kZXJpbmcgYXMgYlAsIGJ1aWxkU2VnVGltZVRleHQgYXMgYlEsIHNvcnRFdmVudFNlZ3MgYXMgYlIsIGdldFNlZ01ldGEgYXMgYlMsIGJ1aWxkRXZlbnRSYW5nZUtleSBhcyBiVCwgZ2V0U2VnQW5jaG9yQXR0cnMgYXMgYlUsIERheVRhYmxlTW9kZWwgYXMgYlYsIFNsaWNlciBhcyBiVywgYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSBhcyBiWCwgaXNQcm9wc1ZhbGlkIGFzIGJZLCBpc0ludGVyYWN0aW9uVmFsaWQgYXMgYlosIGlzRGF0ZVNlbGVjdGlvblZhbGlkIGFzIGJfLCBQb3NpdGlvbkNhY2hlIGFzIGJhLCBTY3JvbGxDb250cm9sbGVyIGFzIGJiLCBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciBhcyBiYywgV2luZG93U2Nyb2xsQ29udHJvbGxlciBhcyBiZCwgRGF0ZUNvbXBvbmVudCBhcyBiZSwgaXNEYXRlU3BhbnNFcXVhbCBhcyBiZiwgYWRkTXMgYXMgYmcsIGFkZFdlZWtzIGFzIGJoLCBkaWZmV2Vla3MgYXMgYmksIGRpZmZXaG9sZVdlZWtzIGFzIGJqLCBkaWZmRGF5QW5kVGltZSBhcyBiaywgZGlmZkRheXMgYXMgYmwsIGlzVmFsaWREYXRlIGFzIGJtLCBhc0NsZWFuRGF5cyBhcyBibiwgbXVsdGlwbHlEdXJhdGlvbiBhcyBibywgYWRkRHVyYXRpb25zIGFzIGJwLCBhc1JvdWdoTWludXRlcyBhcyBicSwgYXNSb3VnaFNlY29uZHMgYXMgYnIsIGFzUm91Z2hNcyBhcyBicywgd2hvbGVEaXZpZGVEdXJhdGlvbnMgYXMgYnQsIGZvcm1hdElzb1RpbWVTdHJpbmcgYXMgYnUsIGZvcm1hdERheVN0cmluZyBhcyBidiwgYnVpbGRJc29TdHJpbmcgYXMgYncsIGZvcm1hdElzb01vbnRoU3RyIGFzIGJ4LCBOYW1lZFRpbWVab25lSW1wbCBhcyBieSwgcGFyc2UgYXMgYnosIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvciBhcyBjLCBoYXNTaHJpbmtXaWR0aCBhcyBjMCwgcmVuZGVyTWljcm9Db2xHcm91cCBhcyBjMSwgZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMgYXMgYzIsIGdldFNlY3Rpb25DbGFzc05hbWVzIGFzIGMzLCBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0IGFzIGM0LCBnZXRBbGxvd1lTY3JvbGxpbmcgYXMgYzUsIHJlbmRlckNodW5rQ29udGVudCBhcyBjNiwgY29tcHV0ZVNocmlua1dpZHRoIGFzIGM3LCBzYW5pdGl6ZVNocmlua1dpZHRoIGFzIGM4LCBpc0NvbFByb3BzRXF1YWwgYXMgYzksIHJlbmRlclNjcm9sbFNoaW0gYXMgY2EsIGdldFN0aWNreUZvb3RlclNjcm9sbGJhciBhcyBjYiwgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMgYXMgY2MsIFNjcm9sbGVyIGFzIGNkLCBnZXRTY3JvbGxiYXJXaWR0aHMgYXMgY2UsIFJlZk1hcCBhcyBjZiwgZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQgYXMgY2csIE5vd1RpbWVyIGFzIGNoLCBTY3JvbGxSZXNwb25kZXIgYXMgY2ksIFN0YW5kYXJkRXZlbnQgYXMgY2osIE5vd0luZGljYXRvckNvbnRhaW5lciBhcyBjaywgRGF5Q2VsbENvbnRhaW5lciBhcyBjbCwgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQgYXMgY20sIEV2ZW50Q29udGFpbmVyIGFzIGNuLCByZW5kZXJGaWxsIGFzIGNvLCBCZ0V2ZW50IGFzIGNwLCBXZWVrTnVtYmVyQ29udGFpbmVyIGFzIGNxLCBNb3JlTGlua0NvbnRhaW5lciBhcyBjciwgY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQgYXMgY3MsIFZpZXdDb250YWluZXIgYXMgY3QsIHRyaWdnZXJEYXRlU2VsZWN0IGFzIGN1LCBnZXREZWZhdWx0RXZlbnRFbmQgYXMgY3YsIGluamVjdFN0eWxlcyBhcyBjdywgYnVpbGRFbEF0dHJzIGFzIGN4LCBDdXN0b21SZW5kZXJpbmdTdG9yZSBhcyBjeSwgY3JlYXRlRHVyYXRpb24gYXMgZCwgQkFTRV9PUFRJT05fREVGQVVMVFMgYXMgZSwgYXJyYXlUb0hhc2ggYXMgZiwgZ3VpZCBhcyBnLCBmaWx0ZXJIYXNoIGFzIGgsIGlzQXJyYXlzRXF1YWwgYXMgaSwgYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzIGFzIGosIGZvcm1hdFdpdGhPcmRpbmFscyBhcyBrLCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lIGFzIGwsIG1lcmdlUHJvcHMgYXMgbSwgaWRlbnRpdHkgYXMgbiwgaW50ZXJzZWN0UmFuZ2VzIGFzIG8sIHBhcnNlRXZlbnRTb3VyY2UgYXMgcCwgc3RhcnRPZkRheSBhcyBxLCByZXF1ZXN0SnNvbiBhcyByLCBzdWJ0cmFjdER1cmF0aW9ucyBhcyBzLCBhZGREYXlzIGFzIHQsIHVucHJvbWlzaWZ5IGFzIHUsIGhhc2hWYWx1ZXNUb0FycmF5IGFzIHYsIGJ1aWxkRXZlbnRBcGlzIGFzIHcsIGNyZWF0ZUZvcm1hdHRlciBhcyB4LCBkaWZmV2hvbGVEYXlzIGFzIHksIG1lbW9pemUgYXMgeiB9O1xuIiwgImltcG9ydCB7IG0gYXMgbWVyZ2VQcm9wcywgZyBhcyBndWlkLCBpIGFzIGlzQXJyYXlzRXF1YWwsIFQgYXMgVGhlbWUsIGEgYXMgbWFwSGFzaCwgQiBhcyBCYXNlQ29tcG9uZW50LCBWIGFzIFZpZXdDb250ZXh0VHlwZSwgQyBhcyBDb250ZW50Q29udGFpbmVyLCBiIGFzIGJ1aWxkVmlld0NsYXNzTmFtZXMsIGMgYXMgZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yLCBkIGFzIGNyZWF0ZUR1cmF0aW9uLCBlIGFzIEJBU0VfT1BUSU9OX0RFRkFVTFRTLCBmIGFzIGFycmF5VG9IYXNoLCBoIGFzIGZpbHRlckhhc2gsIGogYXMgYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzLCBwIGFzIHBhcnNlRXZlbnRTb3VyY2UsIGsgYXMgZm9ybWF0V2l0aE9yZGluYWxzLCB1IGFzIHVucHJvbWlzaWZ5LCBsIGFzIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUsIG4gYXMgaWRlbnRpdHksIHIgYXMgcmVxdWVzdEpzb24sIHMgYXMgc3VidHJhY3REdXJhdGlvbnMsIG8gYXMgaW50ZXJzZWN0UmFuZ2VzLCBxIGFzIHN0YXJ0T2ZEYXksIHQgYXMgYWRkRGF5cywgdiBhcyBoYXNoVmFsdWVzVG9BcnJheSwgdyBhcyBidWlsZEV2ZW50QXBpcywgRCBhcyBEZWxheWVkUnVubmVyLCB4IGFzIGNyZWF0ZUZvcm1hdHRlciwgeSBhcyBkaWZmV2hvbGVEYXlzLCB6IGFzIG1lbW9pemUsIEEgYXMgbWVtb2l6ZU9iakFyZywgRSBhcyBpc1Byb3BzRXF1YWwsIEYgYXMgRW1pdHRlciwgRyBhcyBnZXRJbml0aWFsRGF0ZSwgSCBhcyByYW5nZUNvbnRhaW5zTWFya2VyLCBJIGFzIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSwgSiBhcyByZWR1Y2VDdXJyZW50RGF0ZSwgSyBhcyByZWR1Y2VFdmVudFN0b3JlLCBMIGFzIHJlem9uZUV2ZW50U3RvcmVEYXRlcywgTSBhcyBtZXJnZVJhd09wdGlvbnMsIE4gYXMgQkFTRV9PUFRJT05fUkVGSU5FUlMsIE8gYXMgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMsIFAgYXMgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTLCBRIGFzIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTLCBSIGFzIFZJRVdfT1BUSU9OX1JFRklORVJTLCBTIGFzIERhdGVFbnYsIFUgYXMgRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIFcgYXMgY3JlYXRlRXZlbnRVaSwgWCBhcyBwYXJzZUJ1c2luZXNzSG91cnMsIFkgYXMgc2V0UmVmLCBaIGFzIEludGVyYWN0aW9uLCBfIGFzIGdldEVsU2VnLCAkIGFzIGVsZW1lbnRDbG9zZXN0LCBhMCBhcyBFdmVudEltcGwsIGExIGFzIGxpc3RlbkJ5U2VsZWN0b3IsIGEyIGFzIGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yLCBhMyBhcyBQdXJlQ29tcG9uZW50LCBhNCBhcyBidWlsZFZpZXdDb250ZXh0LCBhNSBhcyBnZXRVbmlxdWVEb21JZCwgYTYgYXMgcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzLCBhNyBhcyBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUsIGE4IGFzIGdldE5vdywgYTkgYXMgQ2FsZW5kYXJJbXBsLCBhYSBhcyBmbHVzaFN5bmMsIGFiIGFzIENhbGVuZGFyUm9vdCwgYWMgYXMgUmVuZGVySWQsIGFkIGFzIGVuc3VyZUVsSGFzU3R5bGVzLCBhZSBhcyBhcHBseVN0eWxlUHJvcCwgYWYgYXMgc2xpY2VFdmVudFN0b3JlIH0gZnJvbSAnLi9pbnRlcm5hbC1jb21tb24uanMnO1xuZXhwb3J0IHsgYWcgYXMgSnNvblJlcXVlc3RFcnJvciB9IGZyb20gJy4vaW50ZXJuYWwtY29tbW9uLmpzJztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIGNyZWF0ZVJlZiwgRnJhZ21lbnQsIHJlbmRlciB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgJ3ByZWFjdC9jb21wYXQnO1xuXG5jb25zdCBnbG9iYWxMb2NhbGVzID0gW107XG5cbmNvbnN0IE1JTklNQUxfUkFXX0VOX0xPQ0FMRSA9IHtcbiAgICBjb2RlOiAnZW4nLFxuICAgIHdlZWs6IHtcbiAgICAgICAgZG93OiAwLFxuICAgICAgICBkb3k6IDQsIC8vIDQgZGF5cyBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgeWVhciB0byBiZSBjb25zaWRlcmVkIHRoZSBmaXJzdCB3ZWVrXG4gICAgfSxcbiAgICBkaXJlY3Rpb246ICdsdHInLFxuICAgIGJ1dHRvblRleHQ6IHtcbiAgICAgICAgcHJldjogJ3ByZXYnLFxuICAgICAgICBuZXh0OiAnbmV4dCcsXG4gICAgICAgIHByZXZZZWFyOiAncHJldiB5ZWFyJyxcbiAgICAgICAgbmV4dFllYXI6ICduZXh0IHllYXInLFxuICAgICAgICB5ZWFyOiAneWVhcicsXG4gICAgICAgIHRvZGF5OiAndG9kYXknLFxuICAgICAgICBtb250aDogJ21vbnRoJyxcbiAgICAgICAgd2VlazogJ3dlZWsnLFxuICAgICAgICBkYXk6ICdkYXknLFxuICAgICAgICBsaXN0OiAnbGlzdCcsXG4gICAgfSxcbiAgICB3ZWVrVGV4dDogJ1cnLFxuICAgIHdlZWtUZXh0TG9uZzogJ1dlZWsnLFxuICAgIGNsb3NlSGludDogJ0Nsb3NlJyxcbiAgICB0aW1lSGludDogJ1RpbWUnLFxuICAgIGV2ZW50SGludDogJ0V2ZW50JyxcbiAgICBhbGxEYXlUZXh0OiAnYWxsLWRheScsXG4gICAgbW9yZUxpbmtUZXh0OiAnbW9yZScsXG4gICAgbm9FdmVudHNUZXh0OiAnTm8gZXZlbnRzIHRvIGRpc3BsYXknLFxufTtcbmNvbnN0IFJBV19FTl9MT0NBTEUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIE1JTklNQUxfUkFXX0VOX0xPQ0FMRSksIHsgXG4gICAgLy8gSW5jbHVkZXMgdGhpbmdzIHdlIGRvbid0IHdhbnQgb3RoZXIgbG9jYWxlcyB0byBpbmhlcml0LFxuICAgIC8vIHRoaW5ncyB0aGF0IGRlcml2ZSBmcm9tIG90aGVyIHRyYW5zbGF0YWJsZSBzdHJpbmdzLlxuICAgIGJ1dHRvbkhpbnRzOiB7XG4gICAgICAgIHByZXY6ICdQcmV2aW91cyAkMCcsXG4gICAgICAgIG5leHQ6ICdOZXh0ICQwJyxcbiAgICAgICAgdG9kYXkoYnV0dG9uVGV4dCwgdW5pdCkge1xuICAgICAgICAgICAgcmV0dXJuICh1bml0ID09PSAnZGF5JylcbiAgICAgICAgICAgICAgICA/ICdUb2RheSdcbiAgICAgICAgICAgICAgICA6IGBUaGlzICR7YnV0dG9uVGV4dH1gO1xuICAgICAgICB9LFxuICAgIH0sIHZpZXdIaW50OiAnJDAgdmlldycsIG5hdkxpbmtIaW50OiAnR28gdG8gJDAnLCBtb3JlTGlua0hpbnQoZXZlbnRDbnQpIHtcbiAgICAgICAgcmV0dXJuIGBTaG93ICR7ZXZlbnRDbnR9IG1vcmUgZXZlbnQke2V2ZW50Q250ID09PSAxID8gJycgOiAncyd9YDtcbiAgICB9IH0pO1xuZnVuY3Rpb24gb3JnYW5pemVSYXdMb2NhbGVzKGV4cGxpY2l0UmF3TG9jYWxlcykge1xuICAgIGxldCBkZWZhdWx0Q29kZSA9IGV4cGxpY2l0UmF3TG9jYWxlcy5sZW5ndGggPiAwID8gZXhwbGljaXRSYXdMb2NhbGVzWzBdLmNvZGUgOiAnZW4nO1xuICAgIGxldCBhbGxSYXdMb2NhbGVzID0gZ2xvYmFsTG9jYWxlcy5jb25jYXQoZXhwbGljaXRSYXdMb2NhbGVzKTtcbiAgICBsZXQgcmF3TG9jYWxlTWFwID0ge1xuICAgICAgICBlbjogUkFXX0VOX0xPQ0FMRSxcbiAgICB9O1xuICAgIGZvciAobGV0IHJhd0xvY2FsZSBvZiBhbGxSYXdMb2NhbGVzKSB7XG4gICAgICAgIHJhd0xvY2FsZU1hcFtyYXdMb2NhbGUuY29kZV0gPSByYXdMb2NhbGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1hcDogcmF3TG9jYWxlTWFwLFxuICAgICAgICBkZWZhdWx0Q29kZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dFNpbmd1bGFyID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbnB1dFNpbmd1bGFyKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VMb2NhbGUoaW5wdXRTaW5ndWxhci5jb2RlLCBbaW5wdXRTaW5ndWxhci5jb2RlXSwgaW5wdXRTaW5ndWxhcik7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeUxvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpO1xufVxuZnVuY3Rpb24gcXVlcnlMb2NhbGUoY29kZUFyZywgYXZhaWxhYmxlKSB7XG4gICAgbGV0IGNvZGVzID0gW10uY29uY2F0KGNvZGVBcmcgfHwgW10pOyAvLyB3aWxsIGNvbnZlcnQgdG8gYXJyYXlcbiAgICBsZXQgcmF3ID0gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkgfHwgUkFXX0VOX0xPQ0FMRTtcbiAgICByZXR1cm4gcGFyc2VMb2NhbGUoY29kZUFyZywgY29kZXMsIHJhdyk7XG59XG5mdW5jdGlvbiBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgcGFydHMgPSBjb2Rlc1tpXS50b0xvY2FsZUxvd2VyQ2FzZSgpLnNwbGl0KCctJyk7XG4gICAgICAgIGZvciAobGV0IGogPSBwYXJ0cy5sZW5ndGg7IGogPiAwOyBqIC09IDEpIHtcbiAgICAgICAgICAgIGxldCBzaW1wbGVJZCA9IHBhcnRzLnNsaWNlKDAsIGopLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIGlmIChhdmFpbGFibGVbc2ltcGxlSWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVtzaW1wbGVJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KSB7XG4gICAgbGV0IG1lcmdlZCA9IG1lcmdlUHJvcHMoW01JTklNQUxfUkFXX0VOX0xPQ0FMRSwgcmF3XSwgWydidXR0b25UZXh0J10pO1xuICAgIGRlbGV0ZSBtZXJnZWQuY29kZTsgLy8gZG9uJ3Qgd2FudCB0aGlzIHBhcnQgb2YgdGhlIG9wdGlvbnNcbiAgICBsZXQgeyB3ZWVrIH0gPSBtZXJnZWQ7XG4gICAgZGVsZXRlIG1lcmdlZC53ZWVrO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVBcmcsXG4gICAgICAgIGNvZGVzLFxuICAgICAgICB3ZWVrLFxuICAgICAgICBzaW1wbGVOdW1iZXJGb3JtYXQ6IG5ldyBJbnRsLk51bWJlckZvcm1hdChjb2RlQXJnKSxcbiAgICAgICAgb3B0aW9uczogbWVyZ2VkLFxuICAgIH07XG59XG5cbi8vIFRPRE86IGVhc2llciB3YXkgdG8gYWRkIG5ldyBob29rcz8gbmVlZCB0byB1cGRhdGUgYSBtaWxsaW9uIHRoaW5nc1xuZnVuY3Rpb24gY3JlYXRlUGx1Z2luKGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGd1aWQoKSxcbiAgICAgICAgbmFtZTogaW5wdXQubmFtZSxcbiAgICAgICAgcHJlbWl1bVJlbGVhc2VEYXRlOiBpbnB1dC5wcmVtaXVtUmVsZWFzZURhdGUgPyBuZXcgRGF0ZShpbnB1dC5wcmVtaXVtUmVsZWFzZURhdGUpIDogdW5kZWZpbmVkLFxuICAgICAgICBkZXBzOiBpbnB1dC5kZXBzIHx8IFtdLFxuICAgICAgICByZWR1Y2VyczogaW5wdXQucmVkdWNlcnMgfHwgW10sXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBpbnB1dC5pc0xvYWRpbmdGdW5jcyB8fCBbXSxcbiAgICAgICAgY29udGV4dEluaXQ6IFtdLmNvbmNhdChpbnB1dC5jb250ZXh0SW5pdCB8fCBbXSksXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IGlucHV0LmV2ZW50UmVmaW5lcnMgfHwge30sXG4gICAgICAgIGV2ZW50RGVmTWVtYmVyQWRkZXJzOiBpbnB1dC5ldmVudERlZk1lbWJlckFkZGVycyB8fCBbXSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogaW5wdXQuZXZlbnRTb3VyY2VSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IGlucHV0LmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaW5wdXQuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMgfHwgW10sXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogaW5wdXQuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzIHx8IFtdLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBpbnB1dC5kYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBpbnB1dC5kYXRlUG9pbnRUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGlucHV0LmRhdGVTcGFuVHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgdmlld3M6IGlucHV0LnZpZXdzIHx8IHt9LFxuICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGlucHV0LnZpZXdQcm9wc1RyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgaXNQcm9wc1ZhbGlkOiBpbnB1dC5pc1Byb3BzVmFsaWQgfHwgbnVsbCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBpbnB1dC5leHRlcm5hbERlZlRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBpbnB1dC52aWV3Q29udGFpbmVyQXBwZW5kcyB8fCBbXSxcbiAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBpbnB1dC5ldmVudERyb3BUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGNvbXBvbmVudEludGVyYWN0aW9uczogaW5wdXQuY29tcG9uZW50SW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaW5wdXQuY2FsZW5kYXJJbnRlcmFjdGlvbnMgfHwgW10sXG4gICAgICAgIHRoZW1lQ2xhc3NlczogaW5wdXQudGhlbWVDbGFzc2VzIHx8IHt9LFxuICAgICAgICBldmVudFNvdXJjZURlZnM6IGlucHV0LmV2ZW50U291cmNlRGVmcyB8fCBbXSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBpbnB1dC5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBpbnB1dC5yZWN1cnJpbmdUeXBlcyB8fCBbXSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBpbnB1dC5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgICAgIGluaXRpYWxWaWV3OiBpbnB1dC5pbml0aWFsVmlldyB8fCAnJyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaW5wdXQuZWxlbWVudERyYWdnaW5nSW1wbCxcbiAgICAgICAgb3B0aW9uQ2hhbmdlSGFuZGxlcnM6IGlucHV0Lm9wdGlvbkNoYW5nZUhhbmRsZXJzIHx8IHt9LFxuICAgICAgICBzY3JvbGxHcmlkSW1wbDogaW5wdXQuc2Nyb2xsR3JpZEltcGwgfHwgbnVsbCxcbiAgICAgICAgbGlzdGVuZXJSZWZpbmVyczogaW5wdXQubGlzdGVuZXJSZWZpbmVycyB8fCB7fSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IGlucHV0Lm9wdGlvblJlZmluZXJzIHx8IHt9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IGlucHV0LnByb3BTZXRIYW5kbGVycyB8fCB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRQbHVnaW5Ib29rcyhwbHVnaW5EZWZzLCBnbG9iYWxEZWZzKSB7XG4gICAgbGV0IGN1cnJlbnRQbHVnaW5JZHMgPSB7fTtcbiAgICBsZXQgaG9va3MgPSB7XG4gICAgICAgIHByZW1pdW1SZWxlYXNlRGF0ZTogdW5kZWZpbmVkLFxuICAgICAgICByZWR1Y2VyczogW10sXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXSxcbiAgICAgICAgY29udGV4dEluaXQ6IFtdLFxuICAgICAgICBldmVudFJlZmluZXJzOiB7fSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IFtdLFxuICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiB7fSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogW10sXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogW10sXG4gICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgdmlld3M6IHt9LFxuICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBpc1Byb3BzVmFsaWQ6IG51bGwsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogW10sXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBbXSxcbiAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBbXSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtdLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IHt9LFxuICAgICAgICBldmVudFNvdXJjZURlZnM6IFtdLFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IG51bGwsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBbXSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBudWxsLFxuICAgICAgICBpbml0aWFsVmlldzogJycsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IG51bGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7fSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IG51bGwsXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IHt9LFxuICAgICAgICBvcHRpb25SZWZpbmVyczoge30sXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczoge30sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBhZGREZWZzKGRlZnMpIHtcbiAgICAgICAgZm9yIChsZXQgZGVmIG9mIGRlZnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpbk5hbWUgPSBkZWYubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJZCA9IGN1cnJlbnRQbHVnaW5JZHNbcGx1Z2luTmFtZV07XG4gICAgICAgICAgICBpZiAoY3VycmVudElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGx1Z2luSWRzW3BsdWdpbk5hbWVdID0gZGVmLmlkO1xuICAgICAgICAgICAgICAgIGFkZERlZnMoZGVmLmRlcHMpO1xuICAgICAgICAgICAgICAgIGhvb2tzID0gY29tYmluZUhvb2tzKGhvb2tzLCBkZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudElkICE9PSBkZWYuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbnQgSUQgdGhhbiB0aGUgb25lIGFscmVhZHkgYWRkZWRcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYER1cGxpY2F0ZSBwbHVnaW4gJyR7cGx1Z2luTmFtZX0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBsdWdpbkRlZnMpIHtcbiAgICAgICAgYWRkRGVmcyhwbHVnaW5EZWZzKTtcbiAgICB9XG4gICAgYWRkRGVmcyhnbG9iYWxEZWZzKTtcbiAgICByZXR1cm4gaG9va3M7XG59XG5mdW5jdGlvbiBidWlsZEJ1aWxkUGx1Z2luSG9va3MoKSB7XG4gICAgbGV0IGN1cnJlbnRPdmVycmlkZURlZnMgPSBbXTtcbiAgICBsZXQgY3VycmVudEdsb2JhbERlZnMgPSBbXTtcbiAgICBsZXQgY3VycmVudEhvb2tzO1xuICAgIHJldHVybiAob3ZlcnJpZGVEZWZzLCBnbG9iYWxEZWZzKSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudEhvb2tzIHx8ICFpc0FycmF5c0VxdWFsKG92ZXJyaWRlRGVmcywgY3VycmVudE92ZXJyaWRlRGVmcykgfHwgIWlzQXJyYXlzRXF1YWwoZ2xvYmFsRGVmcywgY3VycmVudEdsb2JhbERlZnMpKSB7XG4gICAgICAgICAgICBjdXJyZW50SG9va3MgPSBidWlsZFBsdWdpbkhvb2tzKG92ZXJyaWRlRGVmcywgZ2xvYmFsRGVmcyk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudE92ZXJyaWRlRGVmcyA9IG92ZXJyaWRlRGVmcztcbiAgICAgICAgY3VycmVudEdsb2JhbERlZnMgPSBnbG9iYWxEZWZzO1xuICAgICAgICByZXR1cm4gY3VycmVudEhvb2tzO1xuICAgIH07XG59XG5mdW5jdGlvbiBjb21iaW5lSG9va3MoaG9va3MwLCBob29rczEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmVtaXVtUmVsZWFzZURhdGU6IGNvbXBhcmVPcHRpb25hbERhdGVzKGhvb2tzMC5wcmVtaXVtUmVsZWFzZURhdGUsIGhvb2tzMS5wcmVtaXVtUmVsZWFzZURhdGUpLFxuICAgICAgICByZWR1Y2VyczogaG9va3MwLnJlZHVjZXJzLmNvbmNhdChob29rczEucmVkdWNlcnMpLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogaG9va3MwLmlzTG9hZGluZ0Z1bmNzLmNvbmNhdChob29rczEuaXNMb2FkaW5nRnVuY3MpLFxuICAgICAgICBjb250ZXh0SW5pdDogaG9va3MwLmNvbnRleHRJbml0LmNvbmNhdChob29rczEuY29udGV4dEluaXQpLFxuICAgICAgICBldmVudFJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5ldmVudFJlZmluZXJzKSwgaG9va3MxLmV2ZW50UmVmaW5lcnMpLFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaG9va3MwLmV2ZW50RGVmTWVtYmVyQWRkZXJzLmNvbmNhdChob29rczEuZXZlbnREZWZNZW1iZXJBZGRlcnMpLFxuICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5ldmVudFNvdXJjZVJlZmluZXJzKSwgaG9va3MxLmV2ZW50U291cmNlUmVmaW5lcnMpLFxuICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogaG9va3MwLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMpLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaG9va3MwLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzLmNvbmNhdChob29rczEuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMpLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGhvb2tzMC5ldmVudERlZk11dGF0aW9uQXBwbGllcnMuY29uY2F0KGhvb2tzMS5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBob29rczAuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBob29rczAuZGF0ZVBvaW50VHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVQb2ludFRyYW5zZm9ybXMpLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlU3BhblRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlU3BhblRyYW5zZm9ybXMpLFxuICAgICAgICB2aWV3czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAudmlld3MpLCBob29rczEudmlld3MpLFxuICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IGhvb2tzMC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS52aWV3UHJvcHNUcmFuc2Zvcm1lcnMpLFxuICAgICAgICBpc1Byb3BzVmFsaWQ6IGhvb2tzMS5pc1Byb3BzVmFsaWQgfHwgaG9va3MwLmlzUHJvcHNWYWxpZCxcbiAgICAgICAgZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zOiBob29rczAuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zLmNvbmNhdChob29rczEuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zKSxcbiAgICAgICAgdmlld0NvbnRhaW5lckFwcGVuZHM6IGhvb2tzMC52aWV3Q29udGFpbmVyQXBwZW5kcy5jb25jYXQoaG9va3MxLnZpZXdDb250YWluZXJBcHBlbmRzKSxcbiAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBob29rczAuZXZlbnREcm9wVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuZXZlbnREcm9wVHJhbnNmb3JtZXJzKSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGhvb2tzMC5jYWxlbmRhckludGVyYWN0aW9ucy5jb25jYXQoaG9va3MxLmNhbGVuZGFySW50ZXJhY3Rpb25zKSxcbiAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBob29rczAuY29tcG9uZW50SW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY29tcG9uZW50SW50ZXJhY3Rpb25zKSxcbiAgICAgICAgdGhlbWVDbGFzc2VzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC50aGVtZUNsYXNzZXMpLCBob29rczEudGhlbWVDbGFzc2VzKSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBob29rczAuZXZlbnRTb3VyY2VEZWZzLmNvbmNhdChob29rczEuZXZlbnRTb3VyY2VEZWZzKSxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBob29rczEuY21kRm9ybWF0dGVyIHx8IGhvb2tzMC5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBob29rczAucmVjdXJyaW5nVHlwZXMuY29uY2F0KGhvb2tzMS5yZWN1cnJpbmdUeXBlcyksXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaG9va3MxLm5hbWVkVGltZVpvbmVkSW1wbCB8fCBob29rczAubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBpbml0aWFsVmlldzogaG9va3MwLmluaXRpYWxWaWV3IHx8IGhvb2tzMS5pbml0aWFsVmlldyxcbiAgICAgICAgZWxlbWVudERyYWdnaW5nSW1wbDogaG9va3MwLmVsZW1lbnREcmFnZ2luZ0ltcGwgfHwgaG9va3MxLmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25DaGFuZ2VIYW5kbGVycyksIGhvb2tzMS5vcHRpb25DaGFuZ2VIYW5kbGVycyksXG4gICAgICAgIHNjcm9sbEdyaWRJbXBsOiBob29rczEuc2Nyb2xsR3JpZEltcGwgfHwgaG9va3MwLnNjcm9sbEdyaWRJbXBsLFxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhvb2tzMC5saXN0ZW5lclJlZmluZXJzKSwgaG9va3MxLmxpc3RlbmVyUmVmaW5lcnMpLFxuICAgICAgICBvcHRpb25SZWZpbmVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBob29rczAub3B0aW9uUmVmaW5lcnMpLCBob29rczEub3B0aW9uUmVmaW5lcnMpLFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaG9va3MwLnByb3BTZXRIYW5kbGVycyksIGhvb2tzMS5wcm9wU2V0SGFuZGxlcnMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21wYXJlT3B0aW9uYWxEYXRlcyhkYXRlMCwgZGF0ZTEpIHtcbiAgICBpZiAoZGF0ZTAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZGF0ZTE7XG4gICAgfVxuICAgIGlmIChkYXRlMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBkYXRlMDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRlKE1hdGgubWF4KGRhdGUwLnZhbHVlT2YoKSwgZGF0ZTEudmFsdWVPZigpKSk7XG59XG5cbmNsYXNzIFN0YW5kYXJkVGhlbWUgZXh0ZW5kcyBUaGVtZSB7XG59XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge1xuICAgIHJvb3Q6ICdmYy10aGVtZS1zdGFuZGFyZCcsXG4gICAgdGFibGVDZWxsU2hhZGVkOiAnZmMtY2VsbC1zaGFkZWQnLFxuICAgIGJ1dHRvbkdyb3VwOiAnZmMtYnV0dG9uLWdyb3VwJyxcbiAgICBidXR0b246ICdmYy1idXR0b24gZmMtYnV0dG9uLXByaW1hcnknLFxuICAgIGJ1dHRvbkFjdGl2ZTogJ2ZjLWJ1dHRvbi1hY3RpdmUnLFxufTtcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnZmMtaWNvbic7XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHtcbiAgICBjbG9zZTogJ2ZjLWljb24teCcsXG4gICAgcHJldjogJ2ZjLWljb24tY2hldnJvbi1sZWZ0JyxcbiAgICBuZXh0OiAnZmMtaWNvbi1jaGV2cm9uLXJpZ2h0JyxcbiAgICBwcmV2WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtbGVmdCcsXG4gICAgbmV4dFllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0Jyxcbn07XG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5ydGxJY29uQ2xhc3NlcyA9IHtcbiAgICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLXJpZ2h0JyxcbiAgICBuZXh0OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxuICAgIHByZXZZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1yaWdodCcsXG4gICAgbmV4dFllYXI6ICdmYy1pY29uLWNoZXZyb25zLWxlZnQnLFxufTtcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICdidXR0b25JY29ucyc7IC8vIFRPRE86IG1ha2UgVFMtZnJpZW5kbHlcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdpY29uJztcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZVByZWZpeCA9ICdmYy1pY29uLSc7XG5cbmZ1bmN0aW9uIGNvbXBpbGVWaWV3RGVmcyhkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgbGV0IGhhc2ggPSB7fTtcbiAgICBsZXQgdmlld1R5cGU7XG4gICAgZm9yICh2aWV3VHlwZSBpbiBkZWZhdWx0Q29uZmlncykge1xuICAgICAgICBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICB9XG4gICAgZm9yICh2aWV3VHlwZSBpbiBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICAgICAgZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufVxuZnVuY3Rpb24gZW5zdXJlVmlld0RlZih2aWV3VHlwZSwgaGFzaCwgZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncykge1xuICAgIGlmIChoYXNoW3ZpZXdUeXBlXSkge1xuICAgICAgICByZXR1cm4gaGFzaFt2aWV3VHlwZV07XG4gICAgfVxuICAgIGxldCB2aWV3RGVmID0gYnVpbGRWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICBpZiAodmlld0RlZikge1xuICAgICAgICBoYXNoW3ZpZXdUeXBlXSA9IHZpZXdEZWY7XG4gICAgfVxuICAgIHJldHVybiB2aWV3RGVmO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgbGV0IGRlZmF1bHRDb25maWcgPSBkZWZhdWx0Q29uZmlnc1t2aWV3VHlwZV07XG4gICAgbGV0IG92ZXJyaWRlQ29uZmlnID0gb3ZlcnJpZGVDb25maWdzW3ZpZXdUeXBlXTtcbiAgICBsZXQgcXVlcnlQcm9wID0gKG5hbWUpID0+ICgoZGVmYXVsdENvbmZpZyAmJiBkZWZhdWx0Q29uZmlnW25hbWVdICE9PSBudWxsKSA/IGRlZmF1bHRDb25maWdbbmFtZV0gOlxuICAgICAgICAoKG92ZXJyaWRlQ29uZmlnICYmIG92ZXJyaWRlQ29uZmlnW25hbWVdICE9PSBudWxsKSA/IG92ZXJyaWRlQ29uZmlnW25hbWVdIDogbnVsbCkpO1xuICAgIGxldCB0aGVDb21wb25lbnQgPSBxdWVyeVByb3AoJ2NvbXBvbmVudCcpO1xuICAgIGxldCBzdXBlclR5cGUgPSBxdWVyeVByb3AoJ3N1cGVyVHlwZScpO1xuICAgIGxldCBzdXBlckRlZiA9IG51bGw7XG4gICAgaWYgKHN1cGVyVHlwZSkge1xuICAgICAgICBpZiAoc3VwZXJUeXBlID09PSB2aWV3VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGhhdmUgYSBjdXN0b20gdmlldyB0eXBlIHRoYXQgcmVmZXJlbmNlcyBpdHNlbGYnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlckRlZiA9IGVuc3VyZVZpZXdEZWYoc3VwZXJUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICB9XG4gICAgaWYgKCF0aGVDb21wb25lbnQgJiYgc3VwZXJEZWYpIHtcbiAgICAgICAgdGhlQ29tcG9uZW50ID0gc3VwZXJEZWYuY29tcG9uZW50O1xuICAgIH1cbiAgICBpZiAoIXRoZUNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdGhyb3cgYSB3YXJuaW5nLCBtaWdodCBiZSBzZXR0aW5ncyBmb3IgYSBzaW5nbGUtdW5pdCB2aWV3XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHZpZXdUeXBlLFxuICAgICAgICBjb21wb25lbnQ6IHRoZUNvbXBvbmVudCxcbiAgICAgICAgZGVmYXVsdHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKHN1cGVyRGVmID8gc3VwZXJEZWYuZGVmYXVsdHMgOiB7fSkpLCAoZGVmYXVsdENvbmZpZyA/IGRlZmF1bHRDb25maWcucmF3T3B0aW9ucyA6IHt9KSksXG4gICAgICAgIG92ZXJyaWRlczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoc3VwZXJEZWYgPyBzdXBlckRlZi5vdmVycmlkZXMgOiB7fSkpLCAob3ZlcnJpZGVDb25maWcgPyBvdmVycmlkZUNvbmZpZy5yYXdPcHRpb25zIDoge30pKSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWdzKGlucHV0cykge1xuICAgIHJldHVybiBtYXBIYXNoKGlucHV0cywgcGFyc2VWaWV3Q29uZmlnKTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmlld0NvbmZpZyhpbnB1dCkge1xuICAgIGxldCByYXdPcHRpb25zID0gdHlwZW9mIGlucHV0ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgeyBjb21wb25lbnQ6IGlucHV0IH0gOlxuICAgICAgICBpbnB1dDtcbiAgICBsZXQgeyBjb21wb25lbnQgfSA9IHJhd09wdGlvbnM7XG4gICAgaWYgKHJhd09wdGlvbnMuY29udGVudCkge1xuICAgICAgICAvLyBUT0RPOiByZW1vdmUgY29udGVudC9jbGFzc05hbWVzL2RpZE1vdW50L2V0YyBmcm9tIG9wdGlvbnM/XG4gICAgICAgIGNvbXBvbmVudCA9IGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KHJhd09wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb21wb25lbnQgJiYgIShjb21wb25lbnQucHJvdG90eXBlIGluc3RhbmNlb2YgQmFzZUNvbXBvbmVudCkpIHtcbiAgICAgICAgLy8gV0hZPzogcGVvcGxlIHdlcmUgdXNpbmcgYGNvbXBvbmVudGAgcHJvcGVydHkgZm9yIGBjb250ZW50YFxuICAgICAgICAvLyBUT0RPOiBjb252ZXJnZSBvbiBvbmUgc2V0dGluZyBuYW1lXG4gICAgICAgIGNvbXBvbmVudCA9IGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmF3T3B0aW9ucyksIHsgY29udGVudDogY29tcG9uZW50IH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VwZXJUeXBlOiByYXdPcHRpb25zLnR5cGUsXG4gICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICByYXdPcHRpb25zLCAvLyBpbmNsdWRlcyB0eXBlIGFuZCBjb21wb25lbnQgdG9vIDooXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZpZXdIb29rQ29tcG9uZW50KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKHZpZXdQcm9wcykgPT4gKGNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLkNvbnN1bWVyLCBudWxsLCAoY29udGV4dCkgPT4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJkaXZcIiwgZWxDbGFzc2VzOiBidWlsZFZpZXdDbGFzc05hbWVzKGNvbnRleHQudmlld1NwZWMpLCByZW5kZXJQcm9wczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpLCB7IG5leHREYXlUaHJlc2hvbGQ6IGNvbnRleHQub3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkIH0pLCBnZW5lcmF0b3JOYW1lOiB1bmRlZmluZWQsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5jb250ZW50LCBjbGFzc05hbWVHZW5lcmF0b3I6IG9wdGlvbnMuY2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMuZGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLndpbGxVbm1vdW50IH0pKSkpO1xufVxuXG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjcyhkZWZhdWx0SW5wdXRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSB7XG4gICAgbGV0IGRlZmF1bHRDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhkZWZhdWx0SW5wdXRzKTtcbiAgICBsZXQgb3ZlcnJpZGVDb25maWdzID0gcGFyc2VWaWV3Q29uZmlncyhvcHRpb25PdmVycmlkZXMudmlld3MpO1xuICAgIGxldCB2aWV3RGVmcyA9IGNvbXBpbGVWaWV3RGVmcyhkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICByZXR1cm4gbWFwSGFzaCh2aWV3RGVmcywgKHZpZXdEZWYpID0+IGJ1aWxkVmlld1NwZWModmlld0RlZiwgb3ZlcnJpZGVDb25maWdzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKSk7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykge1xuICAgIGxldCBkdXJhdGlvbklucHV0ID0gdmlld0RlZi5vdmVycmlkZXMuZHVyYXRpb24gfHxcbiAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5kdXJhdGlvbiB8fFxuICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgICAgIG9wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbjtcbiAgICBsZXQgZHVyYXRpb24gPSBudWxsO1xuICAgIGxldCBkdXJhdGlvblVuaXQgPSAnJztcbiAgICBsZXQgc2luZ2xlVW5pdCA9ICcnO1xuICAgIGxldCBzaW5nbGVVbml0T3ZlcnJpZGVzID0ge307XG4gICAgaWYgKGR1cmF0aW9uSW5wdXQpIHtcbiAgICAgICAgZHVyYXRpb24gPSBjcmVhdGVEdXJhdGlvbkNhY2hlZChkdXJhdGlvbklucHV0KTtcbiAgICAgICAgaWYgKGR1cmF0aW9uKSB7IC8vIHZhbGlkP1xuICAgICAgICAgICAgbGV0IGRlbm9tID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGR1cmF0aW9uVW5pdCA9IGRlbm9tLnVuaXQ7XG4gICAgICAgICAgICBpZiAoZGVub20udmFsdWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBzaW5nbGVVbml0ID0gZHVyYXRpb25Vbml0O1xuICAgICAgICAgICAgICAgIHNpbmdsZVVuaXRPdmVycmlkZXMgPSBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XSA/IG92ZXJyaWRlQ29uZmlnc1tkdXJhdGlvblVuaXRdLnJhd09wdGlvbnMgOiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcXVlcnlCdXR0b25UZXh0ID0gKG9wdGlvbnNTdWJzZXQpID0+IHtcbiAgICAgICAgbGV0IGJ1dHRvblRleHRNYXAgPSBvcHRpb25zU3Vic2V0LmJ1dHRvblRleHQgfHwge307XG4gICAgICAgIGxldCBidXR0b25UZXh0S2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5O1xuICAgICAgICBpZiAoYnV0dG9uVGV4dEtleSAhPSBudWxsICYmIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbYnV0dG9uVGV4dEtleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFt2aWV3RGVmLnR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW3NpbmdsZVVuaXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgbGV0IHF1ZXJ5QnV0dG9uVGl0bGUgPSAob3B0aW9uc1N1YnNldCkgPT4ge1xuICAgICAgICBsZXQgYnV0dG9uSGludHMgPSBvcHRpb25zU3Vic2V0LmJ1dHRvbkhpbnRzIHx8IHt9O1xuICAgICAgICBsZXQgYnV0dG9uS2V5ID0gdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0S2V5OyAvLyB1c2Ugc2FtZSBrZXkgYXMgdGV4dFxuICAgICAgICBpZiAoYnV0dG9uS2V5ICE9IG51bGwgJiYgYnV0dG9uSGludHNbYnV0dG9uS2V5XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbYnV0dG9uS2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uSGludHNbdmlld0RlZi50eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uSGludHNbdmlld0RlZi50eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uSGludHNbc2luZ2xlVW5pdF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW3NpbmdsZVVuaXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdmlld0RlZi50eXBlLFxuICAgICAgICBjb21wb25lbnQ6IHZpZXdEZWYuY29tcG9uZW50LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZHVyYXRpb25Vbml0LFxuICAgICAgICBzaW5nbGVVbml0LFxuICAgICAgICBvcHRpb25EZWZhdWx0czogdmlld0RlZi5kZWZhdWx0cyxcbiAgICAgICAgb3B0aW9uT3ZlcnJpZGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNpbmdsZVVuaXRPdmVycmlkZXMpLCB2aWV3RGVmLm92ZXJyaWRlcyksXG4gICAgICAgIGJ1dHRvblRleHRPdmVycmlkZTogcXVlcnlCdXR0b25UZXh0KGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uT3ZlcnJpZGVzKSB8fCAvLyBjb25zdHJ1Y3Rvci1zcGVjaWZpZWQgYnV0dG9uVGV4dCBsb29rdXAgaGFzaCB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICAgICAgICB2aWV3RGVmLm92ZXJyaWRlcy5idXR0b25UZXh0LFxuICAgICAgICBidXR0b25UZXh0RGVmYXVsdDogcXVlcnlCdXR0b25UZXh0KGxvY2FsZURlZmF1bHRzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0IHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQoQkFTRV9PUFRJT05fREVGQVVMVFMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLnR5cGUsXG4gICAgICAgIC8vIG5vdCBEUllcbiAgICAgICAgYnV0dG9uVGl0bGVPdmVycmlkZTogcXVlcnlCdXR0b25UaXRsZShkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UaXRsZShvcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLm92ZXJyaWRlcy5idXR0b25IaW50LFxuICAgICAgICBidXR0b25UaXRsZURlZmF1bHQ6IHF1ZXJ5QnV0dG9uVGl0bGUobG9jYWxlRGVmYXVsdHMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvbkhpbnQgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGl0bGUoQkFTRV9PUFRJT05fREVGQVVMVFMpLFxuICAgICAgICAvLyB3aWxsIGV2ZW50dWFsbHkgZmFsbCBiYWNrIHRvIGJ1dHRvblRleHRcbiAgICB9O1xufVxuLy8gaGFjayB0byBnZXQgbWVtb2l6YXRpb24gd29ya2luZ1xubGV0IGR1cmF0aW9uSW5wdXRNYXAgPSB7fTtcbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uQ2FjaGVkKGR1cmF0aW9uSW5wdXQpIHtcbiAgICBsZXQganNvbiA9IEpTT04uc3RyaW5naWZ5KGR1cmF0aW9uSW5wdXQpO1xuICAgIGxldCByZXMgPSBkdXJhdGlvbklucHV0TWFwW2pzb25dO1xuICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMgPSBjcmVhdGVEdXJhdGlvbihkdXJhdGlvbklucHV0KTtcbiAgICAgICAgZHVyYXRpb25JbnB1dE1hcFtqc29uXSA9IHJlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcmVkdWNlVmlld1R5cGUodmlld1R5cGUsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICB2aWV3VHlwZSA9IGFjdGlvbi52aWV3VHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdUeXBlO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGFjdGlvbikge1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnU0VUX09QVElPTic6XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSwgeyBbYWN0aW9uLm9wdGlvbk5hbWVdOiBhY3Rpb24ucmF3T3B0aW9uVmFsdWUgfSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pY09wdGlvbk92ZXJyaWRlcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURhdGVQcm9maWxlKGN1cnJlbnREYXRlUHJvZmlsZSwgYWN0aW9uLCBjdXJyZW50RGF0ZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICBsZXQgZHA7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlciB8fCBjdXJyZW50RGF0ZSk7XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgICAgIHJldHVybiBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChhY3Rpb24uZGF0ZU1hcmtlcik7XG4gICAgICAgIGNhc2UgJ1BSRVYnOlxuICAgICAgICAgICAgZHAgPSBkYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZFByZXYoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSk7XG4gICAgICAgICAgICBpZiAoZHAuaXNWYWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdORVhUJzpcbiAgICAgICAgICAgIGRwID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnREYXRlUHJvZmlsZTtcbn1cblxuZnVuY3Rpb24gaW5pdEV2ZW50U291cmNlcyhjYWxlbmRhck9wdGlvbnMsIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgbGV0IGFjdGl2ZVJhbmdlID0gZGF0ZVByb2ZpbGUgPyBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSA6IG51bGw7XG4gICAgcmV0dXJuIGFkZFNvdXJjZXMoe30sIHBhcnNlSW5pdGlhbFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aW9uLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdBRERfRVZFTlRfU09VUkNFUyc6IC8vIGFscmVhZHkgcGFyc2VkXG4gICAgICAgICAgICByZXR1cm4gYWRkU291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnOlxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVNvdXJjZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCk7XG4gICAgICAgIGNhc2UgJ1BSRVYnOiAvLyBUT0RPOiBob3cgZG8gd2UgdHJhY2sgYWxsIGFjdGlvbnMgdGhhdCBhZmZlY3QgZGF0ZVByb2ZpbGUgOihcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9EQVRFJzpcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hEaXJ0eVNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xuICAgICAgICBjYXNlICdGRVRDSF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZHMgPyAvLyB3aHkgbm8gdHlwZT9cbiAgICAgICAgICAgICAgICBhcnJheVRvSGFzaChhY3Rpb24uc291cmNlSWRzKSA6XG4gICAgICAgICAgICAgICAgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIGFjdGlvbi5pc1JlZmV0Y2ggfHwgZmFsc2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UUyc6XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRfRVJST1InOlxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVSZXNwb25zZShldmVudFNvdXJjZXMsIGFjdGlvbi5zb3VyY2VJZCwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlKTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVF9TT1VSQ0VTJzpcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBldmVudFNvdXJjZXM7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTb3VyY2VzTmV3VGltZVpvbmUoZXZlbnRTb3VyY2VzLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIGxldCBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsOyAvLyBuZWVkIHRoaXMgY2hlY2s/XG4gICAgcmV0dXJuIGZldGNoU291cmNlc0J5SWRzKGV2ZW50U291cmNlcywgZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSwgYWN0aXZlUmFuZ2UsIHRydWUsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUV2ZW50U291cmNlc0xvYWRpbmcoZXZlbnRTb3VyY2VzKSB7XG4gICAgZm9yIChsZXQgc291cmNlSWQgaW4gZXZlbnRTb3VyY2VzKSB7XG4gICAgICAgIGlmIChldmVudFNvdXJjZXNbc291cmNlSWRdLmlzRmV0Y2hpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VzLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgbGV0IGhhc2ggPSB7fTtcbiAgICBmb3IgKGxldCBzb3VyY2Ugb2Ygc291cmNlcykge1xuICAgICAgICBoYXNoW3NvdXJjZS5zb3VyY2VJZF0gPSBzb3VyY2U7XG4gICAgfVxuICAgIGlmIChmZXRjaFJhbmdlKSB7XG4gICAgICAgIGhhc2ggPSBmZXRjaERpcnR5U291cmNlcyhoYXNoLCBmZXRjaFJhbmdlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRTb3VyY2VIYXNoKSwgaGFzaCk7XG59XG5mdW5jdGlvbiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VIYXNoLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlSGFzaCwgKGV2ZW50U291cmNlKSA9PiBldmVudFNvdXJjZS5zb3VyY2VJZCAhPT0gc291cmNlSWQpO1xufVxuZnVuY3Rpb24gZmV0Y2hEaXJ0eVNvdXJjZXMoc291cmNlSGFzaCwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhzb3VyY2VIYXNoLCBmaWx0ZXJIYXNoKHNvdXJjZUhhc2gsIChldmVudFNvdXJjZSkgPT4gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCkpLCBmZXRjaFJhbmdlLCBmYWxzZSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1NvdXJjZURpcnR5KGV2ZW50U291cmNlLCBmZXRjaFJhbmdlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gIWV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQ7XG4gICAgfVxuICAgIHJldHVybiAhY29udGV4dC5vcHRpb25zLmxhenlGZXRjaGluZyB8fFxuICAgICAgICAhZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZSB8fFxuICAgICAgICBldmVudFNvdXJjZS5pc0ZldGNoaW5nIHx8IC8vIGFsd2F5cyBjYW5jZWwgb3V0ZGF0ZWQgaW4tcHJvZ3Jlc3MgZmV0Y2hlc1xuICAgICAgICBmZXRjaFJhbmdlLnN0YXJ0IDwgZXZlbnRTb3VyY2UuZmV0Y2hSYW5nZS5zdGFydCB8fFxuICAgICAgICBmZXRjaFJhbmdlLmVuZCA+IGV2ZW50U291cmNlLmZldGNoUmFuZ2UuZW5kO1xufVxuZnVuY3Rpb24gZmV0Y2hTb3VyY2VzQnlJZHMocHJldlNvdXJjZXMsIHNvdXJjZUlkSGFzaCwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgbGV0IG5leHRTb3VyY2VzID0ge307XG4gICAgZm9yIChsZXQgc291cmNlSWQgaW4gcHJldlNvdXJjZXMpIHtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHByZXZTb3VyY2VzW3NvdXJjZUlkXTtcbiAgICAgICAgaWYgKHNvdXJjZUlkSGFzaFtzb3VyY2VJZF0pIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IGZldGNoU291cmNlKHNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHRTb3VyY2VzW3NvdXJjZUlkXSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV4dFNvdXJjZXM7XG59XG5mdW5jdGlvbiBmZXRjaFNvdXJjZShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgaXNSZWZldGNoLCBjb250ZXh0KSB7XG4gICAgbGV0IHsgb3B0aW9ucywgY2FsZW5kYXJBcGkgfSA9IGNvbnRleHQ7XG4gICAgbGV0IHNvdXJjZURlZiA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXTtcbiAgICBsZXQgZmV0Y2hJZCA9IGd1aWQoKTtcbiAgICBzb3VyY2VEZWYuZmV0Y2goe1xuICAgICAgICBldmVudFNvdXJjZSxcbiAgICAgICAgcmFuZ2U6IGZldGNoUmFuZ2UsXG4gICAgICAgIGlzUmVmZXRjaCxcbiAgICAgICAgY29udGV4dCxcbiAgICB9LCAocmVzKSA9PiB7XG4gICAgICAgIGxldCB7IHJhd0V2ZW50cyB9ID0gcmVzO1xuICAgICAgICBpZiAob3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnJlc3BvbnNlKSB8fCByYXdFdmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50U291cmNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IGV2ZW50U291cmNlLnN1Y2Nlc3MuY2FsbChjYWxlbmRhckFwaSwgcmF3RXZlbnRzLCByZXMucmVzcG9uc2UpIHx8IHJhd0V2ZW50cztcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRUNFSVZFX0VWRU5UUycsXG4gICAgICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgICAgICBmZXRjaElkLFxuICAgICAgICAgICAgZmV0Y2hSYW5nZSxcbiAgICAgICAgICAgIHJhd0V2ZW50cyxcbiAgICAgICAgfSk7XG4gICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgIGxldCBlcnJvckhhbmRsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnRTb3VyY2VGYWlsdXJlKSB7XG4gICAgICAgICAgICBvcHRpb25zLmV2ZW50U291cmNlRmFpbHVyZS5jYWxsKGNhbGVuZGFyQXBpLCBlcnJvcik7XG4gICAgICAgICAgICBlcnJvckhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFNvdXJjZS5mYWlsdXJlKSB7XG4gICAgICAgICAgICBldmVudFNvdXJjZS5mYWlsdXJlKGVycm9yKTtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlcnJvckhhbmRsZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVF9FUlJPUicsXG4gICAgICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgICAgICBmZXRjaElkLFxuICAgICAgICAgICAgZmV0Y2hSYW5nZSxcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFNvdXJjZSksIHsgaXNGZXRjaGluZzogdHJ1ZSwgbGF0ZXN0RmV0Y2hJZDogZmV0Y2hJZCB9KTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVSZXNwb25zZShzb3VyY2VIYXNoLCBzb3VyY2VJZCwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSkge1xuICAgIGxldCBldmVudFNvdXJjZSA9IHNvdXJjZUhhc2hbc291cmNlSWRdO1xuICAgIGlmIChldmVudFNvdXJjZSAmJiAvLyBub3QgYWxyZWFkeSByZW1vdmVkXG4gICAgICAgIGZldGNoSWQgPT09IGV2ZW50U291cmNlLmxhdGVzdEZldGNoSWQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc291cmNlSGFzaCksIHsgW3NvdXJjZUlkXTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFNvdXJjZSksIHsgaXNGZXRjaGluZzogZmFsc2UsIGZldGNoUmFuZ2UgfSkgfSk7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VIYXNoO1xufVxuZnVuY3Rpb24gZXhjbHVkZVN0YXRpY1NvdXJjZXMoZXZlbnRTb3VyY2VzLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZpbHRlckhhc2goZXZlbnRTb3VyY2VzLCAoZXZlbnRTb3VyY2UpID0+IGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSW5pdGlhbFNvdXJjZXMocmF3T3B0aW9ucywgY29udGV4dCkge1xuICAgIGxldCByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KTtcbiAgICBsZXQgcmF3U291cmNlcyA9IFtdLmNvbmNhdChyYXdPcHRpb25zLmV2ZW50U291cmNlcyB8fCBbXSk7XG4gICAgbGV0IHNvdXJjZXMgPSBbXTsgLy8gcGFyc2VkXG4gICAgaWYgKHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cykge1xuICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5pbml0aWFsRXZlbnRzKTtcbiAgICB9XG4gICAgaWYgKHJhd09wdGlvbnMuZXZlbnRzKSB7XG4gICAgICAgIHJhd1NvdXJjZXMudW5zaGlmdChyYXdPcHRpb25zLmV2ZW50cyk7XG4gICAgfVxuICAgIGZvciAobGV0IHJhd1NvdXJjZSBvZiByYXdTb3VyY2VzKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBwYXJzZUV2ZW50U291cmNlKHJhd1NvdXJjZSwgY29udGV4dCwgcmVmaW5lcnMpO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlcztcbn1cbmZ1bmN0aW9uIGRvZXNTb3VyY2VOZWVkUmFuZ2UoZXZlbnRTb3VyY2UsIGNvbnRleHQpIHtcbiAgICBsZXQgZGVmcyA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzO1xuICAgIHJldHVybiAhZGVmc1tldmVudFNvdXJjZS5zb3VyY2VEZWZJZF0uaWdub3JlUmFuZ2U7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURhdGVTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbiwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFTEVDVF9EQVRFUyc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uc2VsZWN0aW9uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VTZWxlY3RlZEV2ZW50KGN1cnJlbnRJbnN0YW5jZUlkLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VMRUNUX0VWRU5UJzpcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY2FzZSAnU0VMRUNUX0VWRU5UJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRJbnN0YW5jZUlkO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZUlkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnREcmFnKGN1cnJlbnREcmFnLCBhY3Rpb24pIHtcbiAgICBsZXQgbmV3RHJhZztcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgIG5ld0RyYWcgPSBhY3Rpb24uc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdEcmFnLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG5ld0RyYWcubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBuZXdEcmFnLmlzRXZlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREcmFnO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRSZXNpemUoY3VycmVudFJlc2l6ZSwgYWN0aW9uKSB7XG4gICAgbGV0IG5ld1Jlc2l6ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICBuZXdSZXNpemUgPSBhY3Rpb24uc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdSZXNpemUuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3UmVzaXplLm11dGF0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogbmV3UmVzaXplLmlzRXZlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXNpemU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRvb2xiYXJzKGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XG4gICAgbGV0IGhlYWRlciA9IGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xuICAgIGxldCBmb290ZXIgPSBjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciA/IHBhcnNlVG9vbGJhcihjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIDogbnVsbDtcbiAgICByZXR1cm4geyBoZWFkZXIsIGZvb3RlciB9O1xufVxuZnVuY3Rpb24gcGFyc2VUb29sYmFyKHNlY3Rpb25TdHJIYXNoLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkge1xuICAgIGxldCBzZWN0aW9uV2lkZ2V0cyA9IHt9O1xuICAgIGxldCB2aWV3c1dpdGhCdXR0b25zID0gW107XG4gICAgbGV0IGhhc1RpdGxlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgc2VjdGlvbk5hbWUgaW4gc2VjdGlvblN0ckhhc2gpIHtcbiAgICAgICAgbGV0IHNlY3Rpb25TdHIgPSBzZWN0aW9uU3RySGFzaFtzZWN0aW9uTmFtZV07XG4gICAgICAgIGxldCBzZWN0aW9uUmVzID0gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKTtcbiAgICAgICAgc2VjdGlvbldpZGdldHNbc2VjdGlvbk5hbWVdID0gc2VjdGlvblJlcy53aWRnZXRzO1xuICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2goLi4uc2VjdGlvblJlcy52aWV3c1dpdGhCdXR0b25zKTtcbiAgICAgICAgaGFzVGl0bGUgPSBoYXNUaXRsZSB8fCBzZWN0aW9uUmVzLmhhc1RpdGxlO1xuICAgIH1cbiAgICByZXR1cm4geyBzZWN0aW9uV2lkZ2V0cywgdmlld3NXaXRoQnV0dG9ucywgaGFzVGl0bGUgfTtcbn1cbi8qXG5CQUQ6IHF1ZXJ5aW5nIGljb25zIGFuZCB0ZXh0IGhlcmUuIHNob3VsZCBiZSBkb25lIGF0IHJlbmRlciB0aW1lXG4qL1xuZnVuY3Rpb24gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgLy8gZGVmYXVsdHMrb3ZlcnJpZGVzLCB0aGVuIHJlZmluZWRcbmNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCAvLyBvdmVycmlkZXMgb25seSEsIHVucmVmaW5lZCA6KFxudGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICBsZXQgaXNSdGwgPSBjYWxlbmRhck9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICBsZXQgY2FsZW5kYXJDdXN0b21CdXR0b25zID0gY2FsZW5kYXJPcHRpb25zLmN1c3RvbUJ1dHRvbnMgfHwge307XG4gICAgbGV0IGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvblRleHQgfHwge307XG4gICAgbGV0IGNhbGVuZGFyQnV0dG9uVGV4dCA9IGNhbGVuZGFyT3B0aW9ucy5idXR0b25UZXh0IHx8IHt9O1xuICAgIGxldCBjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXMgPSBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcy5idXR0b25IaW50cyB8fCB7fTtcbiAgICBsZXQgY2FsZW5kYXJCdXR0b25IaW50cyA9IGNhbGVuZGFyT3B0aW9ucy5idXR0b25IaW50cyB8fCB7fTtcbiAgICBsZXQgc2VjdGlvblN1YnN0cnMgPSBzZWN0aW9uU3RyID8gc2VjdGlvblN0ci5zcGxpdCgnICcpIDogW107XG4gICAgbGV0IHZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcbiAgICBsZXQgaGFzVGl0bGUgPSBmYWxzZTtcbiAgICBsZXQgd2lkZ2V0cyA9IHNlY3Rpb25TdWJzdHJzLm1hcCgoYnV0dG9uR3JvdXBTdHIpID0+IChidXR0b25Hcm91cFN0ci5zcGxpdCgnLCcpLm1hcCgoYnV0dG9uTmFtZSkgPT4ge1xuICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgaGFzVGl0bGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXN0b21CdXR0b25Qcm9wcztcbiAgICAgICAgbGV0IHZpZXdTcGVjO1xuICAgICAgICBsZXQgYnV0dG9uQ2xpY2s7XG4gICAgICAgIGxldCBidXR0b25JY29uOyAvLyBvbmx5IG9uZSBvZiB0aGVzZSB3aWxsIGJlIHNldFxuICAgICAgICBsZXQgYnV0dG9uVGV4dDsgLy8gXCJcbiAgICAgICAgbGV0IGJ1dHRvbkhpbnQ7XG4gICAgICAgIC8vIF4gZm9yIHRoZSB0aXRsZT1cIlwiIGF0dHJpYnV0ZSwgZm9yIGFjY2Vzc2liaWxpdHlcbiAgICAgICAgaWYgKChjdXN0b21CdXR0b25Qcm9wcyA9IGNhbGVuZGFyQ3VzdG9tQnV0dG9uc1tidXR0b25OYW1lXSkpIHtcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrLmNhbGwoZXYudGFyZ2V0LCBldiwgZXYudGFyZ2V0KTsgLy8gVE9ETzogdXNlIENhbGVuZGFyIHRoaXMgY29udGV4dD9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MoY3VzdG9tQnV0dG9uUHJvcHMpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGN1c3RvbUJ1dHRvblByb3BzLnRleHQpO1xuICAgICAgICAgICAgYnV0dG9uSGludCA9IGN1c3RvbUJ1dHRvblByb3BzLmhpbnQgfHwgY3VzdG9tQnV0dG9uUHJvcHMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmlld1NwZWMgPSB2aWV3U3BlY3NbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2goYnV0dG9uTmFtZSk7XG4gICAgICAgICAgICBidXR0b25DbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaS5jaGFuZ2VWaWV3KGJ1dHRvbk5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0KTtcbiAgICAgICAgICAgIGxldCB0ZXh0RmFsbGJhY2sgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUgfHxcbiAgICAgICAgICAgICAgICB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdDtcbiAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHModmlld1NwZWMuYnV0dG9uVGl0bGVPdmVycmlkZSB8fFxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRpdGxlRGVmYXVsdCB8fFxuICAgICAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9ucy52aWV3SGludCwgW3RleHRGYWxsYmFjaywgYnV0dG9uTmFtZV0sIC8vIHZpZXctbmFtZSA9IGJ1dHRvbk5hbWVcbiAgICAgICAgICAgIHRleHRGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0pIHsgLy8gYSBjYWxlbmRhckFwaSBtZXRob2RcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXNbYnV0dG9uTmFtZV0pIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTsgLy8gZXZlcnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgZGVmYXVsdFxuICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICdwcmV2WWVhcicgfHwgYnV0dG9uTmFtZSA9PT0gJ25leHRZZWFyJykge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2T3JOZXh0ID0gYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyA/ICdwcmV2JyA6ICduZXh0JztcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1twcmV2T3JOZXh0XSB8fFxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW3ByZXZPck5leHRdLCBbXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dC55ZWFyIHx8ICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gKG5hdlVuaXQpID0+IGZvcm1hdFdpdGhPcmRpbmFscyhjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXNbYnV0dG9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25IaW50c1tidXR0b25OYW1lXSwgW1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvblRleHRbbmF2VW5pdF0gfHwgbmF2VW5pdCxcbiAgICAgICAgICAgICAgICAgICAgbmF2VW5pdCxcbiAgICAgICAgICAgICAgICBdLCBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJ1dHRvbk5hbWUsIGJ1dHRvbkNsaWNrLCBidXR0b25JY29uLCBidXR0b25UZXh0LCBidXR0b25IaW50IH07XG4gICAgfSkpKTtcbiAgICByZXR1cm4geyB3aWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZSB9O1xufVxuXG4vLyBhbHdheXMgcmVwcmVzZW50cyB0aGUgY3VycmVudCB2aWV3LiBvdGhlcndpc2UsIGl0J2QgbmVlZCB0byBjaGFuZ2UgdmFsdWUgZXZlcnkgdGltZSBkYXRlIGNoYW5nZXNcbmNsYXNzIFZpZXdJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmdldEN1cnJlbnREYXRhID0gZ2V0Q3VycmVudERhdGE7XG4gICAgICAgIHRoaXMuZGF0ZUVudiA9IGRhdGVFbnY7XG4gICAgfVxuICAgIGdldCBjYWxlbmRhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS5jYWxlbmRhckFwaTtcbiAgICB9XG4gICAgZ2V0IHRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50RGF0YSgpLnZpZXdUaXRsZTtcbiAgICB9XG4gICAgZ2V0IGFjdGl2ZVN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2Uuc3RhcnQpO1xuICAgIH1cbiAgICBnZXQgYWN0aXZlRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UuZW5kKTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZUVudi50b0RhdGUodGhpcy5nZXRDdXJyZW50RGF0YSgpLmRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydCk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50RW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLmVuZCk7XG4gICAgfVxuICAgIGdldE9wdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkub3B0aW9uc1tuYW1lXTsgLy8gYXJlIHRoZSB2aWV3LXNwZWNpZmljIG9wdGlvbnNcbiAgICB9XG59XG5cbmxldCBldmVudFNvdXJjZURlZiQyID0ge1xuICAgIGlnbm9yZVJhbmdlOiB0cnVlLFxuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZmluZWQuZXZlbnRzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmV0Y2goYXJnLCBzdWNjZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHtcbiAgICAgICAgICAgIHJhd0V2ZW50czogYXJnLmV2ZW50U291cmNlLm1ldGEsXG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuY29uc3QgYXJyYXlFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2FycmF5LWV2ZW50LXNvdXJjZScsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWYkMl0sXG59KTtcblxubGV0IGV2ZW50U291cmNlRGVmJDEgPSB7XG4gICAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVkLmV2ZW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmV0Y2goYXJnLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgeyBkYXRlRW52IH0gPSBhcmcuY29udGV4dDtcbiAgICAgICAgY29uc3QgZnVuYyA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICB1bnByb21pc2lmeShmdW5jLmJpbmQobnVsbCwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShhcmcucmFuZ2UsIGRhdGVFbnYpKSwgKHJhd0V2ZW50cykgPT4gc3VjY2Vzc0NhbGxiYWNrKHsgcmF3RXZlbnRzIH0pLCBlcnJvckNhbGxiYWNrKTtcbiAgICB9LFxufTtcbmNvbnN0IGZ1bmNFdmVudFNvdXJjZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ2Z1bmMtZXZlbnQtc291cmNlJyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZiQxXSxcbn0pO1xuXG5jb25zdCBKU09OX0ZFRURfRVZFTlRfU09VUkNFX1JFRklORVJTID0ge1xuICAgIG1ldGhvZDogU3RyaW5nLFxuICAgIGV4dHJhUGFyYW1zOiBpZGVudGl0eSxcbiAgICBzdGFydFBhcmFtOiBTdHJpbmcsXG4gICAgZW5kUGFyYW06IFN0cmluZyxcbiAgICB0aW1lWm9uZVBhcmFtOiBTdHJpbmcsXG59O1xuXG5sZXQgZXZlbnRTb3VyY2VEZWYgPSB7XG4gICAgcGFyc2VNZXRhKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKHJlZmluZWQudXJsICYmIChyZWZpbmVkLmZvcm1hdCA9PT0gJ2pzb24nIHx8ICFyZWZpbmVkLmZvcm1hdCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiByZWZpbmVkLnVybCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdqc29uJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IChyZWZpbmVkLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICBleHRyYVBhcmFtczogcmVmaW5lZC5leHRyYVBhcmFtcyxcbiAgICAgICAgICAgICAgICBzdGFydFBhcmFtOiByZWZpbmVkLnN0YXJ0UGFyYW0sXG4gICAgICAgICAgICAgICAgZW5kUGFyYW06IHJlZmluZWQuZW5kUGFyYW0sXG4gICAgICAgICAgICAgICAgdGltZVpvbmVQYXJhbTogcmVmaW5lZC50aW1lWm9uZVBhcmFtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHsgbWV0YSB9ID0gYXJnLmV2ZW50U291cmNlO1xuICAgICAgICBjb25zdCByZXF1ZXN0UGFyYW1zID0gYnVpbGRSZXF1ZXN0UGFyYW1zKG1ldGEsIGFyZy5yYW5nZSwgYXJnLmNvbnRleHQpO1xuICAgICAgICByZXF1ZXN0SnNvbihtZXRhLm1ldGhvZCwgbWV0YS51cmwsIHJlcXVlc3RQYXJhbXMpLnRoZW4oKFtyYXdFdmVudHMsIHJlc3BvbnNlXSkgPT4ge1xuICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHsgcmF3RXZlbnRzLCByZXNwb25zZSB9KTtcbiAgICAgICAgfSwgZXJyb3JDYWxsYmFjayk7XG4gICAgfSxcbn07XG5jb25zdCBqc29uRmVlZEV2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnanNvbi1ldmVudC1zb3VyY2UnLFxuICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxufSk7XG5mdW5jdGlvbiBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgcmFuZ2UsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgIGxldCBzdGFydFBhcmFtO1xuICAgIGxldCBlbmRQYXJhbTtcbiAgICBsZXQgdGltZVpvbmVQYXJhbTtcbiAgICBsZXQgY3VzdG9tUmVxdWVzdFBhcmFtcztcbiAgICBsZXQgcGFyYW1zID0ge307XG4gICAgc3RhcnRQYXJhbSA9IG1ldGEuc3RhcnRQYXJhbTtcbiAgICBpZiAoc3RhcnRQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgIHN0YXJ0UGFyYW0gPSBvcHRpb25zLnN0YXJ0UGFyYW07XG4gICAgfVxuICAgIGVuZFBhcmFtID0gbWV0YS5lbmRQYXJhbTtcbiAgICBpZiAoZW5kUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBlbmRQYXJhbSA9IG9wdGlvbnMuZW5kUGFyYW07XG4gICAgfVxuICAgIHRpbWVab25lUGFyYW0gPSBtZXRhLnRpbWVab25lUGFyYW07XG4gICAgaWYgKHRpbWVab25lUGFyYW0gPT0gbnVsbCkge1xuICAgICAgICB0aW1lWm9uZVBhcmFtID0gb3B0aW9ucy50aW1lWm9uZVBhcmFtO1xuICAgIH1cbiAgICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgZGF0YSBmcm9tIHRoZSBvcHRpb25zXG4gICAgaWYgKHR5cGVvZiBtZXRhLmV4dHJhUGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gcHJvYmFibHkgc3VwcGxpZWQgYXMgYSBzdHJhaWdodCBrZXkvdmFsdWUgb2JqZWN0XG4gICAgICAgIGN1c3RvbVJlcXVlc3RQYXJhbXMgPSBtZXRhLmV4dHJhUGFyYW1zIHx8IHt9O1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHBhcmFtcywgY3VzdG9tUmVxdWVzdFBhcmFtcyk7XG4gICAgcGFyYW1zW3N0YXJ0UGFyYW1dID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2Uuc3RhcnQpO1xuICAgIHBhcmFtc1tlbmRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5lbmQpO1xuICAgIGlmIChkYXRlRW52LnRpbWVab25lICE9PSAnbG9jYWwnKSB7XG4gICAgICAgIHBhcmFtc1t0aW1lWm9uZVBhcmFtXSA9IGRhdGVFbnYudGltZVpvbmU7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG5cbmNvbnN0IFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMgPSB7XG4gICAgZGF5c09mV2VlazogaWRlbnRpdHksXG4gICAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBlbmRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgc3RhcnRSZWN1cjogaWRlbnRpdHksXG4gICAgZW5kUmVjdXI6IGlkZW50aXR5LFxufTtcblxubGV0IHJlY3VycmluZyA9IHtcbiAgICBwYXJzZShyZWZpbmVkLCBkYXRlRW52KSB7XG4gICAgICAgIGlmIChyZWZpbmVkLmRheXNPZldlZWsgfHwgcmVmaW5lZC5zdGFydFRpbWUgfHwgcmVmaW5lZC5lbmRUaW1lIHx8IHJlZmluZWQuc3RhcnRSZWN1ciB8fCByZWZpbmVkLmVuZFJlY3VyKSB7XG4gICAgICAgICAgICBsZXQgcmVjdXJyaW5nRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBkYXlzT2ZXZWVrOiByZWZpbmVkLmRheXNPZldlZWsgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFydFRpbWU6IHJlZmluZWQuc3RhcnRUaW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgZW5kVGltZTogcmVmaW5lZC5lbmRUaW1lIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgc3RhcnRSZWN1cjogcmVmaW5lZC5zdGFydFJlY3VyID8gZGF0ZUVudi5jcmVhdGVNYXJrZXIocmVmaW5lZC5zdGFydFJlY3VyKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgZW5kUmVjdXI6IHJlZmluZWQuZW5kUmVjdXIgPyBkYXRlRW52LmNyZWF0ZU1hcmtlcihyZWZpbmVkLmVuZFJlY3VyKSA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKHJlZmluZWQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHJlZmluZWQuZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWR1cmF0aW9uICYmIHJlZmluZWQuc3RhcnRUaW1lICYmIHJlZmluZWQuZW5kVGltZSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gc3VidHJhY3REdXJhdGlvbnMocmVmaW5lZC5lbmRUaW1lLCByZWZpbmVkLnN0YXJ0VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFsbERheUd1ZXNzOiBCb29sZWFuKCFyZWZpbmVkLnN0YXJ0VGltZSAmJiAhcmVmaW5lZC5lbmRUaW1lKSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nRGF0YSwgLy8gZG9lc24ndCBuZWVkIGVuZFRpbWUgYW55bW9yZSBidXQgb2ggd2VsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGV4cGFuZCh0eXBlRGF0YSwgZnJhbWluZ1JhbmdlLCBkYXRlRW52KSB7XG4gICAgICAgIGxldCBjbGlwcGVkRnJhbWluZ1JhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGZyYW1pbmdSYW5nZSwgeyBzdGFydDogdHlwZURhdGEuc3RhcnRSZWN1ciwgZW5kOiB0eXBlRGF0YS5lbmRSZWN1ciB9KTtcbiAgICAgICAgaWYgKGNsaXBwZWRGcmFtaW5nUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBhbmRSYW5nZXModHlwZURhdGEuZGF5c09mV2VlaywgdHlwZURhdGEuc3RhcnRUaW1lLCBjbGlwcGVkRnJhbWluZ1JhbmdlLCBkYXRlRW52KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcbn07XG5jb25zdCBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdzaW1wbGUtcmVjdXJyaW5nLWV2ZW50JyxcbiAgICByZWN1cnJpbmdUeXBlczogW3JlY3VycmluZ10sXG4gICAgZXZlbnRSZWZpbmVyczogU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyxcbn0pO1xuZnVuY3Rpb24gZXhwYW5kUmFuZ2VzKGRheXNPZldlZWssIHN0YXJ0VGltZSwgZnJhbWluZ1JhbmdlLCBkYXRlRW52KSB7XG4gICAgbGV0IGRvd0hhc2ggPSBkYXlzT2ZXZWVrID8gYXJyYXlUb0hhc2goZGF5c09mV2VlaykgOiBudWxsO1xuICAgIGxldCBkYXlNYXJrZXIgPSBzdGFydE9mRGF5KGZyYW1pbmdSYW5nZS5zdGFydCk7XG4gICAgbGV0IGVuZE1hcmtlciA9IGZyYW1pbmdSYW5nZS5lbmQ7XG4gICAgbGV0IGluc3RhbmNlU3RhcnRzID0gW107XG4gICAgd2hpbGUgKGRheU1hcmtlciA8IGVuZE1hcmtlcikge1xuICAgICAgICBsZXQgaW5zdGFuY2VTdGFydDtcbiAgICAgICAgLy8gaWYgZXZlcnlkYXksIG9yIHRoaXMgcGFydGljdWxhciBkYXktb2Ytd2Vla1xuICAgICAgICBpZiAoIWRvd0hhc2ggfHwgZG93SGFzaFtkYXlNYXJrZXIuZ2V0VVRDRGF5KCldKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCA9IGRhdGVFbnYuYWRkKGRheU1hcmtlciwgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSBkYXlNYXJrZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZVN0YXJ0cy5wdXNoKGluc3RhbmNlU3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGRheU1hcmtlciA9IGFkZERheXMoZGF5TWFya2VyLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlU3RhcnRzO1xufVxuXG5jb25zdCBjaGFuZ2VIYW5kbGVyUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnY2hhbmdlLWhhbmRsZXInLFxuICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7XG4gICAgICAgIGV2ZW50cyhldmVudHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50U291cmNlcyhbZXZlbnRzXSwgY29udGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50U291cmNlczogaGFuZGxlRXZlbnRTb3VyY2VzLFxuICAgIH0sXG59KTtcbi8qXG5CVUc6IGlmIGBldmVudGAgd2FzIHN1cHBsaWVkLCBhbGwgcHJldmlvdXNseS1naXZlbiBgZXZlbnRTb3VyY2VzYCB3aWxsIGJlIHdpcGVkIG91dFxuKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50U291cmNlcyhpbnB1dHMsIGNvbnRleHQpIHtcbiAgICBsZXQgdW5mb3VuZFNvdXJjZXMgPSBoYXNoVmFsdWVzVG9BcnJheShjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzKTtcbiAgICBpZiAodW5mb3VuZFNvdXJjZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGlucHV0cy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgQXJyYXkuaXNBcnJheSh1bmZvdW5kU291cmNlc1swXS5fcmF3KSAmJlxuICAgICAgICBBcnJheS5pc0FycmF5KGlucHV0c1swXSkpIHtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVTRVRfUkFXX0VWRU5UUycsXG4gICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZXNbMF0uc291cmNlSWQsXG4gICAgICAgICAgICByYXdFdmVudHM6IGlucHV0c1swXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG5ld0lucHV0cyA9IFtdO1xuICAgIGZvciAobGV0IGlucHV0IG9mIGlucHV0cykge1xuICAgICAgICBsZXQgaW5wdXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVuZm91bmRTb3VyY2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodW5mb3VuZFNvdXJjZXNbaV0uX3JhdyA9PT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB1bmZvdW5kU291cmNlcy5zcGxpY2UoaSwgMSk7IC8vIGRlbGV0ZVxuICAgICAgICAgICAgICAgIGlucHV0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaW5wdXRGb3VuZCkge1xuICAgICAgICAgICAgbmV3SW5wdXRzLnB1c2goaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IHVuZm91bmRTb3VyY2Ugb2YgdW5mb3VuZFNvdXJjZXMpIHtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UX1NPVVJDRScsXG4gICAgICAgICAgICBzb3VyY2VJZDogdW5mb3VuZFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAobGV0IG5ld0lucHV0IG9mIG5ld0lucHV0cykge1xuICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLmFkZEV2ZW50U291cmNlKG5ld0lucHV0KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZURhdGVQcm9maWxlKGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2RhdGVzU2V0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpV2l0aFRpbWVab25lKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBjb250ZXh0LmRhdGVFbnYpKSwgeyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfSkpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGNvbnRleHQpIHtcbiAgICBsZXQgeyBlbWl0dGVyIH0gPSBjb250ZXh0O1xuICAgIGlmIChlbWl0dGVyLmhhc0hhbmRsZXJzKCdldmVudHNTZXQnKSkge1xuICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50c1NldCcsIGJ1aWxkRXZlbnRBcGlzKGV2ZW50U3RvcmUsIGNvbnRleHQpKTtcbiAgICB9XG59XG5cbi8qXG50aGlzIGFycmF5IGlzIGV4cG9zZWQgb24gdGhlIHJvb3QgbmFtZXNwYWNlIHNvIHRoYXQgVU1EIHBsdWdpbnMgY2FuIGFkZCB0byBpdC5cbnNlZSB0aGUgcm9sbHVwLWJ1bmRsZXMgc2NyaXB0LlxuKi9cbmNvbnN0IGdsb2JhbFBsdWdpbnMgPSBbXG4gICAgYXJyYXlFdmVudFNvdXJjZVBsdWdpbixcbiAgICBmdW5jRXZlbnRTb3VyY2VQbHVnaW4sXG4gICAganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbixcbiAgICBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4sXG4gICAgY2hhbmdlSGFuZGxlclBsdWdpbixcbiAgICBjcmVhdGVQbHVnaW4oe1xuICAgICAgICBuYW1lOiAnbWlzYycsXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXG4gICAgICAgICAgICAoc3RhdGUpID0+IGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKHN0YXRlLmV2ZW50U291cmNlcyksXG4gICAgICAgIF0sXG4gICAgICAgIHByb3BTZXRIYW5kbGVyczoge1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IGhhbmRsZURhdGVQcm9maWxlLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogaGFuZGxlRXZlbnRTdG9yZSxcbiAgICAgICAgfSxcbiAgICB9KSxcbl07XG5cbmNsYXNzIFRhc2tSdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKHJ1blRhc2tPcHRpb24sIGRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5ydW5UYXNrT3B0aW9uID0gcnVuVGFza09wdGlvbjtcbiAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcih0aGlzLmRyYWluLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICByZXF1ZXN0KHRhc2ssIGRlbGF5KSB7XG4gICAgICAgIHRoaXMucXVldWUucHVzaCh0YXNrKTtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnJlcXVlc3QoZGVsYXkpO1xuICAgIH1cbiAgICBwYXVzZShzY29wZSkge1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIucGF1c2Uoc2NvcGUpO1xuICAgIH1cbiAgICByZXN1bWUoc2NvcGUsIGZvcmNlKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZFJ1bm5lci5yZXN1bWUoc2NvcGUsIGZvcmNlKTtcbiAgICB9XG4gICAgZHJhaW4oKSB7XG4gICAgICAgIGxldCB7IHF1ZXVlIH0gPSB0aGlzO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY29tcGxldGVkVGFza3MgPSBbXTtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gcXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRhc2sodGFzayk7XG4gICAgICAgICAgICAgICAgY29tcGxldGVkVGFza3MucHVzaCh0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhaW5lZChjb21wbGV0ZWRUYXNrcyk7XG4gICAgICAgIH0gLy8ga2VlcCBnb2luZywgaW4gY2FzZSBuZXcgdGFza3Mgd2VyZSBhZGRlZCBpbiB0aGUgZHJhaW5lZCBoYW5kbGVyXG4gICAgfVxuICAgIHJ1blRhc2sodGFzaykge1xuICAgICAgICBpZiAodGhpcy5ydW5UYXNrT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24odGFzayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhaW5lZChjb21wbGV0ZWRUYXNrcykge1xuICAgICAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24oY29tcGxldGVkVGFza3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBDb21wdXRlcyB3aGF0IHRoZSB0aXRsZSBhdCB0aGUgdG9wIG9mIHRoZSBjYWxlbmRhckFwaSBzaG91bGQgYmUgZm9yIHRoaXMgdmlld1xuZnVuY3Rpb24gYnVpbGRUaXRsZShkYXRlUHJvZmlsZSwgdmlld09wdGlvbnMsIGRhdGVFbnYpIHtcbiAgICBsZXQgcmFuZ2U7XG4gICAgLy8gZm9yIHZpZXdzIHRoYXQgc3BhbiBhIGxhcmdlIHVuaXQgb2YgdGltZSwgc2hvdyB0aGUgcHJvcGVyIGludGVydmFsLCBpZ25vcmluZyBzdHJheSBkYXlzIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICBpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKSB7XG4gICAgICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gZm9yIGRheSB1bml0cyBvciBzbWFsbGVyLCB1c2UgdGhlIGFjdHVhbCBkYXkgcmFuZ2VcbiAgICAgICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgY3JlYXRlRm9ybWF0dGVyKHZpZXdPcHRpb25zLnRpdGxlRm9ybWF0IHx8IGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpKSwge1xuICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogdmlld09wdGlvbnMudGl0bGVSYW5nZVNlcGFyYXRvcixcbiAgICB9KTtcbn1cbi8vIEdlbmVyYXRlcyB0aGUgZm9ybWF0IHN0cmluZyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aXRsZSBmb3IgdGhlIGN1cnJlbnQgZGF0ZSByYW5nZS5cbi8vIEF0dGVtcHRzIHRvIGNvbXB1dGUgdGhlIG1vc3QgYXBwcm9wcmlhdGUgZm9ybWF0IGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCB3aXRoIGB0aXRsZUZvcm1hdGAuXG5mdW5jdGlvbiBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSB7XG4gICAgbGV0IHsgY3VycmVudFJhbmdlVW5pdCB9ID0gZGF0ZVByb2ZpbGU7XG4gICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycgfTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnIH07IC8vIGxpa2UgXCJTZXB0ZW1iZXIgMjAxNFwiXG4gICAgfVxuICAgIGxldCBkYXlzID0gZGlmZldob2xlRGF5cyhkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQsIGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5lbmQpO1xuICAgIGlmIChkYXlzICE9PSBudWxsICYmIGRheXMgPiAxKSB7XG4gICAgICAgIC8vIG11bHRpLWRheSByYW5nZS4gc2hvcnRlciwgbGlrZSBcIlNlcCA5IC0gMTAgMjAxNFwiXG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdzaG9ydCcsIGRheTogJ251bWVyaWMnIH07XG4gICAgfVxuICAgIC8vIG9uZSBkYXkuIGxvbmdlciwgbGlrZSBcIlNlcHRlbWJlciA5IDIwMTRcIlxuICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJywgZGF5OiAnbnVtZXJpYycgfTtcbn1cblxuLy8gaW4gZnV0dXJlIHJlZmFjdG9yLCBkbyB0aGUgcmVkdXgtc3R5bGUgZnVuY3Rpb24oc3RhdGU9aW5pdGlhbCkgZm9yIGluaXRpYWwtc3RhdGVcbi8vIGFsc28sIHdoYXRldmVyIGlzIGhhcHBlbmluZyBpbiBjb25zdHJ1Y3RvciwgaGF2ZSBpdCBoYXBwZW4gaW4gYWN0aW9uIHF1ZXVlIHRvb1xuY2xhc3MgQ2FsZW5kYXJEYXRhTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhID0gbWVtb2l6ZSh0aGlzLl9jb21wdXRlQ3VycmVudFZpZXdEYXRhKTtcbiAgICAgICAgdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMgPSBtZW1vaXplKG9yZ2FuaXplUmF3TG9jYWxlcyk7XG4gICAgICAgIHRoaXMuYnVpbGRMb2NhbGUgPSBtZW1vaXplKGJ1aWxkTG9jYWxlKTtcbiAgICAgICAgdGhpcy5idWlsZFBsdWdpbkhvb2tzID0gYnVpbGRCdWlsZFBsdWdpbkhvb2tzKCk7XG4gICAgICAgIHRoaXMuYnVpbGREYXRlRW52ID0gbWVtb2l6ZShidWlsZERhdGVFbnYkMSk7XG4gICAgICAgIHRoaXMuYnVpbGRUaGVtZSA9IG1lbW9pemUoYnVpbGRUaGVtZSk7XG4gICAgICAgIHRoaXMucGFyc2VUb29sYmFycyA9IG1lbW9pemUocGFyc2VUb29sYmFycyk7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3U3BlY3MgPSBtZW1vaXplKGJ1aWxkVmlld1NwZWNzKTtcbiAgICAgICAgdGhpcy5idWlsZERhdGVQcm9maWxlR2VuZXJhdG9yID0gbWVtb2l6ZU9iakFyZyhidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdBcGkgPSBtZW1vaXplKGJ1aWxkVmlld0FwaSk7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3VWlQcm9wcyA9IG1lbW9pemVPYmpBcmcoYnVpbGRWaWV3VWlQcm9wcyk7XG4gICAgICAgIHRoaXMuYnVpbGRFdmVudFVpQnlTb3VyY2UgPSBtZW1vaXplKGJ1aWxkRXZlbnRVaUJ5U291cmNlLCBpc1Byb3BzRXF1YWwpO1xuICAgICAgICB0aGlzLmJ1aWxkRXZlbnRVaUJhc2VzID0gbWVtb2l6ZShidWlsZEV2ZW50VWlCYXNlcyk7XG4gICAgICAgIHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyA9IG1lbW9pemVPYmpBcmcocGFyc2VDb250ZXh0QnVzaW5lc3NIb3Vycyk7XG4gICAgICAgIHRoaXMuYnVpbGRUaXRsZSA9IG1lbW9pemUoYnVpbGRUaXRsZSk7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyID0gbmV3IFRhc2tSdW5uZXIodGhpcy5faGFuZGxlQWN0aW9uLmJpbmQodGhpcyksIHRoaXMudXBkYXRlRGF0YS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0ID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zUmVmaW5lZCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVycyA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZyA9IFtdO1xuICAgICAgICB0aGlzLm9wdGlvbnNGb3JIYW5kbGluZyA9IFtdO1xuICAgICAgICB0aGlzLmdldEN1cnJlbnREYXRhID0gKCkgPT4gdGhpcy5kYXRhO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVxdWVzdChhY3Rpb24pOyAvLyBwcm90ZWN0cyBhZ2FpbnN0IHJlY3Vyc2l2ZSBjYWxscyB0byBfaGFuZGxlQWN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucGF1c2UoKTtcbiAgICAgICAgbGV0IGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSB7fTtcbiAgICAgICAgbGV0IG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld1R5cGUgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMuaW5pdGlhbFZpZXcgfHwgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuaW5pdGlhbFZpZXc7XG4gICAgICAgIGxldCBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcbiAgICAgICAgLy8gVE9ETzogbm90IERSWVxuICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0VGhpc0NvbnRleHQocHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XG4gICAgICAgIGxldCBjdXJyZW50RGF0ZSA9IGdldEluaXRpYWxEYXRlKG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucywgb3B0aW9uc0RhdGEuZGF0ZUVudik7XG4gICAgICAgIGxldCBkYXRlUHJvZmlsZSA9IGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChjdXJyZW50RGF0ZSk7XG4gICAgICAgIGlmICghcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY3VycmVudERhdGUpKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FsZW5kYXJDb250ZXh0ID0ge1xuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNEYXRhLmNhbGVuZGFyT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzOiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLFxuICAgICAgICAgICAgZW1pdHRlcjogdGhpcy5lbWl0dGVyLFxuICAgICAgICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIH07XG4gICAgICAgIC8vIG5lZWRzIHRvIGJlIGFmdGVyIHNldFRoaXNDb250ZXh0XG4gICAgICAgIGZvciAobGV0IGNhbGxiYWNrIG9mIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmNvbnRleHRJbml0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVCBEUllcbiAgICAgICAgbGV0IGV2ZW50U291cmNlcyA9IGluaXRFdmVudFNvdXJjZXMob3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgbGV0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjdXJyZW50Vmlld1R5cGUsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgICAgICBldmVudFNvdXJjZXMsXG4gICAgICAgICAgICBldmVudFVpQmFzZXM6IHt9LFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246ICcnLFxuICAgICAgICAgICAgZXZlbnREcmFnOiBudWxsLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IG51bGwsXG4gICAgICAgICAgICBzZWxlY3Rpb25Db25maWc6IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpLnNlbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvbnRleHRBbmRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY2FsZW5kYXJDb250ZXh0KSwgaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgZm9yIChsZXQgcmVkdWNlciBvZiBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2Vycykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpbml0aWFsU3RhdGUsIHJlZHVjZXIobnVsbCwgbnVsbCwgY29udGV4dEFuZFN0YXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXB1dGVJc0xvYWRpbmcoaW5pdGlhbFN0YXRlLCBjYWxlbmRhckNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIHRydWUpOyAvLyBOT1QgRFJZXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhKCk7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlc3VtZSgpO1xuICAgIH1cbiAgICByZXNldE9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBjaGFuZ2VkT3B0aW9uTmFtZXMpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChjaGFuZ2VkT3B0aW9uTmFtZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzID0gb3B0aW9uT3ZlcnJpZGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMub3B0aW9uT3ZlcnJpZGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAocHJvcHMub3B0aW9uT3ZlcnJpZGVzIHx8IHt9KSksIG9wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5wdXNoKC4uLmNoYW5nZWRPcHRpb25OYW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZWRPcHRpb25OYW1lcyA9PT0gdW5kZWZpbmVkIHx8IGNoYW5nZWRPcHRpb25OYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdOT1RISU5HJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9oYW5kbGVBY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgZW1pdHRlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSByZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzKHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGFjdGlvbik7XG4gICAgICAgIGxldCBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICBsZXQgY3VycmVudFZpZXdUeXBlID0gcmVkdWNlVmlld1R5cGUoc3RhdGUuY3VycmVudFZpZXdUeXBlLCBhY3Rpb24pO1xuICAgICAgICBsZXQgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKGN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIC8vIHdpcmUgdGhpbmdzIHVwXG4gICAgICAgIC8vIFRPRE86IG5vdCBEUllcbiAgICAgICAgcHJvcHMuY2FsZW5kYXJBcGkuY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcztcbiAgICAgICAgZW1pdHRlci5zZXRUaGlzQ29udGV4dChwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIGVtaXR0ZXIuc2V0T3B0aW9ucyhjdXJyZW50Vmlld0RhdGEub3B0aW9ucyk7XG4gICAgICAgIGxldCBjYWxlbmRhckNvbnRleHQgPSB7XG4gICAgICAgICAgICBkYXRlRW52OiBvcHRpb25zRGF0YS5kYXRlRW52LFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLFxuICAgICAgICAgICAgcGx1Z2luSG9va3M6IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLFxuICAgICAgICAgICAgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgZGlzcGF0Y2g6IHRoaXMuZGlzcGF0Y2gsXG4gICAgICAgICAgICBlbWl0dGVyLFxuICAgICAgICAgICAgZ2V0Q3VycmVudERhdGE6IHRoaXMuZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IGN1cnJlbnREYXRlLCBkYXRlUHJvZmlsZSB9ID0gc3RhdGU7XG4gICAgICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yICE9PSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHsgLy8gaGFja1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnREYXRlID0gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbik7XG4gICAgICAgIGRhdGVQcm9maWxlID0gcmVkdWNlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGFjdGlvbiwgY3VycmVudERhdGUsIGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ1BSRVYnIHx8IC8vIFRPRE86IG1vdmUgdGhpcyBsb2dpYyBpbnRvIERhdGVQcm9maWxlR2VuZXJhdG9yXG4gICAgICAgICAgICBhY3Rpb24udHlwZSA9PT0gJ05FWFQnIHx8IC8vIFwiXG4gICAgICAgICAgICAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlcyhzdGF0ZS5ldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIGxldCBldmVudFN0b3JlID0gcmVkdWNlRXZlbnRTdG9yZShzdGF0ZS5ldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIGxldCBpc0V2ZW50c0xvYWRpbmcgPSBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhldmVudFNvdXJjZXMpOyAvLyBCQUQuIGFsc28gY2FsbGVkIGluIHRoaXMgZnVuYyBpbiBjb21wdXRlSXNMb2FkaW5nXG4gICAgICAgIGxldCByZW5kZXJhYmxlRXZlbnRTdG9yZSA9IChpc0V2ZW50c0xvYWRpbmcgJiYgIWN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLnByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmcpID9cbiAgICAgICAgICAgIChzdGF0ZS5yZW5kZXJhYmxlRXZlbnRTdG9yZSB8fCBldmVudFN0b3JlKSA6IC8vIHRyeSBmcm9tIHByZXZpb3VzIHN0YXRlXG4gICAgICAgICAgICBldmVudFN0b3JlO1xuICAgICAgICBsZXQgeyBldmVudFVpU2luZ2xlQmFzZSwgc2VsZWN0aW9uQ29uZmlnIH0gPSB0aGlzLmJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KTsgLy8gd2lsbCBtZW1vaXplIG9ialxuICAgICAgICBsZXQgZXZlbnRVaUJ5U291cmNlID0gdGhpcy5idWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpO1xuICAgICAgICBsZXQgZXZlbnRVaUJhc2VzID0gdGhpcy5idWlsZEV2ZW50VWlCYXNlcyhyZW5kZXJhYmxlRXZlbnRTdG9yZS5kZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKTtcbiAgICAgICAgbGV0IG5ld1N0YXRlID0ge1xuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBldmVudFNvdXJjZXMsXG4gICAgICAgICAgICBldmVudFN0b3JlLFxuICAgICAgICAgICAgcmVuZGVyYWJsZUV2ZW50U3RvcmUsXG4gICAgICAgICAgICBzZWxlY3Rpb25Db25maWcsXG4gICAgICAgICAgICBldmVudFVpQmFzZXMsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiB0aGlzLnBhcnNlQ29udGV4dEJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0KSxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHJlZHVjZURhdGVTZWxlY3Rpb24oc3RhdGUuZGF0ZVNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiByZWR1Y2VTZWxlY3RlZEV2ZW50KHN0YXRlLmV2ZW50U2VsZWN0aW9uLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnREcmFnOiByZWR1Y2VFdmVudERyYWcoc3RhdGUuZXZlbnREcmFnLCBhY3Rpb24pLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IHJlZHVjZUV2ZW50UmVzaXplKHN0YXRlLmV2ZW50UmVzaXplLCBhY3Rpb24pLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY29udGV4dEFuZFN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYWxlbmRhckNvbnRleHQpLCBuZXdTdGF0ZSk7XG4gICAgICAgIGZvciAobGV0IHJlZHVjZXIgb2Ygb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3U3RhdGUsIHJlZHVjZXIoc3RhdGUsIGFjdGlvbiwgY29udGV4dEFuZFN0YXRlKSk7IC8vIGdpdmUgdGhlIE9MRCBzdGF0ZSwgZm9yIG9sZCB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGxldCB3YXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgbGV0IGlzTG9hZGluZyA9IGNvbXB1dGVJc0xvYWRpbmcobmV3U3RhdGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIC8vIFRPRE86IHVzZSBwcm9wU2V0SGFuZGxlcnMgaW4gcGx1Z2luIHN5c3RlbVxuICAgICAgICBpZiAoIXdhc0xvYWRpbmcgJiYgaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3YXNMb2FkaW5nICYmICFpc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGlmIChwcm9wcy5vbkFjdGlvbikge1xuICAgICAgICAgICAgcHJvcHMub25BY3Rpb24oYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVEYXRhKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGxldCBvbGREYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBsZXQgb3B0aW9uc0RhdGEgPSB0aGlzLmNvbXB1dGVPcHRpb25zRGF0YShwcm9wcy5vcHRpb25PdmVycmlkZXMsIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMsIHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgbGV0IGN1cnJlbnRWaWV3RGF0YSA9IHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YShzdGF0ZS5jdXJyZW50Vmlld1R5cGUsIG9wdGlvbnNEYXRhLCBwcm9wcy5vcHRpb25PdmVycmlkZXMsIHN0YXRlLmR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgdmlld1RpdGxlOiB0aGlzLmJ1aWxkVGl0bGUoc3RhdGUuZGF0ZVByb2ZpbGUsIGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLCBvcHRpb25zRGF0YS5kYXRlRW52KSwgY2FsZW5kYXJBcGk6IHByb3BzLmNhbGVuZGFyQXBpLCBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCwgZW1pdHRlcjogdGhpcy5lbWl0dGVyLCBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSB9LCBvcHRpb25zRGF0YSksIGN1cnJlbnRWaWV3RGF0YSksIHN0YXRlKTtcbiAgICAgICAgbGV0IGNoYW5nZUhhbmRsZXJzID0gb3B0aW9uc0RhdGEucGx1Z2luSG9va3Mub3B0aW9uQ2hhbmdlSGFuZGxlcnM7XG4gICAgICAgIGxldCBvbGRDYWxlbmRhck9wdGlvbnMgPSBvbGREYXRhICYmIG9sZERhdGEuY2FsZW5kYXJPcHRpb25zO1xuICAgICAgICBsZXQgbmV3Q2FsZW5kYXJPcHRpb25zID0gb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zO1xuICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zICYmIG9sZENhbGVuZGFyT3B0aW9ucyAhPT0gbmV3Q2FsZW5kYXJPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zLnRpbWVab25lICE9PSBuZXdDYWxlbmRhck9wdGlvbnMudGltZVpvbmUpIHtcbiAgICAgICAgICAgICAgICAvLyBoYWNrXG4gICAgICAgICAgICAgICAgc3RhdGUuZXZlbnRTb3VyY2VzID0gZGF0YS5ldmVudFNvdXJjZXMgPSByZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZShkYXRhLmV2ZW50U291cmNlcywgc3RhdGUuZGF0ZVByb2ZpbGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmV2ZW50U3RvcmUgPSBkYXRhLmV2ZW50U3RvcmUgPSByZXpvbmVFdmVudFN0b3JlRGF0ZXMoZGF0YS5ldmVudFN0b3JlLCBvbGREYXRhLmRhdGVFbnYsIGRhdGEuZGF0ZUVudik7XG4gICAgICAgICAgICAgICAgc3RhdGUucmVuZGVyYWJsZUV2ZW50U3RvcmUgPSBkYXRhLnJlbmRlcmFibGVFdmVudFN0b3JlID0gcmV6b25lRXZlbnRTdG9yZURhdGVzKGRhdGEucmVuZGVyYWJsZUV2ZW50U3RvcmUsIG9sZERhdGEuZGF0ZUVudiwgZGF0YS5kYXRlRW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gY2hhbmdlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zRm9ySGFuZGxpbmcuaW5kZXhPZihvcHRpb25OYW1lKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICAgICAgb2xkQ2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdICE9PSBuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGFuZGxlcnNbb3B0aW9uTmFtZV0obmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zRm9ySGFuZGxpbmcgPSBbXTtcbiAgICAgICAgaWYgKHByb3BzLm9uRGF0YSkge1xuICAgICAgICAgICAgcHJvcHMub25EYXRhKGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVPcHRpb25zRGF0YShvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGNhbGVuZGFyQXBpKSB7XG4gICAgICAgIC8vIFRPRE86IGJsYWNrbGlzdCBvcHRpb25zIHRoYXQgYXJlIGhhbmRsZWQgYnkgb3B0aW9uQ2hhbmdlSGFuZGxlcnNcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnNGb3JSZWZpbmluZy5sZW5ndGggJiZcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyA9PT0gdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMgJiZcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMgPT09IHRoaXMuc3RhYmxlRHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhYmxlQ2FsZW5kYXJPcHRpb25zRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyByZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MsIGxvY2FsZURlZmF1bHRzLCBhdmFpbGFibGVMb2NhbGVEYXRhLCBleHRyYSwgfSA9IHRoaXMucHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyhvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpO1xuICAgICAgICBsZXQgZGF0ZUVudiA9IHRoaXMuYnVpbGREYXRlRW52KHJlZmluZWRPcHRpb25zLnRpbWVab25lLCByZWZpbmVkT3B0aW9ucy5sb2NhbGUsIHJlZmluZWRPcHRpb25zLndlZWtOdW1iZXJDYWxjdWxhdGlvbiwgcmVmaW5lZE9wdGlvbnMuZmlyc3REYXksIHJlZmluZWRPcHRpb25zLndlZWtUZXh0LCBwbHVnaW5Ib29rcywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgcmVmaW5lZE9wdGlvbnMuZGVmYXVsdFJhbmdlU2VwYXJhdG9yKTtcbiAgICAgICAgbGV0IHZpZXdTcGVjcyA9IHRoaXMuYnVpbGRWaWV3U3BlY3MocGx1Z2luSG9va3Mudmlld3MsIHRoaXMuc3RhYmxlT3B0aW9uT3ZlcnJpZGVzLCB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMsIGxvY2FsZURlZmF1bHRzKTtcbiAgICAgICAgbGV0IHRoZW1lID0gdGhpcy5idWlsZFRoZW1lKHJlZmluZWRPcHRpb25zLCBwbHVnaW5Ib29rcyk7XG4gICAgICAgIGxldCB0b29sYmFyQ29uZmlnID0gdGhpcy5wYXJzZVRvb2xiYXJzKHJlZmluZWRPcHRpb25zLCB0aGlzLnN0YWJsZU9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFibGVDYWxlbmRhck9wdGlvbnNEYXRhID0ge1xuICAgICAgICAgICAgY2FsZW5kYXJPcHRpb25zOiByZWZpbmVkT3B0aW9ucyxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgICAgICAgZGF0ZUVudixcbiAgICAgICAgICAgIHZpZXdTcGVjcyxcbiAgICAgICAgICAgIHRoZW1lLFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgYXZhaWxhYmxlUmF3TG9jYWxlczogYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGFsd2F5cyBjYWxsZWQgZnJvbSBiZWhpbmQgYSBtZW1vaXplclxuICAgIHByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XG4gICAgICAgIGxldCB7IGxvY2FsZXMsIGxvY2FsZSB9ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIGxldCBhdmFpbGFibGVMb2NhbGVEYXRhID0gdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMobG9jYWxlcyk7XG4gICAgICAgIGxldCBhdmFpbGFibGVSYXdMb2NhbGVzID0gYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXA7XG4gICAgICAgIGxldCBsb2NhbGVEZWZhdWx0cyA9IHRoaXMuYnVpbGRMb2NhbGUobG9jYWxlIHx8IGF2YWlsYWJsZUxvY2FsZURhdGEuZGVmYXVsdENvZGUsIGF2YWlsYWJsZVJhd0xvY2FsZXMpLm9wdGlvbnM7XG4gICAgICAgIGxldCBwbHVnaW5Ib29rcyA9IHRoaXMuYnVpbGRQbHVnaW5Ib29rcyhvcHRpb25PdmVycmlkZXMucGx1Z2lucyB8fCBbXSwgZ2xvYmFsUGx1Z2lucyk7XG4gICAgICAgIGxldCByZWZpbmVycyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBCQVNFX09QVElPTl9SRUZJTkVSUyksIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTKSwgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTKSwgcGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyksIHBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzKTtcbiAgICAgICAgbGV0IGV4dHJhID0ge307XG4gICAgICAgIGxldCByYXcgPSBtZXJnZVJhd09wdGlvbnMoW1xuICAgICAgICAgICAgQkFTRV9PUFRJT05fREVGQVVMVFMsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgcmVmaW5lZCA9IHt9O1xuICAgICAgICBsZXQgY3VycmVudFJhdyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0O1xuICAgICAgICBsZXQgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkO1xuICAgICAgICBsZXQgYW55Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHJhdykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc0ZvclJlZmluaW5nLmluZGV4T2Yob3B0aW9uTmFtZSkgPT09IC0xICYmIChyYXdbb3B0aW9uTmFtZV0gPT09IGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0gfHwgKENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTW29wdGlvbk5hbWVdICYmXG4gICAgICAgICAgICAgICAgKG9wdGlvbk5hbWUgaW4gY3VycmVudFJhdykgJiZcbiAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShjdXJyZW50UmF3W29wdGlvbk5hbWVdLCByYXdbb3B0aW9uTmFtZV0pKSkpIHtcbiAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVyc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xuICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmF3W29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCA9IHJhdztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQgPSByZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zdGFibGVPcHRpb25PdmVycmlkZXMgPSBvcHRpb25PdmVycmlkZXM7XG4gICAgICAgICAgICB0aGlzLnN0YWJsZUR5bmFtaWNPcHRpb25PdmVycmlkZXMgPSBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9uc0ZvckhhbmRsaW5nLnB1c2goLi4udGhpcy5vcHRpb25zRm9yUmVmaW5pbmcpO1xuICAgICAgICB0aGlzLm9wdGlvbnNGb3JSZWZpbmluZyA9IFtdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQsXG4gICAgICAgICAgICByZWZpbmVkT3B0aW9uczogdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCxcbiAgICAgICAgICAgIHBsdWdpbkhvb2tzLFxuICAgICAgICAgICAgYXZhaWxhYmxlTG9jYWxlRGF0YSxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgZXh0cmEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9jb21wdXRlQ3VycmVudFZpZXdEYXRhKHZpZXdUeXBlLCBvcHRpb25zRGF0YSwgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB7XG4gICAgICAgIGxldCB2aWV3U3BlYyA9IG9wdGlvbnNEYXRhLnZpZXdTcGVjc1t2aWV3VHlwZV07XG4gICAgICAgIGlmICghdmlld1NwZWMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmlld1R5cGUgXCIke3ZpZXdUeXBlfVwiIGlzIG5vdCBhdmFpbGFibGUuIFBsZWFzZSBtYWtlIHN1cmUgeW91J3ZlIGxvYWRlZCBhbGwgbmVjY2Vzc2FyeSBwbHVnaW5zYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgcmVmaW5lZE9wdGlvbnMsIGV4dHJhIH0gPSB0aGlzLnByb2Nlc3NSYXdWaWV3T3B0aW9ucyh2aWV3U3BlYywgb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsIG9wdGlvbnNEYXRhLmxvY2FsZURlZmF1bHRzLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpO1xuICAgICAgICB3YXJuVW5rbm93bk9wdGlvbnMoZXh0cmEpO1xuICAgICAgICBsZXQgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3Ioe1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogdmlld1NwZWMub3B0aW9uRGVmYXVsdHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB2aWV3U3BlYy5kdXJhdGlvbixcbiAgICAgICAgICAgIGR1cmF0aW9uVW5pdDogdmlld1NwZWMuZHVyYXRpb25Vbml0LFxuICAgICAgICAgICAgdXNlc01pbk1heFRpbWU6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLnVzZXNNaW5NYXhUaW1lLFxuICAgICAgICAgICAgZGF0ZUVudjogb3B0aW9uc0RhdGEuZGF0ZUVudixcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiB0aGlzLnByb3BzLmNhbGVuZGFyQXBpLFxuICAgICAgICAgICAgc2xvdE1pblRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNaW5UaW1lLFxuICAgICAgICAgICAgc2xvdE1heFRpbWU6IHJlZmluZWRPcHRpb25zLnNsb3RNYXhUaW1lLFxuICAgICAgICAgICAgc2hvd05vbkN1cnJlbnREYXRlczogcmVmaW5lZE9wdGlvbnMuc2hvd05vbkN1cnJlbnREYXRlcyxcbiAgICAgICAgICAgIGRheUNvdW50OiByZWZpbmVkT3B0aW9ucy5kYXlDb3VudCxcbiAgICAgICAgICAgIGRhdGVBbGlnbm1lbnQ6IHJlZmluZWRPcHRpb25zLmRhdGVBbGlnbm1lbnQsXG4gICAgICAgICAgICBkYXRlSW5jcmVtZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlSW5jcmVtZW50LFxuICAgICAgICAgICAgaGlkZGVuRGF5czogcmVmaW5lZE9wdGlvbnMuaGlkZGVuRGF5cyxcbiAgICAgICAgICAgIHdlZWtlbmRzOiByZWZpbmVkT3B0aW9ucy53ZWVrZW5kcyxcbiAgICAgICAgICAgIG5vd0lucHV0OiByZWZpbmVkT3B0aW9ucy5ub3csXG4gICAgICAgICAgICB2YWxpZFJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZhbGlkUmFuZ2UsXG4gICAgICAgICAgICB2aXNpYmxlUmFuZ2VJbnB1dDogcmVmaW5lZE9wdGlvbnMudmlzaWJsZVJhbmdlLFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHJlZmluZWRPcHRpb25zLmZpeGVkV2Vla0NvdW50LFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHZpZXdBcGkgPSB0aGlzLmJ1aWxkVmlld0FwaSh2aWV3VHlwZSwgdGhpcy5nZXRDdXJyZW50RGF0YSwgb3B0aW9uc0RhdGEuZGF0ZUVudik7XG4gICAgICAgIHJldHVybiB7IHZpZXdTcGVjLCBvcHRpb25zOiByZWZpbmVkT3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHZpZXdBcGkgfTtcbiAgICB9XG4gICAgcHJvY2Vzc1Jhd1ZpZXdPcHRpb25zKHZpZXdTcGVjLCBwbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICBsZXQgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgdmlld1NwZWMub3B0aW9uRGVmYXVsdHMsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIHZpZXdTcGVjLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgIF0pO1xuICAgICAgICBsZXQgcmVmaW5lcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIFZJRVdfT1BUSU9OX1JFRklORVJTKSwgcGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyksIHBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzKTtcbiAgICAgICAgbGV0IHJlZmluZWQgPSB7fTtcbiAgICAgICAgbGV0IGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0O1xuICAgICAgICBsZXQgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQ7XG4gICAgICAgIGxldCBhbnlDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIGxldCBleHRyYSA9IHt9O1xuICAgICAgICBmb3IgKGxldCBvcHRpb25OYW1lIGluIHJhdykge1xuICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSB8fFxuICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0sIGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0pKSkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyYXdbb3B0aW9uTmFtZV0gPT09IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdLCB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtvcHRpb25OYW1lXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25OYW1lIGluIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQpIHsgLy8gbWlnaHQgYmUgYW4gXCJleHRyYVwiIHByb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSByYXdbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0ID0gcmF3O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCxcbiAgICAgICAgICAgIHJlZmluZWRPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQsXG4gICAgICAgICAgICBleHRyYSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERhdGVFbnYkMSh0aW1lWm9uZSwgZXhwbGljaXRMb2NhbGUsIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiwgZmlyc3REYXksIHdlZWtUZXh0LCBwbHVnaW5Ib29rcywgYXZhaWxhYmxlTG9jYWxlRGF0YSwgZGVmYXVsdFNlcGFyYXRvcikge1xuICAgIGxldCBsb2NhbGUgPSBidWlsZExvY2FsZShleHBsaWNpdExvY2FsZSB8fCBhdmFpbGFibGVMb2NhbGVEYXRhLmRlZmF1bHRDb2RlLCBhdmFpbGFibGVMb2NhbGVEYXRhLm1hcCk7XG4gICAgcmV0dXJuIG5ldyBEYXRlRW52KHtcbiAgICAgICAgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyxcbiAgICAgICAgdGltZVpvbmUsXG4gICAgICAgIG5hbWVkVGltZVpvbmVJbXBsOiBwbHVnaW5Ib29rcy5uYW1lZFRpbWVab25lZEltcGwsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgd2Vla051bWJlckNhbGN1bGF0aW9uLFxuICAgICAgICBmaXJzdERheSxcbiAgICAgICAgd2Vla1RleHQsXG4gICAgICAgIGNtZEZvcm1hdHRlcjogcGx1Z2luSG9va3MuY21kRm9ybWF0dGVyLFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRUaGVtZShvcHRpb25zLCBwbHVnaW5Ib29rcykge1xuICAgIGxldCBUaGVtZUNsYXNzID0gcGx1Z2luSG9va3MudGhlbWVDbGFzc2VzW29wdGlvbnMudGhlbWVTeXN0ZW1dIHx8IFN0YW5kYXJkVGhlbWU7XG4gICAgcmV0dXJuIG5ldyBUaGVtZUNsYXNzKG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvcihwcm9wcykge1xuICAgIGxldCBEYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzID0gcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyB8fCBEYXRlUHJvZmlsZUdlbmVyYXRvcjtcbiAgICByZXR1cm4gbmV3IERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MocHJvcHMpO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3QXBpKHR5cGUsIGdldEN1cnJlbnREYXRhLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIG5ldyBWaWV3SW1wbCh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudik7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50VWlCeVNvdXJjZShldmVudFNvdXJjZXMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChldmVudFNvdXJjZXMsIChldmVudFNvdXJjZSkgPT4gZXZlbnRTb3VyY2UudWkpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQmFzZXMoZXZlbnREZWZzLCBldmVudFVpU2luZ2xlQmFzZSwgZXZlbnRVaUJ5U291cmNlKSB7XG4gICAgbGV0IGV2ZW50VWlCYXNlcyA9IHsgJyc6IGV2ZW50VWlTaW5nbGVCYXNlIH07XG4gICAgZm9yIChsZXQgZGVmSWQgaW4gZXZlbnREZWZzKSB7XG4gICAgICAgIGxldCBkZWYgPSBldmVudERlZnNbZGVmSWRdO1xuICAgICAgICBpZiAoZGVmLnNvdXJjZUlkICYmIGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdKSB7XG4gICAgICAgICAgICBldmVudFVpQmFzZXNbZGVmSWRdID0gZXZlbnRVaUJ5U291cmNlW2RlZi5zb3VyY2VJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50VWlCYXNlcztcbn1cbmZ1bmN0aW9uIGJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KSB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY2FsZW5kYXJDb250ZXh0O1xuICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50VWlTaW5nbGVCYXNlOiBjcmVhdGVFdmVudFVpKHtcbiAgICAgICAgICAgIGRpc3BsYXk6IG9wdGlvbnMuZXZlbnREaXNwbGF5LFxuICAgICAgICAgICAgZWRpdGFibGU6IG9wdGlvbnMuZWRpdGFibGUsXG4gICAgICAgICAgICBzdGFydEVkaXRhYmxlOiBvcHRpb25zLmV2ZW50U3RhcnRFZGl0YWJsZSxcbiAgICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IG9wdGlvbnMuZXZlbnREdXJhdGlvbkVkaXRhYmxlLFxuICAgICAgICAgICAgY29uc3RyYWludDogb3B0aW9ucy5ldmVudENvbnN0cmFpbnQsXG4gICAgICAgICAgICBvdmVybGFwOiB0eXBlb2Ygb3B0aW9ucy5ldmVudE92ZXJsYXAgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuZXZlbnRPdmVybGFwIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxsb3c6IG9wdGlvbnMuZXZlbnRBbGxvdyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5ldmVudEJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmV2ZW50Qm9yZGVyQ29sb3IsXG4gICAgICAgICAgICB0ZXh0Q29sb3I6IG9wdGlvbnMuZXZlbnRUZXh0Q29sb3IsXG4gICAgICAgICAgICBjb2xvcjogb3B0aW9ucy5ldmVudENvbG9yLFxuICAgICAgICAgICAgLy8gY2xhc3NOYW1lczogb3B0aW9ucy5ldmVudENsYXNzTmFtZXMgLy8gcmVuZGVyIGhvb2sgd2lsbCBoYW5kbGUgdGhpc1xuICAgICAgICB9LCBjYWxlbmRhckNvbnRleHQpLFxuICAgICAgICBzZWxlY3Rpb25Db25maWc6IGNyZWF0ZUV2ZW50VWkoe1xuICAgICAgICAgICAgY29uc3RyYWludDogb3B0aW9ucy5zZWxlY3RDb25zdHJhaW50LFxuICAgICAgICAgICAgb3ZlcmxhcDogdHlwZW9mIG9wdGlvbnMuc2VsZWN0T3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZWxlY3RPdmVybGFwIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYWxsb3c6IG9wdGlvbnMuc2VsZWN0QWxsb3csXG4gICAgICAgIH0sIGNhbGVuZGFyQ29udGV4dCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc0xvYWRpbmcoc3RhdGUsIGNvbnRleHQpIHtcbiAgICBmb3IgKGxldCBpc0xvYWRpbmdGdW5jIG9mIGNvbnRleHQucGx1Z2luSG9va3MuaXNMb2FkaW5nRnVuY3MpIHtcbiAgICAgICAgaWYgKGlzTG9hZGluZ0Z1bmMoc3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCkge1xuICAgIHJldHVybiBwYXJzZUJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0Lm9wdGlvbnMuYnVzaW5lc3NIb3VycywgY2FsZW5kYXJDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHdhcm5Vbmtub3duT3B0aW9ucyhvcHRpb25zLCB2aWV3TmFtZSkge1xuICAgIGZvciAobGV0IG9wdGlvbk5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVua25vd24gb3B0aW9uICcke29wdGlvbk5hbWV9J2AgK1xuICAgICAgICAgICAgKHZpZXdOYW1lID8gYCBmb3IgdmlldyAnJHt2aWV3TmFtZX0nYCA6ICcnKSk7XG4gICAgfVxufVxuXG5jbGFzcyBUb29sYmFyU2VjdGlvbiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gdGhpcy5wcm9wcy53aWRnZXRHcm91cHMubWFwKCh3aWRnZXRHcm91cCkgPT4gdGhpcy5yZW5kZXJXaWRnZXRHcm91cCh3aWRnZXRHcm91cCkpO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnZGl2JywgeyBjbGFzc05hbWU6ICdmYy10b29sYmFyLWNodW5rJyB9LCAuLi5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJlbmRlcldpZGdldEdyb3VwKHdpZGdldEdyb3VwKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyB0aGVtZSB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgbGV0IGlzT25seUJ1dHRvbnMgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCB3aWRnZXQgb2Ygd2lkZ2V0R3JvdXApIHtcbiAgICAgICAgICAgIGxldCB7IGJ1dHRvbk5hbWUsIGJ1dHRvbkNsaWNrLCBidXR0b25UZXh0LCBidXR0b25JY29uLCBidXR0b25IaW50IH0gPSB3aWRnZXQ7XG4gICAgICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgICAgIGlzT25seUJ1dHRvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJoMlwiLCB7IGNsYXNzTmFtZTogXCJmYy10b29sYmFyLXRpdGxlXCIsIGlkOiBwcm9wcy50aXRsZUlkIH0sIHByb3BzLnRpdGxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgaXNQcmVzc2VkID0gYnV0dG9uTmFtZSA9PT0gcHJvcHMuYWN0aXZlQnV0dG9uO1xuICAgICAgICAgICAgICAgIGxldCBpc0Rpc2FibGVkID0gKCFwcm9wcy5pc1RvZGF5RW5hYmxlZCAmJiBidXR0b25OYW1lID09PSAndG9kYXknKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIXByb3BzLmlzUHJldkVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3ByZXYnKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIXByb3BzLmlzTmV4dEVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ25leHQnKTtcbiAgICAgICAgICAgICAgICBsZXQgYnV0dG9uQ2xhc3NlcyA9IFtgZmMtJHtidXR0b25OYW1lfS1idXR0b25gLCB0aGVtZS5nZXRDbGFzcygnYnV0dG9uJyldO1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xhc3Nlcy5wdXNoKHRoZW1lLmdldENsYXNzKCdidXR0b25BY3RpdmUnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IHR5cGU6IFwiYnV0dG9uXCIsIHRpdGxlOiB0eXBlb2YgYnV0dG9uSGludCA9PT0gJ2Z1bmN0aW9uJyA/IGJ1dHRvbkhpbnQocHJvcHMubmF2VW5pdCkgOiBidXR0b25IaW50LCBkaXNhYmxlZDogaXNEaXNhYmxlZCwgXCJhcmlhLXByZXNzZWRcIjogaXNQcmVzc2VkLCBjbGFzc05hbWU6IGJ1dHRvbkNsYXNzZXMuam9pbignICcpLCBvbkNsaWNrOiBidXR0b25DbGljayB9LCBidXR0b25UZXh0IHx8IChidXR0b25JY29uID8gY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGJ1dHRvbkljb24sIHJvbGU6IFwiaW1nXCIgfSkgOiAnJykpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IGdyb3VwQ2xhc3NOYW1lID0gKGlzT25seUJ1dHRvbnMgJiYgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbkdyb3VwJykpIHx8ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHsgY2xhc3NOYW1lOiBncm91cENsYXNzTmFtZSB9LCAuLi5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuWzBdO1xuICAgIH1cbn1cblxuY2xhc3MgVG9vbGJhciBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgbW9kZWwsIGV4dHJhQ2xhc3NOYW1lIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgZm9yY2VMdHIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0Q29udGVudDtcbiAgICAgICAgbGV0IGVuZENvbnRlbnQ7XG4gICAgICAgIGxldCBzZWN0aW9uV2lkZ2V0cyA9IG1vZGVsLnNlY3Rpb25XaWRnZXRzO1xuICAgICAgICBsZXQgY2VudGVyQ29udGVudCA9IHNlY3Rpb25XaWRnZXRzLmNlbnRlcjtcbiAgICAgICAgaWYgKHNlY3Rpb25XaWRnZXRzLmxlZnQpIHtcbiAgICAgICAgICAgIGZvcmNlTHRyID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0YXJ0Q29udGVudCA9IHNlY3Rpb25XaWRnZXRzLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VjdGlvbldpZGdldHMucmlnaHQpIHtcbiAgICAgICAgICAgIGZvcmNlTHRyID0gdHJ1ZTtcbiAgICAgICAgICAgIGVuZENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZENvbnRlbnQgPSBzZWN0aW9uV2lkZ2V0cy5lbmQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICAgICBleHRyYUNsYXNzTmFtZSB8fCAnJyxcbiAgICAgICAgICAgICdmYy10b29sYmFyJyxcbiAgICAgICAgICAgIGZvcmNlTHRyID8gJ2ZjLXRvb2xiYXItbHRyJyA6ICcnLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpIH0sXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ3N0YXJ0Jywgc3RhcnRDb250ZW50IHx8IFtdKSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VjdGlvbignY2VudGVyJywgY2VudGVyQ29udGVudCB8fCBbXSksXG4gICAgICAgICAgICB0aGlzLnJlbmRlclNlY3Rpb24oJ2VuZCcsIGVuZENvbnRlbnQgfHwgW10pKSk7XG4gICAgfVxuICAgIHJlbmRlclNlY3Rpb24oa2V5LCB3aWRnZXRHcm91cHMpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChUb29sYmFyU2VjdGlvbiwgeyBrZXk6IGtleSwgd2lkZ2V0R3JvdXBzOiB3aWRnZXRHcm91cHMsIHRpdGxlOiBwcm9wcy50aXRsZSwgbmF2VW5pdDogcHJvcHMubmF2VW5pdCwgYWN0aXZlQnV0dG9uOiBwcm9wcy5hY3RpdmVCdXR0b24sIGlzVG9kYXlFbmFibGVkOiBwcm9wcy5pc1RvZGF5RW5hYmxlZCwgaXNQcmV2RW5hYmxlZDogcHJvcHMuaXNQcmV2RW5hYmxlZCwgaXNOZXh0RW5hYmxlZDogcHJvcHMuaXNOZXh0RW5hYmxlZCwgdGl0bGVJZDogcHJvcHMudGl0bGVJZCB9KSk7XG4gICAgfVxufVxuXG5jbGFzcyBWaWV3SGFybmVzcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgYXZhaWxhYmxlV2lkdGg6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF2YWlsYWJsZVdpZHRoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBdmFpbGFibGVXaWR0aCgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgYXNwZWN0UmF0aW8gfSA9IHByb3BzO1xuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy12aWV3LWhhcm5lc3MnLFxuICAgICAgICAgICAgKGFzcGVjdFJhdGlvIHx8IHByb3BzLmxpcXVpZCB8fCBwcm9wcy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgPyAnZmMtdmlldy1oYXJuZXNzLWFjdGl2ZScgLy8gaGFybmVzcyBjb250cm9scyB0aGUgaGVpZ2h0XG4gICAgICAgICAgICAgICAgOiAnZmMtdmlldy1oYXJuZXNzLXBhc3NpdmUnLCAvLyBsZXQgdGhlIHZpZXcgZG8gdGhlIGhlaWdodFxuICAgICAgICBdO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gJyc7XG4gICAgICAgIGxldCBwYWRkaW5nQm90dG9tID0gJyc7XG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmF2YWlsYWJsZVdpZHRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc3RhdGUuYXZhaWxhYmxlV2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdoaWxlIHdhaXRpbmcgdG8ga25vdyBhdmFpbGFibGVXaWR0aCwgd2UgY2FuJ3Qgc2V0IGhlaWdodCB0byAqemVybypcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdpbGwgY2F1c2UgbG90cyBvZiB1bm5lY2Vzc2FyeSBzY3JvbGxiYXJzIHdpdGhpbiBzY3JvbGxncmlkLlxuICAgICAgICAgICAgICAgIC8vIEJFVFRFUjogZG9uJ3Qgc3RhcnQgcmVuZGVyaW5nIEFOWVRISU5HIHlldCB1bnRpbCB3ZSBrbm93IGNvbnRhaW5lciB3aWR0aFxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdoeSBub3QgYWx3YXlzIHVzZSBwYWRkaW5nQm90dG9tPyBDYXVzZXMgaGVpZ2h0IG9zY2lsbGF0aW9uIChpc3N1ZSA1NjA2KVxuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b20gPSBgJHsoMSAvIGFzcGVjdFJhdGlvKSAqIDEwMH0lYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHByb3BzLmhlaWdodCB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImFyaWEtbGFiZWxsZWRieVwiOiBwcm9wcy5sYWJlbGVkQnlJZCwgcmVmOiB0aGlzLmhhbmRsZUVsLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBzdHlsZTogeyBoZWlnaHQsIHBhZGRpbmdCb3R0b20gfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH1cbiAgICB1cGRhdGVBdmFpbGFibGVXaWR0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWwgJiYgLy8gbmVlZGVkLiBidXQgd2h5P1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5hc3BlY3RSYXRpbyAvLyBhc3BlY3RSYXRpbyBpcyB0aGUgb25seSBoZWlnaHQgc2V0dGluZyB0aGF0IG5lZWRzIGF2YWlsYWJsZVdpZHRoXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGF2YWlsYWJsZVdpZHRoOiB0aGlzLmVsLm9mZnNldFdpZHRoIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKlxuRGV0ZWN0cyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiBhbiBldmVudCB3aXRoaW4gYSBEYXRlQ29tcG9uZW50XG4qL1xuY2xhc3MgRXZlbnRDbGlja2luZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VnQ2xpY2sgPSAoZXYsIHNlZ0VsKSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgc2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICAgICAgaWYgKHNlZyAmJiAvLyBtaWdodCBiZSB0aGUgPGRpdj4gc3Vycm91bmRpbmcgdGhlIG1vcmUgbGlua1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAvLyBvdXIgd2F5IHRvIHNpbXVsYXRlIGEgbGluayBjbGljayBmb3IgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSA8YT4gdGFnc1xuICAgICAgICAgICAgICAgIC8vIGdyYWIgYmVmb3JlIHRyaWdnZXIgZmlyZWQgaW4gY2FzZSB0cmlnZ2VyIHRyYXNoZXMgRE9NIHRocnUgcmVyZW5kZXJpbmdcbiAgICAgICAgICAgICAgICBsZXQgaGFzVXJsQ29udGFpbmVyID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCAnLmZjLWV2ZW50LWZvcmNlZC11cmwnKTtcbiAgICAgICAgICAgICAgICBsZXQgdXJsID0gaGFzVXJsQ29udGFpbmVyID8gaGFzVXJsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2FbaHJlZl0nKS5ocmVmIDogJyc7XG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29tcG9uZW50LmNvbnRleHQsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh1cmwgJiYgIWV2LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBsaXN0ZW5CeVNlbGVjdG9yKHNldHRpbmdzLmVsLCAnY2xpY2snLCAnLmZjLWV2ZW50JywgLy8gb24gYm90aCBmZyBhbmQgYmcgZXZlbnRzXG4gICAgICAgIHRoaXMuaGFuZGxlU2VnQ2xpY2spO1xuICAgIH1cbn1cblxuLypcblRyaWdnZXJzIGV2ZW50cyBhbmQgYWRkcy9yZW1vdmVzIGNvcmUgY2xhc3NOYW1lcyB3aGVuIHRoZSB1c2VyJ3MgcG9pbnRlclxuZW50ZXJzL2xlYXZlcyBldmVudC1lbGVtZW50cyBvZiBhIGNvbXBvbmVudC5cbiovXG5jbGFzcyBFdmVudEhvdmVyaW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgLy8gZm9yIHNpbXVsYXRpbmcgYW4gZXZlbnRNb3VzZUxlYXZlIHdoZW4gdGhlIGV2ZW50IGVsIGlzIGRlc3Ryb3llZCB3aGlsZSBtb3VzZSBpcyBvdmVyIGl0XG4gICAgICAgIHRoaXMuaGFuZGxlRXZlbnRFbFJlbW92ZSA9IChlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVsID09PSB0aGlzLmN1cnJlbnRTZWdFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2VnTGVhdmUobnVsbCwgdGhpcy5jdXJyZW50U2VnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNlZ0VudGVyID0gKGV2LCBzZWdFbCkgPT4ge1xuICAgICAgICAgICAgaWYgKGdldEVsU2VnKHNlZ0VsKSkgeyAvLyBUT0RPOiBiZXR0ZXIgd2F5IHRvIG1ha2Ugc3VyZSBub3QgaG92ZXJpbmcgb3ZlciBtb3JlKyBsaW5rIG9yIGl0cyB3cmFwcGVyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VnRWwgPSBzZWdFbDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgnZXZlbnRNb3VzZUVudGVyJywgZXYsIHNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWdMZWF2ZSA9IChldiwgc2VnRWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTZWdFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNlZ0VsID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudCgnZXZlbnRNb3VzZUxlYXZlJywgZXYsIHNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW1vdmVIb3Zlckxpc3RlbmVycyA9IGxpc3RlblRvSG92ZXJCeVNlbGVjdG9yKHNldHRpbmdzLmVsLCAnLmZjLWV2ZW50JywgLy8gb24gYm90aCBmZyBhbmQgYmcgZXZlbnRzXG4gICAgICAgIHRoaXMuaGFuZGxlU2VnRW50ZXIsIHRoaXMuaGFuZGxlU2VnTGVhdmUpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZUhvdmVyTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHRyaWdnZXJFdmVudChwdWJsaWNFdk5hbWUsIGV2LCBzZWdFbCkge1xuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGNvbnRleHQgfSA9IGNvbXBvbmVudDtcbiAgICAgICAgbGV0IHNlZyA9IGdldEVsU2VnKHNlZ0VsKTtcbiAgICAgICAgaWYgKCFldiB8fCBjb21wb25lbnQuaXNWYWxpZFNlZ0Rvd25FbChldi50YXJnZXQpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcihwdWJsaWNFdk5hbWUsIHtcbiAgICAgICAgICAgICAgICBlbDogc2VnRWwsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEltcGwoY29udGV4dCwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIENhbGVuZGFyQ29udGVudCBleHRlbmRzIFB1cmVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld0NvbnRleHQgPSBtZW1vaXplKGJ1aWxkVmlld0NvbnRleHQpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMgPSBtZW1vaXplKGJ1aWxkVmlld1Byb3BUcmFuc2Zvcm1lcnMpO1xuICAgICAgICB0aGlzLmJ1aWxkVG9vbGJhclByb3BzID0gbWVtb2l6ZShidWlsZFRvb2xiYXJQcm9wcyk7XG4gICAgICAgIHRoaXMuaGVhZGVyUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuZm9vdGVyUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmUgPSB7fTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2aWV3TGFiZWxJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29tcG9uZW50IFJlZ2lzdHJhdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSAoY29tcG9uZW50LCBzZXR0aW5nc0lucHV0KSA9PiB7XG4gICAgICAgICAgICBsZXQgc2V0dGluZ3MgPSBwYXJzZUludGVyYWN0aW9uU2V0dGluZ3MoY29tcG9uZW50LCBzZXR0aW5nc0lucHV0KTtcbiAgICAgICAgICAgIGxldCBERUZBVUxUX0lOVEVSQUNUSU9OUyA9IFtcbiAgICAgICAgICAgICAgICBFdmVudENsaWNraW5nLFxuICAgICAgICAgICAgICAgIEV2ZW50SG92ZXJpbmcsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uQ2xhc3NlcyA9IERFRkFVTFRfSU5URVJBQ1RJT05TLmNvbmNhdCh0aGlzLnByb3BzLnBsdWdpbkhvb2tzLmNvbXBvbmVudEludGVyYWN0aW9ucyk7XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25zID0gaW50ZXJhY3Rpb25DbGFzc2VzLm1hcCgoVGhlSW50ZXJhY3Rpb25DbGFzcykgPT4gbmV3IFRoZUludGVyYWN0aW9uQ2xhc3Moc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF0gPSBpbnRlcmFjdGlvbnM7XG4gICAgICAgICAgICBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF0gPSBzZXR0aW5ncztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQgPSAoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgbGlzdGVuZXJzID0gdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pbnRlcmFjdGlvbnNTdG9yZVtjb21wb25lbnQudWlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbGV0ZSBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFJlc2l6aW5nXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMucmVzaXplUnVubmVyID0gbmV3IERlbGF5ZWRSdW5uZXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ19yZXNpemUnLCB0cnVlKTsgLy8gc2hvdWxkIHdpbmRvdyByZXNpemVzIGJlIGNvbnNpZGVyZWQgXCJmb3JjZWRcIiA/XG4gICAgICAgICAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignd2luZG93UmVzaXplJywgeyB2aWV3OiB0aGlzLnByb3BzLnZpZXdBcGkgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhbmRsZVdpbmRvd1Jlc2l6ZSAmJlxuICAgICAgICAgICAgICAgIGV2LnRhcmdldCA9PT0gd2luZG93IC8vIGF2b2lkIGpxdWkgZXZlbnRzXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVJ1bm5lci5yZXF1ZXN0KG9wdGlvbnMud2luZG93UmVzaXplRGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKlxuICAgIHJlbmRlcnMgSU5TSURFIG9mIGFuIG91dGVyIGRpdlxuICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgdG9vbGJhckNvbmZpZywgb3B0aW9ucyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB0b29sYmFyUHJvcHMgPSB0aGlzLmJ1aWxkVG9vbGJhclByb3BzKHByb3BzLnZpZXdTcGVjLCBwcm9wcy5kYXRlUHJvZmlsZSwgcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHByb3BzLmN1cnJlbnREYXRlLCBnZXROb3cocHJvcHMub3B0aW9ucy5ub3csIHByb3BzLmRhdGVFbnYpLCAvLyBUT0RPOiB1c2UgTm93VGltZXI/Pz8/XG4gICAgICAgIHByb3BzLnZpZXdUaXRsZSk7XG4gICAgICAgIGxldCB2aWV3Vkdyb3cgPSBmYWxzZTtcbiAgICAgICAgbGV0IHZpZXdIZWlnaHQgPSAnJztcbiAgICAgICAgbGV0IHZpZXdBc3BlY3RSYXRpbztcbiAgICAgICAgaWYgKHByb3BzLmlzSGVpZ2h0QXV0byB8fCBwcm9wcy5mb3JQcmludCkge1xuICAgICAgICAgICAgdmlld0hlaWdodCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZpZXdWR3JvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5jb250ZW50SGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZpZXdIZWlnaHQgPSBvcHRpb25zLmNvbnRlbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2aWV3QXNwZWN0UmF0aW8gPSBNYXRoLm1heChvcHRpb25zLmFzcGVjdFJhdGlvLCAwLjUpOyAvLyBwcmV2ZW50IGZyb20gZ2V0dGluZyB0b28gdGFsbFxuICAgICAgICB9XG4gICAgICAgIGxldCB2aWV3Q29udGV4dCA9IHRoaXMuYnVpbGRWaWV3Q29udGV4dChwcm9wcy52aWV3U3BlYywgcHJvcHMudmlld0FwaSwgcHJvcHMub3B0aW9ucywgcHJvcHMuZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIHByb3BzLmRhdGVFbnYsIHByb3BzLnRoZW1lLCBwcm9wcy5wbHVnaW5Ib29rcywgcHJvcHMuZGlzcGF0Y2gsIHByb3BzLmdldEN1cnJlbnREYXRhLCBwcm9wcy5lbWl0dGVyLCBwcm9wcy5jYWxlbmRhckFwaSwgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LCB0aGlzLnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCk7XG4gICAgICAgIGxldCB2aWV3TGFiZWxJZCA9ICh0b29sYmFyQ29uZmlnLmhlYWRlciAmJiB0b29sYmFyQ29uZmlnLmhlYWRlci5oYXNUaXRsZSlcbiAgICAgICAgICAgID8gdGhpcy5zdGF0ZS52aWV3TGFiZWxJZFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuUHJvdmlkZXIsIHsgdmFsdWU6IHZpZXdDb250ZXh0IH0sXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLmhlYWRlciAmJiAoY3JlYXRlRWxlbWVudChUb29sYmFyLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLmhlYWRlclJlZiwgZXh0cmFDbGFzc05hbWU6IFwiZmMtaGVhZGVyLXRvb2xiYXJcIiwgbW9kZWw6IHRvb2xiYXJDb25maWcuaGVhZGVyLCB0aXRsZUlkOiB2aWV3TGFiZWxJZCB9LCB0b29sYmFyUHJvcHMpKSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFZpZXdIYXJuZXNzLCB7IGxpcXVpZDogdmlld1ZHcm93LCBoZWlnaHQ6IHZpZXdIZWlnaHQsIGFzcGVjdFJhdGlvOiB2aWV3QXNwZWN0UmF0aW8sIGxhYmVsZWRCeUlkOiB2aWV3TGFiZWxJZCB9LFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVmlldyhwcm9wcyksXG4gICAgICAgICAgICAgICAgdGhpcy5idWlsZEFwcGVuZENvbnRlbnQoKSksXG4gICAgICAgICAgICB0b29sYmFyQ29uZmlnLmZvb3RlciAmJiAoY3JlYXRlRWxlbWVudChUb29sYmFyLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLmZvb3RlclJlZiwgZXh0cmFDbGFzc05hbWU6IFwiZmMtZm9vdGVyLXRvb2xiYXJcIiwgbW9kZWw6IHRvb2xiYXJDb25maWcuZm9vdGVyLCB0aXRsZUlkOiBcIlwiIH0sIHRvb2xiYXJQcm9wcykpKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJJbnRlcmFjdGlvbnMgPSBwcm9wcy5wbHVnaW5Ib29rcy5jYWxlbmRhckludGVyYWN0aW9uc1xuICAgICAgICAgICAgLm1hcCgoQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKSA9PiBuZXcgQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzKHByb3BzKSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICAgIGxldCB7IHByb3BTZXRIYW5kbGVycyB9ID0gcHJvcHMucGx1Z2luSG9va3M7XG4gICAgICAgIGZvciAobGV0IHByb3BOYW1lIGluIHByb3BTZXRIYW5kbGVycykge1xuICAgICAgICAgICAgcHJvcFNldEhhbmRsZXJzW3Byb3BOYW1lXShwcm9wc1twcm9wTmFtZV0sIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwcm9wU2V0SGFuZGxlcnMgfSA9IHByb3BzLnBsdWdpbkhvb2tzO1xuICAgICAgICBmb3IgKGxldCBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gIT09IHByZXZQcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBwcm9wU2V0SGFuZGxlcnNbcHJvcE5hbWVdKHByb3BzW3Byb3BOYW1lXSwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICB0aGlzLnJlc2l6ZVJ1bm5lci5jbGVhcigpO1xuICAgICAgICBmb3IgKGxldCBpbnRlcmFjdGlvbiBvZiB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zKSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ191bm1vdW50Jyk7XG4gICAgfVxuICAgIGJ1aWxkQXBwZW5kQ29udGVudCgpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHByb3BzLnBsdWdpbkhvb2tzLnZpZXdDb250YWluZXJBcHBlbmRzLm1hcCgoYnVpbGRBcHBlbmRDb250ZW50KSA9PiBidWlsZEFwcGVuZENvbnRlbnQocHJvcHMpKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCAuLi5jaGlsZHJlbik7XG4gICAgfVxuICAgIHJlbmRlclZpZXcocHJvcHMpIHtcbiAgICAgICAgbGV0IHsgcGx1Z2luSG9va3MgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyB2aWV3U3BlYyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB2aWV3UHJvcHMgPSB7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogcHJvcHMucmVuZGVyYWJsZUV2ZW50U3RvcmUsXG4gICAgICAgICAgICBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcyxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXG4gICAgICAgICAgICBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZyxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSxcbiAgICAgICAgICAgIGlzSGVpZ2h0QXV0bzogcHJvcHMuaXNIZWlnaHRBdXRvLFxuICAgICAgICAgICAgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgdHJhbnNmb3JtZXJzID0gdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHBsdWdpbkhvb2tzLnZpZXdQcm9wc1RyYW5zZm9ybWVycyk7XG4gICAgICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIHRyYW5zZm9ybWVycykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih2aWV3UHJvcHMsIHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh2aWV3UHJvcHMsIHByb3BzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFZpZXdDb21wb25lbnQgPSB2aWV3U3BlYy5jb21wb25lbnQ7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29tcG9uZW50LCBPYmplY3QuYXNzaWduKHt9LCB2aWV3UHJvcHMpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRUb29sYmFyUHJvcHModmlld1NwZWMsIGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgY3VycmVudERhdGUsIG5vdywgdGl0bGUpIHtcbiAgICAvLyBkb24ndCBmb3JjZSBhbnkgZGF0ZS1wcm9maWxlcyB0byB2YWxpZCBkYXRlIHByb2ZpbGVzICh0aGUgYGZhbHNlYCkgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBpdCdzIGludmFsaWRcbiAgICBsZXQgdG9kYXlJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQobm93LCB1bmRlZmluZWQsIGZhbHNlKTsgLy8gVE9ETzogbmVlZCBgdW5kZWZpbmVkYCBvciBlbHNlIElORklOSVRFIExPT1AgZm9yIHNvbWUgcmVhc29uXG4gICAgbGV0IHByZXZJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpO1xuICAgIGxldCBuZXh0SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZSxcbiAgICAgICAgYWN0aXZlQnV0dG9uOiB2aWV3U3BlYy50eXBlLFxuICAgICAgICBuYXZVbml0OiB2aWV3U3BlYy5zaW5nbGVVbml0LFxuICAgICAgICBpc1RvZGF5RW5hYmxlZDogdG9kYXlJbmZvLmlzVmFsaWQgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBub3cpLFxuICAgICAgICBpc1ByZXZFbmFibGVkOiBwcmV2SW5mby5pc1ZhbGlkLFxuICAgICAgICBpc05leHRFbmFibGVkOiBuZXh0SW5mby5pc1ZhbGlkLFxuICAgIH07XG59XG4vLyBQbHVnaW5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHRoZUNsYXNzZXMpIHtcbiAgICByZXR1cm4gdGhlQ2xhc3Nlcy5tYXAoKFRoZUNsYXNzKSA9PiBuZXcgVGhlQ2xhc3MoKSk7XG59XG5cbmNsYXNzIENhbGVuZGFyIGV4dGVuZHMgQ2FsZW5kYXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgb3B0aW9uT3ZlcnJpZGVzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVuZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2xhc3NOYW1lcyA9IFtdO1xuICAgICAgICB0aGlzLmN1c3RvbUNvbnRlbnRSZW5kZXJJZCA9IDA7XG4gICAgICAgIHRoaXMuaGFuZGxlQWN0aW9uID0gKGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgLy8gYWN0aW9ucyB3ZSBrbm93IHdlIHdhbnQgdG8gcmVuZGVyIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9SRVNJWkUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci50cnlEcmFpbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURhdGEgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KGRhdGEuY2FsZW5kYXJPcHRpb25zLnJlcmVuZGVyRGVsYXkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlbmRlclJlcXVlc3QgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1JlbmRlcmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGV0IHsgY3VycmVudERhdGEgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyKGNyZWF0ZUVsZW1lbnQoQ2FsZW5kYXJSb290LCB7IG9wdGlvbnM6IGN1cnJlbnREYXRhLmNhbGVuZGFyT3B0aW9ucywgdGhlbWU6IGN1cnJlbnREYXRhLnRoZW1lLCBlbWl0dGVyOiBjdXJyZW50RGF0YS5lbWl0dGVyIH0sIChjbGFzc05hbWVzLCBoZWlnaHQsIGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lcyhjbGFzc05hbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoUmVuZGVySWQuUHJvdmlkZXIsIHsgdmFsdWU6IHRoaXMuY3VzdG9tQ29udGVudFJlbmRlcklkIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChDYWxlbmRhckNvbnRlbnQsIE9iamVjdC5hc3NpZ24oeyBpc0hlaWdodEF1dG86IGlzSGVpZ2h0QXV0bywgZm9yUHJpbnQ6IGZvclByaW50IH0sIGN1cnJlbnREYXRhKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSksIHRoaXMuZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc1JlbmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVuZGVyKG51bGwsIHRoaXMuZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3NOYW1lcyhbXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIZWlnaHQoJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlbnN1cmVFbEhhc1N0eWxlcyhlbCk7XG4gICAgICAgIHRoaXMuZWwgPSBlbDtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcih0aGlzLmhhbmRsZVJlbmRlclJlcXVlc3QpO1xuICAgICAgICBuZXcgQ2FsZW5kYXJEYXRhTWFuYWdlcih7XG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogdGhpcyxcbiAgICAgICAgICAgIG9uQWN0aW9uOiB0aGlzLmhhbmRsZUFjdGlvbixcbiAgICAgICAgICAgIG9uRGF0YTogdGhpcy5oYW5kbGVEYXRhLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgd2FzUmVuZGVyaW5nID0gdGhpcy5pc1JlbmRlcmluZztcbiAgICAgICAgaWYgKCF3YXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21Db250ZW50UmVuZGVySWQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KCk7XG4gICAgICAgIGlmICh3YXNSZW5kZXJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzUmVuZGVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlbmRlclJ1bm5lci5yZXF1ZXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU2l6ZSgpIHtcbiAgICAgICAgZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgICAgIHN1cGVyLnVwZGF0ZVNpemUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJhdGNoUmVuZGVyaW5nKGZ1bmMpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucGF1c2UoJ2JhdGNoUmVuZGVyaW5nJyk7XG4gICAgICAgIGZ1bmMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVzdW1lKCdiYXRjaFJlbmRlcmluZycpO1xuICAgIH1cbiAgICBwYXVzZVJlbmRlcmluZygpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucGF1c2UoJ3BhdXNlUmVuZGVyaW5nJyk7XG4gICAgfVxuICAgIHJlc3VtZVJlbmRlcmluZygpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJSdW5uZXIucmVzdW1lKCdwYXVzZVJlbmRlcmluZycsIHRydWUpO1xuICAgIH1cbiAgICByZXNldE9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBjaGFuZ2VkT3B0aW9uTmFtZXMpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0YU1hbmFnZXIucmVzZXRPcHRpb25zKG9wdGlvbk92ZXJyaWRlcywgY2hhbmdlZE9wdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgc2V0Q2xhc3NOYW1lcyhjbGFzc05hbWVzKSB7XG4gICAgICAgIGlmICghaXNBcnJheXNFcXVhbChjbGFzc05hbWVzLCB0aGlzLmN1cnJlbnRDbGFzc05hbWVzKSkge1xuICAgICAgICAgICAgbGV0IHsgY2xhc3NMaXN0IH0gPSB0aGlzLmVsO1xuICAgICAgICAgICAgZm9yIChsZXQgY2xhc3NOYW1lIG9mIHRoaXMuY3VycmVudENsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgICAgIGNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudENsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICAgICAgYXBwbHlTdHlsZVByb3AodGhpcy5lbCwgJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGVJbnB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGRhdGVFbnYgPSBidWlsZERhdGVFbnYob3B0aW9ucyk7XG4gICAgbGV0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zKTtcbiAgICBsZXQgZGF0ZU1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZGF0ZUlucHV0KTtcbiAgICBpZiAoIWRhdGVNZXRhKSB7IC8vIFRPRE86IHdhcm5pbmc/XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGRhdGVNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFR6bzogZGF0ZU1ldGEuZm9yY2VkVHpvLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0UmFuZ2Uoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgZGF0ZUVudiA9IGJ1aWxkRGF0ZUVudih0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucyA/IG9wdGlvbnMgOiB7fSk7IC8vIHBhc3MgaW4gaWYgbm9uLW51bGwgb2JqZWN0XG4gICAgbGV0IGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zKTtcbiAgICBsZXQgc3RhcnRNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKHN0YXJ0SW5wdXQpO1xuICAgIGxldCBlbmRNZXRhID0gZGF0ZUVudi5jcmVhdGVNYXJrZXJNZXRhKGVuZElucHV0KTtcbiAgICBpZiAoIXN0YXJ0TWV0YSB8fCAhZW5kTWV0YSkgeyAvLyBUT0RPOiB3YXJuaW5nP1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBkYXRlRW52LmZvcm1hdFJhbmdlKHN0YXJ0TWV0YS5tYXJrZXIsIGVuZE1ldGEubWFya2VyLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YS5mb3JjZWRUem8sXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZW5kTWV0YS5mb3JjZWRUem8sXG4gICAgICAgIGlzRW5kRXhjbHVzaXZlOiBvcHRpb25zLmlzRW5kRXhjbHVzaXZlLFxuICAgICAgICBkZWZhdWx0U2VwYXJhdG9yOiBCQVNFX09QVElPTl9ERUZBVUxUUy5kZWZhdWx0UmFuZ2VTZXBhcmF0b3IsXG4gICAgfSk7XG59XG4vLyBUT0RPOiBtb3JlIERSWSBhbmQgb3B0aW1pemVkXG5mdW5jdGlvbiBidWlsZERhdGVFbnYoc2V0dGluZ3MpIHtcbiAgICBsZXQgbG9jYWxlID0gYnVpbGRMb2NhbGUoc2V0dGluZ3MubG9jYWxlIHx8ICdlbicsIG9yZ2FuaXplUmF3TG9jYWxlcyhbXSkubWFwKTsgLy8gVE9ETzogZG9uJ3QgaGFyZGNvZGUgJ2VuJyBldmVyeXdoZXJlXG4gICAgcmV0dXJuIG5ldyBEYXRlRW52KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHRpbWVab25lOiBCQVNFX09QVElPTl9ERUZBVUxUUy50aW1lWm9uZSwgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyB9LCBzZXR0aW5ncyksIHsgbG9jYWxlIH0pKTtcbn1cblxuLy8gSEVMUEVSU1xuLypcbmlmIG5leHREYXlUaHJlc2hvbGQgaXMgc3BlY2lmaWVkLCBzbGljaW5nIGlzIGRvbmUgaW4gYW4gYWxsLWRheSBmYXNoaW9uLlxueW91IGNhbiBnZXQgbmV4dERheVRocmVzaG9sZCBmcm9tIGNvbnRleHQubmV4dERheVRocmVzaG9sZFxuKi9cbmZ1bmN0aW9uIHNsaWNlRXZlbnRzKHByb3BzLCBhbGxEYXkpIHtcbiAgICByZXR1cm4gc2xpY2VFdmVudFN0b3JlKHByb3BzLmV2ZW50U3RvcmUsIHByb3BzLmV2ZW50VWlCYXNlcywgcHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGFsbERheSA/IHByb3BzLm5leHREYXlUaHJlc2hvbGQgOiBudWxsKS5mZztcbn1cblxuY29uc3QgdmVyc2lvbiA9ICc2LjEuMTUnO1xuXG5leHBvcnQgeyBDYWxlbmRhciwgY3JlYXRlUGx1Z2luLCBmb3JtYXREYXRlLCBmb3JtYXRSYW5nZSwgZ2xvYmFsTG9jYWxlcywgZ2xvYmFsUGx1Z2lucywgc2xpY2VFdmVudHMsIHZlcnNpb24gfTtcbiIsICJpbXBvcnQgeyBEYXRlQ29tcG9uZW50LCBnZXRTdGlja3lIZWFkZXJEYXRlcywgVmlld0NvbnRhaW5lciwgU2ltcGxlU2Nyb2xsR3JpZCwgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyLCByZW5kZXJTY3JvbGxTaGltLCBjcmVhdGVGb3JtYXR0ZXIsIEJhc2VDb21wb25lbnQsIFN0YW5kYXJkRXZlbnQsIGJ1aWxkU2VnVGltZVRleHQsIEV2ZW50Q29udGFpbmVyLCBnZXRTZWdBbmNob3JBdHRycywgbWVtb2l6ZSwgTW9yZUxpbmtDb250YWluZXIsIGdldFNlZ01ldGEsIGdldFVuaXF1ZURvbUlkLCBzZXRSZWYsIERheUNlbGxDb250YWluZXIsIFdlZWtOdW1iZXJDb250YWluZXIsIGJ1aWxkTmF2TGlua0F0dHJzLCBoYXNDdXN0b21EYXlDZWxsQ29udGVudCwgYWRkTXMsIGludGVyc2VjdFJhbmdlcywgYWRkRGF5cywgU2VnSGllcmFyY2h5LCBidWlsZEVudHJ5S2V5LCBpbnRlcnNlY3RTcGFucywgUmVmTWFwLCBzb3J0RXZlbnRTZWdzLCBpc1Byb3BzRXF1YWwsIGJ1aWxkRXZlbnRSYW5nZUtleSwgQmdFdmVudCwgcmVuZGVyRmlsbCwgUG9zaXRpb25DYWNoZSwgTm93VGltZXIsIGZvcm1hdElzb01vbnRoU3RyLCBmb3JtYXREYXlTdHJpbmcsIFNsaWNlciwgRGF5SGVhZGVyLCBEYXlTZXJpZXNNb2RlbCwgRGF5VGFibGVNb2RlbCwgRGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGFkZFdlZWtzLCBkaWZmV2Vla3MsIGluamVjdFN0eWxlcyB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgeyBjcmVhdGVSZWYsIGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL3ByZWFjdC5qcyc7XG5cbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciB0aGUgZGF5Z3JpZCB2aWV3cywgYXMgd2VsbCBhcyBtb250aCB2aWV3LiBSZW5kZXJzIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNlbGxzLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBJdCBpcyBhIG1hbmFnZXIgZm9yIGEgVGFibGUgc3ViY29tcG9uZW50LCB3aGljaCBkb2VzIG1vc3Qgb2YgdGhlIGhlYXZ5IGxpZnRpbmcuXG4vLyBJdCBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgd2lkdGgvaGVpZ2h0LlxuY2xhc3MgVGFibGVWaWV3IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaGVhZGVyRWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICB9XG4gICAgcmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlclJvd0NvbnRlbnQsIGJvZHlDb250ZW50KSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgaWYgKGhlYWRlclJvd0NvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHN0aWNreUhlYWRlckRhdGVzLFxuICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICB0YWJsZUNsYXNzTmFtZTogJ2ZjLWNvbC1oZWFkZXInLFxuICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgY2h1bms6IHsgY29udGVudDogYm9keUNvbnRlbnQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNpbXBsZVNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbHM6IFtdIC8qIFRPRE86IG1ha2Ugb3B0aW9uYWw/ICovLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVySFNjcm9sbExheW91dChoZWFkZXJSb3dDb250ZW50LCBib2R5Q29udGVudCwgY29sQ250LCBkYXlNaW5XaWR0aCkge1xuICAgICAgICBsZXQgU2Nyb2xsR3JpZCA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rcy5zY3JvbGxHcmlkSW1wbDtcbiAgICAgICAgaWYgKCFTY3JvbGxHcmlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNjcm9sbEdyaWQgaW1wbGVtZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAga2V5OiAnYm9keScsXG4gICAgICAgICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBib2R5Q29udGVudCxcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiByZW5kZXJTY3JvbGxTaGltLFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sR3JvdXBzOiBbeyBjb2xzOiBbeyBzcGFuOiBjb2xDbnQsIG1pbldpZHRoOiBkYXlNaW5XaWR0aCB9XSB9XSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzcGxpdFNlZ3NCeVJvdyhzZWdzLCByb3dDbnQpIHtcbiAgICBsZXQgYnlSb3cgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgIGJ5Um93W2ldID0gW107XG4gICAgfVxuICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGJ5Um93W3NlZy5yb3ddLnB1c2goc2VnKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5Um93O1xufVxuZnVuY3Rpb24gc3BsaXRTZWdzQnlGaXJzdENvbChzZWdzLCBjb2xDbnQpIHtcbiAgICBsZXQgYnlDb2wgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgIGJ5Q29sW2ldID0gW107XG4gICAgfVxuICAgIGZvciAobGV0IHNlZyBvZiBzZWdzKSB7XG4gICAgICAgIGJ5Q29sW3NlZy5maXJzdENvbF0ucHVzaChzZWcpO1xuICAgIH1cbiAgICByZXR1cm4gYnlDb2w7XG59XG5mdW5jdGlvbiBzcGxpdEludGVyYWN0aW9uQnlSb3codWksIHJvd0NudCkge1xuICAgIGxldCBieVJvdyA9IFtdO1xuICAgIGlmICghdWkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogdWkuYWZmZWN0ZWRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdWkuaXNFdmVudCxcbiAgICAgICAgICAgICAgICBzZWdzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2VnIG9mIHVpLnNlZ3MpIHtcbiAgICAgICAgICAgIGJ5Um93W3NlZy5yb3ddLnNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cblxuY29uc3QgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIG9taXRaZXJvTWludXRlOiB0cnVlLFxuICAgIG1lcmlkaWVtOiAnbmFycm93Jyxcbn0pO1xuZnVuY3Rpb24gaGFzTGlzdEl0ZW1EaXNwbGF5KHNlZykge1xuICAgIGxldCB7IGRpc3BsYXkgfSA9IHNlZy5ldmVudFJhbmdlLnVpO1xuICAgIHJldHVybiBkaXNwbGF5ID09PSAnbGlzdC1pdGVtJyB8fCAoZGlzcGxheSA9PT0gJ2F1dG8nICYmXG4gICAgICAgICFzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5ICYmXG4gICAgICAgIHNlZy5maXJzdENvbCA9PT0gc2VnLmxhc3RDb2wgJiYgLy8gY2FuJ3QgYmUgbXVsdGktZGF5XG4gICAgICAgIHNlZy5pc1N0YXJ0ICYmIC8vIFwiXG4gICAgICAgIHNlZy5pc0VuZCAvLyBcIlxuICAgICk7XG59XG5cbmNsYXNzIFRhYmxlQmxvY2tFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChTdGFuZGFyZEV2ZW50LCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBlbENsYXNzZXM6IFsnZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWJsb2NrLWV2ZW50JywgJ2ZjLWgtZXZlbnQnXSwgZGVmYXVsdFRpbWVGb3JtYXQ6IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQsIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQsIGRpc2FibGVSZXNpemluZzogIXByb3BzLnNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXkgfSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIFRhYmxlTGlzdEl0ZW1FdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IHNlZyB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB0aW1lRm9ybWF0ID0gb3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVDtcbiAgICAgICAgbGV0IHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHRydWUsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRXZlbnRDb250YWluZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtZXZlbnQnLCAnZmMtZGF5Z3JpZC1kb3QtZXZlbnQnXSwgZWxBdHRyczogZ2V0U2VnQW5jaG9yQXR0cnMocHJvcHMuc2VnLCBjb250ZXh0KSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVySW5uZXJDb250ZW50LCB0aW1lVGV4dDogdGltZVRleHQsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlIH0pKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZXZlbnQtZG90XCIsIHN0eWxlOiB7IGJvcmRlckNvbG9yOiByZW5kZXJQcm9wcy5ib3JkZXJDb2xvciB8fCByZW5kZXJQcm9wcy5iYWNrZ3JvdW5kQ29sb3IgfSB9KSxcbiAgICAgICAgcmVuZGVyUHJvcHMudGltZVRleHQgJiYgKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGltZVwiIH0sIHJlbmRlclByb3BzLnRpbWVUZXh0KSksXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGl0bGVcIiB9LCByZW5kZXJQcm9wcy5ldmVudC50aXRsZSB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSk7XG59XG5cbmNsYXNzIFRhYmxlQ2VsbE1vcmVMaW5rIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29tcGlsZVNlZ3MgPSBtZW1vaXplKGNvbXBpbGVTZWdzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgYWxsU2VncywgaW52aXNpYmxlU2VncyB9ID0gdGhpcy5jb21waWxlU2Vncyhwcm9wcy5zaW5nbGVQbGFjZW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE1vcmVMaW5rQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy1kYXlncmlkLW1vcmUtbGluayddLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGFsbERheURhdGU6IHByb3BzLmFsbERheURhdGUsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsbFNlZ3M6IGFsbFNlZ3MsIGhpZGRlblNlZ3M6IGludmlzaWJsZVNlZ3MsIGFsaWdubWVudEVsUmVmOiBwcm9wcy5hbGlnbm1lbnRFbFJlZiwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIHBvcG92ZXJDb250ZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlzRm9yY2VkSW52aXNpYmxlID0gKHByb3BzLmV2ZW50RHJhZyA/IHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSA/IHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBhbGxTZWdzLm1hcCgoc2VnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZXZlbnQtaGFybmVzc1wiLCBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF0gPyAnaGlkZGVuJyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSB9LCBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSA/IChjcmVhdGVFbGVtZW50KFRhYmxlTGlzdEl0ZW1FdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGZhbHNlIH0sIGdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlKSkpKSA6IChjcmVhdGVFbGVtZW50KFRhYmxlQmxvY2tFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSkpKSkpKTtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfSB9KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGlsZVNlZ3Moc2luZ2xlUGxhY2VtZW50cykge1xuICAgIGxldCBhbGxTZWdzID0gW107XG4gICAgbGV0IGludmlzaWJsZVNlZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBwbGFjZW1lbnQgb2Ygc2luZ2xlUGxhY2VtZW50cykge1xuICAgICAgICBhbGxTZWdzLnB1c2gocGxhY2VtZW50LnNlZyk7XG4gICAgICAgIGlmICghcGxhY2VtZW50LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgaW52aXNpYmxlU2Vncy5wdXNoKHBsYWNlbWVudC5zZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGFsbFNlZ3MsIGludmlzaWJsZVNlZ3MgfTtcbn1cblxuY29uc3QgREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrOiAnbmFycm93JyB9KTtcbmNsYXNzIFRhYmxlQ2VsbCBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJvb3RFbFJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZGF5TnVtYmVySWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vdEVsID0gKGVsKSA9PiB7XG4gICAgICAgICAgICBzZXRSZWYodGhpcy5yb290RWxSZWYsIGVsKTtcbiAgICAgICAgICAgIHNldFJlZih0aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgY29udGV4dCwgcHJvcHMsIHN0YXRlLCByb290RWxSZWYgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVFbnYgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCB7IGRhdGUsIGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgLy8gVE9ETzogbWVtb2l6ZSB0aGlzP1xuICAgICAgICBjb25zdCBpc01vbnRoU3RhcnQgPSBwcm9wcy5zaG93RGF5TnVtYmVyICYmXG4gICAgICAgICAgICBzaG91bGREaXNwbGF5TW9udGhTdGFydChkYXRlLCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGVFbnYpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy1kYXlncmlkLWRheScsXG4gICAgICAgICAgICAgICAgLi4uKHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCAocHJvcHMuc2hvd0RheU51bWJlciA/IHsgJ2FyaWEtbGFiZWxsZWRieSc6IHN0YXRlLmRheU51bWJlcklkIH0gOiB7fSkpLCB7IHJvbGU6ICdncmlkY2VsbCcgfSksIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlclRvcElubmVyLCBkYXRlOiBkYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXIsIGlzTW9udGhTdGFydDogaXNNb250aFN0YXJ0LCBleHRyYVJlbmRlclByb3BzOiBwcm9wcy5leHRyYVJlbmRlclByb3BzIH0sIChJbm5lckNvbnRlbnQsIHJlbmRlclByb3BzKSA9PiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcHJvcHMuaW5uZXJFbFJlZiwgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWZyYW1lIGZjLXNjcm9sbGdyaWQtc3luYy1pbm5lclwiLCBzdHlsZTogeyBtaW5IZWlnaHQ6IHByb3BzLm1pbkhlaWdodCB9IH0sXG4gICAgICAgICAgICBwcm9wcy5zaG93V2Vla051bWJlciAmJiAoY3JlYXRlRWxlbWVudChXZWVrTnVtYmVyQ29udGFpbmVyLCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbJ2ZjLWRheWdyaWQtd2Vlay1udW1iZXInXSwgZWxBdHRyczogYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSwgJ3dlZWsnKSwgZGF0ZTogZGF0ZSwgZGVmYXVsdEZvcm1hdDogREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgfSkpLFxuICAgICAgICAgICAgIXJlbmRlclByb3BzLmlzRGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAocHJvcHMuc2hvd0RheU51bWJlciB8fCBoYXNDdXN0b21EYXlDZWxsQ29udGVudChvcHRpb25zKSB8fCBwcm9wcy5mb3JjZURheVRvcCkgPyAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS10b3BcIiB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtZGF5Z3JpZC1kYXktbnVtYmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTW9udGhTdGFydCAmJiAnZmMtZGF5Z3JpZC1tb250aC1zdGFydCcsXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYnVpbGROYXZMaW5rQXR0cnMoY29udGV4dCwgZGF0ZSkpLCB7IGlkOiBzdGF0ZS5kYXlOdW1iZXJJZCB9KSB9KSkpIDogcHJvcHMuc2hvd0RheU51bWJlciA/IChcbiAgICAgICAgICAgIC8vIGZvciBjcmVhdGluZyBjb3JyZWN0IGFtb3VudCBvZiBzcGFjZSAoc2VlIGlzc3VlICM3MTYyKVxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS10b3BcIiwgc3R5bGU6IHsgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSB9LFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LW51bWJlclwiIH0sIFwiXFx1MDBBMFwiKSkpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1ldmVudHNcIiwgcmVmOiBwcm9wcy5mZ0NvbnRlbnRFbFJlZiB9LFxuICAgICAgICAgICAgICAgIHByb3BzLmZnQ29udGVudCxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWJvdHRvbVwiLCBzdHlsZTogeyBtYXJnaW5Ub3A6IHByb3BzLm1vcmVNYXJnaW5Ub3AgfSB9LFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRhYmxlQ2VsbE1vcmVMaW5rLCB7IGFsbERheURhdGU6IGRhdGUsIHNpbmdsZVBsYWNlbWVudHM6IHByb3BzLnNpbmdsZVBsYWNlbWVudHMsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsaWdubWVudEVsUmVmOiByb290RWxSZWYsIGFsaWduR3JpZFRvcDogIXByb3BzLnNob3dEYXlOdW1iZXIsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlIH0pKSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZGF5LWJnXCIgfSwgcHJvcHMuYmdDb250ZW50KSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyVG9wSW5uZXIocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuZGF5TnVtYmVyVGV4dCB8fCBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIik7XG59XG5mdW5jdGlvbiBzaG91bGREaXNwbGF5TW9udGhTdGFydChkYXRlLCBjdXJyZW50UmFuZ2UsIGRhdGVFbnYpIHtcbiAgICBjb25zdCB7IHN0YXJ0OiBjdXJyZW50U3RhcnQsIGVuZDogY3VycmVudEVuZCB9ID0gY3VycmVudFJhbmdlO1xuICAgIGNvbnN0IGN1cnJlbnRFbmRJbmNsID0gYWRkTXMoY3VycmVudEVuZCwgLTEpO1xuICAgIGNvbnN0IGN1cnJlbnRGaXJzdFllYXIgPSBkYXRlRW52LmdldFllYXIoY3VycmVudFN0YXJ0KTtcbiAgICBjb25zdCBjdXJyZW50Rmlyc3RNb250aCA9IGRhdGVFbnYuZ2V0TW9udGgoY3VycmVudFN0YXJ0KTtcbiAgICBjb25zdCBjdXJyZW50TGFzdFllYXIgPSBkYXRlRW52LmdldFllYXIoY3VycmVudEVuZEluY2wpO1xuICAgIGNvbnN0IGN1cnJlbnRMYXN0TW9udGggPSBkYXRlRW52LmdldE1vbnRoKGN1cnJlbnRFbmRJbmNsKTtcbiAgICAvLyBzcGFucyBtb3JlIHRoYW4gb25lIG1vbnRoP1xuICAgIHJldHVybiAhKGN1cnJlbnRGaXJzdFllYXIgPT09IGN1cnJlbnRMYXN0WWVhciAmJiBjdXJyZW50Rmlyc3RNb250aCA9PT0gY3VycmVudExhc3RNb250aCkgJiZcbiAgICAgICAgQm9vbGVhbihcbiAgICAgICAgLy8gZmlyc3QgZGF0ZSBpbiBjdXJyZW50IHZpZXc/XG4gICAgICAgIGRhdGUudmFsdWVPZigpID09PSBjdXJyZW50U3RhcnQudmFsdWVPZigpIHx8XG4gICAgICAgICAgICAvLyBhIG1vbnRoLXN0YXJ0IHRoYXQncyB3aXRoaW4gdGhlIGN1cnJlbnQgcmFuZ2U/XG4gICAgICAgICAgICAoZGF0ZUVudi5nZXREYXkoZGF0ZSkgPT09IDEgJiYgZGF0ZS52YWx1ZU9mKCkgPCBjdXJyZW50RW5kLnZhbHVlT2YoKSkpO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVNlZ0tleShzZWcpIHtcbiAgICByZXR1cm4gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCArICc6JyArIHNlZy5maXJzdENvbDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlU2VnVWlkKHNlZykge1xuICAgIHJldHVybiBnZW5lcmF0ZVNlZ0tleShzZWcpICsgJzonICsgc2VnLmxhc3RDb2w7XG59XG5mdW5jdGlvbiBjb21wdXRlRmdTZWdQbGFjZW1lbnQoc2VncywgLy8gYXNzdW1lZCBhbHJlYWR5IHNvcnRlZFxuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3MsIHN0cmljdE9yZGVyLCBzZWdIZWlnaHRzLCBtYXhDb250ZW50SGVpZ2h0LCBjZWxscykge1xuICAgIGxldCBoaWVyYXJjaHkgPSBuZXcgRGF5R3JpZFNlZ0hpZXJhcmNoeSgoc2VnRW50cnkpID0+IHtcbiAgICAgICAgLy8gVE9ETzogbW9yZSBEUlkgd2l0aCBnZW5lcmF0ZVNlZ1VpZFxuICAgICAgICBsZXQgc2VnVWlkID0gc2Vnc1tzZWdFbnRyeS5pbmRleF0uZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkICtcbiAgICAgICAgICAgICc6JyArIHNlZ0VudHJ5LnNwYW4uc3RhcnQgK1xuICAgICAgICAgICAgJzonICsgKHNlZ0VudHJ5LnNwYW4uZW5kIC0gMSk7XG4gICAgICAgIC8vIGlmIG5vIHRoaWNrbmVzcyBrbm93biwgYXNzdW1lIDEgKGlmIDAsIHNvIHNtYWxsIGl0IGFsd2F5cyBmaXRzKVxuICAgICAgICByZXR1cm4gc2VnSGVpZ2h0c1tzZWdVaWRdIHx8IDE7XG4gICAgfSk7XG4gICAgaGllcmFyY2h5LmFsbG93UmVzbGljaW5nID0gdHJ1ZTtcbiAgICBoaWVyYXJjaHkuc3RyaWN0T3JkZXIgPSBzdHJpY3RPcmRlcjtcbiAgICBpZiAoZGF5TWF4RXZlbnRzID09PSB0cnVlIHx8IGRheU1heEV2ZW50Um93cyA9PT0gdHJ1ZSkge1xuICAgICAgICBoaWVyYXJjaHkubWF4Q29vcmQgPSBtYXhDb250ZW50SGVpZ2h0O1xuICAgICAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF5TWF4RXZlbnRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBoaWVyYXJjaHkubWF4U3RhY2tDbnQgPSBkYXlNYXhFdmVudHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudFJvd3MgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50Um93cztcbiAgICAgICAgaGllcmFyY2h5LmhpZGRlbkNvbnN1bWVzID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIHNlZ0lucHV0cyBvbmx5IGZvciBzZWdzIHdpdGgga25vd24gaGVpZ2h0c1xuICAgIGxldCBzZWdJbnB1dHMgPSBbXTtcbiAgICBsZXQgdW5rbm93bkhlaWdodFNlZ3MgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaV07XG4gICAgICAgIGxldCBzZWdVaWQgPSBnZW5lcmF0ZVNlZ1VpZChzZWcpO1xuICAgICAgICBsZXQgZXZlbnRIZWlnaHQgPSBzZWdIZWlnaHRzW3NlZ1VpZF07XG4gICAgICAgIGlmIChldmVudEhlaWdodCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZWdJbnB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgc3Bhbjoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnLmZpcnN0Q29sLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZy5sYXN0Q29sICsgMSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bmtub3duSGVpZ2h0U2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhpZGRlbkVudHJpZXMgPSBoaWVyYXJjaHkuYWRkU2VncyhzZWdJbnB1dHMpO1xuICAgIGxldCBzZWdSZWN0cyA9IGhpZXJhcmNoeS50b1JlY3RzKCk7XG4gICAgbGV0IHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgfSA9IHBsYWNlUmVjdHMoc2VnUmVjdHMsIHNlZ3MsIGNlbGxzKTtcbiAgICBsZXQgbW9yZUNudHMgPSBbXTtcbiAgICBsZXQgbW9yZU1hcmdpblRvcHMgPSBbXTtcbiAgICAvLyBhZGQgc2VncyB3aXRoIHVua25vd24gaGVpZ2h0c1xuICAgIGZvciAobGV0IHNlZyBvZiB1bmtub3duSGVpZ2h0U2Vncykge1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHNbc2VnLmZpcnN0Q29sXS5wdXNoKHtcbiAgICAgICAgICAgIHNlZyxcbiAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBjb2wgPSBzZWcuZmlyc3RDb2w7IGNvbCA8PSBzZWcubGFzdENvbDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXS5wdXNoKHtcbiAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCBjb2wsIGNvbCArIDEsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFkZCB0aGUgaGlkZGVuIGVudHJpZXNcbiAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIG1vcmVDbnRzLnB1c2goMCk7XG4gICAgfVxuICAgIGZvciAobGV0IGhpZGRlbkVudHJ5IG9mIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgbGV0IHNlZyA9IHNlZ3NbaGlkZGVuRW50cnkuaW5kZXhdO1xuICAgICAgICBsZXQgaGlkZGVuU3BhbiA9IGhpZGRlbkVudHJ5LnNwYW47XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50c1toaWRkZW5TcGFuLnN0YXJ0XS5wdXNoKHtcbiAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGhpZGRlblNwYW4uc3RhcnQsIGhpZGRlblNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChsZXQgY29sID0gaGlkZGVuU3Bhbi5zdGFydDsgY29sIDwgaGlkZGVuU3Bhbi5lbmQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBtb3JlQ250c1tjb2xdICs9IDE7XG4gICAgICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkZWFsIHdpdGggbGVmdG92ZXIgbWFyZ2luc1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgbW9yZU1hcmdpblRvcHMucHVzaChsZWZ0b3Zlck1hcmdpbnNbY29sXSk7XG4gICAgfVxuICAgIHJldHVybiB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzIH07XG59XG4vLyByZWN0cyBvcmRlcmVkIGJ5IHRvcCBjb29yZCwgdGhlbiBsZWZ0XG5mdW5jdGlvbiBwbGFjZVJlY3RzKGFsbFJlY3RzLCBzZWdzLCBjZWxscykge1xuICAgIGxldCByZWN0c0J5RWFjaENvbCA9IGdyb3VwUmVjdHNCeUVhY2hDb2woYWxsUmVjdHMsIGNlbGxzLmxlbmd0aCk7XG4gICAgbGV0IHNpbmdsZUNvbFBsYWNlbWVudHMgPSBbXTtcbiAgICBsZXQgbXVsdGlDb2xQbGFjZW1lbnRzID0gW107XG4gICAgbGV0IGxlZnRvdmVyTWFyZ2lucyA9IFtdO1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgbGV0IHJlY3RzID0gcmVjdHNCeUVhY2hDb2xbY29sXTtcbiAgICAgICAgLy8gY29tcHV0ZSBhbGwgc3RhdGljIHNlZ3MgaW4gc2luZ2xlUGxhY2VtZW50c1xuICAgICAgICBsZXQgc2luZ2xlUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudEhlaWdodCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgZm9yIChsZXQgcmVjdCBvZiByZWN0cykge1xuICAgICAgICAgICAgbGV0IHNlZyA9IHNlZ3NbcmVjdC5pbmRleF07XG4gICAgICAgICAgICBzaW5nbGVQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGUgbWl4ZWQgc3RhdGljL2Fic29sdXRlIHNlZ3MgaW4gbXVsdGlQbGFjZW1lbnRzXG4gICAgICAgIGxldCBtdWx0aVBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgY3VycmVudEhlaWdodCA9IDA7XG4gICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICBmb3IgKGxldCByZWN0IG9mIHJlY3RzKSB7XG4gICAgICAgICAgICBsZXQgc2VnID0gc2Vnc1tyZWN0LmluZGV4XTtcbiAgICAgICAgICAgIGxldCBpc0Fic29sdXRlID0gcmVjdC5zcGFuLmVuZCAtIHJlY3Quc3Bhbi5zdGFydCA+IDE7IC8vIG11bHRpLWNvbHVtbj9cbiAgICAgICAgICAgIGxldCBpc0ZpcnN0Q29sID0gcmVjdC5zcGFuLnN0YXJ0ID09PSBjb2w7XG4gICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QubGV2ZWxDb29yZCAtIGN1cnJlbnRIZWlnaHQ7IC8vIGFtb3VudCBvZiBzcGFjZSBzaW5jZSBib3R0b20gb2YgcHJldmlvdXMgc2VnXG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ID0gcmVjdC5sZXZlbENvb3JkICsgcmVjdC50aGlja25lc3M7IC8vIGhlaWdodCB3aWxsIG5vdyBiZSBib3R0b20gb2YgY3VycmVudCBzZWdcbiAgICAgICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCArPSByZWN0LnRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICBpZiAoaXNGaXJzdENvbCkge1xuICAgICAgICAgICAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZpcnN0Q29sKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzZWc6IHJlc2xpY2VTZWcoc2VnLCByZWN0LnNwYW4uc3RhcnQsIHJlY3Quc3Bhbi5lbmQsIGNlbGxzKSxcbiAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IHJlY3QubGV2ZWxDb29yZCxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBjdXJyZW50TWFyZ2luVG9wLCAvLyBjbGFpbSB0aGUgbWFyZ2luXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50cy5wdXNoKHNpbmdsZVBsYWNlbWVudHMpO1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHMucHVzaChtdWx0aVBsYWNlbWVudHMpO1xuICAgICAgICBsZWZ0b3Zlck1hcmdpbnMucHVzaChjdXJyZW50TWFyZ2luVG9wKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2luZ2xlQ29sUGxhY2VtZW50cywgbXVsdGlDb2xQbGFjZW1lbnRzLCBsZWZ0b3Zlck1hcmdpbnMgfTtcbn1cbmZ1bmN0aW9uIGdyb3VwUmVjdHNCeUVhY2hDb2wocmVjdHMsIGNvbENudCkge1xuICAgIGxldCByZWN0c0J5RWFjaENvbCA9IFtdO1xuICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgcmVjdHNCeUVhY2hDb2wucHVzaChbXSk7XG4gICAgfVxuICAgIGZvciAobGV0IHJlY3Qgb2YgcmVjdHMpIHtcbiAgICAgICAgZm9yIChsZXQgY29sID0gcmVjdC5zcGFuLnN0YXJ0OyBjb2wgPCByZWN0LnNwYW4uZW5kOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgcmVjdHNCeUVhY2hDb2xbY29sXS5wdXNoKHJlY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWN0c0J5RWFjaENvbDtcbn1cbmZ1bmN0aW9uIHJlc2xpY2VTZWcoc2VnLCBzcGFuU3RhcnQsIHNwYW5FbmQsIGNlbGxzKSB7XG4gICAgaWYgKHNlZy5maXJzdENvbCA9PT0gc3BhblN0YXJ0ICYmIHNlZy5sYXN0Q29sID09PSBzcGFuRW5kIC0gMSkge1xuICAgICAgICByZXR1cm4gc2VnO1xuICAgIH1cbiAgICBsZXQgZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgIGxldCBvcmlnUmFuZ2UgPSBldmVudFJhbmdlLnJhbmdlO1xuICAgIGxldCBzbGljZWRSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhvcmlnUmFuZ2UsIHtcbiAgICAgICAgc3RhcnQ6IGNlbGxzW3NwYW5TdGFydF0uZGF0ZSxcbiAgICAgICAgZW5kOiBhZGREYXlzKGNlbGxzW3NwYW5FbmQgLSAxXS5kYXRlLCAxKSxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZWcpLCB7IGZpcnN0Q29sOiBzcGFuU3RhcnQsIGxhc3RDb2w6IHNwYW5FbmQgLSAxLCBldmVudFJhbmdlOiB7XG4gICAgICAgICAgICBkZWY6IGV2ZW50UmFuZ2UuZGVmLFxuICAgICAgICAgICAgdWk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRSYW5nZS51aSksIHsgZHVyYXRpb25FZGl0YWJsZTogZmFsc2UgfSksXG4gICAgICAgICAgICBpbnN0YW5jZTogZXZlbnRSYW5nZS5pbnN0YW5jZSxcbiAgICAgICAgICAgIHJhbmdlOiBzbGljZWRSYW5nZSxcbiAgICAgICAgfSwgaXNTdGFydDogc2VnLmlzU3RhcnQgJiYgc2xpY2VkUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSBvcmlnUmFuZ2Uuc3RhcnQudmFsdWVPZigpLCBpc0VuZDogc2VnLmlzRW5kICYmIHNsaWNlZFJhbmdlLmVuZC52YWx1ZU9mKCkgPT09IG9yaWdSYW5nZS5lbmQudmFsdWVPZigpIH0pO1xufVxuY2xhc3MgRGF5R3JpZFNlZ0hpZXJhcmNoeSBleHRlbmRzIFNlZ0hpZXJhcmNoeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIGNvbmZpZ1xuICAgICAgICB0aGlzLmhpZGRlbkNvbnN1bWVzID0gZmFsc2U7XG4gICAgICAgIC8vIGFsbG93cyB1cyB0byBrZWVwIGhpZGRlbiBlbnRyaWVzIGluIHRoZSBoaWVyYXJjaHkgc28gdGhleSB0YWtlIHVwIHNwYWNlXG4gICAgICAgIHRoaXMuZm9yY2VIaWRkZW4gPSB7fTtcbiAgICB9XG4gICAgYWRkU2VncyhzZWdJbnB1dHMpIHtcbiAgICAgICAgY29uc3QgaGlkZGVuU2VncyA9IHN1cGVyLmFkZFNlZ3Moc2VnSW5wdXRzKTtcbiAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZXhjbHVkZUhpZGRlbiA9IChlbnRyeSkgPT4gIXRoaXMuZm9yY2VIaWRkZW5bYnVpbGRFbnRyeUtleShlbnRyeSldO1xuICAgICAgICAvLyByZW1vdmUgdGhlIGZvcmNlZC1oaWRkZW4gc2Vnc1xuICAgICAgICBmb3IgKGxldCBsZXZlbCA9IDA7IGxldmVsIDwgZW50cmllc0J5TGV2ZWwubGVuZ3RoOyBsZXZlbCArPSAxKSB7XG4gICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFtsZXZlbF0gPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF0uZmlsdGVyKGV4Y2x1ZGVIaWRkZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5TZWdzO1xuICAgIH1cbiAgICBoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpIHtcbiAgICAgICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCwgZm9yY2VIaWRkZW4gfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdG91Y2hpbmdFbnRyeSwgdG91Y2hpbmdMZXZlbCwgdG91Y2hpbmdMYXRlcmFsIH0gPSBpbnNlcnRpb247XG4gICAgICAgIC8vIHRoZSBlbnRyeSB0aGF0IHRoZSBuZXcgaW5zZXJ0aW9uIGlzIHRvdWNoaW5nIG11c3QgYmUgaGlkZGVuXG4gICAgICAgIGlmICh0aGlzLmhpZGRlbkNvbnN1bWVzICYmIHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdWNoaW5nRW50cnlJZCA9IGJ1aWxkRW50cnlLZXkodG91Y2hpbmdFbnRyeSk7XG4gICAgICAgICAgICBpZiAoIWZvcmNlSGlkZGVuW3RvdWNoaW5nRW50cnlJZF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd1Jlc2xpY2luZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdCB1cCB0aGUgdG91Y2hpbmdFbnRyeSwgcmVpbnNlcnQgaXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGlkZGVuRW50cnkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRvdWNoaW5nRW50cnkpLCB7IHNwYW46IGludGVyc2VjdFNwYW5zKHRvdWNoaW5nRW50cnkuc3BhbiwgZW50cnkuc3BhbikgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlaW5zZXJ0IHRoZSBhcmVhIHRoYXQgdHVybmVkIGludG8gYSBcIm1vcmVcIiBsaW5rIChzbyBubyBvdGhlciBlbnRyaWVzIHRyeSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBvY2N1cHkgdGhlIHNwYWNlKSBidXQgbWFyayBpdCBmb3JjZWQtaGlkZGVuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpZGRlbkVudHJ5SWQgPSBidWlsZEVudHJ5S2V5KGhpZGRlbkVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VIaWRkZW5baGlkZGVuRW50cnlJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbnRyaWVzQnlMZXZlbFt0b3VjaGluZ0xldmVsXVt0b3VjaGluZ0xhdGVyYWxdID0gaGlkZGVuRW50cnk7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaChoaWRkZW5FbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRFbnRyeSh0b3VjaGluZ0VudHJ5LCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZUhpZGRlblt0b3VjaGluZ0VudHJ5SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKHRvdWNoaW5nRW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3aWxsIHRyeSB0byByZXNsaWNlLi4uXG4gICAgICAgIHN1cGVyLmhhbmRsZUludmFsaWRJbnNlcnRpb24oaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgfVxufVxuXG5jbGFzcyBUYWJsZVJvdyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNlbGxFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSA8dGQ+XG4gICAgICAgIHRoaXMuZnJhbWVFbFJlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIHRoZSBmYy1kYXlncmlkLWRheS1mcmFtZVxuICAgICAgICB0aGlzLmZnRWxSZWZzID0gbmV3IFJlZk1hcCgpOyAvLyB0aGUgZmMtZGF5Z3JpZC1kYXktZXZlbnRzXG4gICAgICAgIHRoaXMuc2VnSGFybmVzc1JlZnMgPSBuZXcgUmVmTWFwKCk7IC8vIGluZGV4ZWQgYnkgXCJpbnN0YW5jZUlkOmZpcnN0Q29sXCJcbiAgICAgICAgdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIHNlZ0hlaWdodHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9IChpc0ZvcmNlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRm9yY2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTaXppbmcodHJ1ZSk7IC8vIGlzRXh0ZXJuYWw9dHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBzdGF0ZSwgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IGNvbENudCA9IHByb3BzLmNlbGxzLmxlbmd0aDtcbiAgICAgICAgbGV0IGJ1c2luZXNzSG91cnNCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wocHJvcHMuYnVzaW5lc3NIb3VyU2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGJnRXZlbnRTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJnRXZlbnRTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgaGlnaGxpZ2h0U2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbCh0aGlzLmdldEhpZ2hsaWdodFNlZ3MoKSwgY29sQ250KTtcbiAgICAgICAgbGV0IG1pcnJvclNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRNaXJyb3JTZWdzKCksIGNvbENudCk7XG4gICAgICAgIGxldCB7IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cywgbW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzIH0gPSBjb21wdXRlRmdTZWdQbGFjZW1lbnQoc29ydEV2ZW50U2Vncyhwcm9wcy5mZ0V2ZW50U2Vncywgb3B0aW9ucy5ldmVudE9yZGVyKSwgcHJvcHMuZGF5TWF4RXZlbnRzLCBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIG9wdGlvbnMuZXZlbnRPcmRlclN0cmljdCwgc3RhdGUuc2VnSGVpZ2h0cywgc3RhdGUubWF4Q29udGVudEhlaWdodCwgcHJvcHMuY2VsbHMpO1xuICAgICAgICBsZXQgaXNGb3JjZWRJbnZpc2libGUgPSAvLyBUT0RPOiBtZXNzeSB3YXkgdG8gY29tcHV0ZSB0aGlzXG4gICAgICAgICAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIHt9O1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJlZjogdGhpcy5yb290RWxSZWYsIHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgIHByb3BzLnJlbmRlckludHJvICYmIHByb3BzLnJlbmRlckludHJvKCksXG4gICAgICAgICAgICBwcm9wcy5jZWxscy5tYXAoKGNlbGwsIGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBub3JtYWxGZ05vZGVzID0gdGhpcy5yZW5kZXJGZ1NlZ3MoY29sLCBwcm9wcy5mb3JQcmludCA/IHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXSA6IG11bHRpQ29sUGxhY2VtZW50c1tjb2xdLCBwcm9wcy50b2RheVJhbmdlLCBpc0ZvcmNlZEludmlzaWJsZSk7XG4gICAgICAgICAgICAgICAgbGV0IG1pcnJvckZnTm9kZXMgPSB0aGlzLnJlbmRlckZnU2Vncyhjb2wsIGJ1aWxkTWlycm9yUGxhY2VtZW50cyhtaXJyb3JTZWdzQnlDb2xbY29sXSwgbXVsdGlDb2xQbGFjZW1lbnRzKSwgcHJvcHMudG9kYXlSYW5nZSwge30sIEJvb2xlYW4ocHJvcHMuZXZlbnREcmFnKSwgQm9vbGVhbihwcm9wcy5ldmVudFJlc2l6ZSksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsLCB7IGtleTogY2VsbC5rZXksIGVsUmVmOiB0aGlzLmNlbGxFbFJlZnMuY3JlYXRlUmVmKGNlbGwua2V5KSwgaW5uZXJFbFJlZjogdGhpcy5mcmFtZUVsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpIC8qIEZGIDx0ZD4gcHJvYmxlbSwgYnV0IG9rYXkgdG8gdXNlIGZvciBsZWZ0L3JpZ2h0LiBUT0RPOiByZW5hbWUgcHJvcCAqLywgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBkYXRlOiBjZWxsLmRhdGUsIHNob3dEYXlOdW1iZXI6IHByb3BzLnNob3dEYXlOdW1iZXJzLCBzaG93V2Vla051bWJlcjogcHJvcHMuc2hvd1dlZWtOdW1iZXJzICYmIGNvbCA9PT0gMCwgZm9yY2VEYXlUb3A6IHByb3BzLnNob3dXZWVrTnVtYmVycyAvKiBldmVuIGRpc3BsYXlpbmcgd2Vla251bSBmb3Igcm93LCBub3QgbmVjZXNzYXJpbHkgZGF5ICovLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIGV4dHJhUmVuZGVyUHJvcHM6IGNlbGwuZXh0cmFSZW5kZXJQcm9wcywgZXh0cmFEYXRhQXR0cnM6IGNlbGwuZXh0cmFEYXRhQXR0cnMsIGV4dHJhQ2xhc3NOYW1lczogY2VsbC5leHRyYUNsYXNzTmFtZXMsIGV4dHJhRGF0ZVNwYW46IGNlbGwuZXh0cmFEYXRlU3BhbiwgbW9yZUNudDogbW9yZUNudHNbY29sXSwgbW9yZU1hcmdpblRvcDogbW9yZU1hcmdpblRvcHNbY29sXSwgc2luZ2xlUGxhY2VtZW50czogc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLCBmZ0NvbnRlbnRFbFJlZjogdGhpcy5mZ0VsUmVmcy5jcmVhdGVSZWYoY2VsbC5rZXkpLCBmZ0NvbnRlbnQ6ICggLy8gRnJhZ21lbnQgc2NvcGVzIHRoZSBrZXlzXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBub3JtYWxGZ05vZGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIG1pcnJvckZnTm9kZXMpKSksIGJnQ29udGVudDogKCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmlsbFNlZ3MoaGlnaGxpZ2h0U2Vnc0J5Q29sW2NvbF0sICdoaWdobGlnaHQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmlsbFNlZ3MoYnVzaW5lc3NIb3Vyc0J5Q29sW2NvbF0sICdub24tYnVzaW5lc3MnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyRmlsbFNlZ3MoYmdFdmVudFNlZ3NCeUNvbFtjb2xdLCAnYmctZXZlbnQnKSkpLCBtaW5IZWlnaHQ6IHByb3BzLmNlbGxNaW5IZWlnaHQgfSkpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKHRydWUpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICBsZXQgY3VycmVudFByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoIWlzUHJvcHNFcXVhbChwcmV2UHJvcHMsIGN1cnJlbnRQcm9wcykpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH1cbiAgICBnZXRIaWdobGlnaHRTZWdzKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudERyYWcuc2VncztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncztcbiAgICB9XG4gICAgZ2V0TWlycm9yU2VncygpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzLmxlbmd0aCkgeyAvLyBtZXNzeSBjaGVja1xuICAgICAgICAgICAgcmV0dXJuIHByb3BzLmV2ZW50UmVzaXplLnNlZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZW5kZXJGZ1NlZ3MoY29sLCBzZWdQbGFjZW1lbnRzLCB0b2RheVJhbmdlLCBpc0ZvcmNlZEludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nKSB7XG4gICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGV2ZW50U2VsZWN0aW9uIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyBmcmFtZVBvc2l0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgPSB0aGlzLnByb3BzLmNlbGxzLmxlbmd0aCA9PT0gMTsgLy8gY29sQ250ID09PSAxXG4gICAgICAgIGxldCBpc01pcnJvciA9IGlzRHJhZ2dpbmcgfHwgaXNSZXNpemluZyB8fCBpc0RhdGVTZWxlY3Rpbmc7XG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgICBpZiAoZnJhbWVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHBsYWNlbWVudCBvZiBzZWdQbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgc2VnIH0gPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgbGV0IHsgaW5zdGFuY2VJZCB9ID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgbGV0IGlzVmlzaWJsZSA9IHBsYWNlbWVudC5pc1Zpc2libGUgJiYgIWlzRm9yY2VkSW52aXNpYmxlW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgICAgIGxldCBpc0Fic29sdXRlID0gcGxhY2VtZW50LmlzQWJzb2x1dGU7XG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSAnJztcbiAgICAgICAgICAgICAgICBsZXQgcmlnaHQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5pc1J0bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5sYXN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5maXJzdENvbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5maXJzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmxhc3RDb2xdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAga25vd24gYnVnOiBldmVudHMgdGhhdCBhcmUgZm9yY2UgdG8gYmUgbGlzdC1pdGVtIGJ1dCBzcGFuIG11bHRpcGxlIGRheXMgc3RpbGwgdGFrZSB1cCBzcGFjZSBpbiBsYXRlciBjb2x1bW5zXG4gICAgICAgICAgICAgICAgdG9kbzogaW4gcHJpbnQgdmlldywgZm9yIG11bHRpLWRheSBldmVudHMsIGRvbid0IGRpc3BsYXkgdGl0bGUgd2l0aGluIG5vbi1zdGFydC9lbmQgc2Vnc1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzJyArIChpc0Fic29sdXRlID8gJyBmYy1kYXlncmlkLWV2ZW50LWhhcm5lc3MtYWJzJyA6ICcnKSwga2V5OiBnZW5lcmF0ZVNlZ0tleShzZWcpLCByZWY6IGlzTWlycm9yID8gbnVsbCA6IHRoaXMuc2VnSGFybmVzc1JlZnMuY3JlYXRlUmVmKGdlbmVyYXRlU2VnVWlkKHNlZykpLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogaXNWaXNpYmxlID8gJycgOiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpblRvcDogaXNBYnNvbHV0ZSA/ICcnIDogcGxhY2VtZW50Lm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogaXNBYnNvbHV0ZSA/IHBsYWNlbWVudC5hYnNvbHV0ZVRvcCA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9IH0sIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKGNyZWF0ZUVsZW1lbnQoVGFibGVMaXN0SXRlbUV2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBkZWZhdWx0RGlzcGxheUV2ZW50RW5kOiBkZWZhdWx0RGlzcGxheUV2ZW50RW5kIH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKSkpKSA6IChjcmVhdGVFbGVtZW50KFRhYmxlQmxvY2tFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nOiBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3Rpbmc6IGlzRGF0ZVNlbGVjdGluZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgfSwgZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICByZW5kZXJGaWxsU2VncyhzZWdzLCBmaWxsVHlwZSkge1xuICAgICAgICBsZXQgeyBpc1J0bCB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyB0b2RheVJhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyBmcmFtZVBvc2l0aW9ucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IG5vZGVzID0gW107XG4gICAgICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgZm9yIChsZXQgc2VnIG9mIHNlZ3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdFJpZ2h0Q3NzID0gaXNSdGwgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcubGFzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5sZWZ0c1tzZWcuZmlyc3RDb2xdLFxuICAgICAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmZpcnN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLnJpZ2h0c1tzZWcubGFzdENvbF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IGJ1aWxkRXZlbnRSYW5nZUtleShzZWcuZXZlbnRSYW5nZSksIGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWJnLWhhcm5lc3NcIiwgc3R5bGU6IGxlZnRSaWdodENzcyB9LCBmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQmdFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnIH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKSkpIDpcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyRmlsbChmaWxsVHlwZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwge30sIC4uLm5vZGVzKTtcbiAgICB9XG4gICAgdXBkYXRlU2l6aW5nKGlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIHN0YXRlLCBmcmFtZUVsUmVmcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFwcm9wcy5mb3JQcmludCAmJlxuICAgICAgICAgICAgcHJvcHMuY2xpZW50V2lkdGggIT09IG51bGwgLy8gcG9zaXRpb25pbmcgcmVhZHk/XG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKGlzRXh0ZXJuYWxTaXppbmdDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnJhbWVFbHMgPSBwcm9wcy5jZWxscy5tYXAoKGNlbGwpID0+IGZyYW1lRWxSZWZzLmN1cnJlbnRNYXBbY2VsbC5rZXldKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVFbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvcmlnaW5FbCA9IHRoaXMucm9vdEVsUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdQb3NpdGlvbkNhY2hlID0gbmV3IFBvc2l0aW9uQ2FjaGUob3JpZ2luRWwsIGZyYW1lRWxzLCB0cnVlLCAvLyBpc0hvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmZyYW1lUG9zaXRpb25zIHx8ICFzdGF0ZS5mcmFtZVBvc2l0aW9ucy5zaW1pbGFyVG8obmV3UG9zaXRpb25DYWNoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBuZXcgUG9zaXRpb25DYWNoZShvcmlnaW5FbCwgZnJhbWVFbHMsIHRydWUsIC8vIGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2xkU2VnSGVpZ2h0cyA9IHRoaXMuc3RhdGUuc2VnSGVpZ2h0cztcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlZ0hlaWdodHMgPSB0aGlzLnF1ZXJ5U2VnSGVpZ2h0cygpO1xuICAgICAgICAgICAgY29uc3QgbGltaXRCeUNvbnRlbnRIZWlnaHQgPSBwcm9wcy5kYXlNYXhFdmVudHMgPT09IHRydWUgfHwgcHJvcHMuZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIC8vIEhBQ0sgdG8gcHJldmVudCBvc2NpbGxhdGlvbnMgb2YgZXZlbnRzIGJlaW5nIHNob3duL2hpZGRlbiBmcm9tIG1heC1ldmVudC1yb3dzXG4gICAgICAgICAgICAgICAgLy8gRXNzZW50aWFsbHksIG9uY2UgeW91IGNvbXB1dGUgYW4gZWxlbWVudCdzIGhlaWdodCwgbmV2ZXIgbnVsbC1vdXQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYWx3YXlzIGRpc3BsYXkgYWxsIGV2ZW50cywgYXMgdmlzaWJpbGl0eTpoaWRkZW4/XG4gICAgICAgICAgICAgICAgc2VnSGVpZ2h0czogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvbGRTZWdIZWlnaHRzKSwgbmV3U2VnSGVpZ2h0cyksXG4gICAgICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbGltaXRCeUNvbnRlbnRIZWlnaHQgPyB0aGlzLmNvbXB1dGVNYXhDb250ZW50SGVpZ2h0KCkgOiBudWxsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVlcnlTZWdIZWlnaHRzKCkge1xuICAgICAgICBsZXQgc2VnRWxNYXAgPSB0aGlzLnNlZ0hhcm5lc3NSZWZzLmN1cnJlbnRNYXA7XG4gICAgICAgIGxldCBzZWdIZWlnaHRzID0ge307XG4gICAgICAgIC8vIGdldCB0aGUgbWF4IGhlaWdodCBhbW9uZ3N0IGluc3RhbmNlIHNlZ3NcbiAgICAgICAgZm9yIChsZXQgc2VnVWlkIGluIHNlZ0VsTWFwKSB7XG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gTWF0aC5yb3VuZChzZWdFbE1hcFtzZWdVaWRdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCk7XG4gICAgICAgICAgICBzZWdIZWlnaHRzW3NlZ1VpZF0gPSBNYXRoLm1heChzZWdIZWlnaHRzW3NlZ1VpZF0gfHwgMCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VnSGVpZ2h0cztcbiAgICB9XG4gICAgY29tcHV0ZU1heENvbnRlbnRIZWlnaHQoKSB7XG4gICAgICAgIGxldCBmaXJzdEtleSA9IHRoaXMucHJvcHMuY2VsbHNbMF0ua2V5O1xuICAgICAgICBsZXQgY2VsbEVsID0gdGhpcy5jZWxsRWxSZWZzLmN1cnJlbnRNYXBbZmlyc3RLZXldO1xuICAgICAgICBsZXQgZmNDb250YWluZXJFbCA9IHRoaXMuZmdFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV07XG4gICAgICAgIHJldHVybiBjZWxsRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gZmNDb250YWluZXJFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgfVxuICAgIGdldENlbGxFbHMoKSB7XG4gICAgICAgIGxldCBlbE1hcCA9IHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jZWxscy5tYXAoKGNlbGwpID0+IGVsTWFwW2NlbGwua2V5XSk7XG4gICAgfVxufVxuVGFibGVSb3cuYWRkU3RhdGVFcXVhbGl0eSh7XG4gICAgc2VnSGVpZ2h0czogaXNQcm9wc0VxdWFsLFxufSk7XG5mdW5jdGlvbiBidWlsZE1pcnJvclBsYWNlbWVudHMobWlycm9yU2VncywgY29sUGxhY2VtZW50cykge1xuICAgIGlmICghbWlycm9yU2Vncy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBsZXQgdG9wc0J5SW5zdGFuY2VJZCA9IGJ1aWxkQWJzb2x1dGVUb3BIYXNoKGNvbFBsYWNlbWVudHMpOyAvLyBUT0RPOiBjYWNoZSB0aGlzIGF0IGZpcnN0IHJlbmRlcj9cbiAgICByZXR1cm4gbWlycm9yU2Vncy5tYXAoKHNlZykgPT4gKHtcbiAgICAgICAgc2VnLFxuICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgIGFic29sdXRlVG9wOiB0b3BzQnlJbnN0YW5jZUlkW3NlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWRdLFxuICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgfSkpO1xufVxuZnVuY3Rpb24gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50cykge1xuICAgIGxldCB0b3BzQnlJbnN0YW5jZUlkID0ge307XG4gICAgZm9yIChsZXQgcGxhY2VtZW50cyBvZiBjb2xQbGFjZW1lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IHBsYWNlbWVudCBvZiBwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICB0b3BzQnlJbnN0YW5jZUlkW3BsYWNlbWVudC5zZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSA9IHBsYWNlbWVudC5hYnNvbHV0ZVRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9wc0J5SW5zdGFuY2VJZDtcbn1cblxuY2xhc3MgVGFibGVSb3dzIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRCZ0V2ZW50U2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlSb3cpO1xuICAgICAgICB0aGlzLnNwbGl0RmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Um93KTtcbiAgICAgICAgdGhpcy5zcGxpdERhdGVTZWxlY3Rpb25TZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudERyYWcgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdyk7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcbiAgICAgICAgdGhpcy5yb3dSZWZzID0gbmV3IFJlZk1hcCgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgcm93Q250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICBsZXQgYnVzaW5lc3NIb3VyU2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MocHJvcHMuYnVzaW5lc3NIb3VyU2Vncywgcm93Q250KTtcbiAgICAgICAgbGV0IGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIHJvd0NudCk7XG4gICAgICAgIGxldCBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCByb3dDbnQpO1xuICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2Vncywgcm93Q250KTtcbiAgICAgICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIHJvd0NudCk7XG4gICAgICAgIGxldCBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCByb3dDbnQpO1xuICAgICAgICAvLyBmb3IgRGF5R3JpZCB2aWV3IHdpdGggbWFueSByb3dzLCBmb3JjZSBhIG1pbi1oZWlnaHQgb24gY2VsbHMgc28gZG9lc24ndCBhcHBlYXIgc3F1aXNoZWRcbiAgICAgICAgLy8gY2hvb3NlIDcgYmVjYXVzZSBhIG1vbnRoIHZpZXcgd2lsbCBoYXZlIG1heCA2IHJvd3NcbiAgICAgICAgbGV0IGNlbGxNaW5IZWlnaHQgPSAocm93Q250ID49IDcgJiYgcHJvcHMuY2xpZW50V2lkdGgpID9cbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoIC8gY29udGV4dC5vcHRpb25zLmFzcGVjdFJhdGlvIC8gNiA6XG4gICAgICAgICAgICBudWxsO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHByb3BzLmNlbGxzLm1hcCgoY2VsbHMsIHJvdykgPT4gKGNyZWF0ZUVsZW1lbnQoVGFibGVSb3csIHsgcmVmOiB0aGlzLnJvd1JlZnMuY3JlYXRlUmVmKHJvdyksIGtleTogY2VsbHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgPyBjZWxsc1swXS5kYXRlLnRvSVNPU3RyaW5nKCkgLyogYmVzdD8gb3IgcHV0IGtleSBvbiBjZWxsPyBvciB1c2UgZGlmZiBmb3JtYXR0ZXI/ICovXG4gICAgICAgICAgICAgICAgOiByb3cgLy8gaW4gY2FzZSB0aGVyZSBhcmUgbm8gY2VsbHMgKGxpa2Ugd2hlbiByZXNvdXJjZSB2aWV3IGlzIGxvYWRpbmcpXG4gICAgICAgICAgICAsIHNob3dEYXlOdW1iZXJzOiByb3dDbnQgPiAxLCBzaG93V2Vla051bWJlcnM6IHByb3BzLnNob3dXZWVrTnVtYmVycywgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBjZWxsczogY2VsbHMsIHJlbmRlckludHJvOiBwcm9wcy5yZW5kZXJSb3dJbnRybywgYnVzaW5lc3NIb3VyU2VnczogYnVzaW5lc3NIb3VyU2Vnc0J5Um93W3Jvd10sIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgYmdFdmVudFNlZ3M6IGJnRXZlbnRTZWdzQnlSb3dbcm93XS5maWx0ZXIoaXNTZWdBbGxEYXkpIC8qIGhhY2sgKi8sIGZnRXZlbnRTZWdzOiBmZ0V2ZW50U2Vnc0J5Um93W3Jvd10sIGRhdGVTZWxlY3Rpb25TZWdzOiBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93W3Jvd10sIGV2ZW50RHJhZzogZXZlbnREcmFnQnlSb3dbcm93XSwgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplQnlSb3dbcm93XSwgZGF5TWF4RXZlbnRzOiBwcm9wcy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBjZWxsTWluSGVpZ2h0OiBjZWxsTWluSGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKSkpKSk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICAvLyBmb3IgaWYgc3RhcnRlZCB3aXRoIHplcm8gY2VsbHNcbiAgICAgICAgdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KCk7XG4gICAgfVxuICAgIHJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5yb290RWwpIHtcbiAgICAgICAgICAgIC8vIEhBQ0s6IG5lZWQgYSBkYXlncmlkIHdyYXBwZXIgcGFyZW50IHRvIGRvIHBvc2l0aW9uaW5nXG4gICAgICAgICAgICAvLyBOT1RFOiBhIGRheWdyaWQgcmVzb3VyY2UgdmlldyB3L28gcmVzb3VyY2VzIGNhbiBoYXZlIHplcm8gY2VsbHNcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2VsbEVsID0gdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbMF0uZ2V0Q2VsbEVscygpWzBdO1xuICAgICAgICAgICAgY29uc3Qgcm9vdEVsID0gZmlyc3RDZWxsRWwgPyBmaXJzdENlbGxFbC5jbG9zZXN0KCcuZmMtZGF5Z3JpZC1ib2R5JykgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICAgICAgaXNIaXRDb21ib0FsbG93ZWQ6IHRoaXMucHJvcHMuaXNIaXRDb21ib0FsbG93ZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3RFbCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucm9vdEVsID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIaXQgU3lzdGVtXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHByZXBhcmVIaXRzKCkge1xuICAgICAgICB0aGlzLnJvd1Bvc2l0aW9ucyA9IG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsLCB0aGlzLnJvd1JlZnMuY29sbGVjdCgpLm1hcCgocm93T2JqKSA9PiByb3dPYmouZ2V0Q2VsbEVscygpWzBdKSwgLy8gZmlyc3QgY2VsbCBlbCBpbiBlYWNoIHJvdy4gVE9ETzogbm90IG9wdGltYWxcbiAgICAgICAgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLmNvbFBvc2l0aW9ucyA9IG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsLCB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFswXS5nZXRDZWxsRWxzKCksIC8vIGNlbGwgZWxzIGluIGZpcnN0IHJvd1xuICAgICAgICB0cnVlLCAvLyBob3Jpem9udGFsXG4gICAgICAgIGZhbHNlKTtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCkge1xuICAgICAgICBsZXQgeyBjb2xQb3NpdGlvbnMsIHJvd1Bvc2l0aW9ucyB9ID0gdGhpcztcbiAgICAgICAgbGV0IGNvbCA9IGNvbFBvc2l0aW9ucy5sZWZ0VG9JbmRleChwb3NpdGlvbkxlZnQpO1xuICAgICAgICBsZXQgcm93ID0gcm93UG9zaXRpb25zLnRvcFRvSW5kZXgocG9zaXRpb25Ub3ApO1xuICAgICAgICBpZiAocm93ICE9IG51bGwgJiYgY29sICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCBjZWxsID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlOiB0aGlzLnByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiBPYmplY3QuYXNzaWduKHsgcmFuZ2U6IHRoaXMuZ2V0Q2VsbFJhbmdlKHJvdywgY29sKSwgYWxsRGF5OiB0cnVlIH0sIGNlbGwuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IHRoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKSxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGNvbFBvc2l0aW9ucy5sZWZ0c1tjb2xdLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29sUG9zaXRpb25zLnJpZ2h0c1tjb2xdLFxuICAgICAgICAgICAgICAgICAgICB0b3A6IHJvd1Bvc2l0aW9ucy50b3BzW3Jvd10sXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogcm93UG9zaXRpb25zLmJvdHRvbXNbcm93XSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2VsbEVsKHJvdywgY29sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1JlZnMuY3VycmVudE1hcFtyb3ddLmdldENlbGxFbHMoKVtjb2xdOyAvLyBUT0RPOiBub3Qgb3B0aW1hbFxuICAgIH1cbiAgICBnZXRDZWxsUmFuZ2Uocm93LCBjb2wpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF0uZGF0ZTtcbiAgICAgICAgbGV0IGVuZCA9IGFkZERheXMoc3RhcnQsIDEpO1xuICAgICAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG4gICAgfVxufVxuZnVuY3Rpb24gaXNTZWdBbGxEYXkoc2VnKSB7XG4gICAgcmV0dXJuIHNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXk7XG59XG5cbmNsYXNzIFRhYmxlIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRheU1heEV2ZW50Um93cywgZGF5TWF4RXZlbnRzLCBleHBhbmRSb3dzIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGxpbWl0VmlhQmFsYW5jZWQgPSBkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlO1xuICAgICAgICAvLyBpZiByb3dzIGNhbid0IGV4cGFuZCB0byBmaWxsIGZpeGVkIGhlaWdodCwgY2FuJ3QgZG8gYmFsYW5jZWQtaGVpZ2h0IGV2ZW50IGxpbWl0XG4gICAgICAgIC8vIFRPRE86IGJlc3QgcGxhY2UgdG8gbm9ybWFsaXplIHRoZXNlIG9wdGlvbnM/XG4gICAgICAgIGlmIChsaW1pdFZpYUJhbGFuY2VkICYmICFleHBhbmRSb3dzKSB7XG4gICAgICAgICAgICBsaW1pdFZpYUJhbGFuY2VkID0gZmFsc2U7XG4gICAgICAgICAgICBkYXlNYXhFdmVudFJvd3MgPSBudWxsO1xuICAgICAgICAgICAgZGF5TWF4RXZlbnRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy1kYXlncmlkLWJvZHknLFxuICAgICAgICAgICAgbGltaXRWaWFCYWxhbmNlZCA/ICdmYy1kYXlncmlkLWJvZHktYmFsYW5jZWQnIDogJ2ZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkJyxcbiAgICAgICAgICAgIGV4cGFuZFJvd3MgPyAnJyA6ICdmYy1kYXlncmlkLWJvZHktbmF0dXJhbCcsIC8vIHdpbGwgaGVpZ2h0IG9mIG9uZSByb3cgZGVwZW5kIG9uIHRoZSBvdGhlcnM/XG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5lbFJlZiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAvLyB0aGVzZSBwcm9wcyBhcmUgaW1wb3J0YW50IHRvIGdpdmUgdGhpcyB3cmFwcGVyIGNvcnJlY3QgZGltZW5zaW9ucyBmb3IgaW50ZXJhY3Rpb25zXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogaWYgd2Ugc2V0IGl0IGhlcmUsIGNhbiB3ZSBhdm9pZCBnaXZpbmcgdG8gaW5uZXIgdGFibGVzP1xuICAgICAgICAgICAgICAgIHdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtdGFibGVcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBleHBhbmRSb3dzID8gcHJvcHMuY2xpZW50SGVpZ2h0IDogJycsXG4gICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgIHByb3BzLmNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGFibGVSb3dzLCB7IGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgY2VsbHM6IHByb3BzLmNlbGxzLCByZW5kZXJSb3dJbnRybzogcHJvcHMucmVuZGVyUm93SW50cm8sIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBidXNpbmVzc0hvdXJTZWdzOiBwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBiZ0V2ZW50U2VnczogcHJvcHMuYmdFdmVudFNlZ3MsIGZnRXZlbnRTZWdzOiBwcm9wcy5mZ0V2ZW50U2VncywgZGF0ZVNlbGVjdGlvblNlZ3M6IHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIGRheU1heEV2ZW50czogZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IGRheU1heEV2ZW50Um93cywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBpc0hpdENvbWJvQWxsb3dlZDogcHJvcHMuaXNIaXRDb21ib0FsbG93ZWQgfSkpKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0U2Nyb2xsUmVzZXQoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLmRhdGVQcm9maWxlICE9PSB0aGlzLnByb3BzLmRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RTY3JvbGxSZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbHVzaFNjcm9sbFJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWVzdFNjcm9sbFJlc2V0KCkge1xuICAgICAgICB0aGlzLm5lZWRzU2Nyb2xsUmVzZXQgPSB0cnVlO1xuICAgICAgICB0aGlzLmZsdXNoU2Nyb2xsUmVzZXQoKTtcbiAgICB9XG4gICAgZmx1c2hTY3JvbGxSZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNTY3JvbGxSZXNldCAmJlxuICAgICAgICAgICAgdGhpcy5wcm9wcy5jbGllbnRXaWR0aCAvLyBzaXplcyBjb21wdXRlZD9cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0RWwgPSBnZXRTY3JvbGxTdWJqZWN0RWwodGhpcy5lbFJlZi5jdXJyZW50LCB0aGlzLnByb3BzLmRhdGVQcm9maWxlKTtcbiAgICAgICAgICAgIGlmIChzdWJqZWN0RWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5FbCA9IHN1YmplY3RFbC5jbG9zZXN0KCcuZmMtZGF5Z3JpZC1ib2R5Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Nyb2xsRWwgPSBvcmlnaW5FbC5jbG9zZXN0KCcuZmMtc2Nyb2xsZXInKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JvbGxUb3AgPSBzdWJqZWN0RWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC1cbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICAgICAgICAgIHNjcm9sbEVsLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCA/IChzY3JvbGxUb3AgKyAxKSA6IDA7IC8vIG92ZXJjb21lIGJvcmRlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZWVkc1Njcm9sbFJlc2V0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxTdWJqZWN0RWwoY29udGFpbmVyRWwsIGRhdGVQcm9maWxlKSB7XG4gICAgbGV0IGVsO1xuICAgIGlmIChkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0Lm1hdGNoKC95ZWFyfG1vbnRoLykpIHtcbiAgICAgICAgZWwgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kYXRlPVwiJHtmb3JtYXRJc29Nb250aFN0cihkYXRlUHJvZmlsZS5jdXJyZW50RGF0ZSl9LTAxXCJdYCk7XG4gICAgICAgIC8vIGV2ZW4gaWYgdmlldyBpcyBtb250aC1iYXNlZCwgZmlyc3Qtb2YtbW9udGggbWlnaHQgYmUgaGlkZGVuLi4uXG4gICAgfVxuICAgIGlmICghZWwpIHtcbiAgICAgICAgZWwgPSBjb250YWluZXJFbC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1kYXRlPVwiJHtmb3JtYXREYXlTdHJpbmcoZGF0ZVByb2ZpbGUuY3VycmVudERhdGUpfVwiXWApO1xuICAgICAgICAvLyBjb3VsZCBzdGlsbCBiZSBoaWRkZW4gaWYgYW4gaW50ZXJpb3ItdmlldyBoaWRkZW4gZGF5XG4gICAgfVxuICAgIHJldHVybiBlbDtcbn1cblxuY2xhc3MgRGF5VGFibGVTbGljZXIgZXh0ZW5kcyBTbGljZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmZvcmNlRGF5SWZMaXN0SXRlbSA9IHRydWU7XG4gICAgfVxuICAgIHNsaWNlUmFuZ2UoZGF0ZVJhbmdlLCBkYXlUYWJsZU1vZGVsKSB7XG4gICAgICAgIHJldHVybiBkYXlUYWJsZU1vZGVsLnNsaWNlUmFuZ2UoZGF0ZVJhbmdlKTtcbiAgICB9XG59XG5cbmNsYXNzIERheVRhYmxlIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc2xpY2VyID0gbmV3IERheVRhYmxlU2xpY2VyKCk7XG4gICAgICAgIHRoaXMudGFibGVSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFRhYmxlLCBPYmplY3QuYXNzaWduKHsgcmVmOiB0aGlzLnRhYmxlUmVmIH0sIHRoaXMuc2xpY2VyLnNsaWNlUHJvcHMocHJvcHMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5uZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0LCBwcm9wcy5kYXlUYWJsZU1vZGVsKSwgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGNlbGxzOiBwcm9wcy5kYXlUYWJsZU1vZGVsLmNlbGxzLCBjb2xHcm91cE5vZGU6IHByb3BzLmNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgcmVuZGVyUm93SW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBkYXlNYXhFdmVudHM6IHByb3BzLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBwcm9wcy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiBwcm9wcy5leHBhbmRSb3dzLCBoZWFkZXJBbGlnbkVsUmVmOiBwcm9wcy5oZWFkZXJBbGlnbkVsUmVmLCBjbGllbnRXaWR0aDogcHJvcHMuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogcHJvcHMuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKTtcbiAgICB9XG59XG5cbmNsYXNzIERheVRhYmxlVmlldyBleHRlbmRzIFRhYmxlVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYnVpbGREYXlUYWJsZU1vZGVsID0gbWVtb2l6ZShidWlsZERheVRhYmxlTW9kZWwpO1xuICAgICAgICB0aGlzLmhlYWRlclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICB0aGlzLnRhYmxlUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIC8vIGNhbid0IG92ZXJyaWRlIGFueSBsaWZlY3ljbGUgbWV0aG9kcyBmcm9tIHBhcmVudFxuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IG9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBsZXQgZGF5VGFibGVNb2RlbCA9IHRoaXMuYnVpbGREYXlUYWJsZU1vZGVsKHByb3BzLmRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIGxldCBoZWFkZXJDb250ZW50ID0gb3B0aW9ucy5kYXlIZWFkZXJzICYmIChjcmVhdGVFbGVtZW50KERheUhlYWRlciwgeyByZWY6IHRoaXMuaGVhZGVyUmVmLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGVzOiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzLCBkYXRlc1JlcERpc3RpbmN0RGF5czogZGF5VGFibGVNb2RlbC5yb3dDbnQgPT09IDEgfSkpO1xuICAgICAgICBsZXQgYm9keUNvbnRlbnQgPSAoY29udGVudEFyZykgPT4gKGNyZWF0ZUVsZW1lbnQoRGF5VGFibGUsIHsgcmVmOiB0aGlzLnRhYmxlUmVmLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIGJ1c2luZXNzSG91cnM6IHByb3BzLmJ1c2luZXNzSG91cnMsIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sIGV2ZW50U3RvcmU6IHByb3BzLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlczogcHJvcHMuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIG5leHREYXlUaHJlc2hvbGQ6IG9wdGlvbnMubmV4dERheVRocmVzaG9sZCwgY29sR3JvdXBOb2RlOiBjb250ZW50QXJnLnRhYmxlQ29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGRheU1heEV2ZW50czogb3B0aW9ucy5kYXlNYXhFdmVudHMsIGRheU1heEV2ZW50Um93czogb3B0aW9ucy5kYXlNYXhFdmVudFJvd3MsIHNob3dXZWVrTnVtYmVyczogb3B0aW9ucy53ZWVrTnVtYmVycywgZXhwYW5kUm93czogIXByb3BzLmlzSGVpZ2h0QXV0bywgaGVhZGVyQWxpZ25FbFJlZjogdGhpcy5oZWFkZXJFbFJlZiwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmRheU1pbldpZHRoXG4gICAgICAgICAgICA/IHRoaXMucmVuZGVySFNjcm9sbExheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIG9wdGlvbnMuZGF5TWluV2lkdGgpXG4gICAgICAgICAgICA6IHRoaXMucmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlckNvbnRlbnQsIGJvZHlDb250ZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERheVRhYmxlTW9kZWwoZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgbGV0IGRheVNlcmllcyA9IG5ldyBEYXlTZXJpZXNNb2RlbChkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgIHJldHVybiBuZXcgRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIC95ZWFyfG1vbnRofHdlZWsvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpO1xufVxuXG5jbGFzcyBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yIGV4dGVuZHMgRGF0ZVByb2ZpbGVHZW5lcmF0b3Ige1xuICAgIC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZFxuICAgIGJ1aWxkUmVuZGVyUmFuZ2UoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XG4gICAgICAgIGxldCByZW5kZXJSYW5nZSA9IHN1cGVyLmJ1aWxkUmVuZGVyUmFuZ2UoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KTtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBidWlsZERheVRhYmxlUmVuZGVyUmFuZ2Uoe1xuICAgICAgICAgICAgY3VycmVudFJhbmdlOiByZW5kZXJSYW5nZSxcbiAgICAgICAgICAgIHNuYXBUb1dlZWs6IC9eKHllYXJ8bW9udGgpJC8udGVzdChjdXJyZW50UmFuZ2VVbml0KSxcbiAgICAgICAgICAgIGZpeGVkV2Vla0NvdW50OiBwcm9wcy5maXhlZFdlZWtDb3VudCxcbiAgICAgICAgICAgIGRhdGVFbnY6IHByb3BzLmRhdGVFbnYsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRGF5VGFibGVSZW5kZXJSYW5nZShwcm9wcykge1xuICAgIGxldCB7IGRhdGVFbnYsIGN1cnJlbnRSYW5nZSB9ID0gcHJvcHM7XG4gICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gY3VycmVudFJhbmdlO1xuICAgIGxldCBlbmRPZldlZWs7XG4gICAgLy8geWVhciBhbmQgbW9udGggdmlld3Mgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB3ZWVrcy4gdGhpcyBpcyBhbHJlYWR5IGRvbmUgZm9yIHdlZWtcbiAgICBpZiAocHJvcHMuc25hcFRvV2Vlaykge1xuICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZldlZWsoc3RhcnQpO1xuICAgICAgICAvLyBtYWtlIGVuZC1vZi13ZWVrIGlmIG5vdCBhbHJlYWR5XG4gICAgICAgIGVuZE9mV2VlayA9IGRhdGVFbnYuc3RhcnRPZldlZWsoZW5kKTtcbiAgICAgICAgaWYgKGVuZE9mV2Vlay52YWx1ZU9mKCkgIT09IGVuZC52YWx1ZU9mKCkpIHtcbiAgICAgICAgICAgIGVuZCA9IGFkZFdlZWtzKGVuZE9mV2VlaywgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZW5zdXJlIDYgd2Vla3NcbiAgICBpZiAocHJvcHMuZml4ZWRXZWVrQ291bnQpIHtcbiAgICAgICAgLy8gVE9ETzogaW5zdGVhZCBvZiB0aGVzZSBkYXRlLW1hdGggZ3ltbmFzdGljcyAoZm9yIG11bHRpbW9udGggdmlldyksXG4gICAgICAgIC8vIGNvbXB1dGUgZGF0ZXByb2ZpbGVzIG9mIGFsbCBtb250aHMsIHRoZW4gdXNlIHN0YXJ0IG9mIGZpcnN0IGFuZCBlbmQgb2YgbGFzdC5cbiAgICAgICAgbGV0IGxhc3RNb250aFJlbmRlclN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mV2VlayhkYXRlRW52LnN0YXJ0T2ZNb250aChhZGREYXlzKGN1cnJlbnRSYW5nZS5lbmQsIC0xKSkpO1xuICAgICAgICBsZXQgcm93Q250ID0gTWF0aC5jZWlsKC8vIGNvdWxkIGJlIHBhcnRpYWwgd2Vla3MgZHVlIHRvIGhpZGRlbkRheXNcbiAgICAgICAgZGlmZldlZWtzKGxhc3RNb250aFJlbmRlclN0YXJ0LCBlbmQpKTtcbiAgICAgICAgZW5kID0gYWRkV2Vla3MoZW5kLCA2IC0gcm93Q250KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZCB9O1xufVxuXG52YXIgY3NzXzI0OHogPSBcIjpyb290ey0tZmMtZGF5Z3JpZC1ldmVudC1kb3Qtd2lkdGg6OHB4fS5mYy1kYXlncmlkLWRheS1ldmVudHM6YWZ0ZXIsLmZjLWRheWdyaWQtZGF5LWV2ZW50czpiZWZvcmUsLmZjLWRheWdyaWQtZGF5LWZyYW1lOmFmdGVyLC5mYy1kYXlncmlkLWRheS1mcmFtZTpiZWZvcmUsLmZjLWRheWdyaWQtZXZlbnQtaGFybmVzczphZnRlciwuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzOmJlZm9yZXtjbGVhcjpib3RoO2NvbnRlbnQ6XFxcIlxcXCI7ZGlzcGxheTp0YWJsZX0uZmMgLmZjLWRheWdyaWQtYm9keXtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjF9LmZjIC5mYy1kYXlncmlkLWRheS5mYy1kYXktdG9kYXl7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy10b2RheS1iZy1jb2xvcil9LmZjIC5mYy1kYXlncmlkLWRheS1mcmFtZXttaW4taGVpZ2h0OjEwMCU7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1kYXlncmlkLWRheS10b3B7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfS5mYyAuZmMtZGF5LW90aGVyIC5mYy1kYXlncmlkLWRheS10b3B7b3BhY2l0eTouM30uZmMgLmZjLWRheWdyaWQtZGF5LW51bWJlcntwYWRkaW5nOjRweDtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjR9LmZjIC5mYy1kYXlncmlkLW1vbnRoLXN0YXJ0e2ZvbnQtc2l6ZToxLjFlbTtmb250LXdlaWdodDo3MDB9LmZjIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bWFyZ2luLXRvcDoxcHh9LmZjIC5mYy1kYXlncmlkLWJvZHktYmFsYW5jZWQgLmZjLWRheWdyaWQtZGF5LWV2ZW50c3tsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MH0uZmMgLmZjLWRheWdyaWQtYm9keS11bmJhbGFuY2VkIC5mYy1kYXlncmlkLWRheS1ldmVudHN7bWluLWhlaWdodDoyZW07cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy1kYXlncmlkLWJvZHktbmF0dXJhbCAuZmMtZGF5Z3JpZC1kYXktZXZlbnRze21hcmdpbi1ib3R0b206MWVtfS5mYyAuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNze3Bvc2l0aW9uOnJlbGF0aXZlfS5mYyAuZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzLWFic3tsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMgLmZjLWRheWdyaWQtYmctaGFybmVzc3tib3R0b206MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MH0uZmMgLmZjLWRheWdyaWQtZGF5LWJnIC5mYy1ub24tYnVzaW5lc3N7ei1pbmRleDoxfS5mYyAuZmMtZGF5Z3JpZC1kYXktYmcgLmZjLWJnLWV2ZW50e3otaW5kZXg6Mn0uZmMgLmZjLWRheWdyaWQtZGF5LWJnIC5mYy1oaWdobGlnaHR7ei1pbmRleDozfS5mYyAuZmMtZGF5Z3JpZC1ldmVudHttYXJnaW4tdG9wOjFweDt6LWluZGV4OjZ9LmZjIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LW1pcnJvcnt6LWluZGV4Ojd9LmZjIC5mYy1kYXlncmlkLWRheS1ib3R0b217Zm9udC1zaXplOi44NWVtO21hcmdpbjowIDJweH0uZmMgLmZjLWRheWdyaWQtZGF5LWJvdHRvbTphZnRlciwuZmMgLmZjLWRheWdyaWQtZGF5LWJvdHRvbTpiZWZvcmV7Y2xlYXI6Ym90aDtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LmZjIC5mYy1kYXlncmlkLW1vcmUtbGlua3tib3JkZXItcmFkaXVzOjNweDtjdXJzb3I6cG9pbnRlcjtsaW5lLWhlaWdodDoxO21hcmdpbi10b3A6MXB4O21heC13aWR0aDoxMDAlO292ZXJmbG93OmhpZGRlbjtwYWRkaW5nOjJweDtwb3NpdGlvbjpyZWxhdGl2ZTt3aGl0ZS1zcGFjZTpub3dyYXA7ei1pbmRleDo0fS5mYyAuZmMtZGF5Z3JpZC1tb3JlLWxpbms6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLC4xKX0uZmMgLmZjLWRheWdyaWQtd2Vlay1udW1iZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKTtjb2xvcjp2YXIoLS1mYy1uZXV0cmFsLXRleHQtY29sb3IpO21pbi13aWR0aDoxLjVlbTtwYWRkaW5nOjJweDtwb3NpdGlvbjphYnNvbHV0ZTt0ZXh0LWFsaWduOmNlbnRlcjt0b3A6MDt6LWluZGV4OjV9LmZjIC5mYy1tb3JlLXBvcG92ZXIgLmZjLXBvcG92ZXItYm9keXttaW4td2lkdGg6MjIwcHg7cGFkZGluZzoxMHB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LXN0YXJ0LC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LWVuZHttYXJnaW4tbGVmdDoycHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtZXZlbnQuZmMtZXZlbnQtZW5kLC5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLWV2ZW50LmZjLWV2ZW50LXN0YXJ0e21hcmdpbi1yaWdodDoycHh9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtbW9yZS1saW5re2Zsb2F0OmxlZnR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWRheWdyaWQtd2Vlay1udW1iZXJ7Ym9yZGVyLXJhZGl1czowIDAgM3B4IDA7bGVmdDowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLW1vcmUtbGlua3tmbG9hdDpyaWdodH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtZGF5Z3JpZC13ZWVrLW51bWJlcntib3JkZXItcmFkaXVzOjAgMCAwIDNweDtyaWdodDowfS5mYy1saXF1aWQtaGFjayAuZmMtZGF5Z3JpZC1kYXktZnJhbWV7cG9zaXRpb246c3RhdGljfS5mYy1kYXlncmlkLWV2ZW50e2JvcmRlci1yYWRpdXM6M3B4O2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpO3Bvc2l0aW9uOnJlbGF0aXZlO3doaXRlLXNwYWNlOm5vd3JhcH0uZmMtZGF5Z3JpZC1ibG9jay1ldmVudCAuZmMtZXZlbnQtdGltZXtmb250LXdlaWdodDo3MDB9LmZjLWRheWdyaWQtYmxvY2stZXZlbnQgLmZjLWV2ZW50LXRpbWUsLmZjLWRheWdyaWQtYmxvY2stZXZlbnQgLmZjLWV2ZW50LXRpdGxle3BhZGRpbmc6MXB4fS5mYy1kYXlncmlkLWRvdC1ldmVudHthbGlnbi1pdGVtczpjZW50ZXI7ZGlzcGxheTpmbGV4O3BhZGRpbmc6MnB4IDB9LmZjLWRheWdyaWQtZG90LWV2ZW50IC5mYy1ldmVudC10aXRsZXtmbGV4LWdyb3c6MTtmbGV4LXNocmluazoxO2ZvbnQtd2VpZ2h0OjcwMDttaW4td2lkdGg6MDtvdmVyZmxvdzpoaWRkZW59LmZjLWRheWdyaWQtZG90LWV2ZW50LmZjLWV2ZW50LW1pcnJvciwuZmMtZGF5Z3JpZC1kb3QtZXZlbnQ6aG92ZXJ7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4xKX0uZmMtZGF5Z3JpZC1kb3QtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2JvdHRvbTotMTBweDt0b3A6LTEwcHh9LmZjLWRheWdyaWQtZXZlbnQtZG90e2JvcmRlcjpjYWxjKHZhcigtLWZjLWRheWdyaWQtZXZlbnQtZG90LXdpZHRoKS8yKSBzb2xpZCB2YXIoLS1mYy1ldmVudC1ib3JkZXItY29sb3IpO2JvcmRlci1yYWRpdXM6Y2FsYyh2YXIoLS1mYy1kYXlncmlkLWV2ZW50LWRvdC13aWR0aCkvMik7Ym94LXNpemluZzpjb250ZW50LWJveDtoZWlnaHQ6MDttYXJnaW46MCA0cHg7d2lkdGg6MH0uZmMtZGlyZWN0aW9uLWx0ciAuZmMtZGF5Z3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXttYXJnaW4tcmlnaHQ6M3B4fS5mYy1kaXJlY3Rpb24tcnRsIC5mYy1kYXlncmlkLWV2ZW50IC5mYy1ldmVudC10aW1le21hcmdpbi1sZWZ0OjNweH1cIjtcbmluamVjdFN0eWxlcyhjc3NfMjQ4eik7XG5cbmV4cG9ydCB7IERheVRhYmxlVmlldyBhcyBEYXlHcmlkVmlldywgRGF5VGFibGUsIERheVRhYmxlU2xpY2VyLCBUYWJsZSwgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciwgVGFibGVSb3dzLCBUYWJsZVZpZXcsIGJ1aWxkRGF5VGFibGVNb2RlbCwgYnVpbGREYXlUYWJsZVJlbmRlclJhbmdlIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzJztcbmltcG9ydCB7IERheUdyaWRWaWV3IGFzIERheVRhYmxlVmlldywgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuaW1wb3J0ICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuaW1wb3J0ICdAZnVsbGNhbGVuZGFyL2NvcmUvcHJlYWN0LmpzJztcblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci9kYXlncmlkJyxcbiAgICBpbml0aWFsVmlldzogJ2RheUdyaWRNb250aCcsXG4gICAgdmlld3M6IHtcbiAgICAgICAgZGF5R3JpZDoge1xuICAgICAgICAgICAgY29tcG9uZW50OiBEYXlUYWJsZVZpZXcsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkRGF5OiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRXZWVrOiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkTW9udGg6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IG1vbnRoczogMSB9LFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRZZWFyOiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB5ZWFyczogMSB9LFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IFNwbGl0dGVyLCBoYXNCZ1JlbmRlcmluZywgY3JlYXRlRm9ybWF0dGVyLCBWaWV3Q29udGV4dFR5cGUsIENvbnRlbnRDb250YWluZXIsIEJhc2VDb21wb25lbnQsIERhdGVDb21wb25lbnQsIGRpZmZEYXlzLCBidWlsZE5hdkxpbmtBdHRycywgV2Vla051bWJlckNvbnRhaW5lciwgZ2V0U3RpY2t5SGVhZGVyRGF0ZXMsIFZpZXdDb250YWluZXIsIFNpbXBsZVNjcm9sbEdyaWQsIGdldFN0aWNreUZvb3RlclNjcm9sbGJhciwgTm93VGltZXIsIE5vd0luZGljYXRvckNvbnRhaW5lciwgcmVuZGVyU2Nyb2xsU2hpbSwgcmFuZ2VDb250YWluc01hcmtlciwgc3RhcnRPZkRheSwgYXNSb3VnaE1zLCBjcmVhdGVEdXJhdGlvbiwgUmVmTWFwLCBQb3NpdGlvbkNhY2hlLCBNb3JlTGlua0NvbnRhaW5lciwgU2VnSGllcmFyY2h5LCBncm91cEludGVyc2VjdGluZ0VudHJpZXMsIGJpbmFyeVNlYXJjaCwgZ2V0RW50cnlTcGFuRW5kLCBidWlsZEVudHJ5S2V5LCBTdGFuZGFyZEV2ZW50LCBtZW1vaXplLCBzb3J0RXZlbnRTZWdzLCBEYXlDZWxsQ29udGFpbmVyLCBoYXNDdXN0b21EYXlDZWxsQ29udGVudCwgZ2V0U2VnTWV0YSwgYnVpbGRJc29TdHJpbmcsIGNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0LCBidWlsZEV2ZW50UmFuZ2VLZXksIEJnRXZlbnQsIHJlbmRlckZpbGwsIGFkZER1cmF0aW9ucywgbXVsdGlwbHlEdXJhdGlvbiwgd2hvbGVEaXZpZGVEdXJhdGlvbnMsIFNsaWNlciwgaW50ZXJzZWN0UmFuZ2VzLCBmb3JtYXRJc29UaW1lU3RyaW5nLCBEYXlIZWFkZXIsIERheVNlcmllc01vZGVsLCBEYXlUYWJsZU1vZGVsLCBpbmplY3RTdHlsZXMgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgY3JlYXRlUmVmLCBGcmFnbWVudCB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuaW1wb3J0IHsgRGF5VGFibGUgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2RheWdyaWQvaW50ZXJuYWwuanMnO1xuXG5jbGFzcyBBbGxEYXlTcGxpdHRlciBleHRlbmRzIFNwbGl0dGVyIHtcbiAgICBnZXRLZXlJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsRGF5OiB7fSxcbiAgICAgICAgICAgIHRpbWVkOiB7fSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0S2V5c0ZvckRhdGVTcGFuKGRhdGVTcGFuKSB7XG4gICAgICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2FsbERheSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbJ3RpbWVkJ107XG4gICAgfVxuICAgIGdldEtleXNGb3JFdmVudERlZihldmVudERlZikge1xuICAgICAgICBpZiAoIWV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICAgICAgcmV0dXJuIFsndGltZWQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzQmdSZW5kZXJpbmcoZXZlbnREZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gWyd0aW1lZCcsICdhbGxEYXknXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydhbGxEYXknXTtcbiAgICB9XG59XG5cbmNvbnN0IERFRkFVTFRfU0xBVF9MQUJFTF9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBvbWl0WmVyb01pbnV0ZTogdHJ1ZSxcbiAgICBtZXJpZGllbTogJ3Nob3J0Jyxcbn0pO1xuZnVuY3Rpb24gVGltZUNvbHNBeGlzQ2VsbChwcm9wcykge1xuICAgIGxldCBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtdGltZWdyaWQtc2xvdCcsXG4gICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhYmVsJyxcbiAgICAgICAgcHJvcHMuaXNMYWJlbGVkID8gJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rJyA6ICdmYy10aW1lZ3JpZC1zbG90LW1pbm9yJyxcbiAgICBdO1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGlmICghcHJvcHMuaXNMYWJlbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIFwiZGF0YS10aW1lXCI6IHByb3BzLmlzb1RpbWVTdHIgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMsIHZpZXdBcGkgfSA9IGNvbnRleHQ7XG4gICAgICAgIGxldCBsYWJlbEZvcm1hdCA9IC8vIFRPRE86IGZ1bGx5IHByZS1wYXJzZVxuICAgICAgICAgb3B0aW9ucy5zbG90TGFiZWxGb3JtYXQgPT0gbnVsbCA/IERFRkFVTFRfU0xBVF9MQUJFTF9GT1JNQVQgOlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvcHRpb25zLnNsb3RMYWJlbEZvcm1hdCkgPyBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucy5zbG90TGFiZWxGb3JtYXRbMF0pIDpcbiAgICAgICAgICAgICAgICBjcmVhdGVGb3JtYXR0ZXIob3B0aW9ucy5zbG90TGFiZWxGb3JtYXQpO1xuICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICAgIHRpbWU6IHByb3BzLnRpbWUsXG4gICAgICAgICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShwcm9wcy5kYXRlKSxcbiAgICAgICAgICAgIHZpZXc6IHZpZXdBcGksXG4gICAgICAgICAgICB0ZXh0OiBkYXRlRW52LmZvcm1hdChwcm9wcy5kYXRlLCBsYWJlbEZvcm1hdCksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRkXCIsIGVsQ2xhc3NlczogY2xhc3NOYW1lcywgZWxBdHRyczoge1xuICAgICAgICAgICAgICAgICdkYXRhLXRpbWUnOiBwcm9wcy5pc29UaW1lU3RyLFxuICAgICAgICAgICAgfSwgcmVuZGVyUHJvcHM6IHJlbmRlclByb3BzLCBnZW5lcmF0b3JOYW1lOiBcInNsb3RMYWJlbENvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLnNsb3RMYWJlbENvbnRlbnQsIGRlZmF1bHRHZW5lcmF0b3I6IHJlbmRlcklubmVyQ29udGVudCwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLnNsb3RMYWJlbENsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLnNsb3RMYWJlbERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5zbG90TGFiZWxXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250ZW50KSA9PiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1zbG90LWxhYmVsLWZyYW1lIGZjLXNjcm9sbGdyaWQtc2hyaW5rLWZyYW1lXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICBdIH0pKSkpKTtcbiAgICB9KSk7XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dDtcbn1cblxuY2xhc3MgVGltZUJvZHlBeGlzIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5zbGF0TWV0YXMubWFwKChzbGF0TWV0YSkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xzQXhpc0NlbGwsIE9iamVjdC5hc3NpZ24oe30sIHNsYXRNZXRhKSkpKSk7XG4gICAgfVxufVxuXG5jb25zdCBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICdzaG9ydCcgfSk7XG5jb25zdCBBVVRPX0FMTF9EQVlfTUFYX0VWRU5UX1JPV1MgPSA1O1xuY2xhc3MgVGltZUNvbHNWaWV3IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWxsRGF5U3BsaXR0ZXIgPSBuZXcgQWxsRGF5U3BsaXR0ZXIoKTsgLy8gZm9yIHVzZSBieSBzdWJjbGFzc2VzXG4gICAgICAgIHRoaXMuaGVhZGVyRWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxlckVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzbGF0Q29vcmRzOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbFRvcFJlcXVlc3QgPSAoc2Nyb2xsVG9wKSA9PiB7XG4gICAgICAgICAgICBsZXQgc2Nyb2xsZXJFbCA9IHRoaXMuc2Nyb2xsZXJFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyRWwpIHsgLy8gVE9ETzogbm90IHN1cmUgaG93IHRoaXMgY291bGQgZXZlciBiZSBudWxsLiB3ZWlyZG5lc3Mgd2l0aCB0aGUgcmVkdWNlclxuICAgICAgICAgICAgICAgIHNjcm9sbGVyRWwuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiBIZWFkZXIgUmVuZGVyIE1ldGhvZHNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgdGhpcy5yZW5kZXJIZWFkQXhpcyA9IChyb3dLZXksIGZyYW1lSGVpZ2h0ID0gJycpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgbGV0IHJhbmdlID0gZGF0ZVByb2ZpbGUucmVuZGVyUmFuZ2U7XG4gICAgICAgICAgICBsZXQgZGF5Q250ID0gZGlmZkRheXMocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCk7XG4gICAgICAgICAgICAvLyBvbmx5IGRvIGluIGRheSB2aWV3cyAodG8gYXZvaWQgZG9pbmcgaW4gd2VlayB2aWV3cyB0aGF0IGRvbnQgbmVlZCBpdClcbiAgICAgICAgICAgIGxldCBuYXZMaW5rQXR0cnMgPSAoZGF5Q250ID09PSAxKVxuICAgICAgICAgICAgICAgID8gYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCByYW5nZS5zdGFydCwgJ3dlZWsnKVxuICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICBpZiAob3B0aW9ucy53ZWVrTnVtYmVycyAmJiByb3dLZXkgPT09ICdkYXknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFdlZWtOdW1iZXJDb250YWluZXIsIHsgZWxUYWc6IFwidGhcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnLFxuICAgICAgICAgICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LCBkYXRlOiByYW5nZS5zdGFydCwgZGVmYXVsdEZvcm1hdDogREVGQVVMVF9XRUVLX05VTV9GT1JNQVQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1heGlzLWZyYW1lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWQnLFxuICAgICAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSwgc3R5bGU6IHsgaGVpZ2h0OiBmcmFtZUhlaWdodCB9IH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImFcIiwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSwgZWxBdHRyczogbmF2TGlua0F0dHJzIH0pKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRoXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpc1wiIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1heGlzLWZyYW1lXCIsIHN0eWxlOiB7IGhlaWdodDogZnJhbWVIZWlnaHQgfSB9KSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKiBUYWJsZSBDb21wb25lbnQgUmVuZGVyIE1ldGhvZHNcbiAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAgICAgLy8gb25seSBhIG9uZS13YXkgaGVpZ2h0IHN5bmMuIHdlIGRvbid0IHNlbmQgdGhlIGF4aXMgaW5uZXItY29udGVudCBoZWlnaHQgdG8gdGhlIERheUdyaWQsXG4gICAgICAgIC8vIGJ1dCBEYXlHcmlkIHN0aWxsIG5lZWRzIHRvIGhhdmUgY2xhc3NOYW1lcyBvbiBpbm5lciBlbGVtZW50cyBpbiBvcmRlciB0byBtZWFzdXJlLlxuICAgICAgICB0aGlzLnJlbmRlclRhYmxlUm93QXhpcyA9IChyb3dIZWlnaHQpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBvcHRpb25zLmFsbERheVRleHQsXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSByZXVzYWJsZSBob29rLiB1c2VkIGluIGxpc3QgdmlldyB0b29cbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMnLFxuICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnLFxuICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwiYWxsRGF5Q29udGVudFwiLCBjdXN0b21HZW5lcmF0b3I6IG9wdGlvbnMuYWxsRGF5Q29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyQWxsRGF5SW5uZXIsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5hbGxEYXlDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5hbGxEYXlEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuYWxsRGF5V2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtZnJhbWUnLFxuICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnLFxuICAgICAgICAgICAgICAgICAgICByb3dIZWlnaHQgPT0gbnVsbCA/ICcgZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWQnIDogJycsXG4gICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogcm93SGVpZ2h0IH0gfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJzcGFuXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zaHJpbmstY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyJyxcbiAgICAgICAgICAgICAgICAgICAgXSB9KSkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2xhdENvb3JkcyA9IChzbGF0Q29vcmRzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgc2xhdENvb3JkcyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gcmVuZGVyaW5nXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlbmRlclNpbXBsZUxheW91dChoZWFkZXJSb3dDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lQ29udGVudCkge1xuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHNlY3Rpb25zID0gW107XG4gICAgICAgIGxldCBzdGlja3lIZWFkZXJEYXRlcyA9IGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbERheUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5JyxcbiAgICAgICAgICAgICAgICBjaHVuazogeyBjb250ZW50OiBhbGxEYXlDb250ZW50IH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxuICAgICAgICAgICAgICAgIG91dGVyQ29udGVudDogKCAvLyBUT0RPOiByZW5hbWUgdG8gY2VsbENvbnRlbnQgc28gZG9uJ3QgbmVlZCB0byBkZWZpbmUgPHRyPj9cbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRkXCIsIHsgY2xhc3NOYW1lOiAnZmMtdGltZWdyaWQtZGl2aWRlciAnICsgY29udGV4dC50aGVtZS5nZXRDbGFzcygndGFibGVDZWxsU2hhZGVkJykgfSkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAga2V5OiAnYm9keScsXG4gICAgICAgICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICAgICAgICBleHBhbmRSb3dzOiBCb29sZWFuKGNvbnRleHQub3B0aW9ucy5leHBhbmRSb3dzKSxcbiAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJFbFJlZjogdGhpcy5zY3JvbGxlckVsUmVmLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRpbWVDb250ZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLnJvb3RFbFJlZiwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkJ10sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNpbXBsZVNjcm9sbEdyaWQsIHsgbGlxdWlkOiAhcHJvcHMuaXNIZWlnaHRBdXRvICYmICFwcm9wcy5mb3JQcmludCwgY29sbGFwc2libGVXaWR0aDogcHJvcHMuZm9yUHJpbnQsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XG4gICAgfVxuICAgIHJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyUm93Q29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUNvbnRlbnQsIGNvbENudCwgZGF5TWluV2lkdGgsIHNsYXRNZXRhcywgc2xhdENvb3Jkcykge1xuICAgICAgICBsZXQgU2Nyb2xsR3JpZCA9IHRoaXMuY29udGV4dC5wbHVnaW5Ib29rcy5zY3JvbGxHcmlkSW1wbDtcbiAgICAgICAgaWYgKCFTY3JvbGxHcmlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFNjcm9sbEdyaWQgaW1wbGVtZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHN0aWNreUhlYWRlckRhdGVzID0gIXByb3BzLmZvclByaW50ICYmIGdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSAhcHJvcHMuZm9yUHJpbnQgJiYgZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGxldCBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogKGFyZykgPT4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicHJlc2VudGF0aW9uXCIgfSwgdGhpcy5yZW5kZXJIZWFkQXhpcygnZGF5JywgYXJnLnJvd1N5bmNIZWlnaHRzWzBdKSkpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdjb2xzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsUmVmOiB0aGlzLmhlYWRlckVsUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0NvbnRlbnQ6IGhlYWRlclJvd0NvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxEYXlDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICAgICAga2V5OiAnYWxsLWRheScsXG4gICAgICAgICAgICAgICAgc3luY1Jvd0hlaWdodHM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogKGNvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIHRoaXMucmVuZGVyVGFibGVSb3dBeGlzKGNvbnRlbnRBcmcucm93U3luY0hlaWdodHNbMF0pKSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogYWxsRGF5Q29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6ICdhbGwtZGF5LWRpdmlkZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgICAgICBvdXRlckNvbnRlbnQ6ICggLy8gVE9ETzogcmVuYW1lIHRvIGNlbGxDb250ZW50IHNvIGRvbid0IG5lZWQgdG8gZGVmaW5lIDx0cj4/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRyXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc2VjdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNvbFNwYW46IDIsIGNsYXNzTmFtZTogJ2ZjLXRpbWVncmlkLWRpdmlkZXIgJyArIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlQ2VsbFNoYWRlZCcpIH0pKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNOb3dJbmRpY2F0b3IgPSBjb250ZXh0Lm9wdGlvbnMubm93SW5kaWNhdG9yO1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdib2R5JyxcbiAgICAgICAgICAgIGtleTogJ2JvZHknLFxuICAgICAgICAgICAgbGlxdWlkOiB0cnVlLFxuICAgICAgICAgICAgZXhwYW5kUm93czogQm9vbGVhbihjb250ZXh0Lm9wdGlvbnMuZXhwYW5kUm93cyksXG4gICAgICAgICAgICBjaHVua3M6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ2F4aXMnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAoYXJnKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgdGhpcyBub3ctaW5kaWNhdG9yIGFycm93IG1vcmUgRFJZIHdpdGggVGltZUNvbHNDb250ZW50XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYXhpcy1jaHVua1wiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIHN0eWxlOiB7IGhlaWdodDogYXJnLmV4cGFuZFJvd3MgPyBhcmcuY2xpZW50SGVpZ2h0IDogJycgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZy50YWJsZUNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQm9keUF4aXMsIHsgc2xhdE1ldGFzOiBzbGF0TWV0YXMgfSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogaXNOb3dJbmRpY2F0b3IgPyAnbWludXRlJyA6ICdkYXknIC8qIGhhY2t5ICovIH0sIChub3dEYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub3dJbmRpY2F0b3JUb3AgPSBpc05vd0luZGljYXRvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3JkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xhdENvb3Jkcy5zYWZlQ29tcHV0ZVRvcChub3dEYXRlKTsgLy8gbWlnaHQgcmV0dXJuIHZvaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBub3dJbmRpY2F0b3JUb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93SW5kaWNhdG9yQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1ub3ctaW5kaWNhdG9yLWFycm93J10sIGVsU3R5bGU6IHsgdG9wOiBub3dJbmRpY2F0b3JUb3AgfSwgaXNBeGlzOiB0cnVlLCBkYXRlOiBub3dEYXRlIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkpKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiAnY29scycsXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGVyRWxSZWY6IHRoaXMuc2Nyb2xsZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdGltZUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNodW5rczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6ICdheGlzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHJlbmRlclNjcm9sbFNoaW0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogJ2NvbHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogcmVuZGVyU2Nyb2xsU2hpbSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFZpZXdDb250YWluZXIsIHsgZWxSZWY6IHRoaXMucm9vdEVsUmVmLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQnXSwgdmlld1NwZWM6IGNvbnRleHQudmlld1NwZWMgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IGZhbHNlLCBjb2xHcm91cHM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyB3aWR0aDogJ3NocmluaycsIGNvbHM6IFt7IHdpZHRoOiAnc2hyaW5rJyB9XSB9LFxuICAgICAgICAgICAgICAgICAgICB7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH0sXG4gICAgICAgICAgICAgICAgXSwgc2VjdGlvbnM6IHNlY3Rpb25zIH0pKSk7XG4gICAgfVxuICAgIC8qIERpbWVuc2lvbnNcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuICAgIGdldEFsbERheU1heEV2ZW50UHJvcHMoKSB7XG4gICAgICAgIGxldCB7IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzIH0gPSB0aGlzLmNvbnRleHQub3B0aW9ucztcbiAgICAgICAgaWYgKGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWUpIHsgLy8gaXMgYXV0bz9cbiAgICAgICAgICAgIGRheU1heEV2ZW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGRheU1heEV2ZW50Um93cyA9IEFVVE9fQUxMX0RBWV9NQVhfRVZFTlRfUk9XUzsgLy8gbWFrZSBzdXJlIFwiYXV0b1wiIGdvZXMgdG8gYSByZWFsIG51bWJlclxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzIH07XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyQWxsRGF5SW5uZXIocmVuZGVyUHJvcHMpIHtcbiAgICByZXR1cm4gcmVuZGVyUHJvcHMudGV4dDtcbn1cblxuY2xhc3MgVGltZUNvbHNTbGF0c0Nvb3JkcyB7XG4gICAgY29uc3RydWN0b3IocG9zaXRpb25zLCBkYXRlUHJvZmlsZSwgc2xvdER1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmRhdGVQcm9maWxlID0gZGF0ZVByb2ZpbGU7XG4gICAgICAgIHRoaXMuc2xvdER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xuICAgIH1cbiAgICBzYWZlQ29tcHV0ZVRvcChkYXRlKSB7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSB0aGlzO1xuICAgICAgICBpZiAocmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGRhdGUpKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRPZkRheURhdGUgPSBzdGFydE9mRGF5KGRhdGUpO1xuICAgICAgICAgICAgbGV0IHRpbWVNcyA9IGRhdGUudmFsdWVPZigpIC0gc3RhcnRPZkRheURhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgaWYgKHRpbWVNcyA+PSBhc1JvdWdoTXMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUpICYmXG4gICAgICAgICAgICAgICAgdGltZU1zIDwgYXNSb3VnaE1zKGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNyZWF0ZUR1cmF0aW9uKHRpbWVNcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIEEgYHN0YXJ0T2ZEYXlEYXRlYCBtdXN0IGJlIGdpdmVuIGZvciBhdm9pZGluZyBhbWJpZ3VpdHkgb3ZlciBob3cgdG8gdHJlYXQgbWlkbmlnaHQuXG4gICAgY29tcHV0ZURhdGVUb3Aod2hlbiwgc3RhcnRPZkRheURhdGUpIHtcbiAgICAgICAgaWYgKCFzdGFydE9mRGF5RGF0ZSkge1xuICAgICAgICAgICAgc3RhcnRPZkRheURhdGUgPSBzdGFydE9mRGF5KHdoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKGNyZWF0ZUR1cmF0aW9uKHdoZW4udmFsdWVPZigpIC0gc3RhcnRPZkRheURhdGUudmFsdWVPZigpKSk7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHRoZSB0b3AgY29vcmRpbmF0ZSwgcmVsYXRpdmUgdG8gdGhlIGJvdW5kcyBvZiB0aGUgZ3JpZCwgb2YgdGhlIGdpdmVuIHRpbWUgKGEgRHVyYXRpb24pLlxuICAgIC8vIFRoaXMgaXMgYSBtYWtlc2hpZnkgd2F5IHRvIGNvbXB1dGUgdGhlIHRpbWUtdG9wLiBBc3N1bWVzIGFsbCBzbGF0TWV0YXMgZGF0ZXMgYXJlIHVuaWZvcm0uXG4gICAgLy8gRXZlbnR1YWxseSBhbGxvdyBjb21wdXRhdGlvbiB3aXRoIGFyYmlyYXJ5IHNsYXQgZGF0ZXMuXG4gICAgY29tcHV0ZVRpbWVUb3AoZHVyYXRpb24pIHtcbiAgICAgICAgbGV0IHsgcG9zaXRpb25zLCBkYXRlUHJvZmlsZSB9ID0gdGhpcztcbiAgICAgICAgbGV0IGxlbiA9IHBvc2l0aW9ucy5lbHMubGVuZ3RoO1xuICAgICAgICAvLyBmbG9hdGluZy1wb2ludCB2YWx1ZSBvZiAjIG9mIHNsb3RzIGNvdmVyZWRcbiAgICAgICAgbGV0IHNsYXRDb3ZlcmFnZSA9IChkdXJhdGlvbi5taWxsaXNlY29uZHMgLSBhc1JvdWdoTXMoZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUpKSAvIGFzUm91Z2hNcyh0aGlzLnNsb3REdXJhdGlvbik7XG4gICAgICAgIGxldCBzbGF0SW5kZXg7XG4gICAgICAgIGxldCBzbGF0UmVtYWluZGVyO1xuICAgICAgICAvLyBjb21wdXRlIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGZvciBob3cgbWFueSBzbGF0cyBzaG91bGQgYmUgcHJvZ3Jlc3NlZCB0aHJvdWdoLlxuICAgICAgICAvLyBmcm9tIDAgdG8gbnVtYmVyIG9mIHNsYXRzIChpbmNsdXNpdmUpXG4gICAgICAgIC8vIGNvbnN0cmFpbmVkIGJlY2F1c2Ugc2xvdE1pblRpbWUvc2xvdE1heFRpbWUgbWlnaHQgYmUgY3VzdG9taXplZC5cbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5tYXgoMCwgc2xhdENvdmVyYWdlKTtcbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5taW4obGVuLCBzbGF0Q292ZXJhZ2UpO1xuICAgICAgICAvLyBhbiBpbnRlZ2VyIGluZGV4IG9mIHRoZSBmdXJ0aGVzdCB3aG9sZSBzbGF0XG4gICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgc2xhdHMgKCpleGNsdXNpdmUqLCBzbyBsZW4tMSlcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5mbG9vcihzbGF0Q292ZXJhZ2UpO1xuICAgICAgICBzbGF0SW5kZXggPSBNYXRoLm1pbihzbGF0SW5kZXgsIGxlbiAtIDEpO1xuICAgICAgICAvLyBob3cgbXVjaCBmdXJ0aGVyIHRocm91Z2ggdGhlIHNsYXRJbmRleCBzbGF0IChmcm9tIDAuMC0xLjApIG11c3QgYmUgY292ZXJlZCBpbiBhZGRpdGlvbi5cbiAgICAgICAgLy8gY291bGQgYmUgMS4wIGlmIHNsYXRDb3ZlcmFnZSBpcyBjb3ZlcmluZyAqYWxsKiB0aGUgc2xvdHNcbiAgICAgICAgc2xhdFJlbWFpbmRlciA9IHNsYXRDb3ZlcmFnZSAtIHNsYXRJbmRleDtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9ucy50b3BzW3NsYXRJbmRleF0gK1xuICAgICAgICAgICAgcG9zaXRpb25zLmdldEhlaWdodChzbGF0SW5kZXgpICogc2xhdFJlbWFpbmRlcjtcbiAgICB9XG59XG5cbmNsYXNzIFRpbWVDb2xzU2xhdHNCb2R5IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgc2xhdEVsUmVmcyB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsIHByb3BzLnNsYXRNZXRhcy5tYXAoKHNsYXRNZXRhLCBpKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVuZGVyUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgdGltZTogc2xhdE1ldGEudGltZSxcbiAgICAgICAgICAgICAgICBkYXRlOiBjb250ZXh0LmRhdGVFbnYudG9EYXRlKHNsYXRNZXRhLmRhdGUpLFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2xhdE1ldGEua2V5LCByZWY6IHNsYXRFbFJlZnMuY3JlYXRlUmVmKHNsYXRNZXRhLmtleSkgfSxcbiAgICAgICAgICAgICAgICBwcm9wcy5heGlzICYmIChjcmVhdGVFbGVtZW50KFRpbWVDb2xzQXhpc0NlbGwsIE9iamVjdC5hc3NpZ24oe30sIHNsYXRNZXRhKSkpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1zbG90LWxhbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgIXNsYXRNZXRhLmlzTGFiZWxlZCAmJiAnZmMtdGltZWdyaWQtc2xvdC1taW5vcicsXG4gICAgICAgICAgICAgICAgICAgIF0sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXRpbWUnOiBzbGF0TWV0YS5pc29UaW1lU3RyLFxuICAgICAgICAgICAgICAgICAgICB9LCByZW5kZXJQcm9wczogcmVuZGVyUHJvcHMsIGdlbmVyYXRvck5hbWU6IFwic2xvdExhbmVDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFuZUNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5zbG90TGFuZUNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLnNsb3RMYW5lRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLnNsb3RMYW5lV2lsbFVubW91bnQgfSkpKTtcbiAgICAgICAgfSkpKTtcbiAgICB9XG59XG5cbi8qXG5mb3IgdGhlIGhvcml6b250YWwgXCJzbGF0c1wiIHRoYXQgcnVuIHdpZHRoLXdpc2UuIEhhcyBhIHRpbWUgYXhpcyBvbiBhIHNpZGUuIERlcGVuZHMgb24gUlRMLlxuKi9cbmNsYXNzIFRpbWVDb2xzU2xhdHMgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yb290RWxSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgdGhpcy5zbGF0RWxSZWZzID0gbmV3IFJlZk1hcCgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMucm9vdEVsUmVmLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtc2xvdHNcIiB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogcHJvcHMubWluSGVpZ2h0LFxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSAvKiByZWxpZXMgb24gdGhlcmUgb25seSBiZWluZyBhIHNpbmdsZSA8Y29sPiBmb3IgdGhlIGF4aXMgKi8sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sc1NsYXRzQm9keSwgeyBzbGF0RWxSZWZzOiB0aGlzLnNsYXRFbFJlZnMsIGF4aXM6IHByb3BzLmF4aXMsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzIH0pKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTaXppbmcoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZygpO1xuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25Db29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Db29yZHMobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU2l6aW5nKCkge1xuICAgICAgICBsZXQgeyBjb250ZXh0LCBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKHByb3BzLm9uQ29vcmRzICYmXG4gICAgICAgICAgICBwcm9wcy5jbGllbnRXaWR0aCAhPT0gbnVsbCAvLyBtZWFucyBzaXppbmcgaGFzIHN0YWJpbGl6ZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBsZXQgcm9vdEVsID0gdGhpcy5yb290RWxSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChyb290RWwub2Zmc2V0SGVpZ2h0KSB7IC8vIG5vdCBoaWRkZW4gYnkgY3NzXG4gICAgICAgICAgICAgICAgcHJvcHMub25Db29yZHMobmV3IFRpbWVDb2xzU2xhdHNDb29yZHMobmV3IFBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWxSZWYuY3VycmVudCwgY29sbGVjdFNsYXRFbHModGhpcy5zbGF0RWxSZWZzLmN1cnJlbnRNYXAsIHByb3BzLnNsYXRNZXRhcyksIGZhbHNlLCB0cnVlKSwgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSwgY29udGV4dC5vcHRpb25zLnNsb3REdXJhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY29sbGVjdFNsYXRFbHMoZWxNYXAsIHNsYXRNZXRhcykge1xuICAgIHJldHVybiBzbGF0TWV0YXMubWFwKChzbGF0TWV0YSkgPT4gZWxNYXBbc2xhdE1ldGEua2V5XSk7XG59XG5cbmZ1bmN0aW9uIHNwbGl0U2Vnc0J5Q29sKHNlZ3MsIGNvbENudCkge1xuICAgIGxldCBzZWdzQnlDb2wgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgc2Vnc0J5Q29sLnB1c2goW10pO1xuICAgIH1cbiAgICBpZiAoc2Vncykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgc2Vnc0J5Q29sW3NlZ3NbaV0uY29sXS5wdXNoKHNlZ3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWdzQnlDb2w7XG59XG5mdW5jdGlvbiBzcGxpdEludGVyYWN0aW9uQnlDb2wodWksIGNvbENudCkge1xuICAgIGxldCBieVJvdyA9IFtdO1xuICAgIGlmICghdWkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogdWkuYWZmZWN0ZWRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdWkuaXNFdmVudCxcbiAgICAgICAgICAgICAgICBzZWdzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgc2VnIG9mIHVpLnNlZ3MpIHtcbiAgICAgICAgICAgIGJ5Um93W3NlZy5jb2xdLnNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBieVJvdztcbn1cblxuY2xhc3MgVGltZUNvbE1vcmVMaW5rIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KE1vcmVMaW5rQ29udGFpbmVyLCB7IGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1tb3JlLWxpbmsnXSwgZWxTdHlsZToge1xuICAgICAgICAgICAgICAgIHRvcDogcHJvcHMudG9wLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogcHJvcHMuYm90dG9tLFxuICAgICAgICAgICAgfSwgYWxsRGF5RGF0ZTogbnVsbCwgbW9yZUNudDogcHJvcHMuaGlkZGVuU2Vncy5sZW5ndGgsIGFsbFNlZ3M6IHByb3BzLmhpZGRlblNlZ3MsIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgcG9wb3ZlckNvbnRlbnQ6ICgpID0+IHJlbmRlclBsYWluRmdTZWdzKHByb3BzLmhpZGRlblNlZ3MsIHByb3BzKSwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyTW9yZUxpbmtJbm5lciwgZm9yY2VUaW1lZDogdHJ1ZSB9LCAoSW5uZXJDb250ZW50KSA9PiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy10aW1lZ3JpZC1tb3JlLWxpbmstaW5uZXInLCAnZmMtc3RpY2t5J10gfSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyTW9yZUxpbmtJbm5lcihwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy5zaG9ydFRleHQ7XG59XG5cbi8vIHNlZ0lucHV0cyBhc3N1bWVkIHNvcnRlZFxuZnVuY3Rpb24gYnVpbGRQb3NpdGlvbmluZyhzZWdJbnB1dHMsIHN0cmljdE9yZGVyLCBtYXhTdGFja0NudCkge1xuICAgIGxldCBoaWVyYXJjaHkgPSBuZXcgU2VnSGllcmFyY2h5KCk7XG4gICAgaWYgKHN0cmljdE9yZGVyICE9IG51bGwpIHtcbiAgICAgICAgaGllcmFyY2h5LnN0cmljdE9yZGVyID0gc3RyaWN0T3JkZXI7XG4gICAgfVxuICAgIGlmIChtYXhTdGFja0NudCAhPSBudWxsKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IG1heFN0YWNrQ250O1xuICAgIH1cbiAgICBsZXQgaGlkZGVuRW50cmllcyA9IGhpZXJhcmNoeS5hZGRTZWdzKHNlZ0lucHV0cyk7XG4gICAgbGV0IGhpZGRlbkdyb3VwcyA9IGdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyhoaWRkZW5FbnRyaWVzKTtcbiAgICBsZXQgd2ViID0gYnVpbGRXZWIoaGllcmFyY2h5KTtcbiAgICB3ZWIgPSBzdHJldGNoV2ViKHdlYiwgMSk7IC8vIGFsbCBsZXZlbENvb3Jkcy90aGlja25lc3Mgd2lsbCBoYXZlIDAuMC0xLjBcbiAgICBsZXQgc2VnUmVjdHMgPSB3ZWJUb1JlY3RzKHdlYik7XG4gICAgcmV0dXJuIHsgc2VnUmVjdHMsIGhpZGRlbkdyb3VwcyB9O1xufVxuZnVuY3Rpb24gYnVpbGRXZWIoaGllcmFyY2h5KSB7XG4gICAgY29uc3QgeyBlbnRyaWVzQnlMZXZlbCB9ID0gaGllcmFyY2h5O1xuICAgIGNvbnN0IGJ1aWxkTm9kZSA9IGNhY2hlYWJsZSgobGV2ZWwsIGxhdGVyYWwpID0+IGxldmVsICsgJzonICsgbGF0ZXJhbCwgKGxldmVsLCBsYXRlcmFsKSA9PiB7XG4gICAgICAgIGxldCBzaWJsaW5nUmFuZ2UgPSBmaW5kTmV4dExldmVsU2VncyhoaWVyYXJjaHksIGxldmVsLCBsYXRlcmFsKTtcbiAgICAgICAgbGV0IG5leHRMZXZlbFJlcyA9IGJ1aWxkTm9kZXMoc2libGluZ1JhbmdlLCBidWlsZE5vZGUpO1xuICAgICAgICBsZXQgZW50cnkgPSBlbnRyaWVzQnlMZXZlbFtsZXZlbF1bbGF0ZXJhbF07XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVudHJ5KSwgeyBuZXh0TGV2ZWxOb2RlczogbmV4dExldmVsUmVzWzBdIH0pLFxuICAgICAgICAgICAgZW50cnkudGhpY2tuZXNzICsgbmV4dExldmVsUmVzWzFdLCAvLyB0aGUgcHJlc3N1cmUgYnVpbGRzXG4gICAgICAgIF07XG4gICAgfSk7XG4gICAgcmV0dXJuIGJ1aWxkTm9kZXMoZW50cmllc0J5TGV2ZWwubGVuZ3RoXG4gICAgICAgID8geyBsZXZlbDogMCwgbGF0ZXJhbFN0YXJ0OiAwLCBsYXRlcmFsRW5kOiBlbnRyaWVzQnlMZXZlbFswXS5sZW5ndGggfVxuICAgICAgICA6IG51bGwsIGJ1aWxkTm9kZSlbMF07XG59XG5mdW5jdGlvbiBidWlsZE5vZGVzKHNpYmxpbmdSYW5nZSwgYnVpbGROb2RlKSB7XG4gICAgaWYgKCFzaWJsaW5nUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFtbXSwgMF07XG4gICAgfVxuICAgIGxldCB7IGxldmVsLCBsYXRlcmFsU3RhcnQsIGxhdGVyYWxFbmQgfSA9IHNpYmxpbmdSYW5nZTtcbiAgICBsZXQgbGF0ZXJhbCA9IGxhdGVyYWxTdGFydDtcbiAgICBsZXQgcGFpcnMgPSBbXTtcbiAgICB3aGlsZSAobGF0ZXJhbCA8IGxhdGVyYWxFbmQpIHtcbiAgICAgICAgcGFpcnMucHVzaChidWlsZE5vZGUobGV2ZWwsIGxhdGVyYWwpKTtcbiAgICAgICAgbGF0ZXJhbCArPSAxO1xuICAgIH1cbiAgICBwYWlycy5zb3J0KGNtcERlc2NQcmVzc3VyZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHBhaXJzLm1hcChleHRyYWN0Tm9kZSksXG4gICAgICAgIHBhaXJzWzBdWzFdLCAvLyBmaXJzdCBpdGVtJ3MgcHJlc3N1cmVcbiAgICBdO1xufVxuZnVuY3Rpb24gY21wRGVzY1ByZXNzdXJlcyhhLCBiKSB7XG4gICAgcmV0dXJuIGJbMV0gLSBhWzFdO1xufVxuZnVuY3Rpb24gZXh0cmFjdE5vZGUoYSkge1xuICAgIHJldHVybiBhWzBdO1xufVxuZnVuY3Rpb24gZmluZE5leHRMZXZlbFNlZ3MoaGllcmFyY2h5LCBzdWJqZWN0TGV2ZWwsIHN1YmplY3RMYXRlcmFsKSB7XG4gICAgbGV0IHsgbGV2ZWxDb29yZHMsIGVudHJpZXNCeUxldmVsIH0gPSBoaWVyYXJjaHk7XG4gICAgbGV0IHN1YmplY3RFbnRyeSA9IGVudHJpZXNCeUxldmVsW3N1YmplY3RMZXZlbF1bc3ViamVjdExhdGVyYWxdO1xuICAgIGxldCBhZnRlclN1YmplY3QgPSBsZXZlbENvb3Jkc1tzdWJqZWN0TGV2ZWxdICsgc3ViamVjdEVudHJ5LnRoaWNrbmVzcztcbiAgICBsZXQgbGV2ZWxDbnQgPSBsZXZlbENvb3Jkcy5sZW5ndGg7XG4gICAgbGV0IGxldmVsID0gc3ViamVjdExldmVsO1xuICAgIC8vIHNraXAgcGFzdCBsZXZlbHMgdGhhdCBhcmUgdG9vIGhpZ2ggdXBcbiAgICBmb3IgKDsgbGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tsZXZlbF0gPCBhZnRlclN1YmplY3Q7IGxldmVsICs9IDEpXG4gICAgICAgIDsgLy8gZG8gbm90aGluZ1xuICAgIGZvciAoOyBsZXZlbCA8IGxldmVsQ250OyBsZXZlbCArPSAxKSB7XG4gICAgICAgIGxldCBlbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdO1xuICAgICAgICBsZXQgZW50cnk7XG4gICAgICAgIGxldCBzZWFyY2hJbmRleCA9IGJpbmFyeVNlYXJjaChlbnRyaWVzLCBzdWJqZWN0RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTtcbiAgICAgICAgbGV0IGxhdGVyYWxTdGFydCA9IHNlYXJjaEluZGV4WzBdICsgc2VhcmNoSW5kZXhbMV07IC8vIGlmIGV4YWN0IG1hdGNoICh3aGljaCBkb2Vzbid0IGNvbGxpZGUpLCBnbyB0byBuZXh0IG9uZVxuICAgICAgICBsZXQgbGF0ZXJhbEVuZCA9IGxhdGVyYWxTdGFydDtcbiAgICAgICAgd2hpbGUgKCAvLyBsb29wIHRocm91Z2ggZW50cmllcyB0aGF0IGhvcml6b250YWxseSBpbnRlcnNlY3RcbiAgICAgICAgKGVudHJ5ID0gZW50cmllc1tsYXRlcmFsRW5kXSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBzZWcgbGlzdFxuICAgICAgICAgICAgZW50cnkuc3Bhbi5zdGFydCA8IHN1YmplY3RFbnRyeS5zcGFuLmVuZCkge1xuICAgICAgICAgICAgbGF0ZXJhbEVuZCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXRlcmFsU3RhcnQgPCBsYXRlcmFsRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBsZXZlbCwgbGF0ZXJhbFN0YXJ0LCBsYXRlcmFsRW5kIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBzdHJldGNoV2ViKHRvcExldmVsTm9kZXMsIHRvdGFsVGhpY2tuZXNzKSB7XG4gICAgY29uc3Qgc3RyZXRjaE5vZGUgPSBjYWNoZWFibGUoKG5vZGUsIHN0YXJ0Q29vcmQsIHByZXZUaGlja25lc3MpID0+IGJ1aWxkRW50cnlLZXkobm9kZSksIChub2RlLCBzdGFydENvb3JkLCBwcmV2VGhpY2tuZXNzKSA9PiB7XG4gICAgICAgIGxldCB7IG5leHRMZXZlbE5vZGVzLCB0aGlja25lc3MgfSA9IG5vZGU7XG4gICAgICAgIGxldCBhbGxUaGlja25lc3MgPSB0aGlja25lc3MgKyBwcmV2VGhpY2tuZXNzO1xuICAgICAgICBsZXQgdGhpY2tuZXNzRnJhY3Rpb24gPSB0aGlja25lc3MgLyBhbGxUaGlja25lc3M7XG4gICAgICAgIGxldCBlbmRDb29yZDtcbiAgICAgICAgbGV0IG5ld0NoaWxkcmVuID0gW107XG4gICAgICAgIGlmICghbmV4dExldmVsTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmRDb29yZCA9IHRvdGFsVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGROb2RlIG9mIG5leHRMZXZlbE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZENvb3JkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IHN0cmV0Y2hOb2RlKGNoaWxkTm9kZSwgc3RhcnRDb29yZCwgYWxsVGhpY2tuZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29vcmQgPSByZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIG5ld0NoaWxkcmVuLnB1c2gocmVzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBzdHJldGNoTm9kZShjaGlsZE5vZGUsIGVuZENvb3JkLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGRyZW4ucHVzaChyZXNbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3VGhpY2tuZXNzID0gKGVuZENvb3JkIC0gc3RhcnRDb29yZCkgKiB0aGlja25lc3NGcmFjdGlvbjtcbiAgICAgICAgcmV0dXJuIFtlbmRDb29yZCAtIG5ld1RoaWNrbmVzcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub2RlKSwgeyB0aGlja25lc3M6IG5ld1RoaWNrbmVzcywgbmV4dExldmVsTm9kZXM6IG5ld0NoaWxkcmVuIH0pXTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9wTGV2ZWxOb2Rlcy5tYXAoKG5vZGUpID0+IHN0cmV0Y2hOb2RlKG5vZGUsIDAsIDApWzFdKTtcbn1cbi8vIG5vdCBzb3J0ZWQgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXJcbmZ1bmN0aW9uIHdlYlRvUmVjdHModG9wTGV2ZWxOb2Rlcykge1xuICAgIGxldCByZWN0cyA9IFtdO1xuICAgIGNvbnN0IHByb2Nlc3NOb2RlID0gY2FjaGVhYmxlKChub2RlLCBsZXZlbENvb3JkLCBzdGFja0RlcHRoKSA9PiBidWlsZEVudHJ5S2V5KG5vZGUpLCAobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkgPT4ge1xuICAgICAgICBsZXQgcmVjdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZSksIHsgbGV2ZWxDb29yZCxcbiAgICAgICAgICAgIHN0YWNrRGVwdGgsIHN0YWNrRm9yd2FyZDogMCB9KTtcbiAgICAgICAgcmVjdHMucHVzaChyZWN0KTtcbiAgICAgICAgcmV0dXJuIChyZWN0LnN0YWNrRm9yd2FyZCA9IHByb2Nlc3NOb2Rlcyhub2RlLm5leHRMZXZlbE5vZGVzLCBsZXZlbENvb3JkICsgbm9kZS50aGlja25lc3MsIHN0YWNrRGVwdGggKyAxKSArIDEpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHByb2Nlc3NOb2Rlcyhub2RlcywgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCkge1xuICAgICAgICBsZXQgc3RhY2tGb3J3YXJkID0gMDtcbiAgICAgICAgZm9yIChsZXQgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICAgICAgc3RhY2tGb3J3YXJkID0gTWF0aC5tYXgocHJvY2Vzc05vZGUobm9kZSwgbGV2ZWxDb29yZCwgc3RhY2tEZXB0aCksIHN0YWNrRm9yd2FyZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrRm9yd2FyZDtcbiAgICB9XG4gICAgcHJvY2Vzc05vZGVzKHRvcExldmVsTm9kZXMsIDAsIDApO1xuICAgIHJldHVybiByZWN0czsgLy8gVE9ETzogc29ydCByZWN0cyBieSBsZXZlbENvb3JkIHRvIGJlIGNvbnNpc3RlbnQgd2l0aCB0b1JlY3RzP1xufVxuLy8gVE9ETzogbW92ZSB0byBnZW5lcmFsIHV0aWxcbmZ1bmN0aW9uIGNhY2hlYWJsZShrZXlGdW5jLCB3b3JrRnVuYykge1xuICAgIGNvbnN0IGNhY2hlID0ge307XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGxldCBrZXkgPSBrZXlGdW5jKC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gKGtleSBpbiBjYWNoZSlcbiAgICAgICAgICAgID8gY2FjaGVba2V5XVxuICAgICAgICAgICAgOiAoY2FjaGVba2V5XSA9IHdvcmtGdW5jKC4uLmFyZ3MpKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU2VnVkNvb3JkcyhzZWdzLCBjb2xEYXRlLCBzbGF0Q29vcmRzID0gbnVsbCwgZXZlbnRNaW5IZWlnaHQgPSAwKSB7XG4gICAgbGV0IHZjb29yZHMgPSBbXTtcbiAgICBpZiAoc2xhdENvb3Jkcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAgICAgbGV0IHNwYW5TdGFydCA9IHNsYXRDb29yZHMuY29tcHV0ZURhdGVUb3Aoc2VnLnN0YXJ0LCBjb2xEYXRlKTtcbiAgICAgICAgICAgIGxldCBzcGFuRW5kID0gTWF0aC5tYXgoc3BhblN0YXJ0ICsgKGV2ZW50TWluSGVpZ2h0IHx8IDApLCAvLyA6KFxuICAgICAgICAgICAgc2xhdENvb3Jkcy5jb21wdXRlRGF0ZVRvcChzZWcuZW5kLCBjb2xEYXRlKSk7XG4gICAgICAgICAgICB2Y29vcmRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBNYXRoLnJvdW5kKHNwYW5TdGFydCksXG4gICAgICAgICAgICAgICAgZW5kOiBNYXRoLnJvdW5kKHNwYW5FbmQpLCAvL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZjb29yZHM7XG59XG5mdW5jdGlvbiBjb21wdXRlRmdTZWdQbGFjZW1lbnRzKHNlZ3MsIHNlZ1ZDb29yZHMsIC8vIG1pZ2h0IG5vdCBoYXZlIGZvciBldmVyeSBzZWdcbmV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spIHtcbiAgICBsZXQgc2VnSW5wdXRzID0gW107XG4gICAgbGV0IGR1bWJTZWdzID0gW107IC8vIHNlZ3Mgd2l0aG91dCBjb29yZHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IHZjb29yZHMgPSBzZWdWQ29vcmRzW2ldO1xuICAgICAgICBpZiAodmNvb3Jkcykge1xuICAgICAgICAgICAgc2VnSW5wdXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogMSxcbiAgICAgICAgICAgICAgICBzcGFuOiB2Y29vcmRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkdW1iU2Vncy5wdXNoKHNlZ3NbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB7IHNlZ1JlY3RzLCBoaWRkZW5Hcm91cHMgfSA9IGJ1aWxkUG9zaXRpb25pbmcoc2VnSW5wdXRzLCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1heFN0YWNrKTtcbiAgICBsZXQgc2VnUGxhY2VtZW50cyA9IFtdO1xuICAgIGZvciAobGV0IHNlZ1JlY3Qgb2Ygc2VnUmVjdHMpIHtcbiAgICAgICAgc2VnUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgIHNlZzogc2Vnc1tzZWdSZWN0LmluZGV4XSxcbiAgICAgICAgICAgIHJlY3Q6IHNlZ1JlY3QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBkdW1iU2VnIG9mIGR1bWJTZWdzKSB7XG4gICAgICAgIHNlZ1BsYWNlbWVudHMucHVzaCh7IHNlZzogZHVtYlNlZywgcmVjdDogbnVsbCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VnUGxhY2VtZW50cywgaGlkZGVuR3JvdXBzIH07XG59XG5cbmNvbnN0IERFRkFVTFRfVElNRV9GT1JNQVQgPSBjcmVhdGVGb3JtYXR0ZXIoe1xuICAgIGhvdXI6ICdudW1lcmljJyxcbiAgICBtaW51dGU6ICcyLWRpZ2l0JyxcbiAgICBtZXJpZGllbTogZmFsc2UsXG59KTtcbmNsYXNzIFRpbWVDb2xFdmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFN0YW5kYXJkRXZlbnQsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLXRpbWVncmlkLWV2ZW50JyxcbiAgICAgICAgICAgICAgICAnZmMtdi1ldmVudCcsXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5pc1Nob3J0ICYmICdmYy10aW1lZ3JpZC1ldmVudC1zaG9ydCcsXG4gICAgICAgICAgICBdLCBkZWZhdWx0VGltZUZvcm1hdDogREVGQVVMVF9USU1FX0ZPUk1BVCB9KSkpO1xuICAgIH1cbn1cblxuY2xhc3MgVGltZUNvbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNvcnRFdmVudFNlZ3MgPSBtZW1vaXplKHNvcnRFdmVudFNlZ3MpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBtZW1vaXplIGV2ZW50LXBsYWNlbWVudD9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGxldCB7IHByb3BzLCBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBvcHRpb25zIH0gPSBjb250ZXh0O1xuICAgICAgICBsZXQgaXNTZWxlY3RNaXJyb3IgPSBvcHRpb25zLnNlbGVjdE1pcnJvcjtcbiAgICAgICAgbGV0IG1pcnJvclNlZ3MgPSAvLyB5dWNrXG4gICAgICAgICAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5zZWdzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLnNlZ3MpIHx8XG4gICAgICAgICAgICAoaXNTZWxlY3RNaXJyb3IgJiYgcHJvcHMuZGF0ZVNlbGVjdGlvblNlZ3MpIHx8XG4gICAgICAgICAgICBbXTtcbiAgICAgICAgbGV0IGludGVyYWN0aW9uQWZmZWN0ZWRJbnN0YW5jZXMgPSAvLyBUT0RPOiBtZXNzeSB3YXkgdG8gY29tcHV0ZSB0aGlzXG4gICAgICAgICAocHJvcHMuZXZlbnREcmFnICYmIHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSAmJiBwcm9wcy5ldmVudFJlc2l6ZS5hZmZlY3RlZEluc3RhbmNlcykgfHxcbiAgICAgICAgICAgIHt9O1xuICAgICAgICBsZXQgc29ydGVkRmdTZWdzID0gdGhpcy5zb3J0RXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBvcHRpb25zLmV2ZW50T3JkZXIpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRGF5Q2VsbENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbFJlZjogcHJvcHMuZWxSZWYsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy10aW1lZ3JpZC1jb2wnLFxuICAgICAgICAgICAgICAgIC4uLihwcm9wcy5leHRyYUNsYXNzTmFtZXMgfHwgW10pLFxuICAgICAgICAgICAgXSwgZWxBdHRyczogT2JqZWN0LmFzc2lnbih7IHJvbGU6ICdncmlkY2VsbCcgfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLCBkYXRlOiBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhUmVuZGVyUHJvcHM6IHByb3BzLmV4dHJhUmVuZGVyUHJvcHMgfSwgKElubmVyQ29udGVudCkgPT4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWZyYW1lXCIgfSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sLWJnXCIgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsICdub24tYnVzaW5lc3MnKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmJnRXZlbnRTZWdzLCAnYmctZXZlbnQnKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckZpbGxTZWdzKHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCAnaGlnaGxpZ2h0JykpLFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1jb2wtZXZlbnRzXCIgfSwgdGhpcy5yZW5kZXJGZ1NlZ3Moc29ydGVkRmdTZWdzLCBpbnRlcmFjdGlvbkFmZmVjdGVkSW5zdGFuY2VzLCBmYWxzZSwgZmFsc2UsIGZhbHNlKSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1ldmVudHNcIiB9LCB0aGlzLnJlbmRlckZnU2VncyhtaXJyb3JTZWdzLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgQm9vbGVhbihpc1NlbGVjdE1pcnJvciksICdtaXJyb3InKSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVyXCIgfSwgdGhpcy5yZW5kZXJOb3dJbmRpY2F0b3IocHJvcHMubm93SW5kaWNhdG9yU2VncykpLFxuICAgICAgICAgICAgaGFzQ3VzdG9tRGF5Q2VsbENvbnRlbnQob3B0aW9ucykgJiYgKGNyZWF0ZUVsZW1lbnQoSW5uZXJDb250ZW50LCB7IGVsVGFnOiBcImRpdlwiLCBlbENsYXNzZXM6IFsnZmMtdGltZWdyaWQtY29sLW1pc2MnXSB9KSkpKSkpO1xuICAgIH1cbiAgICByZW5kZXJGZ1NlZ3Moc29ydGVkRmdTZWdzLCBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nLCBmb3JjZWRLZXkpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGlmIChwcm9wcy5mb3JQcmludCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlclBsYWluRmdTZWdzKHNvcnRlZEZnU2VncywgcHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclBvc2l0aW9uZWRGZ1NlZ3Moc29ydGVkRmdTZWdzLCBzZWdJc0ludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nLCBmb3JjZWRLZXkpO1xuICAgIH1cbiAgICByZW5kZXJQb3NpdGlvbmVkRmdTZWdzKHNlZ3MsIC8vIGlmIG5vdCBtaXJyb3IsIG5lZWRzIHRvIGJlIHNvcnRlZFxuICAgIHNlZ0lzSW52aXNpYmxlLCBpc0RyYWdnaW5nLCBpc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3RpbmcsIGZvcmNlZEtleSkge1xuICAgICAgICBsZXQgeyBldmVudE1heFN0YWNrLCBldmVudFNob3J0SGVpZ2h0LCBldmVudE9yZGVyU3RyaWN0LCBldmVudE1pbkhlaWdodCB9ID0gdGhpcy5jb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIGxldCB7IGRhdGUsIHNsYXRDb29yZHMsIGV2ZW50U2VsZWN0aW9uLCB0b2RheVJhbmdlLCBub3dEYXRlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgaXNNaXJyb3IgPSBpc0RyYWdnaW5nIHx8IGlzUmVzaXppbmcgfHwgaXNEYXRlU2VsZWN0aW5nO1xuICAgICAgICBsZXQgc2VnVkNvb3JkcyA9IGNvbXB1dGVTZWdWQ29vcmRzKHNlZ3MsIGRhdGUsIHNsYXRDb29yZHMsIGV2ZW50TWluSGVpZ2h0KTtcbiAgICAgICAgbGV0IHsgc2VnUGxhY2VtZW50cywgaGlkZGVuR3JvdXBzIH0gPSBjb21wdXRlRmdTZWdQbGFjZW1lbnRzKHNlZ3MsIHNlZ1ZDb29yZHMsIGV2ZW50T3JkZXJTdHJpY3QsIGV2ZW50TWF4U3RhY2spO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZGRlbkdyb3VwcyhoaWRkZW5Hcm91cHMsIHNlZ3MpLFxuICAgICAgICAgICAgc2VnUGxhY2VtZW50cy5tYXAoKHNlZ1BsYWNlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB7IHNlZywgcmVjdCB9ID0gc2VnUGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZUlkID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICBsZXQgaXNWaXNpYmxlID0gaXNNaXJyb3IgfHwgQm9vbGVhbighc2VnSXNJbnZpc2libGVbaW5zdGFuY2VJZF0gJiYgcmVjdCk7XG4gICAgICAgICAgICAgICAgbGV0IHZTdHlsZSA9IGNvbXB1dGVTZWdWU3R5bGUocmVjdCAmJiByZWN0LnNwYW4pO1xuICAgICAgICAgICAgICAgIGxldCBoU3R5bGUgPSAoIWlzTWlycm9yICYmIHJlY3QpID8gdGhpcy5jb21wdXRlU2VnSFN0eWxlKHJlY3QpIDogeyBsZWZ0OiAwLCByaWdodDogMCB9O1xuICAgICAgICAgICAgICAgIGxldCBpc0luc2V0ID0gQm9vbGVhbihyZWN0KSAmJiByZWN0LnN0YWNrRm9yd2FyZCA+IDA7XG4gICAgICAgICAgICAgICAgbGV0IGlzU2hvcnQgPSBCb29sZWFuKHJlY3QpICYmIChyZWN0LnNwYW4uZW5kIC0gcmVjdC5zcGFuLnN0YXJ0KSA8IGV2ZW50U2hvcnRIZWlnaHQ7IC8vIGxvb2sgYXQgb3RoZXIgcGxhY2VzIGZvciB0aGlzIHByb2JsZW1cbiAgICAgICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmYy10aW1lZ3JpZC1ldmVudC1oYXJuZXNzJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNJbnNldCA/ICcgZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcy1pbnNldCcgOiAnJyksIGtleTogZm9yY2VkS2V5IHx8IGluc3RhbmNlSWQsIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nIH0sIHZTdHlsZSksIGhTdHlsZSkgfSxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChUaW1lQ29sRXZlbnQsIE9iamVjdC5hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNSZXNpemluZzogaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nOiBpc0RhdGVTZWxlY3RpbmcsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBpc1Nob3J0IH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSkpKSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH1cbiAgICAvLyB3aWxsIGFscmVhZHkgaGF2ZSBldmVudE1pbkhlaWdodCBhcHBsaWVkIGJlY2F1c2Ugc2VnSW5wdXRzIGFscmVhZHkgaGFkIGl0XG4gICAgcmVuZGVySGlkZGVuR3JvdXBzKGhpZGRlbkdyb3Vwcywgc2Vncykge1xuICAgICAgICBsZXQgeyBleHRyYURhdGVTcGFuLCBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZywgZXZlbnRSZXNpemUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgaGlkZGVuR3JvdXBzLm1hcCgoaGlkZGVuR3JvdXApID0+IHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbkNzcyA9IGNvbXB1dGVTZWdWU3R5bGUoaGlkZGVuR3JvdXAuc3Bhbik7XG4gICAgICAgICAgICBsZXQgaGlkZGVuU2VncyA9IGNvbXBpbGVTZWdzRnJvbUVudHJpZXMoaGlkZGVuR3JvdXAuZW50cmllcywgc2Vncyk7XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbE1vcmVMaW5rLCB7IGtleTogYnVpbGRJc29TdHJpbmcoY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncykpLCBoaWRkZW5TZWdzOiBoaWRkZW5TZWdzLCB0b3A6IHBvc2l0aW9uQ3NzLnRvcCwgYm90dG9tOiBwb3NpdGlvbkNzcy5ib3R0b20sIGV4dHJhRGF0ZVNwYW46IGV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgbm93RGF0ZTogbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb246IGV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IGV2ZW50RHJhZywgZXZlbnRSZXNpemU6IGV2ZW50UmVzaXplIH0pKTtcbiAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRmlsbFNlZ3Moc2VncywgZmlsbFR5cGUpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCBzZWdWQ29vcmRzID0gY29tcHV0ZVNlZ1ZDb29yZHMoc2VncywgcHJvcHMuZGF0ZSwgcHJvcHMuc2xhdENvb3JkcywgY29udGV4dC5vcHRpb25zLmV2ZW50TWluSGVpZ2h0KTsgLy8gZG9uJ3QgYXNzdW1lIGFsbCBwb3B1bGF0ZWRcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gc2VnVkNvb3Jkcy5tYXAoKHZjb29yZHMsIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBzZWcgPSBzZWdzW2ldO1xuICAgICAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBidWlsZEV2ZW50UmFuZ2VLZXkoc2VnLmV2ZW50UmFuZ2UpLCBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtYmctaGFybmVzc1wiLCBzdHlsZTogY29tcHV0ZVNlZ1ZTdHlsZSh2Y29vcmRzKSB9LCBmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChCZ0V2ZW50LCBPYmplY3QuYXNzaWduKHsgc2VnOiBzZWcgfSwgZ2V0U2VnTWV0YShzZWcsIHByb3BzLnRvZGF5UmFuZ2UsIHByb3BzLm5vd0RhdGUpKSkgOlxuICAgICAgICAgICAgICAgIHJlbmRlckZpbGwoZmlsbFR5cGUpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICByZW5kZXJOb3dJbmRpY2F0b3Ioc2Vncykge1xuICAgICAgICBsZXQgeyBzbGF0Q29vcmRzLCBkYXRlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAoIXNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzLm1hcCgoc2VnLCBpKSA9PiAoY3JlYXRlRWxlbWVudChOb3dJbmRpY2F0b3JDb250YWluZXJcbiAgICAgICAgLy8ga2V5IGRvZXNuJ3QgbWF0dGVyLiB3aWxsIG9ubHkgZXZlciBiZSBvbmVcbiAgICAgICAgLCB7IFxuICAgICAgICAgICAgLy8ga2V5IGRvZXNuJ3QgbWF0dGVyLiB3aWxsIG9ubHkgZXZlciBiZSBvbmVcbiAgICAgICAgICAgIGtleTogaSwgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItbGluZSddLCBlbFN0eWxlOiB7XG4gICAgICAgICAgICAgICAgdG9wOiBzbGF0Q29vcmRzLmNvbXB1dGVEYXRlVG9wKHNlZy5zdGFydCwgZGF0ZSksXG4gICAgICAgICAgICB9LCBpc0F4aXM6IGZhbHNlLCBkYXRlOiBkYXRlIH0pKSk7XG4gICAgfVxuICAgIGNvbXB1dGVTZWdIU3R5bGUoc2VnSENvb3Jkcykge1xuICAgICAgICBsZXQgeyBpc1J0bCwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgc2hvdWxkT3ZlcmxhcCA9IG9wdGlvbnMuc2xvdEV2ZW50T3ZlcmxhcDtcbiAgICAgICAgbGV0IG5lYXJDb29yZCA9IHNlZ0hDb29yZHMubGV2ZWxDb29yZDsgLy8gdGhlIGxlZnQgc2lkZSBpZiBMVFIuIHRoZSByaWdodCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcbiAgICAgICAgbGV0IGZhckNvb3JkID0gc2VnSENvb3Jkcy5sZXZlbENvb3JkICsgc2VnSENvb3Jkcy50aGlja25lc3M7IC8vIHRoZSByaWdodCBzaWRlIGlmIExUUi4gdGhlIGxlZnQgc2lkZSBpZiBSVEwuIGZsb2F0aW5nLXBvaW50XG4gICAgICAgIGxldCBsZWZ0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSBsZWZ0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXG4gICAgICAgIGxldCByaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIGZyb20gcmlnaHQgZWRnZSwgYSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgd2lkdGhcbiAgICAgICAgaWYgKHNob3VsZE92ZXJsYXApIHtcbiAgICAgICAgICAgIC8vIGRvdWJsZSB0aGUgd2lkdGgsIGJ1dCBkb24ndCBnbyBiZXlvbmQgdGhlIG1heGltdW0gZm9yd2FyZCBjb29yZGluYXRlICgxLjApXG4gICAgICAgICAgICBmYXJDb29yZCA9IE1hdGgubWluKDEsIG5lYXJDb29yZCArIChmYXJDb29yZCAtIG5lYXJDb29yZCkgKiAyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSdGwpIHtcbiAgICAgICAgICAgIGxlZnQgPSAxIC0gZmFyQ29vcmQ7XG4gICAgICAgICAgICByaWdodCA9IG5lYXJDb29yZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBuZWFyQ29vcmQ7XG4gICAgICAgICAgICByaWdodCA9IDEgLSBmYXJDb29yZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvcHMgPSB7XG4gICAgICAgICAgICB6SW5kZXg6IHNlZ0hDb29yZHMuc3RhY2tEZXB0aCArIDEsXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0ICogMTAwICsgJyUnLFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0ICogMTAwICsgJyUnLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2hvdWxkT3ZlcmxhcCAmJiAhc2VnSENvb3Jkcy5zdGFja0ZvcndhcmQpIHtcbiAgICAgICAgICAgIC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBlZGdlIHNvIHRoYXQgZm9yd2FyZCBzdGFja2VkIGV2ZW50cyBkb24ndCBjb3ZlciB0aGUgcmVzaXplcidzIGljb25cbiAgICAgICAgICAgIHByb3BzW2lzUnRsID8gJ21hcmdpbkxlZnQnIDogJ21hcmdpblJpZ2h0J10gPSAxMCAqIDI7IC8vIDEwIGlzIGEgZ3Vlc3N0aW1hdGUgb2YgdGhlIGljb24ncyB3aWR0aFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJQbGFpbkZnU2Vncyhzb3J0ZWRGZ1NlZ3MsIHsgdG9kYXlSYW5nZSwgbm93RGF0ZSwgZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZywgZXZlbnRSZXNpemUgfSkge1xuICAgIGxldCBoaWRkZW5JbnN0YW5jZXMgPSAoZXZlbnREcmFnID8gZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgKGV2ZW50UmVzaXplID8gZXZlbnRSZXNpemUuYWZmZWN0ZWRJbnN0YW5jZXMgOiBudWxsKSB8fFxuICAgICAgICB7fTtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHNvcnRlZEZnU2Vncy5tYXAoKHNlZykgPT4ge1xuICAgICAgICBsZXQgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogaW5zdGFuY2VJZCwgc3R5bGU6IHsgdmlzaWJpbGl0eTogaGlkZGVuSW5zdGFuY2VzW2luc3RhbmNlSWRdID8gJ2hpZGRlbicgOiAnJyB9IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xFdmVudCwgT2JqZWN0LmFzc2lnbih7IHNlZzogc2VnLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGluc3RhbmNlSWQgPT09IGV2ZW50U2VsZWN0aW9uLCBpc1Nob3J0OiBmYWxzZSB9LCBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkpKSkpO1xuICAgIH0pKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnVlN0eWxlKHNlZ1ZDb29yZHMpIHtcbiAgICBpZiAoIXNlZ1ZDb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHsgdG9wOiAnJywgYm90dG9tOiAnJyB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHNlZ1ZDb29yZHMuc3RhcnQsXG4gICAgICAgIGJvdHRvbTogLXNlZ1ZDb29yZHMuZW5kLFxuICAgIH07XG59XG5mdW5jdGlvbiBjb21waWxlU2Vnc0Zyb21FbnRyaWVzKHNlZ0VudHJpZXMsIGFsbFNlZ3MpIHtcbiAgICByZXR1cm4gc2VnRW50cmllcy5tYXAoKHNlZ0VudHJ5KSA9PiBhbGxTZWdzW3NlZ0VudHJ5LmluZGV4XSk7XG59XG5cbmNsYXNzIFRpbWVDb2xzQ29udGVudCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNwbGl0RmdFdmVudFNlZ3MgPSBtZW1vaXplKHNwbGl0U2Vnc0J5Q29sKTtcbiAgICAgICAgdGhpcy5zcGxpdEJnRXZlbnRTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXROb3dJbmRpY2F0b3JTZWdzID0gbWVtb2l6ZShzcGxpdFNlZ3NCeUNvbCk7XG4gICAgICAgIHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2VncyA9IG1lbW9pemUoc3BsaXRTZWdzQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnREcmFnID0gbWVtb2l6ZShzcGxpdEludGVyYWN0aW9uQnlDb2wpO1xuICAgICAgICB0aGlzLnNwbGl0RXZlbnRSZXNpemUgPSBtZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeUNvbCk7XG4gICAgICAgIHRoaXMucm9vdEVsUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuY2VsbEVsUmVmcyA9IG5ldyBSZWZNYXAoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IG5vd0luZGljYXRvclRvcCA9IGNvbnRleHQub3B0aW9ucy5ub3dJbmRpY2F0b3IgJiZcbiAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMgJiZcbiAgICAgICAgICAgIHByb3BzLnNsYXRDb29yZHMuc2FmZUNvbXB1dGVUb3AocHJvcHMubm93RGF0ZSk7IC8vIG1pZ2h0IHJldHVybiB2b2lkXG4gICAgICAgIGxldCBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIGxldCBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgYmdFdmVudFNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCZ0V2ZW50U2Vncyhwcm9wcy5iZ0V2ZW50U2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGJ1c2luZXNzSG91clNlZ3NCeVJvdyA9IHRoaXMuc3BsaXRCdXNpbmVzc0hvdXJTZWdzKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudCk7XG4gICAgICAgIGxldCBub3dJbmRpY2F0b3JTZWdzQnlSb3cgPSB0aGlzLnNwbGl0Tm93SW5kaWNhdG9yU2Vncyhwcm9wcy5ub3dJbmRpY2F0b3JTZWdzLCBjb2xDbnQpO1xuICAgICAgICBsZXQgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2VncywgY29sQ250KTtcbiAgICAgICAgbGV0IGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIGNvbENudCk7XG4gICAgICAgIGxldCBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCBjb2xDbnQpO1xuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtY29sc1wiLCByZWY6IHRoaXMucm9vdEVsUmVmIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGFibGVcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICBtaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgICAgICBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmF4aXMgJiYgKGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbCBmYy10aW1lZ3JpZC1heGlzXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXRpbWVncmlkLWNvbC1mcmFtZVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJcIiB9LCB0eXBlb2Ygbm93SW5kaWNhdG9yVG9wID09PSAnbnVtYmVyJyAmJiAoY3JlYXRlRWxlbWVudChOb3dJbmRpY2F0b3JDb250YWluZXIsIHsgZWxDbGFzc2VzOiBbJ2ZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3cnXSwgZWxTdHlsZTogeyB0b3A6IG5vd0luZGljYXRvclRvcCB9LCBpc0F4aXM6IHRydWUsIGRhdGU6IHByb3BzLm5vd0RhdGUgfSkpKSkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmNlbGxzLm1hcCgoY2VsbCwgaSkgPT4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbCwgeyBrZXk6IGNlbGwua2V5LCBlbFJlZjogdGhpcy5jZWxsRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZTogY2VsbC5kYXRlLCBub3dEYXRlOiBwcm9wcy5ub3dEYXRlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYVJlbmRlclByb3BzOiBjZWxsLmV4dHJhUmVuZGVyUHJvcHMsIGV4dHJhRGF0YUF0dHJzOiBjZWxsLmV4dHJhRGF0YUF0dHJzLCBleHRyYUNsYXNzTmFtZXM6IGNlbGwuZXh0cmFDbGFzc05hbWVzLCBleHRyYURhdGVTcGFuOiBjZWxsLmV4dHJhRGF0ZVNwYW4sIGZnRXZlbnRTZWdzOiBmZ0V2ZW50U2Vnc0J5Um93W2ldLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tpXSwgYnVzaW5lc3NIb3VyU2VnczogYnVzaW5lc3NIb3VyU2Vnc0J5Um93W2ldLCBub3dJbmRpY2F0b3JTZWdzOiBub3dJbmRpY2F0b3JTZWdzQnlSb3dbaV0sIGRhdGVTZWxlY3Rpb25TZWdzOiBkYXRlU2VsZWN0aW9uU2Vnc0J5Um93W2ldLCBldmVudERyYWc6IGV2ZW50RHJhZ0J5Um93W2ldLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tpXSwgc2xhdENvb3JkczogcHJvcHMuc2xhdENvb3JkcywgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSkpKSkpKSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb29yZHMoKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUNvb3JkcygpO1xuICAgIH1cbiAgICB1cGRhdGVDb29yZHMoKSB7XG4gICAgICAgIGxldCB7IHByb3BzIH0gPSB0aGlzO1xuICAgICAgICBpZiAocHJvcHMub25Db2xDb29yZHMgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIG1lYW5zIHNpemluZyBoYXMgc3RhYmlsaXplZFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHByb3BzLm9uQ29sQ29vcmRzKG5ldyBQb3NpdGlvbkNhY2hlKHRoaXMucm9vdEVsUmVmLmN1cnJlbnQsIGNvbGxlY3RDZWxsRWxzKHRoaXMuY2VsbEVsUmVmcy5jdXJyZW50TWFwLCBwcm9wcy5jZWxscyksIHRydWUsIC8vIGhvcml6b250YWxcbiAgICAgICAgICAgIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb2xsZWN0Q2VsbEVscyhlbE1hcCwgY2VsbHMpIHtcbiAgICByZXR1cm4gY2VsbHMubWFwKChjZWxsKSA9PiBlbE1hcFtjZWxsLmtleV0pO1xufVxuXG4vKiBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgb25lIG9yIG1vcmUgY29sdW1ucyBvZiB2ZXJ0aWNhbCB0aW1lIHNsb3RzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmNsYXNzIFRpbWVDb2xzIGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc1Nsb3RPcHRpb25zID0gbWVtb2l6ZShwcm9jZXNzU2xvdE9wdGlvbnMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc2xhdENvb3JkczogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb290RWwgPSAoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiB0aGlzLnByb3BzLmlzSGl0Q29tYm9BbGxvd2VkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0ID0gKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIGxldCB7IG9uU2Nyb2xsVG9wUmVxdWVzdCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGxldCB7IHNsYXRDb29yZHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAob25TY3JvbGxUb3BSZXF1ZXN0ICYmIHNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC50aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3AgPSBzbGF0Q29vcmRzLmNvbXB1dGVUaW1lVG9wKHJlcXVlc3QudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IE1hdGguY2VpbCh0b3ApOyAvLyB6b29tIGNhbiBnaXZlIHdlaXJkIGZsb2F0aW5nLXBvaW50IHZhbHVlcy4gcmF0aGVyIHNjcm9sbCBhIGxpdHRsZSBiaXQgZnVydGhlclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgKz0gMTsgLy8gdG8gb3ZlcmNvbWUgdG9wIGJvcmRlciB0aGF0IHNsb3RzIGJleW9uZCB0aGUgZmlyc3QgaGF2ZS4gbG9va3MgYmV0dGVyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb25TY3JvbGxUb3BSZXF1ZXN0KHRvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUNvbENvb3JkcyA9IChjb2xDb29yZHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29sQ29vcmRzID0gY29sQ29vcmRzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVNsYXRDb29yZHMgPSAoc2xhdENvb3JkcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHNsYXRDb29yZHMgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblNsYXRDb29yZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uU2xhdENvb3JkcyhzbGF0Q29vcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy10aW1lZ3JpZC1ib2R5XCIsIHJlZjogdGhpcy5oYW5kbGVSb290RWwsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cbiAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFRpbWVDb2xzU2xhdHMsIHsgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBzbGF0TWV0YXM6IHByb3BzLnNsYXRNZXRhcywgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBtaW5IZWlnaHQ6IHByb3BzLmV4cGFuZFJvd3MgPyBwcm9wcy5jbGllbnRIZWlnaHQgOiAnJywgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgdGFibGVDb2xHcm91cE5vZGU6IHByb3BzLmF4aXMgPyBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSA6IG51bGwgLyogYXhpcyBkZXBlbmRzIG9uIHRoZSBjb2xncm91cCdzIHNocmlua2luZyAqLywgb25Db29yZHM6IHRoaXMuaGFuZGxlU2xhdENvb3JkcyB9KSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoVGltZUNvbHNDb250ZW50LCB7IGNlbGxzOiBwcm9wcy5jZWxscywgYXhpczogcHJvcHMuYXhpcywgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCBidXNpbmVzc0hvdXJTZWdzOiBwcm9wcy5idXNpbmVzc0hvdXJTZWdzLCBiZ0V2ZW50U2VnczogcHJvcHMuYmdFdmVudFNlZ3MsIGZnRXZlbnRTZWdzOiBwcm9wcy5mZ0V2ZW50U2VncywgZGF0ZVNlbGVjdGlvblNlZ3M6IHByb3BzLmRhdGVTZWxlY3Rpb25TZWdzLCBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGV2ZW50RHJhZzogcHJvcHMuZXZlbnREcmFnLCBldmVudFJlc2l6ZTogcHJvcHMuZXZlbnRSZXNpemUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIG5vd0RhdGU6IHByb3BzLm5vd0RhdGUsIG5vd0luZGljYXRvclNlZ3M6IHByb3BzLm5vd0luZGljYXRvclNlZ3MsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgdGFibGVDb2xHcm91cE5vZGU6IHByb3BzLnRhYmxlQ29sR3JvdXBOb2RlLCBzbGF0Q29vcmRzOiBzdGF0ZS5zbGF0Q29vcmRzLCBvbkNvbENvb3JkczogdGhpcy5oYW5kbGVDb2xDb29yZHMsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlU2Nyb2xsUmVzcG9uZGVyKHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZXNwb25kZXIudXBkYXRlKHByZXZQcm9wcy5kYXRlUHJvZmlsZSAhPT0gdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSk7XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICB0aGlzLnNjcm9sbFJlc3BvbmRlci5kZXRhY2goKTtcbiAgICB9XG4gICAgcXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCkge1xuICAgICAgICBsZXQgeyBkYXRlRW52LCBvcHRpb25zIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCB7IGNvbENvb3JkcyB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZVByb2ZpbGUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IHNsYXRDb29yZHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCB7IHNuYXBEdXJhdGlvbiwgc25hcHNQZXJTbG90IH0gPSB0aGlzLnByb2Nlc3NTbG90T3B0aW9ucyh0aGlzLnByb3BzLnNsb3REdXJhdGlvbiwgb3B0aW9ucy5zbmFwRHVyYXRpb24pO1xuICAgICAgICBsZXQgY29sSW5kZXggPSBjb2xDb29yZHMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcbiAgICAgICAgbGV0IHNsYXRJbmRleCA9IHNsYXRDb29yZHMucG9zaXRpb25zLnRvcFRvSW5kZXgocG9zaXRpb25Ub3ApO1xuICAgICAgICBpZiAoY29sSW5kZXggIT0gbnVsbCAmJiBzbGF0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGNlbGwgPSB0aGlzLnByb3BzLmNlbGxzW2NvbEluZGV4XTtcbiAgICAgICAgICAgIGxldCBzbGF0VG9wID0gc2xhdENvb3Jkcy5wb3NpdGlvbnMudG9wc1tzbGF0SW5kZXhdO1xuICAgICAgICAgICAgbGV0IHNsYXRIZWlnaHQgPSBzbGF0Q29vcmRzLnBvc2l0aW9ucy5nZXRIZWlnaHQoc2xhdEluZGV4KTtcbiAgICAgICAgICAgIGxldCBwYXJ0aWFsID0gKHBvc2l0aW9uVG9wIC0gc2xhdFRvcCkgLyBzbGF0SGVpZ2h0OyAvLyBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgICAgICBsZXQgbG9jYWxTbmFwSW5kZXggPSBNYXRoLmZsb29yKHBhcnRpYWwgKiBzbmFwc1BlclNsb3QpOyAvLyB0aGUgc25hcCAjIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHNsYXRcbiAgICAgICAgICAgIGxldCBzbmFwSW5kZXggPSBzbGF0SW5kZXggKiBzbmFwc1BlclNsb3QgKyBsb2NhbFNuYXBJbmRleDtcbiAgICAgICAgICAgIGxldCBkYXlEYXRlID0gdGhpcy5wcm9wcy5jZWxsc1tjb2xJbmRleF0uZGF0ZTtcbiAgICAgICAgICAgIGxldCB0aW1lID0gYWRkRHVyYXRpb25zKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLCBtdWx0aXBseUR1cmF0aW9uKHNuYXBEdXJhdGlvbiwgc25hcEluZGV4KSk7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBkYXRlRW52LmFkZChkYXlEYXRlLCB0aW1lKTtcbiAgICAgICAgICAgIGxldCBlbmQgPSBkYXRlRW52LmFkZChzdGFydCwgc25hcER1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICAgICAgZGF0ZVNwYW46IE9iamVjdC5hc3NpZ24oeyByYW5nZTogeyBzdGFydCwgZW5kIH0sIGFsbERheTogZmFsc2UgfSwgY2VsbC5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogY29sQ29vcmRzLmVsc1tjb2xJbmRleF0sXG4gICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb2xDb29yZHMubGVmdHNbY29sSW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogY29sQ29vcmRzLnJpZ2h0c1tjb2xJbmRleF0sXG4gICAgICAgICAgICAgICAgICAgIHRvcDogc2xhdFRvcCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBzbGF0VG9wICsgc2xhdEhlaWdodCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxheWVyOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzU2xvdE9wdGlvbnMoc2xvdER1cmF0aW9uLCBzbmFwRHVyYXRpb25PdmVycmlkZSkge1xuICAgIGxldCBzbmFwRHVyYXRpb24gPSBzbmFwRHVyYXRpb25PdmVycmlkZSB8fCBzbG90RHVyYXRpb247XG4gICAgbGV0IHNuYXBzUGVyU2xvdCA9IHdob2xlRGl2aWRlRHVyYXRpb25zKHNsb3REdXJhdGlvbiwgc25hcER1cmF0aW9uKTtcbiAgICBpZiAoc25hcHNQZXJTbG90ID09PSBudWxsKSB7XG4gICAgICAgIHNuYXBEdXJhdGlvbiA9IHNsb3REdXJhdGlvbjtcbiAgICAgICAgc25hcHNQZXJTbG90ID0gMTtcbiAgICAgICAgLy8gVE9ETzogc2F5IHdhcm5pbmc/XG4gICAgfVxuICAgIHJldHVybiB7IHNuYXBEdXJhdGlvbiwgc25hcHNQZXJTbG90IH07XG59XG5cbmNsYXNzIERheVRpbWVDb2xzU2xpY2VyIGV4dGVuZHMgU2xpY2VyIHtcbiAgICBzbGljZVJhbmdlKHJhbmdlLCBkYXlSYW5nZXMpIHtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgZGF5UmFuZ2VzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBzZWdSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhyYW5nZSwgZGF5UmFuZ2VzW2NvbF0pO1xuICAgICAgICAgICAgaWYgKHNlZ1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlZ1JhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHNlZ1JhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSByYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWdSYW5nZS5lbmQudmFsdWVPZigpID09PSByYW5nZS5lbmQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxufVxuXG5jbGFzcyBEYXlUaW1lQ29scyBleHRlbmRzIERhdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF5UmFuZ2VzID0gbWVtb2l6ZShidWlsZERheVJhbmdlcyk7XG4gICAgICAgIHRoaXMuc2xpY2VyID0gbmV3IERheVRpbWVDb2xzU2xpY2VyKCk7XG4gICAgICAgIHRoaXMudGltZUNvbHNSZWYgPSBjcmVhdGVSZWYoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgZGF0ZVByb2ZpbGUsIGRheVRhYmxlTW9kZWwgfSA9IHByb3BzO1xuICAgICAgICBsZXQgeyBub3dJbmRpY2F0b3IsIG5leHREYXlUaHJlc2hvbGQgfSA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgbGV0IGRheVJhbmdlcyA9IHRoaXMuYnVpbGREYXlSYW5nZXMoZGF5VGFibGVNb2RlbCwgZGF0ZVByb2ZpbGUsIGNvbnRleHQuZGF0ZUVudik7XG4gICAgICAgIC8vIGdpdmUgaXQgdGhlIGZpcnN0IHJvdyBvZiBjZWxsc1xuICAgICAgICAvLyBUT0RPOiB3b3VsZCBtb3ZlIHRoaXMgZnVydGhlciBkb3duIGhpZXJhcmNoeSwgYnV0IHNsaWNlTm93RGF0ZSBuZWVkcyBpdFxuICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoTm93VGltZXIsIHsgdW5pdDogbm93SW5kaWNhdG9yID8gJ21pbnV0ZScgOiAnZGF5JyB9LCAobm93RGF0ZSwgdG9kYXlSYW5nZSkgPT4gKGNyZWF0ZUVsZW1lbnQoVGltZUNvbHMsIE9iamVjdC5hc3NpZ24oeyByZWY6IHRoaXMudGltZUNvbHNSZWYgfSwgdGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgZGF0ZVByb2ZpbGUsIG51bGwsIGNvbnRleHQsIGRheVJhbmdlcyksIHsgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCBheGlzOiBwcm9wcy5heGlzLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHNsYXRNZXRhczogcHJvcHMuc2xhdE1ldGFzLCBzbG90RHVyYXRpb246IHByb3BzLnNsb3REdXJhdGlvbiwgY2VsbHM6IGRheVRhYmxlTW9kZWwuY2VsbHNbMF0sIHRhYmxlQ29sR3JvdXBOb2RlOiBwcm9wcy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogcHJvcHMudGFibGVNaW5XaWR0aCwgY2xpZW50V2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IHByb3BzLmNsaWVudEhlaWdodCwgZXhwYW5kUm93czogcHJvcHMuZXhwYW5kUm93cywgbm93RGF0ZTogbm93RGF0ZSwgbm93SW5kaWNhdG9yU2Vnczogbm93SW5kaWNhdG9yICYmIHRoaXMuc2xpY2VyLnNsaWNlTm93RGF0ZShub3dEYXRlLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCwgZGF5UmFuZ2VzKSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgb25TY3JvbGxUb3BSZXF1ZXN0OiBwcm9wcy5vblNjcm9sbFRvcFJlcXVlc3QsIG9uU2xhdENvb3JkczogcHJvcHMub25TbGF0Q29vcmRzIH0pKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZERheVJhbmdlcyhkYXlUYWJsZU1vZGVsLCBkYXRlUHJvZmlsZSwgZGF0ZUVudikge1xuICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICBmb3IgKGxldCBkYXRlIG9mIGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMpIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IGRhdGVFbnYuYWRkKGRhdGUsIGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lKSxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoZGF0ZSwgZGF0ZVByb2ZpbGUuc2xvdE1heFRpbWUpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cblxuLy8gcG90ZW50aWFsIG5pY2UgdmFsdWVzIGZvciB0aGUgc2xvdC1kdXJhdGlvbiBhbmQgaW50ZXJ2YWwtZHVyYXRpb25cbi8vIGZyb20gbGFyZ2VzdCB0byBzbWFsbGVzdFxuY29uc3QgU1RPQ0tfU1VCX0RVUkFUSU9OUyA9IFtcbiAgICB7IGhvdXJzOiAxIH0sXG4gICAgeyBtaW51dGVzOiAzMCB9LFxuICAgIHsgbWludXRlczogMTUgfSxcbiAgICB7IHNlY29uZHM6IDMwIH0sXG4gICAgeyBzZWNvbmRzOiAxNSB9LFxuXTtcbmZ1bmN0aW9uIGJ1aWxkU2xhdE1ldGFzKHNsb3RNaW5UaW1lLCBzbG90TWF4VGltZSwgZXhwbGljaXRMYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24sIGRhdGVFbnYpIHtcbiAgICBsZXQgZGF5U3RhcnQgPSBuZXcgRGF0ZSgwKTtcbiAgICBsZXQgc2xhdFRpbWUgPSBzbG90TWluVGltZTtcbiAgICBsZXQgc2xhdEl0ZXJhdG9yID0gY3JlYXRlRHVyYXRpb24oMCk7XG4gICAgbGV0IGxhYmVsSW50ZXJ2YWwgPSBleHBsaWNpdExhYmVsSW50ZXJ2YWwgfHwgY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKTtcbiAgICBsZXQgbWV0YXMgPSBbXTtcbiAgICB3aGlsZSAoYXNSb3VnaE1zKHNsYXRUaW1lKSA8IGFzUm91Z2hNcyhzbG90TWF4VGltZSkpIHtcbiAgICAgICAgbGV0IGRhdGUgPSBkYXRlRW52LmFkZChkYXlTdGFydCwgc2xhdFRpbWUpO1xuICAgICAgICBsZXQgaXNMYWJlbGVkID0gd2hvbGVEaXZpZGVEdXJhdGlvbnMoc2xhdEl0ZXJhdG9yLCBsYWJlbEludGVydmFsKSAhPT0gbnVsbDtcbiAgICAgICAgbWV0YXMucHVzaCh7XG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgdGltZTogc2xhdFRpbWUsXG4gICAgICAgICAgICBrZXk6IGRhdGUudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGlzb1RpbWVTdHI6IGZvcm1hdElzb1RpbWVTdHJpbmcoZGF0ZSksXG4gICAgICAgICAgICBpc0xhYmVsZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBzbGF0VGltZSA9IGFkZER1cmF0aW9ucyhzbGF0VGltZSwgc2xvdER1cmF0aW9uKTtcbiAgICAgICAgc2xhdEl0ZXJhdG9yID0gYWRkRHVyYXRpb25zKHNsYXRJdGVyYXRvciwgc2xvdER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFzO1xufVxuLy8gQ29tcHV0ZXMgYW4gYXV0b21hdGljIHZhbHVlIGZvciBzbG90TGFiZWxJbnRlcnZhbFxuZnVuY3Rpb24gY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGxhYmVsSW50ZXJ2YWw7XG4gICAgbGV0IHNsb3RzUGVyTGFiZWw7XG4gICAgLy8gZmluZCB0aGUgc21hbGxlc3Qgc3RvY2sgbGFiZWwgaW50ZXJ2YWwgdGhhdCByZXN1bHRzIGluIG1vcmUgdGhhbiBvbmUgc2xvdHMtcGVyLWxhYmVsXG4gICAgZm9yIChpID0gU1RPQ0tfU1VCX0RVUkFUSU9OUy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBsYWJlbEludGVydmFsID0gY3JlYXRlRHVyYXRpb24oU1RPQ0tfU1VCX0RVUkFUSU9OU1tpXSk7XG4gICAgICAgIHNsb3RzUGVyTGFiZWwgPSB3aG9sZURpdmlkZUR1cmF0aW9ucyhsYWJlbEludGVydmFsLCBzbG90RHVyYXRpb24pO1xuICAgICAgICBpZiAoc2xvdHNQZXJMYWJlbCAhPT0gbnVsbCAmJiBzbG90c1BlckxhYmVsID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhYmVsSW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNsb3REdXJhdGlvbjsgLy8gZmFsbCBiYWNrXG59XG5cbmNsYXNzIERheVRpbWVDb2xzVmlldyBleHRlbmRzIFRpbWVDb2xzVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYnVpbGRUaW1lQ29sc01vZGVsID0gbWVtb2l6ZShidWlsZFRpbWVDb2xzTW9kZWwpO1xuICAgICAgICB0aGlzLmJ1aWxkU2xhdE1ldGFzID0gbWVtb2l6ZShidWlsZFNsYXRNZXRhcyk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgb3B0aW9ucywgZGF0ZUVudiwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgcHJvcHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRhdGVQcm9maWxlIH0gPSBwcm9wcztcbiAgICAgICAgbGV0IGRheVRhYmxlTW9kZWwgPSB0aGlzLmJ1aWxkVGltZUNvbHNNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICBsZXQgc3BsaXRQcm9wcyA9IHRoaXMuYWxsRGF5U3BsaXR0ZXIuc3BsaXRQcm9wcyhwcm9wcyk7XG4gICAgICAgIGxldCBzbGF0TWV0YXMgPSB0aGlzLmJ1aWxkU2xhdE1ldGFzKGRhdGVQcm9maWxlLnNsb3RNaW5UaW1lLCBkYXRlUHJvZmlsZS5zbG90TWF4VGltZSwgb3B0aW9ucy5zbG90TGFiZWxJbnRlcnZhbCwgb3B0aW9ucy5zbG90RHVyYXRpb24sIGRhdGVFbnYpO1xuICAgICAgICBsZXQgeyBkYXlNaW5XaWR0aCB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IGhhc0F0dGFjaGVkQXhpcyA9ICFkYXlNaW5XaWR0aDtcbiAgICAgICAgbGV0IGhhc0RldGFjaGVkQXhpcyA9IGRheU1pbldpZHRoO1xuICAgICAgICBsZXQgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoY3JlYXRlRWxlbWVudChEYXlIZWFkZXIsIHsgZGF0ZXM6IGRheVRhYmxlTW9kZWwuaGVhZGVyRGF0ZXMsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgZGF0ZXNSZXBEaXN0aW5jdERheXM6IHRydWUsIHJlbmRlckludHJvOiBoYXNBdHRhY2hlZEF4aXMgPyB0aGlzLnJlbmRlckhlYWRBeGlzIDogbnVsbCB9KSk7XG4gICAgICAgIGxldCBhbGxEYXlDb250ZW50ID0gKG9wdGlvbnMuYWxsRGF5U2xvdCAhPT0gZmFsc2UpICYmICgoY29udGVudEFyZykgPT4gKGNyZWF0ZUVsZW1lbnQoRGF5VGFibGUsIE9iamVjdC5hc3NpZ24oe30sIHNwbGl0UHJvcHMuYWxsRGF5LCB7IGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgbmV4dERheVRocmVzaG9sZDogb3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLCB0YWJsZU1pbldpZHRoOiBjb250ZW50QXJnLnRhYmxlTWluV2lkdGgsIGNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgcmVuZGVyUm93SW50cm86IGhhc0F0dGFjaGVkQXhpcyA/IHRoaXMucmVuZGVyVGFibGVSb3dBeGlzIDogbnVsbCwgc2hvd1dlZWtOdW1iZXJzOiBmYWxzZSwgZXhwYW5kUm93czogZmFsc2UsIGhlYWRlckFsaWduRWxSZWY6IHRoaXMuaGVhZGVyRWxSZWYsIGNsaWVudFdpZHRoOiBjb250ZW50QXJnLmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQ6IGNvbnRlbnRBcmcuY2xpZW50SGVpZ2h0LCBmb3JQcmludDogcHJvcHMuZm9yUHJpbnQgfSwgdGhpcy5nZXRBbGxEYXlNYXhFdmVudFByb3BzKCkpKSkpO1xuICAgICAgICBsZXQgdGltZUdyaWRDb250ZW50ID0gKGNvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KERheVRpbWVDb2xzLCBPYmplY3QuYXNzaWduKHt9LCBzcGxpdFByb3BzLnRpbWVkLCB7IGRheVRhYmxlTW9kZWw6IGRheVRhYmxlTW9kZWwsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgYXhpczogaGFzQXR0YWNoZWRBeGlzLCBzbG90RHVyYXRpb246IG9wdGlvbnMuc2xvdER1cmF0aW9uLCBzbGF0TWV0YXM6IHNsYXRNZXRhcywgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LCB0YWJsZUNvbEdyb3VwTm9kZTogY29udGVudEFyZy50YWJsZUNvbEdyb3VwTm9kZSwgdGFibGVNaW5XaWR0aDogY29udGVudEFyZy50YWJsZU1pbldpZHRoLCBjbGllbnRXaWR0aDogY29udGVudEFyZy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBjb250ZW50QXJnLmNsaWVudEhlaWdodCwgb25TbGF0Q29vcmRzOiB0aGlzLmhhbmRsZVNsYXRDb29yZHMsIGV4cGFuZFJvd3M6IGNvbnRlbnRBcmcuZXhwYW5kUm93cywgb25TY3JvbGxUb3BSZXF1ZXN0OiB0aGlzLmhhbmRsZVNjcm9sbFRvcFJlcXVlc3QgfSkpKTtcbiAgICAgICAgcmV0dXJuIGhhc0RldGFjaGVkQXhpc1xuICAgICAgICAgICAgPyB0aGlzLnJlbmRlckhTY3JvbGxMYXlvdXQoaGVhZGVyQ29udGVudCwgYWxsRGF5Q29udGVudCwgdGltZUdyaWRDb250ZW50LCBkYXlUYWJsZU1vZGVsLmNvbENudCwgZGF5TWluV2lkdGgsIHNsYXRNZXRhcywgdGhpcy5zdGF0ZS5zbGF0Q29vcmRzKVxuICAgICAgICAgICAgOiB0aGlzLnJlbmRlclNpbXBsZUxheW91dChoZWFkZXJDb250ZW50LCBhbGxEYXlDb250ZW50LCB0aW1lR3JpZENvbnRlbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkVGltZUNvbHNNb2RlbChkYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHtcbiAgICBsZXQgZGF5U2VyaWVzID0gbmV3IERheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgcmV0dXJuIG5ldyBEYXlUYWJsZU1vZGVsKGRheVNlcmllcywgZmFsc2UpO1xufVxuXG52YXIgY3NzXzI0OHogPSBcIi5mYy12LWV2ZW50e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtZXZlbnQtYmctY29sb3IpO2JvcmRlcjoxcHggc29saWQgdmFyKC0tZmMtZXZlbnQtYm9yZGVyLWNvbG9yKTtkaXNwbGF5OmJsb2NrfS5mYy12LWV2ZW50IC5mYy1ldmVudC1tYWlue2NvbG9yOnZhcigtLWZjLWV2ZW50LXRleHQtY29sb3IpO2hlaWdodDoxMDAlfS5mYy12LWV2ZW50IC5mYy1ldmVudC1tYWluLWZyYW1le2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47aGVpZ2h0OjEwMCV9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXRpbWV7ZmxleC1ncm93OjA7ZmxleC1zaHJpbms6MDttYXgtaGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVufS5mYy12LWV2ZW50IC5mYy1ldmVudC10aXRsZS1jb250YWluZXJ7ZmxleC1ncm93OjE7ZmxleC1zaHJpbms6MTttaW4taGVpZ2h0OjB9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXRpdGxle2JvdHRvbTowO21heC1oZWlnaHQ6MTAwJTtvdmVyZmxvdzpoaWRkZW47dG9wOjB9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zdGFydCl7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLXRvcC13aWR0aDowfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtZW5kKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItYm90dG9tLXdpZHRoOjB9LmZjLXYtZXZlbnQuZmMtZXZlbnQtc2VsZWN0ZWQ6YmVmb3Jle2xlZnQ6LTEwcHg7cmlnaHQ6LTEwcHh9LmZjLXYtZXZlbnQgLmZjLWV2ZW50LXJlc2l6ZXItc3RhcnR7Y3Vyc29yOm4tcmVzaXplfS5mYy12LWV2ZW50IC5mYy1ldmVudC1yZXNpemVyLWVuZHtjdXJzb3I6cy1yZXNpemV9LmZjLXYtZXZlbnQ6bm90KC5mYy1ldmVudC1zZWxlY3RlZCkgLmZjLWV2ZW50LXJlc2l6ZXJ7aGVpZ2h0OnZhcigtLWZjLWV2ZW50LXJlc2l6ZXItdGhpY2tuZXNzKTtsZWZ0OjA7cmlnaHQ6MH0uZmMtdi1ldmVudDpub3QoLmZjLWV2ZW50LXNlbGVjdGVkKSAuZmMtZXZlbnQtcmVzaXplci1zdGFydHt0b3A6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykvLTIpfS5mYy12LWV2ZW50Om5vdCguZmMtZXZlbnQtc2VsZWN0ZWQpIC5mYy1ldmVudC1yZXNpemVyLWVuZHtib3R0b206Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLXRoaWNrbmVzcykvLTIpfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVye2xlZnQ6NTAlO21hcmdpbi1sZWZ0OmNhbGModmFyKC0tZmMtZXZlbnQtcmVzaXplci1kb3QtdG90YWwtd2lkdGgpLy0yKX0uZmMtdi1ldmVudC5mYy1ldmVudC1zZWxlY3RlZCAuZmMtZXZlbnQtcmVzaXplci1zdGFydHt0b3A6Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkvLTIpfS5mYy12LWV2ZW50LmZjLWV2ZW50LXNlbGVjdGVkIC5mYy1ldmVudC1yZXNpemVyLWVuZHtib3R0b206Y2FsYyh2YXIoLS1mYy1ldmVudC1yZXNpemVyLWRvdC10b3RhbC13aWR0aCkvLTIpfS5mYyAuZmMtdGltZWdyaWQgLmZjLWRheWdyaWQtYm9keXt6LWluZGV4OjJ9LmZjIC5mYy10aW1lZ3JpZC1kaXZpZGVye3BhZGRpbmc6MCAwIDJweH0uZmMgLmZjLXRpbWVncmlkLWJvZHl7bWluLWhlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY2h1bmt7cG9zaXRpb246cmVsYXRpdmV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWNodW5rPnRhYmxlLC5mYyAuZmMtdGltZWdyaWQtc2xvdHN7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxfS5mYyAuZmMtdGltZWdyaWQtc2xvdHtib3JkZXItYm90dG9tOjA7aGVpZ2h0OjEuNWVtfS5mYyAuZmMtdGltZWdyaWQtc2xvdDplbXB0eTpiZWZvcmV7Y29udGVudDpcXFwiXFxcXDAwYTBcXFwifS5mYyAuZmMtdGltZWdyaWQtc2xvdC1taW5vcntib3JkZXItdG9wLXN0eWxlOmRvdHRlZH0uZmMgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbntkaXNwbGF5OmlubGluZS1ibG9jazt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVse3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbiwuZmMgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtY3VzaGlvbntwYWRkaW5nOjAgNHB4fS5mYyAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWR7aGVpZ2h0OjEwMCV9LmZjIC5mYy10aW1lZ3JpZC1heGlzLWZyYW1le2FsaWduLWl0ZW1zOmNlbnRlcjtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmZsZXgtZW5kO292ZXJmbG93OmhpZGRlbn0uZmMgLmZjLXRpbWVncmlkLWF4aXMtY3VzaGlvbntmbGV4LXNocmluazowO21heC13aWR0aDo2MHB4fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1zbG90LWxhYmVsLWZyYW1le3RleHQtYWxpZ246cmlnaHR9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLXNsb3QtbGFiZWwtZnJhbWV7dGV4dC1hbGlnbjpsZWZ0fS5mYy1saXF1aWQtaGFjayAuZmMtdGltZWdyaWQtYXhpcy1mcmFtZS1saXF1aWR7Ym90dG9tOjA7aGVpZ2h0OmF1dG87bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjIC5mYy10aW1lZ3JpZC1jb2wuZmMtZGF5LXRvZGF5e2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtdG9kYXktYmctY29sb3IpfS5mYyAuZmMtdGltZWdyaWQtY29sLWZyYW1le21pbi1oZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZX0uZmMtbWVkaWEtc2NyZWVuLmZjLWxpcXVpZC1oYWNrIC5mYy10aW1lZ3JpZC1jb2wtZnJhbWV7Ym90dG9tOjA7aGVpZ2h0OmF1dG87bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLW1lZGlhLXNjcmVlbiAuZmMtdGltZWdyaWQtY29sc3tib3R0b206MDtsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDt0b3A6MH0uZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2xzPnRhYmxle2hlaWdodDoxMDAlfS5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLWNvbC1iZywuZmMtbWVkaWEtc2NyZWVuIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRzLC5mYy1tZWRpYS1zY3JlZW4gLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItY29udGFpbmVye2xlZnQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDowO3RvcDowfS5mYyAuZmMtdGltZWdyaWQtY29sLWJne3otaW5kZXg6Mn0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtbm9uLWJ1c2luZXNze3otaW5kZXg6MX0uZmMgLmZjLXRpbWVncmlkLWNvbC1iZyAuZmMtYmctZXZlbnR7ei1pbmRleDoyfS5mYyAuZmMtdGltZWdyaWQtY29sLWJnIC5mYy1oaWdobGlnaHR7ei1pbmRleDozfS5mYyAuZmMtdGltZWdyaWQtYmctaGFybmVzc3tsZWZ0OjA7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MH0uZmMgLmZjLXRpbWVncmlkLWNvbC1ldmVudHN7ei1pbmRleDozfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1jb250YWluZXJ7Ym90dG9tOjA7b3ZlcmZsb3c6aGlkZGVufS5mYy1kaXJlY3Rpb24tbHRyIC5mYy10aW1lZ3JpZC1jb2wtZXZlbnRze21hcmdpbjowIDIuNSUgMCAycHh9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLXRpbWVncmlkLWNvbC1ldmVudHN7bWFyZ2luOjAgMnB4IDAgMi41JX0uZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzc3twb3NpdGlvbjphYnNvbHV0ZX0uZmMtdGltZWdyaWQtZXZlbnQtaGFybmVzcz4uZmMtdGltZWdyaWQtZXZlbnR7Ym90dG9tOjA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7dG9wOjB9LmZjLXRpbWVncmlkLWV2ZW50LWhhcm5lc3MtaW5zZXQgLmZjLXRpbWVncmlkLWV2ZW50LC5mYy10aW1lZ3JpZC1ldmVudC5mYy1ldmVudC1taXJyb3IsLmZjLXRpbWVncmlkLW1vcmUtbGlua3tib3gtc2hhZG93OjAgMCAwIDFweCB2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKX0uZmMtdGltZWdyaWQtZXZlbnQsLmZjLXRpbWVncmlkLW1vcmUtbGlua3tib3JkZXItcmFkaXVzOjNweDtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKX0uZmMtdGltZWdyaWQtZXZlbnR7bWFyZ2luLWJvdHRvbToxcHh9LmZjLXRpbWVncmlkLWV2ZW50IC5mYy1ldmVudC1tYWlue3BhZGRpbmc6MXB4IDFweCAwfS5mYy10aW1lZ3JpZC1ldmVudCAuZmMtZXZlbnQtdGltZXtmb250LXNpemU6dmFyKC0tZmMtc21hbGwtZm9udC1zaXplKTttYXJnaW4tYm90dG9tOjFweDt3aGl0ZS1zcGFjZTpub3dyYXB9LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC1tYWluLWZyYW1le2ZsZXgtZGlyZWN0aW9uOnJvdztvdmVyZmxvdzpoaWRkZW59LmZjLXRpbWVncmlkLWV2ZW50LXNob3J0IC5mYy1ldmVudC10aW1lOmFmdGVye2NvbnRlbnQ6XFxcIlxcXFwwMGEwLVxcXFwwMGEwXFxcIn0uZmMtdGltZWdyaWQtZXZlbnQtc2hvcnQgLmZjLWV2ZW50LXRpdGxle2ZvbnQtc2l6ZTp2YXIoLS1mYy1zbWFsbC1mb250LXNpemUpfS5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7YmFja2dyb3VuZDp2YXIoLS1mYy1tb3JlLWxpbmstYmctY29sb3IpO2NvbG9yOnZhcigtLWZjLW1vcmUtbGluay10ZXh0LWNvbG9yKTtjdXJzb3I6cG9pbnRlcjttYXJnaW4tYm90dG9tOjFweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4Ojk5OTl9LmZjLXRpbWVncmlkLW1vcmUtbGluay1pbm5lcntwYWRkaW5nOjNweCAycHg7dG9wOjB9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRpbWVncmlkLW1vcmUtbGlua3tyaWdodDowfS5mYy1kaXJlY3Rpb24tcnRsIC5mYy10aW1lZ3JpZC1tb3JlLWxpbmt7bGVmdDowfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvdywuZmMgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItbGluZXtwb2ludGVyLWV2ZW50czpub25lfS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1saW5le2JvcmRlci1jb2xvcjp2YXIoLS1mYy1ub3ctaW5kaWNhdG9yLWNvbG9yKTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOjFweCAwIDA7bGVmdDowO3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjA7ei1pbmRleDo0fS5mYyAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvd3tib3JkZXItY29sb3I6dmFyKC0tZmMtbm93LWluZGljYXRvci1jb2xvcik7Ym9yZGVyLXN0eWxlOnNvbGlkO21hcmdpbi10b3A6LTVweDtwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLXRpbWVncmlkLW5vdy1pbmRpY2F0b3ItYXJyb3d7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItdG9wLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci13aWR0aDo1cHggMCA1cHggNnB4O2xlZnQ6MH0uZmMtZGlyZWN0aW9uLXJ0bCAuZmMtdGltZWdyaWQtbm93LWluZGljYXRvci1hcnJvd3tib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci10b3AtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXdpZHRoOjVweCA2cHggNXB4IDA7cmlnaHQ6MH1cIjtcbmluamVjdFN0eWxlcyhjc3NfMjQ4eik7XG5cbmV4cG9ydCB7IERheVRpbWVDb2xzLCBEYXlUaW1lQ29sc1NsaWNlciwgRGF5VGltZUNvbHNWaWV3LCBUaW1lQ29scywgVGltZUNvbHNTbGF0c0Nvb3JkcywgVGltZUNvbHNWaWV3LCBidWlsZERheVJhbmdlcywgYnVpbGRTbGF0TWV0YXMsIGJ1aWxkVGltZUNvbHNNb2RlbCB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyBEYXlUaW1lQ29sc1ZpZXcgfSBmcm9tICcuL2ludGVybmFsLmpzJztcbmltcG9ydCAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCAnQGZ1bGxjYWxlbmRhci9jb3JlL3ByZWFjdC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvZGF5Z3JpZC9pbnRlcm5hbC5qcyc7XG5cbmNvbnN0IE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBhbGxEYXlTbG90OiBCb29sZWFuLFxufTtcblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci90aW1lZ3JpZCcsXG4gICAgaW5pdGlhbFZpZXc6ICd0aW1lR3JpZFdlZWsnLFxuICAgIG9wdGlvblJlZmluZXJzOiBPUFRJT05fUkVGSU5FUlMsXG4gICAgdmlld3M6IHtcbiAgICAgICAgdGltZUdyaWQ6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogRGF5VGltZUNvbHNWaWV3LFxuICAgICAgICAgICAgdXNlc01pbk1heFRpbWU6IHRydWUsXG4gICAgICAgICAgICBhbGxEYXlTbG90OiB0cnVlLFxuICAgICAgICAgICAgc2xvdER1cmF0aW9uOiAnMDA6MzA6MDAnLFxuICAgICAgICAgICAgc2xvdEV2ZW50T3ZlcmxhcDogdHJ1ZSwgLy8gYSBiYWQgbmFtZS4gY29uZnVzZWQgd2l0aCBvdmVybGFwL2NvbnN0cmFpbnQgc3lzdGVtXG4gICAgICAgIH0sXG4gICAgICAgIHRpbWVHcmlkRGF5OiB7XG4gICAgICAgICAgICB0eXBlOiAndGltZUdyaWQnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxuICAgICAgICB9LFxuICAgICAgICB0aW1lR3JpZFdlZWs6IHtcbiAgICAgICAgICAgIHR5cGU6ICd0aW1lR3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxuICAgICAgICB9LFxuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcclxuICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxufVxyXG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiaW1wb3J0IHsgY3JlYXRlUGx1Z2luIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIHJydWxlTGliIGZyb20gJ3JydWxlJztcbmltcG9ydCB7IHBhcnNlTWFya2VyLCBpZGVudGl0eSwgY3JlYXRlRHVyYXRpb24gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuXG5jb25zdCByZWN1cnJpbmdUeXBlID0ge1xuICAgIHBhcnNlKGV2ZW50UHJvcHMsIGRhdGVFbnYpIHtcbiAgICAgICAgaWYgKGV2ZW50UHJvcHMucnJ1bGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IGV2ZW50UlJ1bGVEYXRhID0gcGFyc2VFdmVudFJSdWxlKGV2ZW50UHJvcHMsIGRhdGVFbnYpO1xuICAgICAgICAgICAgaWYgKGV2ZW50UlJ1bGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZURhdGE6IHsgcnJ1bGVTZXQ6IGV2ZW50UlJ1bGVEYXRhLnJydWxlU2V0LCBpc1RpbWVab25lU3BlY2lmaWVkOiBldmVudFJSdWxlRGF0YS5pc1RpbWVab25lU3BlY2lmaWVkIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsbERheUd1ZXNzOiAhZXZlbnRSUnVsZURhdGEuaXNUaW1lU3BlY2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZXZlbnRQcm9wcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZXhwYW5kKGV2ZW50UlJ1bGVEYXRhLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcbiAgICAgICAgbGV0IGRhdGVzO1xuICAgICAgICBpZiAoZXZlbnRSUnVsZURhdGEuaXNUaW1lWm9uZVNwZWNpZmllZCkge1xuICAgICAgICAgICAgZGF0ZXMgPSBldmVudFJSdWxlRGF0YS5ycnVsZVNldC5iZXR3ZWVuKGRhdGVFbnYudG9EYXRlKGZyYW1pbmdSYW5nZS5zdGFydCksIC8vIHJydWxlIGxpYiB3aWxsIHRyZWF0IGFzIFVUQy16b25lZFxuICAgICAgICAgICAgZGF0ZUVudi50b0RhdGUoZnJhbWluZ1JhbmdlLmVuZCksIC8vIChzYW1lKVxuICAgICAgICAgICAgdHJ1ZSkubWFwKChkYXRlKSA9PiBkYXRlRW52LmNyZWF0ZU1hcmtlcihkYXRlKSk7IC8vIGNvbnZlcnQgVVRDLXpvbmVkLWRhdGUgdG8gbG9jYWxlIGRhdGVtYXJrZXJcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdoZW4gbm8gdGltZXpvbmUgaW4gZ2l2ZW4gc3RhcnQvZW5kLCB0aGUgcnJ1bGUgbGliIHdpbGwgYXNzdW1lIFVUQyxcbiAgICAgICAgICAgIC8vIHdoaWNoIGlzIHNhbWUgYXMgb3VyIERhdGVNYXJrZXJzLiBubyBuZWVkIHRvIG1hbmlwdWxhdGVcbiAgICAgICAgICAgIGRhdGVzID0gZXZlbnRSUnVsZURhdGEucnJ1bGVTZXQuYmV0d2VlbihmcmFtaW5nUmFuZ2Uuc3RhcnQsIGZyYW1pbmdSYW5nZS5lbmQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlcztcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHBhcnNlRXZlbnRSUnVsZShldmVudFByb3BzLCBkYXRlRW52KSB7XG4gICAgbGV0IHJydWxlU2V0O1xuICAgIGxldCBpc1RpbWVTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBsZXQgaXNUaW1lWm9uZVNwZWNpZmllZCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgZXZlbnRQcm9wcy5ycnVsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IHJlcyA9IHBhcnNlUlJ1bGVTdHJpbmcoZXZlbnRQcm9wcy5ycnVsZSk7XG4gICAgICAgIHJydWxlU2V0ID0gcmVzLnJydWxlU2V0O1xuICAgICAgICBpc1RpbWVTcGVjaWZpZWQgPSByZXMuaXNUaW1lU3BlY2lmaWVkO1xuICAgICAgICBpc1RpbWVab25lU3BlY2lmaWVkID0gcmVzLmlzVGltZVpvbmVTcGVjaWZpZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXZlbnRQcm9wcy5ycnVsZSA9PT0gJ29iamVjdCcgJiYgZXZlbnRQcm9wcy5ycnVsZSkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgbGV0IHJlcyA9IHBhcnNlUlJ1bGVPYmplY3QoZXZlbnRQcm9wcy5ycnVsZSwgZGF0ZUVudik7XG4gICAgICAgIHJydWxlU2V0ID0gbmV3IHJydWxlTGliLlJSdWxlU2V0KCk7XG4gICAgICAgIHJydWxlU2V0LnJydWxlKHJlcy5ycnVsZSk7XG4gICAgICAgIGlzVGltZVNwZWNpZmllZCA9IHJlcy5pc1RpbWVTcGVjaWZpZWQ7XG4gICAgICAgIGlzVGltZVpvbmVTcGVjaWZpZWQgPSByZXMuaXNUaW1lWm9uZVNwZWNpZmllZDtcbiAgICB9XG4gICAgLy8gY29udmVyeSB0byBhcnJheXMuIFRPRE86IGdlbmVyYWwgdXRpbD9cbiAgICBsZXQgZXhkYXRlSW5wdXRzID0gW10uY29uY2F0KGV2ZW50UHJvcHMuZXhkYXRlIHx8IFtdKTtcbiAgICBsZXQgZXhydWxlSW5wdXRzID0gW10uY29uY2F0KGV2ZW50UHJvcHMuZXhydWxlIHx8IFtdKTtcbiAgICBmb3IgKGxldCBleGRhdGVJbnB1dCBvZiBleGRhdGVJbnB1dHMpIHtcbiAgICAgICAgbGV0IHJlcyA9IHBhcnNlTWFya2VyKGV4ZGF0ZUlucHV0KTtcbiAgICAgICAgaXNUaW1lU3BlY2lmaWVkID0gaXNUaW1lU3BlY2lmaWVkIHx8ICFyZXMuaXNUaW1lVW5zcGVjaWZpZWQ7XG4gICAgICAgIGlzVGltZVpvbmVTcGVjaWZpZWQgPSBpc1RpbWVab25lU3BlY2lmaWVkIHx8IHJlcy50aW1lWm9uZU9mZnNldCAhPT0gbnVsbDtcbiAgICAgICAgcnJ1bGVTZXQuZXhkYXRlKG5ldyBEYXRlKHJlcy5tYXJrZXIudmFsdWVPZigpIC0gKHJlcy50aW1lWm9uZU9mZnNldCB8fCAwKSAqIDYwICogMTAwMCkpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBleHJ1bGUgaXMgZGVwcmVjYXRlZC4gd2hhdCB0byBkbz8gKGh0dHBzOi8vaWNhbGVuZGFyLm9yZy9pQ2FsZW5kYXItUkZDLTU1NDUvYS0zLWRlcHJlY2F0ZWQtZmVhdHVyZXMuaHRtbClcbiAgICBmb3IgKGxldCBleHJ1bGVJbnB1dCBvZiBleHJ1bGVJbnB1dHMpIHtcbiAgICAgICAgbGV0IHJlcyA9IHBhcnNlUlJ1bGVPYmplY3QoZXhydWxlSW5wdXQsIGRhdGVFbnYpO1xuICAgICAgICBpc1RpbWVTcGVjaWZpZWQgPSBpc1RpbWVTcGVjaWZpZWQgfHwgcmVzLmlzVGltZVNwZWNpZmllZDtcbiAgICAgICAgaXNUaW1lWm9uZVNwZWNpZmllZCA9IGlzVGltZVpvbmVTcGVjaWZpZWQgfHwgcmVzLmlzVGltZVpvbmVTcGVjaWZpZWQ7XG4gICAgICAgIHJydWxlU2V0LmV4cnVsZShyZXMucnJ1bGUpO1xuICAgIH1cbiAgICByZXR1cm4geyBycnVsZVNldCwgaXNUaW1lU3BlY2lmaWVkLCBpc1RpbWVab25lU3BlY2lmaWVkIH07XG59XG5mdW5jdGlvbiBwYXJzZVJSdWxlT2JqZWN0KHJydWxlSW5wdXQsIGRhdGVFbnYpIHtcbiAgICBsZXQgaXNUaW1lU3BlY2lmaWVkID0gZmFsc2U7XG4gICAgbGV0IGlzVGltZVpvbmVTcGVjaWZpZWQgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzRGF0ZUlucHV0KGRhdGVJbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGVJbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGxldCBtYXJrZXJEYXRhID0gcGFyc2VNYXJrZXIoZGF0ZUlucHV0KTtcbiAgICAgICAgICAgIGlmIChtYXJrZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgaXNUaW1lU3BlY2lmaWVkID0gaXNUaW1lU3BlY2lmaWVkIHx8ICFtYXJrZXJEYXRhLmlzVGltZVVuc3BlY2lmaWVkO1xuICAgICAgICAgICAgICAgIGlzVGltZVpvbmVTcGVjaWZpZWQgPSBpc1RpbWVab25lU3BlY2lmaWVkIHx8IG1hcmtlckRhdGEudGltZVpvbmVPZmZzZXQgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG1hcmtlckRhdGEubWFya2VyLnZhbHVlT2YoKSAtIChtYXJrZXJEYXRhLnRpbWVab25lT2Zmc2V0IHx8IDApICogNjAgKiAxMDAwKTsgLy8gTk9UIERSWVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVJbnB1dDsgLy8gVE9ETzogd2hhdCBhYm91dCBudW1iZXIgdGltZXN0YW1wcz9cbiAgICB9XG4gICAgbGV0IHJydWxlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcnJ1bGVJbnB1dCksIHsgZHRzdGFydDogcHJvY2Vzc0RhdGVJbnB1dChycnVsZUlucHV0LmR0c3RhcnQpLCB1bnRpbDogcHJvY2Vzc0RhdGVJbnB1dChycnVsZUlucHV0LnVudGlsKSwgZnJlcTogY29udmVydENvbnN0YW50KHJydWxlSW5wdXQuZnJlcSksIHdrc3Q6IHJydWxlSW5wdXQud2tzdCA9PSBudWxsXG4gICAgICAgICAgICA/IChkYXRlRW52LndlZWtEb3cgLSAxICsgNykgJSA3IC8vIGNvbnZlcnQgU3VuZGF5LWZpcnN0IHRvIE1vbmRheS1maXJzdFxuICAgICAgICAgICAgOiBjb252ZXJ0Q29uc3RhbnQocnJ1bGVJbnB1dC53a3N0KSwgYnl3ZWVrZGF5OiBjb252ZXJ0Q29uc3RhbnRzKHJydWxlSW5wdXQuYnl3ZWVrZGF5KSB9KTtcbiAgICByZXR1cm4geyBycnVsZTogbmV3IHJydWxlTGliLlJSdWxlKHJydWxlT3B0aW9ucyksIGlzVGltZVNwZWNpZmllZCwgaXNUaW1lWm9uZVNwZWNpZmllZCB9O1xufVxuZnVuY3Rpb24gcGFyc2VSUnVsZVN0cmluZyhzdHIpIHtcbiAgICBsZXQgcnJ1bGVTZXQgPSBycnVsZUxpYi5ycnVsZXN0cihzdHIsIHsgZm9yY2VzZXQ6IHRydWUgfSk7XG4gICAgbGV0IGFuYWx5c2lzID0gYW5hbHl6ZVJSdWxlU3RyaW5nKHN0cik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBycnVsZVNldCB9LCBhbmFseXNpcyk7XG59XG5mdW5jdGlvbiBhbmFseXplUlJ1bGVTdHJpbmcoc3RyKSB7XG4gICAgbGV0IGlzVGltZVNwZWNpZmllZCA9IGZhbHNlO1xuICAgIGxldCBpc1RpbWVab25lU3BlY2lmaWVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc01hdGNoKHdob2xlLCBpbnRyb1BhcnQsIGRhdGVQYXJ0KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBwYXJzZU1hcmtlcihkYXRlUGFydCk7XG4gICAgICAgIGlzVGltZVNwZWNpZmllZCA9IGlzVGltZVNwZWNpZmllZCB8fCAhcmVzdWx0LmlzVGltZVVuc3BlY2lmaWVkO1xuICAgICAgICBpc1RpbWVab25lU3BlY2lmaWVkID0gaXNUaW1lWm9uZVNwZWNpZmllZCB8fCByZXN1bHQudGltZVpvbmVPZmZzZXQgIT09IG51bGw7XG4gICAgfVxuICAgIHN0ci5yZXBsYWNlKC9cXGIoRFRTVEFSVDopKFteXFxuXSopLywgcHJvY2Vzc01hdGNoKTtcbiAgICBzdHIucmVwbGFjZSgvXFxiKEVYREFURTopKFteXFxuXSopLywgcHJvY2Vzc01hdGNoKTtcbiAgICBzdHIucmVwbGFjZSgvXFxiKFVOVElMPSkoW147XFxuXSopLywgcHJvY2Vzc01hdGNoKTtcbiAgICByZXR1cm4geyBpc1RpbWVTcGVjaWZpZWQsIGlzVGltZVpvbmVTcGVjaWZpZWQgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRDb25zdGFudHMoaW5wdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0Lm1hcChjb252ZXJ0Q29uc3RhbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydENvbnN0YW50KGlucHV0KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRDb25zdGFudChpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBycnVsZUxpYi5SUnVsZVtpbnB1dC50b1VwcGVyQ2FzZSgpXTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0O1xufVxuXG5jb25zdCBSUlVMRV9FVkVOVF9SRUZJTkVSUyA9IHtcbiAgICBycnVsZTogaWRlbnRpdHksXG4gICAgZXhydWxlOiBpZGVudGl0eSxcbiAgICBleGRhdGU6IGlkZW50aXR5LFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbn07XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvcnJ1bGUnLFxuICAgIHJlY3VycmluZ1R5cGVzOiBbcmVjdXJyaW5nVHlwZV0sXG4gICAgZXZlbnRSZWZpbmVyczogUlJVTEVfRVZFTlRfUkVGSU5FUlMsXG59KTtcblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IEJhc2VDb21wb25lbnQsIGdldFVuaXF1ZURvbUlkLCBnZXREYXRlTWV0YSwgYnVpbGROYXZMaW5rQXR0cnMsIENvbnRlbnRDb250YWluZXIsIGdldERheUNsYXNzTmFtZXMsIGZvcm1hdERheVN0cmluZywgY3JlYXRlRm9ybWF0dGVyLCBFdmVudENvbnRhaW5lciwgZ2V0U2VnQW5jaG9yQXR0cnMsIGlzTXVsdGlEYXlSYW5nZSwgYnVpbGRTZWdUaW1lVGV4dCwgRGF0ZUNvbXBvbmVudCwgbWVtb2l6ZSwgVmlld0NvbnRhaW5lciwgU2Nyb2xsZXIsIE5vd1RpbWVyLCBzb3J0RXZlbnRTZWdzLCBnZXRTZWdNZXRhLCBzbGljZUV2ZW50U3RvcmUsIGludGVyc2VjdFJhbmdlcywgc3RhcnRPZkRheSwgYWRkRGF5cywgaW5qZWN0U3R5bGVzIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL3ByZWFjdC5qcyc7XG5cbmNsYXNzIExpc3RWaWV3SGVhZGVyUm93IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0ZXh0SWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgdGhlbWUsIGRhdGVFbnYsIG9wdGlvbnMsIHZpZXdBcGkgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHsgY2VsbElkLCBkYXlEYXRlLCB0b2RheVJhbmdlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgeyB0ZXh0SWQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBkYXlNZXRhID0gZ2V0RGF0ZU1ldGEoZGF5RGF0ZSwgdG9kYXlSYW5nZSk7XG4gICAgICAgIC8vIHdpbGwgZXZlciBiZSBmYWxzeT9cbiAgICAgICAgbGV0IHRleHQgPSBvcHRpb25zLmxpc3REYXlGb3JtYXQgPyBkYXRlRW52LmZvcm1hdChkYXlEYXRlLCBvcHRpb25zLmxpc3REYXlGb3JtYXQpIDogJyc7XG4gICAgICAgIC8vIHdpbGwgZXZlciBiZSBmYWxzeT8gYWxzbywgQkFEIE5BTUUgXCJhbHRcIlxuICAgICAgICBsZXQgc2lkZVRleHQgPSBvcHRpb25zLmxpc3REYXlTaWRlRm9ybWF0ID8gZGF0ZUVudi5mb3JtYXQoZGF5RGF0ZSwgb3B0aW9ucy5saXN0RGF5U2lkZUZvcm1hdCkgOiAnJztcbiAgICAgICAgbGV0IHJlbmRlclByb3BzID0gT2JqZWN0LmFzc2lnbih7IGRhdGU6IGRhdGVFbnYudG9EYXRlKGRheURhdGUpLCB2aWV3OiB2aWV3QXBpLCB0ZXh0SWQsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgc2lkZVRleHQsIG5hdkxpbmtBdHRyczogYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCBkYXlEYXRlKSwgc2lkZU5hdkxpbmtBdHRyczogYnVpbGROYXZMaW5rQXR0cnModGhpcy5jb250ZXh0LCBkYXlEYXRlLCAnZGF5JywgZmFsc2UpIH0sIGRheU1ldGEpO1xuICAgICAgICAvLyBUT0RPOiBtYWtlIGEgcmV1c2FibGUgSE9DIGZvciBkYXlIZWFkZXIgKHVzZWQgaW4gZGF5Z3JpZC90aW1lZ3JpZCB0b28pXG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChDb250ZW50Q29udGFpbmVyLCB7IGVsVGFnOiBcInRyXCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICdmYy1saXN0LWRheScsXG4gICAgICAgICAgICAgICAgLi4uZ2V0RGF5Q2xhc3NOYW1lcyhkYXlNZXRhLCB0aGVtZSksXG4gICAgICAgICAgICBdLCBlbEF0dHJzOiB7XG4gICAgICAgICAgICAgICAgJ2RhdGEtZGF0ZSc6IGZvcm1hdERheVN0cmluZyhkYXlEYXRlKSxcbiAgICAgICAgICAgIH0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJkYXlIZWFkZXJDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJJbm5lckNvbnRlbnQsIGNsYXNzTmFtZUdlbmVyYXRvcjogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgKElubmVyQ29udGVudCkgPT4gKCAvLyBUT0RPOiBmb3JjZS1oaWRlIHRvcCBib3JkZXIgYmFzZWQgb24gOmZpcnN0LWNoaWxkXG4gICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB7IHNjb3BlOiBcImNvbGdyb3VwXCIsIGNvbFNwYW46IDMsIGlkOiBjZWxsSWQsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHRleHRJZCB9LFxuICAgICAgICAgICAgY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogW1xuICAgICAgICAgICAgICAgICAgICAnZmMtbGlzdC1kYXktY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCd0YWJsZUNlbGxTaGFkZWQnKSxcbiAgICAgICAgICAgICAgICBdIH0pKSkpKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQocHJvcHMpIHtcbiAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsXG4gICAgICAgIHByb3BzLnRleHQgJiYgKGNyZWF0ZUVsZW1lbnQoXCJhXCIsIE9iamVjdC5hc3NpZ24oeyBpZDogcHJvcHMudGV4dElkLCBjbGFzc05hbWU6IFwiZmMtbGlzdC1kYXktdGV4dFwiIH0sIHByb3BzLm5hdkxpbmtBdHRycyksIHByb3BzLnRleHQpKSxcbiAgICAgICAgcHJvcHMuc2lkZVRleHQgJiYgKCAvKiBub3Qga2V5Ym9hcmQgdGFiYmFibGUgKi9jcmVhdGVFbGVtZW50KFwiYVwiLCBPYmplY3QuYXNzaWduKHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IFwiZmMtbGlzdC1kYXktc2lkZS10ZXh0XCIgfSwgcHJvcHMuc2lkZU5hdkxpbmtBdHRycyksIHByb3BzLnNpZGVUZXh0KSkpKTtcbn1cblxuY29uc3QgREVGQVVMVF9USU1FX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7XG4gICAgaG91cjogJ251bWVyaWMnLFxuICAgIG1pbnV0ZTogJzItZGlnaXQnLFxuICAgIG1lcmlkaWVtOiAnc2hvcnQnLFxufSk7XG5jbGFzcyBMaXN0Vmlld0V2ZW50Um93IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBsZXQgeyBwcm9wcywgY29udGV4dCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICAgICAgbGV0IHsgc2VnLCB0aW1lSGVhZGVySWQsIGV2ZW50SGVhZGVySWQsIGRhdGVIZWFkZXJJZCB9ID0gcHJvcHM7XG4gICAgICAgIGxldCB0aW1lRm9ybWF0ID0gb3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgREVGQVVMVF9USU1FX0ZPUk1BVDtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEV2ZW50Q29udGFpbmVyLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgeyBlbFRhZzogXCJ0clwiLCBlbENsYXNzZXM6IFtcbiAgICAgICAgICAgICAgICAnZmMtbGlzdC1ldmVudCcsXG4gICAgICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UuZGVmLnVybCAmJiAnZmMtZXZlbnQtZm9yY2VkLXVybCcsXG4gICAgICAgICAgICBdLCBkZWZhdWx0R2VuZXJhdG9yOiAoKSA9PiByZW5kZXJFdmVudElubmVyQ29udGVudChzZWcsIGNvbnRleHQpIC8qIHdlaXJkICovLCBzZWc6IHNlZywgdGltZVRleHQ6IFwiXCIsIGRpc2FibGVEcmFnZ2luZzogdHJ1ZSwgZGlzYWJsZVJlc2l6aW5nOiB0cnVlIH0pLCAoSW5uZXJDb250ZW50LCBldmVudENvbnRlbnRBcmcpID0+IChjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgYnVpbGRUaW1lQ29udGVudChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHRpbWVIZWFkZXJJZCwgZGF0ZUhlYWRlcklkKSxcbiAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSwgY2xhc3NOYW1lOiBcImZjLWxpc3QtZXZlbnQtZ3JhcGhpY1wiIH0sXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwiZmMtbGlzdC1ldmVudC1kb3RcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBldmVudENvbnRlbnRBcmcuYm9yZGVyQ29sb3IgfHwgZXZlbnRDb250ZW50QXJnLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgfSB9KSksXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1ldmVudC10aXRsZSddLCBlbEF0dHJzOiB7IGhlYWRlcnM6IGAke2V2ZW50SGVhZGVySWR9ICR7ZGF0ZUhlYWRlcklkfWAgfSB9KSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRXZlbnRJbm5lckNvbnRlbnQoc2VnLCBjb250ZXh0KSB7XG4gICAgbGV0IGludGVyYWN0aXZlQXR0cnMgPSBnZXRTZWdBbmNob3JBdHRycyhzZWcsIGNvbnRleHQpO1xuICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcImFcIiwgT2JqZWN0LmFzc2lnbih7fSwgaW50ZXJhY3RpdmVBdHRycyksIHNlZy5ldmVudFJhbmdlLmRlZi50aXRsZSkpO1xufVxuZnVuY3Rpb24gYnVpbGRUaW1lQ29udGVudChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIHRpbWVIZWFkZXJJZCwgZGF0ZUhlYWRlcklkKSB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29udGV4dDtcbiAgICBpZiAob3B0aW9ucy5kaXNwbGF5RXZlbnRUaW1lICE9PSBmYWxzZSkge1xuICAgICAgICBsZXQgZXZlbnREZWYgPSBzZWcuZXZlbnRSYW5nZS5kZWY7XG4gICAgICAgIGxldCBldmVudEluc3RhbmNlID0gc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2U7XG4gICAgICAgIGxldCBkb0FsbERheSA9IGZhbHNlO1xuICAgICAgICBsZXQgdGltZVRleHQ7XG4gICAgICAgIGlmIChldmVudERlZi5hbGxEYXkpIHtcbiAgICAgICAgICAgIGRvQWxsRGF5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc011bHRpRGF5UmFuZ2Uoc2VnLmV2ZW50UmFuZ2UucmFuZ2UpKSB7IC8vIFRPRE86IHVzZSAoIWlzU3RhcnQgfHwgIWlzRW5kKSBpbnN0ZWFkP1xuICAgICAgICAgICAgaWYgKHNlZy5pc1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgbnVsbCwgbnVsbCwgZXZlbnRJbnN0YW5jZS5yYW5nZS5zdGFydCwgc2VnLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWcuaXNFbmQpIHtcbiAgICAgICAgICAgICAgICB0aW1lVGV4dCA9IGJ1aWxkU2VnVGltZVRleHQoc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCBudWxsLCBudWxsLCBzZWcuc3RhcnQsIGV2ZW50SW5zdGFuY2UucmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvQWxsRGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVUZXh0ID0gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb0FsbERheSkge1xuICAgICAgICAgICAgbGV0IHJlbmRlclByb3BzID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6IGNvbnRleHQub3B0aW9ucy5hbGxEYXlUZXh0LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKGNyZWF0ZUVsZW1lbnQoQ29udGVudENvbnRhaW5lciwgeyBlbFRhZzogXCJ0ZFwiLCBlbENsYXNzZXM6IFsnZmMtbGlzdC1ldmVudC10aW1lJ10sIGVsQXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogYCR7dGltZUhlYWRlcklkfSAke2RhdGVIZWFkZXJJZH1gLFxuICAgICAgICAgICAgICAgIH0sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJhbGxEYXlDb250ZW50XCIsIGN1c3RvbUdlbmVyYXRvcjogb3B0aW9ucy5hbGxEYXlDb250ZW50LCBkZWZhdWx0R2VuZXJhdG9yOiByZW5kZXJBbGxEYXlJbm5lciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLmFsbERheUNsYXNzTmFtZXMsIGRpZE1vdW50OiBvcHRpb25zLmFsbERheURpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5hbGxEYXlXaWxsVW5tb3VudCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6IFwiZmMtbGlzdC1ldmVudC10aW1lXCIgfSwgdGltZVRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiByZW5kZXJBbGxEYXlJbm5lcihyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiByZW5kZXJQcm9wcy50ZXh0O1xufVxuXG4vKlxuUmVzcG9uc2libGUgZm9yIHRoZSBzY3JvbGxlciwgYW5kIGZvcndhcmRpbmcgZXZlbnQtcmVsYXRlZCBhY3Rpb25zIGludG8gdGhlIFwiZ3JpZFwiLlxuKi9cbmNsYXNzIExpc3RWaWV3IGV4dGVuZHMgRGF0ZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY29tcHV0ZURhdGVWYXJzID0gbWVtb2l6ZShjb21wdXRlRGF0ZVZhcnMpO1xuICAgICAgICB0aGlzLmV2ZW50U3RvcmVUb1NlZ3MgPSBtZW1vaXplKHRoaXMuX2V2ZW50U3RvcmVUb1NlZ3MpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdGltZUhlYWRlcklkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICAgICAgZXZlbnRIZWFkZXJJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgICAgIGRhdGVIZWFkZXJJZFJvb3Q6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0Um9vdEVsID0gKHJvb3RFbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC51bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgbGV0IHsgcHJvcHMsIGNvbnRleHQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IGRheURhdGVzLCBkYXlSYW5nZXMgfSA9IHRoaXMuY29tcHV0ZURhdGVWYXJzKHByb3BzLmRhdGVQcm9maWxlKTtcbiAgICAgICAgbGV0IGV2ZW50U2VncyA9IHRoaXMuZXZlbnRTdG9yZVRvU2Vncyhwcm9wcy5ldmVudFN0b3JlLCBwcm9wcy5ldmVudFVpQmFzZXMsIGRheVJhbmdlcyk7XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChWaWV3Q29udGFpbmVyLCB7IGVsUmVmOiB0aGlzLnNldFJvb3RFbCwgZWxDbGFzc2VzOiBbXG4gICAgICAgICAgICAgICAgJ2ZjLWxpc3QnLFxuICAgICAgICAgICAgICAgIGNvbnRleHQudGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJyksXG4gICAgICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLnN0aWNreUhlYWRlckRhdGVzICE9PSBmYWxzZSA/XG4gICAgICAgICAgICAgICAgICAgICdmYy1saXN0LXN0aWNreScgOlxuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIF0sIHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sXG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50KFNjcm9sbGVyLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0bywgb3ZlcmZsb3dYOiBwcm9wcy5pc0hlaWdodEF1dG8gPyAndmlzaWJsZScgOiAnaGlkZGVuJywgb3ZlcmZsb3dZOiBwcm9wcy5pc0hlaWdodEF1dG8gPyAndmlzaWJsZScgOiAnYXV0bycgfSwgZXZlbnRTZWdzLmxlbmd0aCA+IDAgP1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU2VnTGlzdChldmVudFNlZ3MsIGRheURhdGVzKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJFbXB0eU1lc3NhZ2UoKSkpKTtcbiAgICB9XG4gICAgcmVuZGVyRW1wdHlNZXNzYWdlKCkge1xuICAgICAgICBsZXQgeyBvcHRpb25zLCB2aWV3QXBpIH0gPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICAgICAgICAgIHRleHQ6IG9wdGlvbnMubm9FdmVudHNUZXh0LFxuICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KENvbnRlbnRDb250YWluZXIsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1saXN0LWVtcHR5J10sIHJlbmRlclByb3BzOiByZW5kZXJQcm9wcywgZ2VuZXJhdG9yTmFtZTogXCJub0V2ZW50c0NvbnRlbnRcIiwgY3VzdG9tR2VuZXJhdG9yOiBvcHRpb25zLm5vRXZlbnRzQ29udGVudCwgZGVmYXVsdEdlbmVyYXRvcjogcmVuZGVyTm9FdmVudHNJbm5lciwgY2xhc3NOYW1lR2VuZXJhdG9yOiBvcHRpb25zLm5vRXZlbnRzQ2xhc3NOYW1lcywgZGlkTW91bnQ6IG9wdGlvbnMubm9FdmVudHNEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMubm9FdmVudHNXaWxsVW5tb3VudCB9LCAoSW5uZXJDb250ZW50KSA9PiAoY3JlYXRlRWxlbWVudChJbm5lckNvbnRlbnQsIHsgZWxUYWc6IFwiZGl2XCIsIGVsQ2xhc3NlczogWydmYy1saXN0LWVtcHR5LWN1c2hpb24nXSB9KSkpKTtcbiAgICB9XG4gICAgcmVuZGVyU2VnTGlzdChhbGxTZWdzLCBkYXlEYXRlcykge1xuICAgICAgICBsZXQgeyB0aGVtZSwgb3B0aW9ucyB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyB0aW1lSGVhZGVySWQsIGV2ZW50SGVhZGVySWQsIGRhdGVIZWFkZXJJZFJvb3QgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGxldCBzZWdzQnlEYXkgPSBncm91cFNlZ3NCeURheShhbGxTZWdzKTsgLy8gc3BhcnNlIGFycmF5XG4gICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChOb3dUaW1lciwgeyB1bml0OiBcImRheVwiIH0sIChub3dEYXRlLCB0b2RheVJhbmdlKSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5uZXJOb2RlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IHNlZ3NCeURheS5sZW5ndGg7IGRheUluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGF5U2VncyA9IHNlZ3NCeURheVtkYXlJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGRheVNlZ3MpIHsgLy8gc3BhcnNlIGFycmF5LCBzbyBtaWdodCBiZSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRheVN0ciA9IGZvcm1hdERheVN0cmluZyhkYXlEYXRlc1tkYXlJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGF0ZUhlYWRlcklkID0gZGF0ZUhlYWRlcklkUm9vdCArICctJyArIGRheVN0cjtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwZW5kIGEgZGF5IGhlYWRlclxuICAgICAgICAgICAgICAgICAgICBpbm5lck5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChMaXN0Vmlld0hlYWRlclJvdywgeyBrZXk6IGRheVN0ciwgY2VsbElkOiBkYXRlSGVhZGVySWQsIGRheURhdGU6IGRheURhdGVzW2RheUluZGV4XSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGRheVNlZ3MgPSBzb3J0RXZlbnRTZWdzKGRheVNlZ3MsIG9wdGlvbnMuZXZlbnRPcmRlcik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHNlZyBvZiBkYXlTZWdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lck5vZGVzLnB1c2goY3JlYXRlRWxlbWVudChMaXN0Vmlld0V2ZW50Um93LCBPYmplY3QuYXNzaWduKHsga2V5OiBkYXlTdHIgKyAnOicgKyBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkIC8qIGFyZSBtdWx0aXBsZSBzZWdzIGZvciBhbiBpbnN0YW5jZUlkICovLCBzZWc6IHNlZywgaXNEcmFnZ2luZzogZmFsc2UsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBmYWxzZSwgdGltZUhlYWRlcklkOiB0aW1lSGVhZGVySWQsIGV2ZW50SGVhZGVySWQ6IGV2ZW50SGVhZGVySWQsIGRhdGVIZWFkZXJJZDogZGF0ZUhlYWRlcklkIH0sIGdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlLCBub3dEYXRlKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgY2xhc3NOYW1lOiAnZmMtbGlzdC10YWJsZSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3RhYmxlJykgfSxcbiAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGhlYWRcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRyXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGhcIiwgeyBzY29wZTogXCJjb2xcIiwgaWQ6IHRpbWVIZWFkZXJJZCB9LCBvcHRpb25zLnRpbWVIaW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnQoXCJ0aFwiLCB7IHNjb3BlOiBcImNvbFwiLCBcImFyaWEtaGlkZGVuXCI6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVFbGVtZW50KFwidGhcIiwgeyBzY29wZTogXCJjb2xcIiwgaWQ6IGV2ZW50SGVhZGVySWQgfSwgb3B0aW9ucy5ldmVudEhpbnQpKSksXG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudChcInRib2R5XCIsIG51bGwsIGlubmVyTm9kZXMpKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgX2V2ZW50U3RvcmVUb1NlZ3MoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBkYXlSYW5nZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRSYW5nZXNUb1NlZ3Moc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgdGhpcy5wcm9wcy5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgdGhpcy5jb250ZXh0Lm9wdGlvbnMubmV4dERheVRocmVzaG9sZCkuZmcsIGRheVJhbmdlcyk7XG4gICAgfVxuICAgIGV2ZW50UmFuZ2VzVG9TZWdzKGV2ZW50UmFuZ2VzLCBkYXlSYW5nZXMpIHtcbiAgICAgICAgbGV0IHNlZ3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgZXZlbnRSYW5nZSBvZiBldmVudFJhbmdlcykge1xuICAgICAgICAgICAgc2Vncy5wdXNoKC4uLnRoaXMuZXZlbnRSYW5nZVRvU2VncyhldmVudFJhbmdlLCBkYXlSYW5nZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9XG4gICAgZXZlbnRSYW5nZVRvU2VncyhldmVudFJhbmdlLCBkYXlSYW5nZXMpIHtcbiAgICAgICAgbGV0IHsgZGF0ZUVudiB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgeyBuZXh0RGF5VGhyZXNob2xkIH0gPSB0aGlzLmNvbnRleHQub3B0aW9ucztcbiAgICAgICAgbGV0IHJhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcbiAgICAgICAgbGV0IGFsbERheSA9IGV2ZW50UmFuZ2UuZGVmLmFsbERheTtcbiAgICAgICAgbGV0IGRheUluZGV4O1xuICAgICAgICBsZXQgc2VnUmFuZ2U7XG4gICAgICAgIGxldCBzZWc7XG4gICAgICAgIGxldCBzZWdzID0gW107XG4gICAgICAgIGZvciAoZGF5SW5kZXggPSAwOyBkYXlJbmRleCA8IGRheVJhbmdlcy5sZW5ndGg7IGRheUluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIHNlZ1JhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKHJhbmdlLCBkYXlSYW5nZXNbZGF5SW5kZXhdKTtcbiAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xuICAgICAgICAgICAgICAgIHNlZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBldmVudFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogc2VnUmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogc2VnUmFuZ2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBldmVudFJhbmdlLmlzU3RhcnQgJiYgc2VnUmFuZ2Uuc3RhcnQudmFsdWVPZigpID09PSByYW5nZS5zdGFydC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBldmVudFJhbmdlLmlzRW5kICYmIHNlZ1JhbmdlLmVuZC52YWx1ZU9mKCkgPT09IHJhbmdlLmVuZC52YWx1ZU9mKCksXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKHNlZyk7XG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IHdoZW4gcmFuZ2Ugd29uJ3QgZ28gZnVsbHkgaW50byB0aGUgbmV4dCBkYXksXG4gICAgICAgICAgICAgICAgLy8gYW5kIG11dGF0ZSB0aGUgbGF0ZXN0IHNlZyB0byB0aGUgYmUgdGhlIGVuZC5cbiAgICAgICAgICAgICAgICBpZiAoIXNlZy5pc0VuZCAmJiAhYWxsRGF5ICYmXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4ICsgMSA8IGRheVJhbmdlcy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UuZW5kIDxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVFbnYuYWRkKGRheVJhbmdlc1tkYXlJbmRleCArIDFdLnN0YXJ0LCBuZXh0RGF5VGhyZXNob2xkKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWcuZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICAgICAgICAgICAgICBzZWcuaXNFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVyTm9FdmVudHNJbm5lcihyZW5kZXJQcm9wcykge1xuICAgIHJldHVybiByZW5kZXJQcm9wcy50ZXh0O1xufVxuZnVuY3Rpb24gY29tcHV0ZURhdGVWYXJzKGRhdGVQcm9maWxlKSB7XG4gICAgbGV0IGRheVN0YXJ0ID0gc3RhcnRPZkRheShkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZS5zdGFydCk7XG4gICAgbGV0IHZpZXdFbmQgPSBkYXRlUHJvZmlsZS5yZW5kZXJSYW5nZS5lbmQ7XG4gICAgbGV0IGRheURhdGVzID0gW107XG4gICAgbGV0IGRheVJhbmdlcyA9IFtdO1xuICAgIHdoaWxlIChkYXlTdGFydCA8IHZpZXdFbmQpIHtcbiAgICAgICAgZGF5RGF0ZXMucHVzaChkYXlTdGFydCk7XG4gICAgICAgIGRheVJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXlTdGFydCxcbiAgICAgICAgICAgIGVuZDogYWRkRGF5cyhkYXlTdGFydCwgMSksXG4gICAgICAgIH0pO1xuICAgICAgICBkYXlTdGFydCA9IGFkZERheXMoZGF5U3RhcnQsIDEpO1xuICAgIH1cbiAgICByZXR1cm4geyBkYXlEYXRlcywgZGF5UmFuZ2VzIH07XG59XG4vLyBSZXR1cm5zIGEgc3BhcnNlIGFycmF5IG9mIGFycmF5cywgc2VncyBncm91cGVkIGJ5IHRoZWlyIGRheUluZGV4XG5mdW5jdGlvbiBncm91cFNlZ3NCeURheShzZWdzKSB7XG4gICAgbGV0IHNlZ3NCeURheSA9IFtdOyAvLyBzcGFyc2UgYXJyYXlcbiAgICBsZXQgaTtcbiAgICBsZXQgc2VnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgIChzZWdzQnlEYXlbc2VnLmRheUluZGV4XSB8fCAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gPSBbXSkpXG4gICAgICAgICAgICAucHVzaChzZWcpO1xuICAgIH1cbiAgICByZXR1cm4gc2Vnc0J5RGF5O1xufVxuXG52YXIgY3NzXzI0OHogPSBcIjpyb290ey0tZmMtbGlzdC1ldmVudC1kb3Qtd2lkdGg6MTBweDstLWZjLWxpc3QtZXZlbnQtaG92ZXItYmctY29sb3I6I2Y1ZjVmNX0uZmMtdGhlbWUtc3RhbmRhcmQgLmZjLWxpc3R7Ym9yZGVyOjFweCBzb2xpZCB2YXIoLS1mYy1ib3JkZXItY29sb3IpfS5mYyAuZmMtbGlzdC1lbXB0eXthbGlnbi1pdGVtczpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1uZXV0cmFsLWJnLWNvbG9yKTtkaXNwbGF5OmZsZXg7aGVpZ2h0OjEwMCU7anVzdGlmeS1jb250ZW50OmNlbnRlcn0uZmMgLmZjLWxpc3QtZW1wdHktY3VzaGlvbnttYXJnaW46NWVtIDB9LmZjIC5mYy1saXN0LXRhYmxle2JvcmRlci1zdHlsZTpoaWRkZW47d2lkdGg6MTAwJX0uZmMgLmZjLWxpc3QtdGFibGUgdHI+Kntib3JkZXItbGVmdDowO2JvcmRlci1yaWdodDowfS5mYyAuZmMtbGlzdC1zdGlja3kgLmZjLWxpc3QtZGF5Pip7YmFja2dyb3VuZDp2YXIoLS1mYy1wYWdlLWJnLWNvbG9yKTtwb3NpdGlvbjpzdGlja3k7dG9wOjB9LmZjIC5mYy1saXN0LXRhYmxlIHRoZWFke2xlZnQ6LTEwMDAwcHg7cG9zaXRpb246YWJzb2x1dGV9LmZjIC5mYy1saXN0LXRhYmxlIHRib2R5PnRyOmZpcnN0LWNoaWxkIHRoe2JvcmRlci10b3A6MH0uZmMgLmZjLWxpc3QtdGFibGUgdGh7cGFkZGluZzowfS5mYyAuZmMtbGlzdC1kYXktY3VzaGlvbiwuZmMgLmZjLWxpc3QtdGFibGUgdGR7cGFkZGluZzo4cHggMTRweH0uZmMgLmZjLWxpc3QtZGF5LWN1c2hpb246YWZ0ZXJ7Y2xlYXI6Ym90aDtjb250ZW50OlxcXCJcXFwiO2Rpc3BsYXk6dGFibGV9LmZjLXRoZW1lLXN0YW5kYXJkIC5mYy1saXN0LWRheS1jdXNoaW9ue2JhY2tncm91bmQtY29sb3I6dmFyKC0tZmMtbmV1dHJhbC1iZy1jb2xvcil9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWxpc3QtZGF5LXRleHQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtZGF5LXNpZGUtdGV4dHtmbG9hdDpsZWZ0fS5mYy1kaXJlY3Rpb24tbHRyIC5mYy1saXN0LWRheS1zaWRlLXRleHQsLmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtZGF5LXRleHR7ZmxvYXQ6cmlnaHR9LmZjLWRpcmVjdGlvbi1sdHIgLmZjLWxpc3QtdGFibGUgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpY3twYWRkaW5nLXJpZ2h0OjB9LmZjLWRpcmVjdGlvbi1ydGwgLmZjLWxpc3QtdGFibGUgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpY3twYWRkaW5nLWxlZnQ6MH0uZmMgLmZjLWxpc3QtZXZlbnQuZmMtZXZlbnQtZm9yY2VkLXVybHtjdXJzb3I6cG9pbnRlcn0uZmMgLmZjLWxpc3QtZXZlbnQ6aG92ZXIgdGR7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1mYy1saXN0LWV2ZW50LWhvdmVyLWJnLWNvbG9yKX0uZmMgLmZjLWxpc3QtZXZlbnQtZ3JhcGhpYywuZmMgLmZjLWxpc3QtZXZlbnQtdGltZXt3aGl0ZS1zcGFjZTpub3dyYXA7d2lkdGg6MXB4fS5mYyAuZmMtbGlzdC1ldmVudC1kb3R7Ym9yZGVyOmNhbGModmFyKC0tZmMtbGlzdC1ldmVudC1kb3Qtd2lkdGgpLzIpIHNvbGlkIHZhcigtLWZjLWV2ZW50LWJvcmRlci1jb2xvcik7Ym9yZGVyLXJhZGl1czpjYWxjKHZhcigtLWZjLWxpc3QtZXZlbnQtZG90LXdpZHRoKS8yKTtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDowO3dpZHRoOjB9LmZjIC5mYy1saXN0LWV2ZW50LXRpdGxlIGF7Y29sb3I6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246bm9uZX0uZmMgLmZjLWxpc3QtZXZlbnQuZmMtZXZlbnQtZm9yY2VkLXVybDpob3ZlciBhe3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9XCI7XG5pbmplY3RTdHlsZXMoY3NzXzI0OHopO1xuXG5leHBvcnQgeyBMaXN0VmlldyB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyBMaXN0VmlldyB9IGZyb20gJy4vaW50ZXJuYWwuanMnO1xuaW1wb3J0IHsgaWRlbnRpdHksIGNyZWF0ZUZvcm1hdHRlciB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbnRlcm5hbC5qcyc7XG5pbXBvcnQgJ0BmdWxsY2FsZW5kYXIvY29yZS9wcmVhY3QuanMnO1xuXG5jb25zdCBPUFRJT05fUkVGSU5FUlMgPSB7XG4gICAgbGlzdERheUZvcm1hdDogY3JlYXRlRmFsc2FibGVGb3JtYXR0ZXIsXG4gICAgbGlzdERheVNpZGVGb3JtYXQ6IGNyZWF0ZUZhbHNhYmxlRm9ybWF0dGVyLFxuICAgIG5vRXZlbnRzQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgbm9FdmVudHNDb250ZW50OiBpZGVudGl0eSxcbiAgICBub0V2ZW50c0RpZE1vdW50OiBpZGVudGl0eSxcbiAgICBub0V2ZW50c1dpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICAvLyBub0V2ZW50c1RleHQgaXMgZGVmaW5lZCBpbiBiYXNlIG9wdGlvbnNcbn07XG5mdW5jdGlvbiBjcmVhdGVGYWxzYWJsZUZvcm1hdHRlcihpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCA9PT0gZmFsc2UgPyBudWxsIDogY3JlYXRlRm9ybWF0dGVyKGlucHV0KTtcbn1cblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci9saXN0JyxcbiAgICBvcHRpb25SZWZpbmVyczogT1BUSU9OX1JFRklORVJTLFxuICAgIHZpZXdzOiB7XG4gICAgICAgIGxpc3Q6IHtcbiAgICAgICAgICAgIGNvbXBvbmVudDogTGlzdFZpZXcsXG4gICAgICAgICAgICBidXR0b25UZXh0S2V5OiAnbGlzdCcsXG4gICAgICAgICAgICBsaXN0RGF5Rm9ybWF0OiB7IG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnLCB5ZWFyOiAnbnVtZXJpYycgfSwgLy8gbGlrZSBcIkphbnVhcnkgMSwgMjAxNlwiXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3REYXk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfSxcbiAgICAgICAgICAgIGxpc3REYXlGb3JtYXQ6IHsgd2Vla2RheTogJ2xvbmcnIH0sIC8vIGRheS1vZi13ZWVrIGlzIGFsbCB3ZSBuZWVkLiBmdWxsIGRhdGUgaXMgcHJvYmFibHkgaW4gaGVhZGVyVG9vbGJhclxuICAgICAgICB9LFxuICAgICAgICBsaXN0V2Vlazoge1xuICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcbiAgICAgICAgICAgIGxpc3REYXlGb3JtYXQ6IHsgd2Vla2RheTogJ2xvbmcnIH0sXG4gICAgICAgICAgICBsaXN0RGF5U2lkZUZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3RNb250aDoge1xuICAgICAgICAgICAgdHlwZTogJ2xpc3QnLFxuICAgICAgICAgICAgZHVyYXRpb246IHsgbW9udGg6IDEgfSxcbiAgICAgICAgICAgIGxpc3REYXlTaWRlRm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LCAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcbiAgICAgICAgfSxcbiAgICAgICAgbGlzdFllYXI6IHtcbiAgICAgICAgICAgIHR5cGU6ICdsaXN0JyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IHllYXI6IDEgfSxcbiAgICAgICAgICAgIGxpc3REYXlTaWRlRm9ybWF0OiB7IHdlZWtkYXk6ICdsb25nJyB9LCAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcbiAgICAgICAgfSxcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVQbHVnaW4gfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW5kZXguanMnO1xuaW1wb3J0IHsgY29uZmlnLCBFbWl0dGVyLCBlbGVtZW50Q2xvc2VzdCwgYXBwbHlTdHlsZSwgd2hlblRyYW5zaXRpb25Eb25lLCByZW1vdmVFbGVtZW50LCBTY3JvbGxDb250cm9sbGVyLCBFbGVtZW50U2Nyb2xsQ29udHJvbGxlciwgY29tcHV0ZUlubmVyUmVjdCwgV2luZG93U2Nyb2xsQ29udHJvbGxlciwgRWxlbWVudERyYWdnaW5nLCBwcmV2ZW50U2VsZWN0aW9uLCBwcmV2ZW50Q29udGV4dE1lbnUsIGFsbG93U2VsZWN0aW9uLCBhbGxvd0NvbnRleHRNZW51LCBjb21wdXRlUmVjdCwgZ2V0Q2xpcHBpbmdQYXJlbnRzLCBwb2ludEluc2lkZVJlY3QsIGNvbnN0cmFpblBvaW50LCBpbnRlcnNlY3RSZWN0cywgZ2V0UmVjdENlbnRlciwgZGlmZlBvaW50cywgbWFwSGFzaCwgcmFuZ2VDb250YWluc1JhbmdlLCBpc0RhdGVTcGFuc0VxdWFsLCBJbnRlcmFjdGlvbiwgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUsIGlzRGF0ZVNlbGVjdGlvblZhbGlkLCBlbmFibGVDdXJzb3IsIGRpc2FibGVDdXJzb3IsIHRyaWdnZXJEYXRlU2VsZWN0LCBjb21wYXJlTnVtYmVycywgZ2V0RWxTZWcsIGdldFJlbGV2YW50RXZlbnRzLCBFdmVudEltcGwsIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSwgYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZSwgaXNJbnRlcmFjdGlvblZhbGlkLCBidWlsZEV2ZW50QXBpcywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlLCBzdGFydE9mRGF5LCBkaWZmRGF0ZXMsIGNyZWF0ZUR1cmF0aW9uLCBnZXRFdmVudFRhcmdldFZpYVJvb3QsIGlkZW50aXR5LCBldmVudFR1cGxlVG9TdG9yZSwgcGFyc2VEcmFnTWV0YSwgZWxlbWVudE1hdGNoZXMsIHJlZmluZUV2ZW50RGVmLCBwYXJzZUV2ZW50RGVmLCBnZXREZWZhdWx0RXZlbnRFbmQsIGNyZWF0ZUV2ZW50SW5zdGFuY2UsIEJBU0VfT1BUSU9OX0RFRkFVTFRTIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcblxuY29uZmlnLnRvdWNoTW91c2VJZ25vcmVXYWl0ID0gNTAwO1xubGV0IGlnbm9yZU1vdXNlRGVwdGggPSAwO1xubGV0IGxpc3RlbmVyQ250ID0gMDtcbmxldCBpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCA9IGZhbHNlO1xuLypcblVzZXMgYSBcInBvaW50ZXJcIiBhYnN0cmFjdGlvbiwgd2hpY2ggbW9uaXRvcnMgVUkgZXZlbnRzIGZvciBib3RoIG1vdXNlIGFuZCB0b3VjaC5cblRyYWNrcyB3aGVuIHRoZSBwb2ludGVyIFwiZHJhZ3NcIiBvbiBhIGNlcnRhaW4gZWxlbWVudCwgbWVhbmluZyBkb3duK21vdmUrdXAuXG5cbkFsc28sIHRyYWNrcyBpZiB0aGVyZSB3YXMgdG91Y2gtc2Nyb2xsaW5nLlxuQWxzbywgY2FuIHByZXZlbnQgdG91Y2gtc2Nyb2xsaW5nIGZyb20gaGFwcGVuaW5nLlxuQWxzbywgY2FuIGZpcmUgcG9pbnRlcm1vdmUgZXZlbnRzIHdoZW4gc2Nyb2xsaW5nIGhhcHBlbnMgdW5kZXJuZWF0aCwgZXZlbiB3aGVuIG5vIHJlYWwgcG9pbnRlciBtb3ZlbWVudC5cblxuZW1pdHM6XG4tIHBvaW50ZXJkb3duXG4tIHBvaW50ZXJtb3ZlXG4tIHBvaW50ZXJ1cFxuKi9cbmNsYXNzIFBvaW50ZXJEcmFnZ2luZyB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyRWwpIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIGRpcmVjdGx5IGFzc2lnbmVkIGJ5IGNhbGxlclxuICAgICAgICB0aGlzLnNlbGVjdG9yID0gJyc7IC8vIHdpbGwgY2F1c2Ugc3ViamVjdEVsIGluIGFsbCBlbWl0dGVkIGV2ZW50cyB0byBiZSB0aGlzIGVsZW1lbnRcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3RvciA9ICcnO1xuICAgICAgICB0aGlzLnNob3VsZElnbm9yZU1vdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRXYXRjaFNjcm9sbCA9IHRydWU7IC8vIGZvciBzaW11bGF0aW5nIHBvaW50ZXJtb3ZlIG9uIHNjcm9sbFxuICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZXNcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2FzVG91Y2hTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgLy8gTW91c2VcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdXNlKCkgJiZcbiAgICAgICAgICAgICAgICBpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVN0YXJ0KGV2KSkge1xuICAgICAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNjcm9sbFdhdGNoKHBldik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVNb3VzZVVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZU1vdmUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbU1vdXNlKGV2KTtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkQ29vcmRzKHBldik7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcm1vdmUnLCBwZXYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlVXAgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZU1vdXNlVXApO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuY3JlYXRlRXZlbnRGcm9tTW91c2UoZXYpKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xuICAgICAgICB9O1xuICAgICAgICAvLyBUb3VjaFxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJ5U3RhcnQoZXYpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1RvdWNoRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBwZXYgPSB0aGlzLmNyZWF0ZUV2ZW50RnJvbVRvdWNoKGV2LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcmRvd24nLCBwZXYpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFNjcm9sbFdhdGNoKHBldik7XG4gICAgICAgICAgICAgICAgLy8gdW5saWtlIG1vdXNlLCBuZWVkIHRvIGF0dGFjaCB0byB0YXJnZXQsIG5vdCBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NTc2MDAxNFxuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRFbCA9IGV2LnRhcmdldDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW92ZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZVRvdWNoTW92ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLmhhbmRsZVRvdWNoRW5kKTsgLy8gdHJlYXQgaXQgYXMgYSB0b3VjaCBlbmRcbiAgICAgICAgICAgICAgICAvLyBhdHRhY2ggYSBoYW5kbGVyIHRvIGdldCBjYWxsZWQgd2hlbiBBTlkgc2Nyb2xsIGFjdGlvbiBoYXBwZW5zIG9uIHRoZSBwYWdlLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIGltcG9zc2libGUgdG8gZG8gd2l0aCBub3JtYWwgb24vb2ZmIGJlY2F1c2UgJ3Njcm9sbCcgZG9lc24ndCBidWJibGUuXG4gICAgICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzI5NTQ1NjUvOTYzNDJcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hNb3ZlID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgcGV2ID0gdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldik7XG4gICAgICAgICAgICB0aGlzLnJlY29yZENvb3JkcyhwZXYpO1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJtb3ZlJywgcGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3VjaEVuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykgeyAvLyBkb25lIHRvIGd1YXJkIGFnYWluc3QgdG91Y2hlbmQgZm9sbG93ZWQgYnkgdG91Y2hjYW5jZWxcbiAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0RWwgPSBldi50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmUpO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5oYW5kbGVUb3VjaEVuZCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLmhhbmRsZVRvdWNoRW5kKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVUb3VjaFNjcm9sbCwgdHJ1ZSk7IC8vIHVzZUNhcHR1cmVkPXRydWVcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgdGhpcy5jcmVhdGVFdmVudEZyb21Ub3VjaChldikpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpOyAvLyBjYWxsIGxhc3Qgc28gdGhhdCBwb2ludGVydXAgaGFzIGFjY2VzcyB0byBwcm9wc1xuICAgICAgICAgICAgICAgIHRoaXMuaXNUb3VjaERyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhcnRJZ25vcmluZ01vdXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG91Y2hTY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhZ2VYID0gKHdpbmRvdy5zY3JvbGxYIC0gdGhpcy5wcmV2U2Nyb2xsWCkgKyB0aGlzLnByZXZQYWdlWDtcbiAgICAgICAgICAgICAgICBsZXQgcGFnZVkgPSAod2luZG93LnNjcm9sbFkgLSB0aGlzLnByZXZTY3JvbGxZKSArIHRoaXMucHJldlBhZ2VZO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ0V2ZW50OiBldixcbiAgICAgICAgICAgICAgICAgICAgaXNUb3VjaDogdGhpcy5pc1RvdWNoRHJhZ2dpbmcsXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3RFbDogdGhpcy5zdWJqZWN0RWwsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgICAgICAgICBwYWdlWSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFYOiBwYWdlWCAtIHRoaXMub3JpZ1BhZ2VYLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YVk6IHBhZ2VZIC0gdGhpcy5vcmlnUGFnZVksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29udGFpbmVyRWwgPSBjb250YWluZXJFbDtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgY29udGFpbmVyRWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24pO1xuICAgICAgICBjb250YWluZXJFbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIGxpc3RlbmVyQ3JlYXRlZCgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2VEb3duKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIGxpc3RlbmVyRGVzdHJveWVkKCk7XG4gICAgfVxuICAgIHRyeVN0YXJ0KGV2KSB7XG4gICAgICAgIGxldCBzdWJqZWN0RWwgPSB0aGlzLnF1ZXJ5U3ViamVjdEVsKGV2KTtcbiAgICAgICAgbGV0IGRvd25FbCA9IGV2LnRhcmdldDtcbiAgICAgICAgaWYgKHN1YmplY3RFbCAmJlxuICAgICAgICAgICAgKCF0aGlzLmhhbmRsZVNlbGVjdG9yIHx8IGVsZW1lbnRDbG9zZXN0KGRvd25FbCwgdGhpcy5oYW5kbGVTZWxlY3RvcikpKSB7XG4gICAgICAgICAgICB0aGlzLnN1YmplY3RFbCA9IHN1YmplY3RFbDtcbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7IC8vIGRvIHRoaXMgZmlyc3Qgc28gY2FuY2VsVG91Y2hTY3JvbGwgd2lsbCB3b3JrXG4gICAgICAgICAgICB0aGlzLndhc1RvdWNoU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1YmplY3RFbCA9IG51bGw7XG4gICAgICAgIC8vIGtlZXAgd2FzVG91Y2hTY3JvbGwgYXJvdW5kIGZvciBsYXRlciBhY2Nlc3NcbiAgICAgICAgdGhpcy5kZXN0cm95U2Nyb2xsV2F0Y2goKTtcbiAgICB9XG4gICAgcXVlcnlTdWJqZWN0RWwoZXYpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Q2xvc2VzdChldi50YXJnZXQsIHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lckVsO1xuICAgIH1cbiAgICBzaG91bGRJZ25vcmVNb3VzZSgpIHtcbiAgICAgICAgcmV0dXJuIGlnbm9yZU1vdXNlRGVwdGggfHwgdGhpcy5pc1RvdWNoRHJhZ2dpbmc7XG4gICAgfVxuICAgIC8vIGNhbiBiZSBjYWxsZWQgYnkgdXNlciBvZiB0aGlzIGNsYXNzLCB0byBjYW5jZWwgdG91Y2gtYmFzZWQgc2Nyb2xsaW5nIGZvciB0aGUgY3VycmVudCBkcmFnXG4gICAgY2FuY2VsVG91Y2hTY3JvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGlzV2luZG93VG91Y2hNb3ZlQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTY3JvbGxpbmcgdGhhdCBzaW11bGF0ZXMgcG9pbnRlcm1vdmVzXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGluaXRTY3JvbGxXYXRjaChldikge1xuICAgICAgICBpZiAodGhpcy5zaG91bGRXYXRjaFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRDb29yZHMoZXYpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsLCB0cnVlKTsgLy8gdXNlQ2FwdHVyZT10cnVlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVjb3JkQ29vcmRzKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZQYWdlWCA9IGV2LnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5wcmV2UGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgICAgIHRoaXMucHJldlNjcm9sbFggPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgIHRoaXMucHJldlNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95U2Nyb2xsV2F0Y2goKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFdhdGNoU2Nyb2xsKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwsIHRydWUpOyAvLyB1c2VDYXB0dXJlZD10cnVlXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRXZlbnQgTm9ybWFsaXphdGlvblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjcmVhdGVFdmVudEZyb21Nb3VzZShldiwgaXNGaXJzdCkge1xuICAgICAgICBsZXQgZGVsdGFYID0gMDtcbiAgICAgICAgbGV0IGRlbHRhWSA9IDA7XG4gICAgICAgIC8vIFRPRE86IHJlcGVhdCBjb2RlXG4gICAgICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWCA9IGV2LnBhZ2VYO1xuICAgICAgICAgICAgdGhpcy5vcmlnUGFnZVkgPSBldi5wYWdlWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IGV2LnBhZ2VYIC0gdGhpcy5vcmlnUGFnZVg7XG4gICAgICAgICAgICBkZWx0YVkgPSBldi5wYWdlWSAtIHRoaXMub3JpZ1BhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvcmlnRXZlbnQ6IGV2LFxuICAgICAgICAgICAgaXNUb3VjaDogZmFsc2UsXG4gICAgICAgICAgICBzdWJqZWN0RWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICAgICAgcGFnZVg6IGV2LnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2LnBhZ2VZLFxuICAgICAgICAgICAgZGVsdGFYLFxuICAgICAgICAgICAgZGVsdGFZLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVFdmVudEZyb21Ub3VjaChldiwgaXNGaXJzdCkge1xuICAgICAgICBsZXQgdG91Y2hlcyA9IGV2LnRvdWNoZXM7XG4gICAgICAgIGxldCBwYWdlWDtcbiAgICAgICAgbGV0IHBhZ2VZO1xuICAgICAgICBsZXQgZGVsdGFYID0gMDtcbiAgICAgICAgbGV0IGRlbHRhWSA9IDA7XG4gICAgICAgIC8vIGlmIHRvdWNoIGNvb3JkcyBhdmFpbGFibGUsIHByZWZlcixcbiAgICAgICAgLy8gYmVjYXVzZSBGRiB3b3VsZCBnaXZlIGJhZCBldi5wYWdlWCBldi5wYWdlWVxuICAgICAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFnZVggPSB0b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICAgICAgcGFnZVkgPSB0b3VjaGVzWzBdLnBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFnZVggPSBldi5wYWdlWDtcbiAgICAgICAgICAgIHBhZ2VZID0gZXYucGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVwZWF0IGNvZGVcbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ1BhZ2VYID0gcGFnZVg7XG4gICAgICAgICAgICB0aGlzLm9yaWdQYWdlWSA9IHBhZ2VZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsdGFYID0gcGFnZVggLSB0aGlzLm9yaWdQYWdlWDtcbiAgICAgICAgICAgIGRlbHRhWSA9IHBhZ2VZIC0gdGhpcy5vcmlnUGFnZVk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9yaWdFdmVudDogZXYsXG4gICAgICAgICAgICBpc1RvdWNoOiB0cnVlLFxuICAgICAgICAgICAgc3ViamVjdEVsOiB0aGlzLnN1YmplY3RFbCxcbiAgICAgICAgICAgIHBhZ2VYLFxuICAgICAgICAgICAgcGFnZVksXG4gICAgICAgICAgICBkZWx0YVgsXG4gICAgICAgICAgICBkZWx0YVksXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8gUmV0dXJucyBhIGJvb2xlYW4gd2hldGhlciB0aGlzIHdhcyBhIGxlZnQgbW91c2UgY2xpY2sgYW5kIG5vIGN0cmwga2V5ICh3aGljaCBtZWFucyByaWdodCBjbGljayBvbiBNYWMpXG5mdW5jdGlvbiBpc1ByaW1hcnlNb3VzZUJ1dHRvbihldikge1xuICAgIHJldHVybiBldi5idXR0b24gPT09IDAgJiYgIWV2LmN0cmxLZXk7XG59XG4vLyBJZ25vcmluZyBmYWtlIG1vdXNlIGV2ZW50cyBnZW5lcmF0ZWQgYnkgdG91Y2hcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHN0YXJ0SWdub3JpbmdNb3VzZSgpIHtcbiAgICBpZ25vcmVNb3VzZURlcHRoICs9IDE7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlnbm9yZU1vdXNlRGVwdGggLT0gMTtcbiAgICB9LCBjb25maWcudG91Y2hNb3VzZUlnbm9yZVdhaXQpO1xufVxuLy8gV2Ugd2FudCB0byBhdHRhY2ggdG91Y2htb3ZlIGFzIGVhcmx5IGFzIHBvc3NpYmxlIGZvciBTYWZhcmlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGxpc3RlbmVyQ3JlYXRlZCgpIHtcbiAgICBsaXN0ZW5lckNudCArPSAxO1xuICAgIGlmIChsaXN0ZW5lckNudCA9PT0gMSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25XaW5kb3dUb3VjaE1vdmUsIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGlzdGVuZXJEZXN0cm95ZWQoKSB7XG4gICAgbGlzdGVuZXJDbnQgLT0gMTtcbiAgICBpZiAoIWxpc3RlbmVyQ250KSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbldpbmRvd1RvdWNoTW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBvbldpbmRvd1RvdWNoTW92ZShldikge1xuICAgIGlmIChpc1dpbmRvd1RvdWNoTW92ZUNhbmNlbGxlZCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn1cblxuLypcbkFuIGVmZmVjdCBpbiB3aGljaCBhbiBlbGVtZW50IGZvbGxvd3MgdGhlIG1vdmVtZW50IG9mIGEgcG9pbnRlciBhY3Jvc3MgdGhlIHNjcmVlbi5cblRoZSBtb3ZpbmcgZWxlbWVudCBpcyBhIGNsb25lIG9mIHNvbWUgb3RoZXIgZWxlbWVudC5cbk11c3QgY2FsbCBzdGFydCArIGhhbmRsZU1vdmUgKyBzdG9wLlxuKi9cbmNsYXNzIEVsZW1lbnRNaXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlOyAvLyBtdXN0IGJlIGV4cGxpY2l0bHkgZW5hYmxlZFxuICAgICAgICB0aGlzLnNvdXJjZUVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5taXJyb3JFbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc291cmNlRWxSZWN0ID0gbnVsbDsgLy8gc2NyZWVuIGNvb3JkcyByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgICAvLyBvcHRpb25zIHRoYXQgY2FuIGJlIHNldCBkaXJlY3RseSBieSBjYWxsZXJcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlID0gZG9jdW1lbnQuYm9keTsgLy8gSElHSExZIFNVR0dFU1RFRCB0byBzZXQgdGhpcyB0byBzaWRlc3RlcCBTaGFkb3dET00gaXNzdWVzXG4gICAgICAgIHRoaXMuekluZGV4ID0gOTk5OTtcbiAgICAgICAgdGhpcy5yZXZlcnREdXJhdGlvbiA9IDA7XG4gICAgfVxuICAgIHN0YXJ0KHNvdXJjZUVsLCBwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VFbCA9IHNvdXJjZUVsO1xuICAgICAgICB0aGlzLnNvdXJjZUVsUmVjdCA9IHRoaXMuc291cmNlRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMub3JpZ1NjcmVlblggPSBwYWdlWCAtIHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICB0aGlzLm9yaWdTY3JlZW5ZID0gcGFnZVkgLSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgdGhpcy5kZWx0YVggPSAwO1xuICAgICAgICB0aGlzLmRlbHRhWSA9IDA7XG4gICAgICAgIHRoaXMudXBkYXRlRWxQb3NpdGlvbigpO1xuICAgIH1cbiAgICBoYW5kbGVNb3ZlKHBhZ2VYLCBwYWdlWSkge1xuICAgICAgICB0aGlzLmRlbHRhWCA9IChwYWdlWCAtIHdpbmRvdy5zY3JvbGxYKSAtIHRoaXMub3JpZ1NjcmVlblg7XG4gICAgICAgIHRoaXMuZGVsdGFZID0gKHBhZ2VZIC0gd2luZG93LnNjcm9sbFkpIC0gdGhpcy5vcmlnU2NyZWVuWTtcbiAgICAgICAgdGhpcy51cGRhdGVFbFBvc2l0aW9uKCk7XG4gICAgfVxuICAgIC8vIGNhbiBiZSBjYWxsZWQgYmVmb3JlIHN0YXJ0XG4gICAgc2V0SXNWaXNpYmxlKGJvb2wpIHtcbiAgICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXJyb3JFbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1pcnJvckVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBib29sOyAvLyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHVwZGF0ZUVsUG9zaXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVsUG9zaXRpb24oKTsgLy8gYmVjYXVzZSB3YXMgbm90IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBpbnZpc2libGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvckVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGJvb2w7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWx3YXlzIGFzeW5jXG4gICAgc3RvcChuZWVkc1JldmVydEFuaW1hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgbGV0IGRvbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChuZWVkc1JldmVydEFuaW1hdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5taXJyb3JFbCAmJlxuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgJiZcbiAgICAgICAgICAgIHRoaXMucmV2ZXJ0RHVyYXRpb24gJiYgLy8gaWYgMCwgdHJhbnNpdGlvbiB3b24ndCB3b3JrXG4gICAgICAgICAgICAodGhpcy5kZWx0YVggfHwgdGhpcy5kZWx0YVkpIC8vIGlmIHNhbWUgY29vcmRzLCB0cmFuc2l0aW9uIHdvbid0IHdvcmtcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmRvUmV2ZXJ0QW5pbWF0aW9uKGRvbmUsIHRoaXMucmV2ZXJ0RHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChkb25lLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb1JldmVydEFuaW1hdGlvbihjYWxsYmFjaywgcmV2ZXJ0RHVyYXRpb24pIHtcbiAgICAgICAgbGV0IG1pcnJvckVsID0gdGhpcy5taXJyb3JFbDtcbiAgICAgICAgbGV0IGZpbmFsU291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gYmVjYXVzZSBhdXRvc2Nyb2xsaW5nIG1pZ2h0IGhhdmUgaGFwcGVuZWRcbiAgICAgICAgbWlycm9yRWwuc3R5bGUudHJhbnNpdGlvbiA9XG4gICAgICAgICAgICAndG9wICcgKyByZXZlcnREdXJhdGlvbiArICdtcywnICtcbiAgICAgICAgICAgICAgICAnbGVmdCAnICsgcmV2ZXJ0RHVyYXRpb24gKyAnbXMnO1xuICAgICAgICBhcHBseVN0eWxlKG1pcnJvckVsLCB7XG4gICAgICAgICAgICBsZWZ0OiBmaW5hbFNvdXJjZUVsUmVjdC5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBmaW5hbFNvdXJjZUVsUmVjdC50b3AsXG4gICAgICAgIH0pO1xuICAgICAgICB3aGVuVHJhbnNpdGlvbkRvbmUobWlycm9yRWwsICgpID0+IHtcbiAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnRyYW5zaXRpb24gPSAnJztcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbGVhbnVwKCkge1xuICAgICAgICBpZiAodGhpcy5taXJyb3JFbCkge1xuICAgICAgICAgICAgcmVtb3ZlRWxlbWVudCh0aGlzLm1pcnJvckVsKTtcbiAgICAgICAgICAgIHRoaXMubWlycm9yRWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlRWwgPSBudWxsO1xuICAgIH1cbiAgICB1cGRhdGVFbFBvc2l0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2VFbCAmJiB0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgYXBwbHlTdHlsZSh0aGlzLmdldE1pcnJvckVsKCksIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLnNvdXJjZUVsUmVjdC5sZWZ0ICsgdGhpcy5kZWx0YVgsXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLnNvdXJjZUVsUmVjdC50b3AgKyB0aGlzLmRlbHRhWSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1pcnJvckVsKCkge1xuICAgICAgICBsZXQgc291cmNlRWxSZWN0ID0gdGhpcy5zb3VyY2VFbFJlY3Q7XG4gICAgICAgIGxldCBtaXJyb3JFbCA9IHRoaXMubWlycm9yRWw7XG4gICAgICAgIGlmICghbWlycm9yRWwpIHtcbiAgICAgICAgICAgIG1pcnJvckVsID0gdGhpcy5taXJyb3JFbCA9IHRoaXMuc291cmNlRWwuY2xvbmVOb2RlKHRydWUpOyAvLyBjbG9uZUNoaWxkcmVuPXRydWVcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgbG9uZyB0YXBzIG9yIGFueSBtb3VzZSBpbnRlcmFjdGlvbiBjYXVzaW5nIHNlbGVjdGlvbi9tZW51cy5cbiAgICAgICAgICAgIC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxuICAgICAgICAgICAgbWlycm9yRWwuc3R5bGUudXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgICAgICBtaXJyb3JFbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgbWlycm9yRWwuY2xhc3NMaXN0LmFkZCgnZmMtZXZlbnQtZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUobWlycm9yRWwsIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IHRoaXMuekluZGV4LFxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICcnLFxuICAgICAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzb3VyY2VFbFJlY3QucmlnaHQgLSBzb3VyY2VFbFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNvdXJjZUVsUmVjdC5ib3R0b20gLSBzb3VyY2VFbFJlY3QudG9wLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiAnYXV0bycsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobWlycm9yRWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaXJyb3JFbDtcbiAgICB9XG59XG5cbi8qXG5JcyBhIGNhY2hlIGZvciBhIGdpdmVuIGVsZW1lbnQncyBzY3JvbGwgaW5mb3JtYXRpb24gKGFsbCB0aGUgaW5mbyB0aGF0IFNjcm9sbENvbnRyb2xsZXIgc3RvcmVzKVxuaW4gYWRkaXRpb24gdGhlIFwiY2xpZW50IHJlY3RhbmdsZVwiIG9mIHRoZSBlbGVtZW50Li4gdGhlIGFyZWEgd2l0aGluIHRoZSBzY3JvbGxiYXJzLlxuXG5UaGUgY2FjaGUgY2FuIGJlIGluIG9uZSBvZiB0d28gbW9kZXM6XG4tIGRvZXNMaXN0ZW5pbmc6ZmFsc2UgLSBpZ25vcmVzIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBzY3JvbGxlZCBieSBzb21lb25lIGVsc2Vcbi0gZG9lc0xpc3RlbmluZzp0cnVlIC0gd2F0Y2ggZm9yIHNjcm9sbGluZyBhbmQgdXBkYXRlIHRoZSBjYWNoZVxuKi9cbmNsYXNzIFNjcm9sbEdlb21DYWNoZSBleHRlbmRzIFNjcm9sbENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKHNjcm9sbENvbnRyb2xsZXIsIGRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxUb3AoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMuc2Nyb2xsQ29udHJvbGxlci5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRyb2xsZXIgPSBzY3JvbGxDb250cm9sbGVyO1xuICAgICAgICB0aGlzLmRvZXNMaXN0ZW5pbmcgPSBkb2VzTGlzdGVuaW5nO1xuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMub3JpZ1Njcm9sbFRvcCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsVG9wKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsTGVmdCA9IHRoaXMub3JpZ1Njcm9sbExlZnQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbExlZnQoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxXaWR0aCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0U2Nyb2xsV2lkdGgoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxIZWlnaHQgPSBzY3JvbGxDb250cm9sbGVyLmdldFNjcm9sbEhlaWdodCgpO1xuICAgICAgICB0aGlzLmNsaWVudFdpZHRoID0gc2Nyb2xsQ29udHJvbGxlci5nZXRDbGllbnRXaWR0aCgpO1xuICAgICAgICB0aGlzLmNsaWVudEhlaWdodCA9IHNjcm9sbENvbnRyb2xsZXIuZ2V0Q2xpZW50SGVpZ2h0KCk7XG4gICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRoaXMuY29tcHV0ZUNsaWVudFJlY3QoKTsgLy8gZG8gbGFzdCBpbiBjYXNlIGl0IG5lZWRzIGNhY2hlZCB2YWx1ZXNcbiAgICAgICAgaWYgKHRoaXMuZG9lc0xpc3RlbmluZykge1xuICAgICAgICAgICAgdGhpcy5nZXRFdmVudFRhcmdldCgpLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5kb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmdldEV2ZW50VGFyZ2V0KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5oYW5kbGVTY3JvbGwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNjcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG9wO1xuICAgIH1cbiAgICBnZXRTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxMZWZ0O1xuICAgIH1cbiAgICBzZXRTY3JvbGxUb3AodG9wKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ29udHJvbGxlci5zZXRTY3JvbGxUb3AodG9wKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgcmVseWluZyBvbiB0aGUgZWxlbWVudCB0byBub3JtYWxpemUgb3V0LW9mLWJvdW5kcyBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHNhbml0aXplIG91cnNlbHZlc1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSBNYXRoLm1heChNYXRoLm1pbih0b3AsIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkpLCAwKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0U2Nyb2xsTGVmdCh0b3ApIHtcbiAgICAgICAgdGhpcy5zY3JvbGxDb250cm9sbGVyLnNldFNjcm9sbExlZnQodG9wKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvZXNMaXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgcmVseWluZyBvbiB0aGUgZWxlbWVudCB0byBub3JtYWxpemUgb3V0LW9mLWJvdW5kcyBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHNhbml0aXplIG91cnNlbHZlc1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gTWF0aC5tYXgoTWF0aC5taW4odG9wLCB0aGlzLmdldE1heFNjcm9sbExlZnQoKSksIDApO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDbGllbnRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50V2lkdGg7XG4gICAgfVxuICAgIGdldENsaWVudEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgICBnZXRTY3JvbGxXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsV2lkdGg7XG4gICAgfVxuICAgIGdldFNjcm9sbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgICBoYW5kbGVTY3JvbGxDaGFuZ2UoKSB7XG4gICAgfVxufVxuXG5jbGFzcyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlIGV4dGVuZHMgU2Nyb2xsR2VvbUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihlbCwgZG9lc0xpc3RlbmluZykge1xuICAgICAgICBzdXBlcihuZXcgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIoZWwpLCBkb2VzTGlzdGVuaW5nKTtcbiAgICB9XG4gICAgZ2V0RXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbENvbnRyb2xsZXIuZWw7XG4gICAgfVxuICAgIGNvbXB1dGVDbGllbnRSZWN0KCkge1xuICAgICAgICByZXR1cm4gY29tcHV0ZUlubmVyUmVjdCh0aGlzLnNjcm9sbENvbnRyb2xsZXIuZWwpO1xuICAgIH1cbn1cblxuY2xhc3MgV2luZG93U2Nyb2xsR2VvbUNhY2hlIGV4dGVuZHMgU2Nyb2xsR2VvbUNhY2hlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2VzTGlzdGVuaW5nKSB7XG4gICAgICAgIHN1cGVyKG5ldyBXaW5kb3dTY3JvbGxDb250cm9sbGVyKCksIGRvZXNMaXN0ZW5pbmcpO1xuICAgIH1cbiAgICBnZXRFdmVudFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgY29tcHV0ZUNsaWVudFJlY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiB0aGlzLnNjcm9sbExlZnQsXG4gICAgICAgICAgICByaWdodDogdGhpcy5zY3JvbGxMZWZ0ICsgdGhpcy5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIHRvcDogdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgICAgICBib3R0b206IHRoaXMuc2Nyb2xsVG9wICsgdGhpcy5jbGllbnRIZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIHRoZSB3aW5kb3cgaXMgdGhlIG9ubHkgc2Nyb2xsIG9iamVjdCB0aGF0IGNoYW5nZXMgaXQncyByZWN0YW5nbGUgcmVsYXRpdmVcbiAgICAvLyB0byB0aGUgZG9jdW1lbnQncyB0b3BsZWZ0IGFzIGl0IHNjcm9sbHNcbiAgICBoYW5kbGVTY3JvbGxDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuY2xpZW50UmVjdCA9IHRoaXMuY29tcHV0ZUNsaWVudFJlY3QoKTtcbiAgICB9XG59XG5cbi8vIElmIGF2YWlsYWJsZSB3ZSBhcmUgdXNpbmcgbmF0aXZlIFwicGVyZm9ybWFuY2VcIiBBUEkgaW5zdGVhZCBvZiBcIkRhdGVcIlxuLy8gUmVhZCBtb3JlIGFib3V0IGl0IG9uIE1ETjpcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QZXJmb3JtYW5jZVxuY29uc3QgZ2V0VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ2Z1bmN0aW9uJyA/IHBlcmZvcm1hbmNlLm5vdyA6IERhdGUubm93O1xuLypcbkZvciBhIHBvaW50ZXIgaW50ZXJhY3Rpb24sIGF1dG9tYXRpY2FsbHkgc2Nyb2xscyBjZXJ0YWluIHNjcm9sbCBjb250YWluZXJzIHdoZW4gdGhlIHBvaW50ZXJcbmFwcHJvYWNoZXMgdGhlIGVkZ2UuXG5cblRoZSBjYWxsZXIgbXVzdCBjYWxsIHN0YXJ0ICsgaGFuZGxlTW92ZSArIHN0b3AuXG4qL1xuY2xhc3MgQXV0b1Njcm9sbGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY3JvbGxRdWVyeSA9IFt3aW5kb3csICcuZmMtc2Nyb2xsZXInXTtcbiAgICAgICAgdGhpcy5lZGdlVGhyZXNob2xkID0gNTA7IC8vIHBpeGVsc1xuICAgICAgICB0aGlzLm1heFZlbG9jaXR5ID0gMzAwOyAvLyBwaXhlbHMgcGVyIHNlY29uZFxuICAgICAgICAvLyBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICB0aGlzLnBvaW50ZXJTY3JlZW5YID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWSA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY3JvbGxDYWNoZXMgPSBudWxsO1xuICAgICAgICAvLyBwcm90ZWN0IGFnYWluc3QgdGhlIGluaXRpYWwgcG9pbnRlcmRvd24gYmVpbmcgdG9vIGNsb3NlIHRvIGFuIGVkZ2UgYW5kIHN0YXJ0aW5nIHRoZSBzY3JvbGxcbiAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmV2ZXJNb3ZlZERvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlck1vdmVkUmlnaHQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbmltYXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBbmltYXRpbmcpIHsgLy8gd2Fzbid0IGNhbmNlbGxlZCBiZXR3ZWVuIGFuaW1hdGlvbiBjYWxsc1xuICAgICAgICAgICAgICAgIGxldCBlZGdlID0gdGhpcy5jb21wdXRlQmVzdEVkZ2UodGhpcy5wb2ludGVyU2NyZWVuWCArIHdpbmRvdy5zY3JvbGxYLCB0aGlzLnBvaW50ZXJTY3JlZW5ZICsgd2luZG93LnNjcm9sbFkpO1xuICAgICAgICAgICAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub3cgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2lkZShlZGdlLCAobm93IC0gdGhpcy5tc1NpbmNlUmVxdWVzdCkgLyAxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKG5vdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7IC8vIHdpbGwgc3RvcCBhbmltYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXJ0KHBhZ2VYLCBwYWdlWSwgc2Nyb2xsU3RhcnRFbCkge1xuICAgICAgICBpZiAodGhpcy5pc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gdGhpcy5idWlsZENhY2hlcyhzY3JvbGxTdGFydEVsKTtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyU2NyZWVuWSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFVwID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZERvd24gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXZlck1vdmVkTGVmdCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRSaWdodCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKHBhZ2VYLCBwYWdlWSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlTW92ZShwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICBsZXQgcG9pbnRlclNjcmVlblggPSBwYWdlWCAtIHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICAgICAgbGV0IHBvaW50ZXJTY3JlZW5ZID0gcGFnZVkgLSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgICAgIGxldCB5RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5ZID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5ZIC0gdGhpcy5wb2ludGVyU2NyZWVuWTtcbiAgICAgICAgICAgIGxldCB4RGVsdGEgPSB0aGlzLnBvaW50ZXJTY3JlZW5YID09PSBudWxsID8gMCA6IHBvaW50ZXJTY3JlZW5YIC0gdGhpcy5wb2ludGVyU2NyZWVuWDtcbiAgICAgICAgICAgIGlmICh5RGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh5RGVsdGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWREb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4RGVsdGEgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVyTW92ZWRMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHhEZWx0YSA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZXJNb3ZlZFJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblggPSBwb2ludGVyU2NyZWVuWDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRlclNjcmVlblkgPSBwb2ludGVyU2NyZWVuWTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0FuaW1hdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbihnZXRUaW1lKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGluZyA9IGZhbHNlOyAvLyB3aWxsIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgICAgIHNjcm9sbENhY2hlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ2FjaGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0QW5pbWF0aW9uKG5vdykge1xuICAgICAgICB0aGlzLm1zU2luY2VSZXF1ZXN0ID0gbm93O1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlKTtcbiAgICB9XG4gICAgaGFuZGxlU2lkZShlZGdlLCBzZWNvbmRzKSB7XG4gICAgICAgIGxldCB7IHNjcm9sbENhY2hlIH0gPSBlZGdlO1xuICAgICAgICBsZXQgeyBlZGdlVGhyZXNob2xkIH0gPSB0aGlzO1xuICAgICAgICBsZXQgaW52RGlzdGFuY2UgPSBlZGdlVGhyZXNob2xkIC0gZWRnZS5kaXN0YW5jZTtcbiAgICAgICAgbGV0IHZlbG9jaXR5ID0gLy8gdGhlIGNsb3NlciB0byB0aGUgZWRnZSwgdGhlIGZhc3RlciB3ZSBzY3JvbGxcbiAgICAgICAgICgoaW52RGlzdGFuY2UgKiBpbnZEaXN0YW5jZSkgLyAoZWRnZVRocmVzaG9sZCAqIGVkZ2VUaHJlc2hvbGQpKSAqIC8vIHF1YWRyYXRpY1xuICAgICAgICAgICAgdGhpcy5tYXhWZWxvY2l0eSAqIHNlY29uZHM7XG4gICAgICAgIGxldCBzaWduID0gMTtcbiAgICAgICAgc3dpdGNoIChlZGdlLm5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgICAgICBzY3JvbGxDYWNoZS5zZXRTY3JvbGxMZWZ0KHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKSArIHZlbG9jaXR5ICogc2lnbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICAgIHNpZ24gPSAtMTtcbiAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgc2Nyb2xsQ2FjaGUuc2V0U2Nyb2xsVG9wKHNjcm9sbENhY2hlLmdldFNjcm9sbFRvcCgpICsgdmVsb2NpdHkgKiBzaWduKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBsZWZ0L3RvcCBhcmUgcmVsYXRpdmUgdG8gZG9jdW1lbnQgdG9wbGVmdFxuICAgIGNvbXB1dGVCZXN0RWRnZShsZWZ0LCB0b3ApIHtcbiAgICAgICAgbGV0IHsgZWRnZVRocmVzaG9sZCB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJlc3RTaWRlID0gbnVsbDtcbiAgICAgICAgbGV0IHNjcm9sbENhY2hlcyA9IHRoaXMuc2Nyb2xsQ2FjaGVzIHx8IFtdO1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiBzY3JvbGxDYWNoZXMpIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdDtcbiAgICAgICAgICAgIGxldCBsZWZ0RGlzdCA9IGxlZnQgLSByZWN0LmxlZnQ7XG4gICAgICAgICAgICBsZXQgcmlnaHREaXN0ID0gcmVjdC5yaWdodCAtIGxlZnQ7XG4gICAgICAgICAgICBsZXQgdG9wRGlzdCA9IHRvcCAtIHJlY3QudG9wO1xuICAgICAgICAgICAgbGV0IGJvdHRvbURpc3QgPSByZWN0LmJvdHRvbSAtIHRvcDtcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgd2l0aGluIHRoZSByZWN0P1xuICAgICAgICAgICAgaWYgKGxlZnREaXN0ID49IDAgJiYgcmlnaHREaXN0ID49IDAgJiYgdG9wRGlzdCA+PSAwICYmIGJvdHRvbURpc3QgPj0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0b3BEaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWRVcCAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxVcCgpICYmXG4gICAgICAgICAgICAgICAgICAgICghYmVzdFNpZGUgfHwgYmVzdFNpZGUuZGlzdGFuY2UgPiB0b3BEaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICd0b3AnLCBkaXN0YW5jZTogdG9wRGlzdCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYm90dG9tRGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkRG93biAmJiBzY3JvbGxDYWNoZS5jYW5TY3JvbGxEb3duKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFiZXN0U2lkZSB8fCBiZXN0U2lkZS5kaXN0YW5jZSA+IGJvdHRvbURpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZSwgbmFtZTogJ2JvdHRvbScsIGRpc3RhbmNlOiBib3R0b21EaXN0IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgVE9ETzogZml4IGJyb2tlbiBSVEwgc2Nyb2xsaW5nLiBjYW5TY3JvbGxMZWZ0IGFsd2F5cyByZXR1cm5pbmcgZmFsc2VcbiAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNDgzN1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGxlZnREaXN0IDw9IGVkZ2VUaHJlc2hvbGQgJiYgdGhpcy5ldmVyTW92ZWRMZWZ0ICYmIHNjcm9sbENhY2hlLmNhblNjcm9sbExlZnQoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gbGVmdERpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RTaWRlID0geyBzY3JvbGxDYWNoZSwgbmFtZTogJ2xlZnQnLCBkaXN0YW5jZTogbGVmdERpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0RGlzdCA8PSBlZGdlVGhyZXNob2xkICYmIHRoaXMuZXZlck1vdmVkUmlnaHQgJiYgc2Nyb2xsQ2FjaGUuY2FuU2Nyb2xsUmlnaHQoKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWJlc3RTaWRlIHx8IGJlc3RTaWRlLmRpc3RhbmNlID4gcmlnaHREaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHsgc2Nyb2xsQ2FjaGUsIG5hbWU6ICdyaWdodCcsIGRpc3RhbmNlOiByaWdodERpc3QgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJlc3RTaWRlO1xuICAgIH1cbiAgICBidWlsZENhY2hlcyhzY3JvbGxTdGFydEVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2Nyb2xsRWxzKHNjcm9sbFN0YXJ0RWwpLm1hcCgoZWwpID0+IHtcbiAgICAgICAgICAgIGlmIChlbCA9PT0gd2luZG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXaW5kb3dTY3JvbGxHZW9tQ2FjaGUoZmFsc2UpOyAvLyBmYWxzZSA9IGRvbid0IGxpc3RlbiB0byB1c2VyLWdlbmVyYXRlZCBzY3JvbGxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRTY3JvbGxHZW9tQ2FjaGUoZWwsIGZhbHNlKTsgLy8gZmFsc2UgPSBkb24ndCBsaXN0ZW4gdG8gdXNlci1nZW5lcmF0ZWQgc2Nyb2xsc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVlcnlTY3JvbGxFbHMoc2Nyb2xsU3RhcnRFbCkge1xuICAgICAgICBsZXQgZWxzID0gW107XG4gICAgICAgIGZvciAobGV0IHF1ZXJ5IG9mIHRoaXMuc2Nyb2xsUXVlcnkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcXVlcnkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZWxzLnB1c2gocXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBUT0RPOiBpbiB0aGUgZnV0dXJlLCBhbHdheXMgaGF2ZSBhdXRvLXNjcm9sbCBoYXBwZW4gb24gZWxlbWVudCB3aGVyZSBjdXJyZW50IEhpdCBjYW1lIGZyb21cbiAgICAgICAgICAgICAgICBUaWNrZXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9mdWxsY2FsZW5kYXIvZnVsbGNhbGVuZGFyL2lzc3Vlcy80NTkzXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBlbHMucHVzaCguLi5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzY3JvbGxTdGFydEVsLmdldFJvb3ROb2RlKCkucXVlcnlTZWxlY3RvckFsbChxdWVyeSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxzO1xuICAgIH1cbn1cblxuLypcbk1vbml0b3JzIGRyYWdnaW5nIG9uIGFuIGVsZW1lbnQuIEhhcyBhIG51bWJlciBvZiBoaWdoLWxldmVsIGZlYXR1cmVzOlxuLSBtaW5pbXVtIGRpc3RhbmNlIHJlcXVpcmVkIGJlZm9yZSBkcmFnZ2luZ1xuLSBtaW5pbXVtIHdhaXQgdGltZSAoXCJkZWxheVwiKSBiZWZvcmUgZHJhZ2dpbmdcbi0gYSBtaXJyb3IgZWxlbWVudCB0aGF0IGZvbGxvd3MgdGhlIHBvaW50ZXJcbiovXG5jbGFzcyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nIGV4dGVuZHMgRWxlbWVudERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJFbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyRWwpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsID0gY29udGFpbmVyRWw7XG4gICAgICAgIC8vIG9wdGlvbnMgdGhhdCBjYW4gYmUgZGlyZWN0bHkgc2V0IGJ5IGNhbGxlclxuICAgICAgICAvLyB0aGUgY2FsbGVyIGNhbiBhbHNvIHNldCB0aGUgUG9pbnRlckRyYWdnaW5nJ3Mgb3B0aW9ucyBhcyB3ZWxsXG4gICAgICAgIHRoaXMuZGVsYXkgPSBudWxsO1xuICAgICAgICB0aGlzLm1pbkRpc3RhbmNlID0gMDtcbiAgICAgICAgdGhpcy50b3VjaFNjcm9sbEFsbG93ZWQgPSB0cnVlOyAvLyBwcmV2ZW50cyBkcmFnIGZyb20gc3RhcnRpbmcgYW5kIGJsb2NrcyBzY3JvbGxpbmcgZHVyaW5nIGRyYWdcbiAgICAgICAgdGhpcy5taXJyb3JOZWVkc1JldmVydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSBmYWxzZTsgLy8gaXMgdGhlIHVzZXIgdmFsaWRseSBtb3ZpbmcgdGhlIHBvaW50ZXI/IGxhc3RzIHVudGlsIHBvaW50ZXJ1cFxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTsgLy8gaXMgaXQgSU5URU5URlVMTFkgZHJhZ2dpbmc/IGxhc3RzIHVudGlsIGFmdGVyIHJldmVydCBhbmltYXRpb25cbiAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLm9uUG9pbnRlckRvd24gPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0RyYWdnaW5nKSB7IC8vIHNvIG5ldyBkcmFnIGRvZXNuJ3QgaGFwcGVuIHdoaWxlIHJldmVydCBhbmltYXRpb24gaXMgZ29pbmdcbiAgICAgICAgICAgICAgICB0aGlzLmlzSW50ZXJhY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJldmVudFNlbGVjdGlvbihkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICBwcmV2ZW50Q29udGV4dE1lbnUoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgLy8gcHJldmVudCBsaW5rcyBmcm9tIGJlaW5nIHZpc2l0ZWQgaWYgdGhlcmUncyBhbiBldmVudHVhbCBkcmFnLlxuICAgICAgICAgICAgICAgIC8vIGFsc28gcHJldmVudHMgc2VsZWN0aW9uIGluIG9sZGVyIGJyb3dzZXJzIChtYXliZT8pLlxuICAgICAgICAgICAgICAgIC8vIG5vdCBuZWNlc3NhcnkgZm9yIHRvdWNoLCBiZXNpZGVzLCBicm93c2VyIHdvdWxkIGNvbXBsYWluIGFib3V0IHBhc3NpdmVuZXNzLlxuICAgICAgICAgICAgICAgIGlmICghZXYuaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICBldi5vcmlnRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgZXYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW50ZXJhY3RpbmcgJiYgLy8gbm90IGRlc3Ryb3llZCB2aWEgcG9pbnRlcmRvd24gaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5wb2ludGVyLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0aW9ucyByZWxhdGVkIHRvIGluaXRpYXRpbmcgZHJhZ3N0YXJ0K2RyYWdtb3ZlK2RyYWdlbmQuLi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5taXJyb3Iuc2V0SXNWaXNpYmxlKGZhbHNlKTsgLy8gcmVzZXQuIGNhbGxlciBtdXN0IHNldC12aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yLnN0YXJ0KGV2LnN1YmplY3RFbCwgZXYucGFnZVgsIGV2LnBhZ2VZKTsgLy8gbXVzdCBoYXBwZW4gb24gZmlyc3QgcG9pbnRlciBkb3duXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREZWxheShldik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5taW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXN0YW5jZVN1cnBhc3NlZChldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Qb2ludGVyTW92ZSA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnRlcmFjdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVybW92ZScsIGV2KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWluRGlzdGFuY2UgPSB0aGlzLm1pbkRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2VTcTsgLy8gY3VycmVudCBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4sIHNxdWFyZWRcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgZGVsdGFYLCBkZWx0YVkgfSA9IGV2O1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVNxID0gZGVsdGFYICogZGVsdGFYICsgZGVsdGFZICogZGVsdGFZO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VTcSA+PSBtaW5EaXN0YW5jZSAqIG1pbkRpc3RhbmNlKSB7IC8vIHVzZSBweXRoYWdvcmVhbiB0aGVvcmVtXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgcmVhbCBwb2ludGVyIG1vdmU/IChub3Qgb25lIHNpbXVsYXRlZCBieSBzY3JvbGxpbmcpXG4gICAgICAgICAgICAgICAgICAgIGlmIChldi5vcmlnRXZlbnQudHlwZSAhPT0gJ3Njcm9sbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWlycm9yLmhhbmRsZU1vdmUoZXYucGFnZVgsIGV2LnBhZ2VZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLmhhbmRsZU1vdmUoZXYucGFnZVgsIGV2LnBhZ2VZKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ21vdmUnLCBldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9pbnRlclVwID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYWxsb3dTZWxlY3Rpb24oZG9jdW1lbnQuYm9keSk7XG4gICAgICAgICAgICAgICAgYWxsb3dDb250ZXh0TWVudShkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcigncG9pbnRlcnVwJywgZXYpOyAvLyBjYW4gcG90ZW50aWFsbHkgc2V0IG1pcnJvck5lZWRzUmV2ZXJ0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF1dG9TY3JvbGxlci5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5U3RvcERyYWcoZXYpOyAvLyB3aGljaCB3aWxsIHN0b3AgdGhlIG1pcnJvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxheVRpbWVvdXRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsYXlUaW1lb3V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBvaW50ZXIgPSB0aGlzLnBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGNvbnRhaW5lckVsKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMub25Qb2ludGVyRG93bik7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcm1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMub25Qb2ludGVyVXApO1xuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHBvaW50ZXIuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pcnJvciA9IG5ldyBFbGVtZW50TWlycm9yKCk7XG4gICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyID0gbmV3IEF1dG9TY3JvbGxlcigpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBvaW50ZXIuZGVzdHJveSgpO1xuICAgICAgICAvLyBIQUNLOiBzaW11bGF0ZSBhIHBvaW50ZXItdXAgdG8gZW5kIHRoZSBjdXJyZW50IGRyYWdcbiAgICAgICAgLy8gVE9ETzogZmlyZSAnZHJhZ2VuZCcgZGlyZWN0bHkgYW5kIHN0b3AgaW50ZXJhY3Rpb24uIGRpc2NvdXJhZ2UgdXNlIG9mIHBvaW50ZXJ1cCBldmVudCAoYi9jIG1pZ2h0IG5vdCBmaXJlKVxuICAgICAgICB0aGlzLm9uUG9pbnRlclVwKHt9KTtcbiAgICB9XG4gICAgc3RhcnREZWxheShldikge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEZWxheUVuZChldik7XG4gICAgICAgICAgICB9LCB0aGlzLmRlbGF5KTsgLy8gbm90IGFzc2lnbmFibGUgdG8gbnVtYmVyIVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEZWxheUVuZChldik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRGVsYXlFbmQoZXYpIHtcbiAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyeVN0YXJ0RHJhZyhldik7XG4gICAgfVxuICAgIGhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KSB7XG4gICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudHJ5U3RhcnREcmFnKGV2KTtcbiAgICB9XG4gICAgdHJ5U3RhcnREcmFnKGV2KSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVsYXlFbmRlZCAmJiB0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wb2ludGVyLndhc1RvdWNoU2Nyb2xsIHx8IHRoaXMudG91Y2hTY3JvbGxBbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1pcnJvck5lZWRzUmV2ZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5hdXRvU2Nyb2xsZXIuc3RhcnQoZXYucGFnZVgsIGV2LnBhZ2VZLCB0aGlzLmNvbnRhaW5lckVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvdWNoU2Nyb2xsQWxsb3dlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2ludGVyLmNhbmNlbFRvdWNoU2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyeVN0b3BEcmFnKGV2KSB7XG4gICAgICAgIC8vIC5zdG9wKCkgaXMgQUxXQVlTIGFzeW5jaHJvbm91cywgd2hpY2ggd2UgTkVFRCBiZWNhdXNlIHdlIHdhbnQgYWxsIHBvaW50ZXJ1cCBldmVudHNcbiAgICAgICAgLy8gdGhhdCBjb21lIGZyb20gdGhlIGRvY3VtZW50IHRvIGZpcmUgYmVmb3JlaGFuZC4gbXVjaCBtb3JlIGNvbnZlbmllbnQgdGhpcyB3YXkuXG4gICAgICAgIHRoaXMubWlycm9yLnN0b3AodGhpcy5taXJyb3JOZWVkc1JldmVydCwgdGhpcy5zdG9wRHJhZy5iaW5kKHRoaXMsIGV2KSk7XG4gICAgfVxuICAgIHN0b3BEcmFnKGV2KSB7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ2VuZCcsIGV2KTtcbiAgICB9XG4gICAgLy8gZmlsbCBpbiB0aGUgaW1wbGVtZW50YXRpb25zLi4uXG4gICAgc2V0SWdub3JlTW92ZShib29sKSB7XG4gICAgICAgIHRoaXMucG9pbnRlci5zaG91bGRJZ25vcmVNb3ZlID0gYm9vbDtcbiAgICB9XG4gICAgc2V0TWlycm9ySXNWaXNpYmxlKGJvb2wpIHtcbiAgICAgICAgdGhpcy5taXJyb3Iuc2V0SXNWaXNpYmxlKGJvb2wpO1xuICAgIH1cbiAgICBzZXRNaXJyb3JOZWVkc1JldmVydChib29sKSB7XG4gICAgICAgIHRoaXMubWlycm9yTmVlZHNSZXZlcnQgPSBib29sO1xuICAgIH1cbiAgICBzZXRBdXRvU2Nyb2xsRW5hYmxlZChib29sKSB7XG4gICAgICAgIHRoaXMuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGJvb2w7XG4gICAgfVxufVxuXG4vKlxuV2hlbiB0aGlzIGNsYXNzIGlzIGluc3RhbnRpYXRlZCwgaXQgcmVjb3JkcyB0aGUgb2Zmc2V0IG9mIGFuIGVsZW1lbnQgKHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCB0b3BsZWZ0KSxcbmFuZCBjb250aW51ZXMgdG8gbW9uaXRvciBzY3JvbGxpbmcsIHVwZGF0aW5nIHRoZSBjYWNoZWQgY29vcmRpbmF0ZXMgaWYgaXQgbmVlZHMgdG8uXG5Eb2VzIG5vdCBhY2Nlc3MgdGhlIERPTSBhZnRlciBpbnN0YW50aWF0aW9uLCBzbyBoaWdobHkgcGVyZm9ybWFudC5cblxuQWxzbyBrZWVwcyB0cmFjayBvZiBhbGwgc2Nyb2xsaW5nL292ZXJmbG93OmhpZGRlbiBjb250YWluZXJzIHRoYXQgYXJlIHBhcmVudHMgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbmFuZCBhbiBkZXRlcm1pbmUgaWYgYSBnaXZlbiBwb2ludCBpcyBpbnNpZGUgdGhlIGNvbWJpbmVkIGNsaXBwaW5nIHJlY3RhbmdsZS5cbiovXG5jbGFzcyBPZmZzZXRUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihlbCkge1xuICAgICAgICB0aGlzLmVsID0gZWw7XG4gICAgICAgIHRoaXMub3JpZ1JlY3QgPSBjb21wdXRlUmVjdChlbCk7XG4gICAgICAgIC8vIHdpbGwgd29yayBmaW5lIGZvciBkaXZzIHRoYXQgaGF2ZSBvdmVyZmxvdzpoaWRkZW5cbiAgICAgICAgdGhpcy5zY3JvbGxDYWNoZXMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpLm1hcCgoc2Nyb2xsRWwpID0+IG5ldyBFbGVtZW50U2Nyb2xsR2VvbUNhY2hlKHNjcm9sbEVsLCB0cnVlKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzKSB7XG4gICAgICAgICAgICBzY3JvbGxDYWNoZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZUxlZnQoKSB7XG4gICAgICAgIGxldCBsZWZ0ID0gdGhpcy5vcmlnUmVjdC5sZWZ0O1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgbGVmdCArPSBzY3JvbGxDYWNoZS5vcmlnU2Nyb2xsTGVmdCAtIHNjcm9sbENhY2hlLmdldFNjcm9sbExlZnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG4gICAgY29tcHV0ZVRvcCgpIHtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMub3JpZ1JlY3QudG9wO1xuICAgICAgICBmb3IgKGxldCBzY3JvbGxDYWNoZSBvZiB0aGlzLnNjcm9sbENhY2hlcykge1xuICAgICAgICAgICAgdG9wICs9IHNjcm9sbENhY2hlLm9yaWdTY3JvbGxUb3AgLSBzY3JvbGxDYWNoZS5nZXRTY3JvbGxUb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH1cbiAgICBpc1dpdGhpbkNsaXBwaW5nKHBhZ2VYLCBwYWdlWSkge1xuICAgICAgICBsZXQgcG9pbnQgPSB7IGxlZnQ6IHBhZ2VYLCB0b3A6IHBhZ2VZIH07XG4gICAgICAgIGZvciAobGV0IHNjcm9sbENhY2hlIG9mIHRoaXMuc2Nyb2xsQ2FjaGVzKSB7XG4gICAgICAgICAgICBpZiAoIWlzSWdub3JlZENsaXBwaW5nKHNjcm9sbENhY2hlLmdldEV2ZW50VGFyZ2V0KCkpICYmXG4gICAgICAgICAgICAgICAgIXBvaW50SW5zaWRlUmVjdChwb2ludCwgc2Nyb2xsQ2FjaGUuY2xpZW50UmVjdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLy8gY2VydGFpbiBjbGlwcGluZyBjb250YWluZXJzIHNob3VsZCBuZXZlciBjb25zdHJhaW4gaW50ZXJhY3Rpb25zLCBsaWtlIDxodG1sPiBhbmQgPGJvZHk+XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvMzYxNVxuZnVuY3Rpb24gaXNJZ25vcmVkQ2xpcHBpbmcobm9kZSkge1xuICAgIGxldCB0YWdOYW1lID0gbm9kZS50YWdOYW1lO1xuICAgIHJldHVybiB0YWdOYW1lID09PSAnSFRNTCcgfHwgdGFnTmFtZSA9PT0gJ0JPRFknO1xufVxuXG4vKlxuVHJhY2tzIG1vdmVtZW50IG92ZXIgbXVsdGlwbGUgZHJvcHBhYmxlIGFyZWFzIChha2EgXCJoaXRzXCIpXG50aGF0IGV4aXN0IGluIG9uZSBvciBtb3JlIERhdGVDb21wb25lbnRzLlxuUmVsaWVzIG9uIGFuIGV4aXN0aW5nIGRyYWdnYWJsZS5cblxuZW1pdHM6XG4tIHBvaW50ZXJkb3duXG4tIGRyYWdzdGFydFxuLSBoaXRjaGFuZ2UgLSBmaXJlcyBpbml0aWFsbHksIGV2ZW4gaWYgbm90IG92ZXIgYSBoaXRcbi0gcG9pbnRlcnVwXG4tIChoaXRjaGFuZ2UgLSBhZ2FpbiwgdG8gbnVsbCwgaWYgZW5kZWQgb3ZlciBhIGhpdClcbi0gZHJhZ2VuZFxuKi9cbmNsYXNzIEhpdERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihkcmFnZ2luZywgZHJvcHBhYmxlU3RvcmUpIHtcbiAgICAgICAgLy8gb3B0aW9ucyB0aGF0IGNhbiBiZSBzZXQgYnkgY2FsbGVyXG4gICAgICAgIHRoaXMudXNlU3ViamVjdENlbnRlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlcXVpcmVJbml0aWFsID0gdHJ1ZTsgLy8gaWYgZG9lc24ndCBzdGFydCBvdXQgb24gYSBoaXQsIHdvbid0IGVtaXQgYW55IGV2ZW50c1xuICAgICAgICB0aGlzLmRpc2FibGVQb2ludENoZWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5pdGlhbEhpdCA9IG51bGw7XG4gICAgICAgIHRoaXMubW92aW5nSGl0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5maW5hbEhpdCA9IG51bGw7IC8vIHdvbid0IGV2ZXIgYmUgcG9wdWxhdGVkIGlmIHNob3VsZElnbm9yZU1vdmVcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxIaXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5tb3ZpbmdIaXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5maW5hbEhpdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnByZXBhcmVIaXRzKCk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NGaXJzdENvb3JkKGV2KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmluaXRpYWxIaXQgfHwgIXRoaXMucmVxdWlyZUluaXRpYWwpIHtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBmaXJlIHRoaXMgYmVmb3JlIGNvbXB1dGluZyBwcm9jZXNzRmlyc3RDb29yZCwgc28gbGlzdGVuZXJzIGNhbiBjYW5jZWwuIHRoaXMgZ2V0cyBmaXJlZCBieSBhbG1vc3QgZXZlcnkgaGFuZGxlciA6KFxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVyZG93bicsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXR0ZXIudHJpZ2dlcignZHJhZ3N0YXJ0JywgZXYpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKGV2LCB0cnVlKTsgLy8gZm9yY2UgPSBmaXJlIGV2ZW4gaWYgaW5pdGlhbGx5IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnTW92ZSA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKGV2KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZUhpdHMoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdwb2ludGVydXAnLCBldik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubW92aW5nSGl0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2hpdHVwZGF0ZScsIG51bGwsIHRydWUsIGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmluYWxIaXQgPSB0aGlzLm1vdmluZ0hpdDtcbiAgICAgICAgICAgIHRoaXMubW92aW5nSGl0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnZW5kJywgZXYpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRyb3BwYWJsZVN0b3JlID0gZHJvcHBhYmxlU3RvcmU7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5oYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGRyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ21vdmUnLCB0aGlzLmhhbmRsZURyYWdNb3ZlKTtcbiAgICAgICAgZHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5oYW5kbGVQb2ludGVyVXApO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGRyYWdnaW5nO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgIH1cbiAgICAvLyBzZXRzIGluaXRpYWxIaXRcbiAgICAvLyBzZXRzIGNvb3JkQWRqdXN0XG4gICAgcHJvY2Vzc0ZpcnN0Q29vcmQoZXYpIHtcbiAgICAgICAgbGV0IG9yaWdQb2ludCA9IHsgbGVmdDogZXYucGFnZVgsIHRvcDogZXYucGFnZVkgfTtcbiAgICAgICAgbGV0IGFkanVzdGVkUG9pbnQgPSBvcmlnUG9pbnQ7XG4gICAgICAgIGxldCBzdWJqZWN0RWwgPSBldi5zdWJqZWN0RWw7XG4gICAgICAgIGxldCBzdWJqZWN0UmVjdDtcbiAgICAgICAgaWYgKHN1YmplY3RFbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7IC8vIGkuZS4gbm90IGEgRG9jdW1lbnQvU2hhZG93Um9vdFxuICAgICAgICAgICAgc3ViamVjdFJlY3QgPSBjb21wdXRlUmVjdChzdWJqZWN0RWwpO1xuICAgICAgICAgICAgYWRqdXN0ZWRQb2ludCA9IGNvbnN0cmFpblBvaW50KGFkanVzdGVkUG9pbnQsIHN1YmplY3RSZWN0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaW5pdGlhbEhpdCA9IHRoaXMucXVlcnlIaXRGb3JPZmZzZXQoYWRqdXN0ZWRQb2ludC5sZWZ0LCBhZGp1c3RlZFBvaW50LnRvcCk7XG4gICAgICAgIGlmIChpbml0aWFsSGl0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VTdWJqZWN0Q2VudGVyICYmIHN1YmplY3RSZWN0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHNsaWNlZFN1YmplY3RSZWN0ID0gaW50ZXJzZWN0UmVjdHMoc3ViamVjdFJlY3QsIGluaXRpYWxIaXQucmVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKHNsaWNlZFN1YmplY3RSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdGVkUG9pbnQgPSBnZXRSZWN0Q2VudGVyKHNsaWNlZFN1YmplY3RSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvb3JkQWRqdXN0ID0gZGlmZlBvaW50cyhhZGp1c3RlZFBvaW50LCBvcmlnUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IHsgbGVmdDogMCwgdG9wOiAwIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlTW92ZShldiwgZm9yY2VIYW5kbGUpIHtcbiAgICAgICAgbGV0IGhpdCA9IHRoaXMucXVlcnlIaXRGb3JPZmZzZXQoZXYucGFnZVggKyB0aGlzLmNvb3JkQWRqdXN0LmxlZnQsIGV2LnBhZ2VZICsgdGhpcy5jb29yZEFkanVzdC50b3ApO1xuICAgICAgICBpZiAoZm9yY2VIYW5kbGUgfHwgIWlzSGl0c0VxdWFsKHRoaXMubW92aW5nSGl0LCBoaXQpKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmluZ0hpdCA9IGhpdDtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdoaXR1cGRhdGUnLCBoaXQsIGZhbHNlLCBldik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlcGFyZUhpdHMoKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0VHJhY2tlcnMgPSBtYXBIYXNoKHRoaXMuZHJvcHBhYmxlU3RvcmUsIChpbnRlcmFjdGlvblNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvblNldHRpbmdzLmNvbXBvbmVudC5wcmVwYXJlSGl0cygpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRUcmFja2VyKGludGVyYWN0aW9uU2V0dGluZ3MuZWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVsZWFzZUhpdHMoKSB7XG4gICAgICAgIGxldCB7IG9mZnNldFRyYWNrZXJzIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpZCBpbiBvZmZzZXRUcmFja2Vycykge1xuICAgICAgICAgICAgb2Zmc2V0VHJhY2tlcnNbaWRdLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldFRyYWNrZXJzID0ge307XG4gICAgfVxuICAgIHF1ZXJ5SGl0Rm9yT2Zmc2V0KG9mZnNldExlZnQsIG9mZnNldFRvcCkge1xuICAgICAgICBsZXQgeyBkcm9wcGFibGVTdG9yZSwgb2Zmc2V0VHJhY2tlcnMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBiZXN0SGl0ID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaWQgaW4gZHJvcHBhYmxlU3RvcmUpIHtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnQgPSBkcm9wcGFibGVTdG9yZVtpZF0uY29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IG9mZnNldFRyYWNrZXIgPSBvZmZzZXRUcmFja2Vyc1tpZF07XG4gICAgICAgICAgICBpZiAob2Zmc2V0VHJhY2tlciAmJiAvLyB3YXNuJ3QgZGVzdHJveWVkIG1pZC1kcmFnXG4gICAgICAgICAgICAgICAgb2Zmc2V0VHJhY2tlci5pc1dpdGhpbkNsaXBwaW5nKG9mZnNldExlZnQsIG9mZnNldFRvcCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ2luTGVmdCA9IG9mZnNldFRyYWNrZXIuY29tcHV0ZUxlZnQoKTtcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ2luVG9wID0gb2Zmc2V0VHJhY2tlci5jb21wdXRlVG9wKCk7XG4gICAgICAgICAgICAgICAgbGV0IHBvc2l0aW9uTGVmdCA9IG9mZnNldExlZnQgLSBvcmlnaW5MZWZ0O1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGlvblRvcCA9IG9mZnNldFRvcCAtIG9yaWdpblRvcDtcbiAgICAgICAgICAgICAgICBsZXQgeyBvcmlnUmVjdCB9ID0gb2Zmc2V0VHJhY2tlcjtcbiAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSBvcmlnUmVjdC5yaWdodCAtIG9yaWdSZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodCA9IG9yaWdSZWN0LmJvdHRvbSAtIG9yaWdSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gbXVzdCBiZSB3aXRoaW4gdGhlIGVsZW1lbnQncyBib3VuZHNcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkxlZnQgPj0gMCAmJiBwb3NpdGlvbkxlZnQgPCB3aWR0aCAmJlxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRvcCA+PSAwICYmIHBvc2l0aW9uVG9wIDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoaXQgPSBjb21wb25lbnQucXVlcnlIaXQocG9zaXRpb25MZWZ0LCBwb3NpdGlvblRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoaXQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGhpdCBpcyB3aXRoaW4gYWN0aXZlUmFuZ2UsIG1lYW5pbmcgaXQncyBub3QgYSBkZWFkIGNlbGxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2VDb250YWluc1JhbmdlKGhpdC5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgaGl0LmRhdGVTcGFuLnJhbmdlKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgY29tcG9uZW50IHdlIGFyZSBxdWVyeWluZyBmb3IgdGhlIGhpdCBpcyBhY2Nlc3NpYmx5IG15IHRoZSBwb2ludGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50cyBvYnNjdXJlZCBjYWxlbmRhcnMgKGV4OiB1bmRlciBhIG1vZGFsIGRpYWxvZykgZnJvbSBhY2NlcHRpbmcgaGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNTAyNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZGlzYWJsZVBvaW50Q2hlY2sgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRUcmFja2VyLmVsLmNvbnRhaW5zKG9mZnNldFRyYWNrZXIuZWwuZ2V0Um9vdE5vZGUoKS5lbGVtZW50RnJvbVBvaW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZC1iYWNrIG9yaWdpbnMgdG8gZ2V0IGNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdG9wLWxlZnQgb2Ygd2luZG93IHZpZXdwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25MZWZ0ICsgb3JpZ2luTGVmdCAtIHdpbmRvdy5zY3JvbGxYLCBwb3NpdGlvblRvcCArIG9yaWdpblRvcCAtIHdpbmRvdy5zY3JvbGxZKSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWJlc3RIaXQgfHwgaGl0LmxheWVyID4gYmVzdEhpdC5sYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5jb21wb25lbnRJZCA9IGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LmNvbnRleHQgPSBjb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGJldHRlciB3YXkgdG8gcmUtb3JpZW50IHJlY3RhbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QubGVmdCArPSBvcmlnaW5MZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0LnJlY3QucmlnaHQgKz0gb3JpZ2luTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdC5yZWN0LnRvcCArPSBvcmlnaW5Ub3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQucmVjdC5ib3R0b20gKz0gb3JpZ2luVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEhpdCA9IGhpdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdEhpdDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0hpdHNFcXVhbChoaXQwLCBoaXQxKSB7XG4gICAgaWYgKCFoaXQwICYmICFoaXQxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQm9vbGVhbihoaXQwKSAhPT0gQm9vbGVhbihoaXQxKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0RhdGVTcGFuc0VxdWFsKGhpdDAuZGF0ZVNwYW4sIGhpdDEuZGF0ZVNwYW4pO1xufVxuXG5mdW5jdGlvbiBidWlsZERhdGVQb2ludEFwaVdpdGhDb250ZXh0KGRhdGVTcGFuLCBjb250ZXh0KSB7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgZm9yIChsZXQgdHJhbnNmb3JtIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVBvaW50VHJhbnNmb3Jtcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHByb3BzLCB0cmFuc2Zvcm0oZGF0ZVNwYW4sIGNvbnRleHQpKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihwcm9wcywgYnVpbGREYXRlUG9pbnRBcGkoZGF0ZVNwYW4sIGNvbnRleHQuZGF0ZUVudikpO1xuICAgIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGJ1aWxkRGF0ZVBvaW50QXBpKHNwYW4sIGRhdGVFbnYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlOiBkYXRlRW52LnRvRGF0ZShzcGFuLnJhbmdlLnN0YXJ0KSxcbiAgICAgICAgZGF0ZVN0cjogZGF0ZUVudi5mb3JtYXRJc28oc3Bhbi5yYW5nZS5zdGFydCwgeyBvbWl0VGltZTogc3Bhbi5hbGxEYXkgfSksXG4gICAgICAgIGFsbERheTogc3Bhbi5hbGxEYXksXG4gICAgfTtcbn1cblxuLypcbk1vbml0b3JzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGEgc3BlY2lmaWMgZGF0ZS90aW1lIG9mIGEgY29tcG9uZW50LlxuQSBwb2ludGVyZG93bitwb2ludGVydXAgb24gdGhlIHNhbWUgXCJoaXRcIiBjb25zdGl0dXRlcyBhIGNsaWNrLlxuKi9cbmNsYXNzIERhdGVDbGlja2luZyBleHRlbmRzIEludGVyYWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzZXR0aW5ncykge1xuICAgICAgICBzdXBlcihzZXR0aW5ncyk7XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlckRvd24gPSAocGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBkcmFnZ2luZyB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBkb3duRWwgPSBwZXYub3JpZ0V2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIC8vIGRvIHRoaXMgaW4gcG9pbnRlcmRvd24gKG5vdCBkcmFnZW5kKSBiZWNhdXNlIERPTSBtaWdodCBiZSBtdXRhdGVkIGJ5IHRoZSB0aW1lIGRyYWdlbmQgaXMgZmlyZWRcbiAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIXRoaXMuY29tcG9uZW50LmlzVmFsaWREYXRlRG93bkVsKGRvd25FbCkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyB3b24ndCBldmVuIGZpcmUgaWYgbW92aW5nIHdhcyBpZ25vcmVkXG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgcG9pbnRlciB9ID0gdGhpcy5kcmFnZ2luZztcbiAgICAgICAgICAgIGlmICghcG9pbnRlci53YXNUb3VjaFNjcm9sbCkge1xuICAgICAgICAgICAgICAgIGxldCB7IGluaXRpYWxIaXQsIGZpbmFsSGl0IH0gPSB0aGlzLmhpdERyYWdnaW5nO1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsSGl0ICYmIGZpbmFsSGl0ICYmIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGZpbmFsSGl0KSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhcmcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkRGF0ZVBvaW50QXBpV2l0aENvbnRleHQoaW5pdGlhbEhpdC5kYXRlU3BhbiwgY29udGV4dCkpLCB7IGRheUVsOiBpbml0aWFsSGl0LmRheUVsLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdkYXRlQ2xpY2snLCBhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gd2UgRE8gd2FudCB0byB3YXRjaCBwb2ludGVyIG1vdmVzIGJlY2F1c2Ugb3RoZXJ3aXNlIGZpbmFsSGl0IHdvbid0IGdldCBwb3B1bGF0ZWRcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKHNldHRpbmdzLmVsKTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZy5hdXRvU2Nyb2xsZXIuaXNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbn1cblxuLypcblRyYWNrcyB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYSBwb3J0aW9uIG9mIHRpbWUgb2YgYSBjb21wb25lbnQsXG5jb25zdGl0dXRlZCBieSBhIGRyYWcgb3ZlciBkYXRlIGNlbGxzLCB3aXRoIGEgcG9zc2libGUgZGVsYXkgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZHJhZy5cbiovXG5jbGFzcyBEYXRlU2VsZWN0aW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5kcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50LCBkcmFnZ2luZyB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgbGV0IGNhblNlbGVjdCA9IG9wdGlvbnMuc2VsZWN0YWJsZSAmJlxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc1ZhbGlkRGF0ZURvd25FbChldi5vcmlnRXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIC8vIGRvbid0IGJvdGhlciB0byB3YXRjaCBleHBlbnNpdmUgbW92ZXMgaWYgY29tcG9uZW50IHdvbid0IGRvIHNlbGVjdGlvblxuICAgICAgICAgICAgZHJhZ2dpbmcuc2V0SWdub3JlTW92ZSghY2FuU2VsZWN0KTtcbiAgICAgICAgICAgIC8vIGlmIHRvdWNoLCByZXF1aXJlIHVzZXIgdG8gaG9sZCBkb3duXG4gICAgICAgICAgICBkcmFnZ2luZy5kZWxheSA9IGV2LmlzVG91Y2ggPyBnZXRDb21wb25lbnRUb3VjaERlbGF5JDEoY29tcG9uZW50KSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0ID0gKGV2KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5jb250ZXh0LmNhbGVuZGFyQXBpLnVuc2VsZWN0KGV2KTsgLy8gdW5zZWxlY3QgcHJldmlvdXMgc2VsZWN0aW9uc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IChoaXQsIGlzRmluYWwpID0+IHtcbiAgICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAgICAgbGV0IGRyYWdTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgICAgICAgIGxldCBpbml0aWFsSGl0ID0gdGhpcy5oaXREcmFnZ2luZy5pbml0aWFsSGl0O1xuICAgICAgICAgICAgICAgIGxldCBkaXNhbGxvd2VkID0gaGl0LmNvbXBvbmVudElkID09PSBpbml0aWFsSGl0LmNvbXBvbmVudElkXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXMuaXNIaXRDb21ib0FsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgJiYgIXRoaXMuaXNIaXRDb21ib0FsbG93ZWQoaW5pdGlhbEhpdCwgaGl0KTtcbiAgICAgICAgICAgICAgICBpZiAoIWRpc2FsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1NlbGVjdGlvbiA9IGpvaW5IaXRzSW50b1NlbGVjdGlvbihpbml0aWFsSGl0LCBoaXQsIGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZHJhZ1NlbGVjdGlvbiB8fCAhaXNEYXRlU2VsZWN0aW9uVmFsaWQoZHJhZ1NlbGVjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkcmFnU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ1NlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0RBVEVTJywgc2VsZWN0aW9uOiBkcmFnU2VsZWN0aW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRmluYWwpIHsgLy8gb25seSB1bnNlbGVjdCBpZiBtb3ZlZCBhd2F5IHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9EQVRFUycgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnU2VsZWN0aW9uID0gZHJhZ1NlbGVjdGlvbjsgLy8gb25seSBjbGVhciBpZiBtb3ZlZCBhd2F5IGZyb20gYWxsIGhpdHMgd2hpbGUgZHJhZ2dpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSAocGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VsZWN0aW9uIGlzIGFscmVhZHkgcmVuZGVyZWQsIHNvIGp1c3QgbmVlZCB0byByZXBvcnQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgdHJpZ2dlckRhdGVTZWxlY3QodGhpcy5kcmFnU2VsZWN0aW9uLCBwZXYsIHRoaXMuY29tcG9uZW50LmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1NlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gc2V0dGluZ3M7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xuICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgZHJhZ2dpbmcubWluRGlzdGFuY2UgPSBvcHRpb25zLnNlbGVjdE1pbkRpc3RhbmNlIHx8IDA7XG4gICAgICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBvcHRpb25zLmRyYWdTY3JvbGw7XG4gICAgICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUoc2V0dGluZ3MpKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50VG91Y2hEZWxheSQxKGNvbXBvbmVudCkge1xuICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgIGxldCBkZWxheSA9IG9wdGlvbnMuc2VsZWN0TG9uZ1ByZXNzRGVsYXk7XG4gICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgZGVsYXkgPSBvcHRpb25zLmxvbmdQcmVzc0RlbGF5O1xuICAgIH1cbiAgICByZXR1cm4gZGVsYXk7XG59XG5mdW5jdGlvbiBqb2luSGl0c0ludG9TZWxlY3Rpb24oaGl0MCwgaGl0MSwgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycykge1xuICAgIGxldCBkYXRlU3BhbjAgPSBoaXQwLmRhdGVTcGFuO1xuICAgIGxldCBkYXRlU3BhbjEgPSBoaXQxLmRhdGVTcGFuO1xuICAgIGxldCBtcyA9IFtcbiAgICAgICAgZGF0ZVNwYW4wLnJhbmdlLnN0YXJ0LFxuICAgICAgICBkYXRlU3BhbjAucmFuZ2UuZW5kLFxuICAgICAgICBkYXRlU3BhbjEucmFuZ2Uuc3RhcnQsXG4gICAgICAgIGRhdGVTcGFuMS5yYW5nZS5lbmQsXG4gICAgXTtcbiAgICBtcy5zb3J0KGNvbXBhcmVOdW1iZXJzKTtcbiAgICBsZXQgcHJvcHMgPSB7fTtcbiAgICBmb3IgKGxldCB0cmFuc2Zvcm1lciBvZiBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzKSB7XG4gICAgICAgIGxldCByZXMgPSB0cmFuc2Zvcm1lcihoaXQwLCBoaXQxKTtcbiAgICAgICAgaWYgKHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocHJvcHMsIHJlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMucmFuZ2UgPSB7IHN0YXJ0OiBtc1swXSwgZW5kOiBtc1szXSB9O1xuICAgIHByb3BzLmFsbERheSA9IGRhdGVTcGFuMC5hbGxEYXk7XG4gICAgcmV0dXJuIHByb3BzO1xufVxuXG5jbGFzcyBFdmVudERyYWdnaW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgdGhpcy5zdWJqZWN0RWwgPSBudWxsO1xuICAgICAgICB0aGlzLnN1YmplY3RTZWcgPSBudWxsOyAvLyB0aGUgc2VnIGJlaW5nIHNlbGVjdGVkL2RyYWdnZWRcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlbnRSYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsOyAvLyB0aGUgZXZlbnRzIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJEb3duID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgb3JpZ1RhcmdldCA9IGV2Lm9yaWdFdmVudC50YXJnZXQ7XG4gICAgICAgICAgICBsZXQgeyBjb21wb25lbnQsIGRyYWdnaW5nIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgbWlycm9yIH0gPSBkcmFnZ2luZztcbiAgICAgICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICB0aGlzLnN1YmplY3RFbCA9IGV2LnN1YmplY3RFbDtcbiAgICAgICAgICAgIGxldCBzdWJqZWN0U2VnID0gdGhpcy5zdWJqZWN0U2VnID0gZ2V0RWxTZWcoZXYuc3ViamVjdEVsKTtcbiAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gdGhpcy5ldmVudFJhbmdlID0gc3ViamVjdFNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2VJZCA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhpbml0aWFsQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U3RvcmUsIGV2ZW50SW5zdGFuY2VJZCk7XG4gICAgICAgICAgICBkcmFnZ2luZy5taW5EaXN0YW5jZSA9IGV2LmlzVG91Y2ggPyAwIDogb3B0aW9ucy5ldmVudERyYWdNaW5EaXN0YW5jZTtcbiAgICAgICAgICAgIGRyYWdnaW5nLmRlbGF5ID1cbiAgICAgICAgICAgICAgICAvLyBvbmx5IGRvIGEgdG91Y2ggZGVsYXkgaWYgdG91Y2ggYW5kIHRoaXMgZXZlbnQgaGFzbid0IGJlZW4gc2VsZWN0ZWQgeWV0XG4gICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggJiYgZXZlbnRJbnN0YW5jZUlkICE9PSBjb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pID9cbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50VG91Y2hEZWxheShjb21wb25lbnQpIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpeGVkTWlycm9yUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgbWlycm9yLnBhcmVudE5vZGUgPSBvcHRpb25zLmZpeGVkTWlycm9yUGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWlycm9yLnBhcmVudE5vZGUgPSBlbGVtZW50Q2xvc2VzdChvcmlnVGFyZ2V0LCAnLmZjJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaXJyb3IucmV2ZXJ0RHVyYXRpb24gPSBvcHRpb25zLmRyYWdSZXZlcnREdXJhdGlvbjtcbiAgICAgICAgICAgIGxldCBpc1ZhbGlkID0gY29tcG9uZW50LmlzVmFsaWRTZWdEb3duRWwob3JpZ1RhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAhZWxlbWVudENsb3Nlc3Qob3JpZ1RhcmdldCwgJy5mYy1ldmVudC1yZXNpemVyJyk7IC8vIE5PVCBvbiBhIHJlc2l6ZXJcbiAgICAgICAgICAgIGRyYWdnaW5nLnNldElnbm9yZU1vdmUoIWlzVmFsaWQpO1xuICAgICAgICAgICAgLy8gZGlzYWJsZSBkcmFnZ2luZyBmb3IgZWxlbWVudHMgdGhhdCBhcmUgcmVzaXphYmxlIChpZSwgc2VsZWN0YWJsZSlcbiAgICAgICAgICAgIC8vIGJ1dCBhcmUgbm90IGRyYWdnYWJsZVxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gaXNWYWxpZCAmJlxuICAgICAgICAgICAgICAgIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50LWRyYWdnYWJsZScpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgIGxldCBldmVudFJhbmdlID0gdGhpcy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgbGV0IGV2ZW50SW5zdGFuY2VJZCA9IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZDtcbiAgICAgICAgICAgIGlmIChldi5pc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBzZWxlY3QgYSBkaWZmZXJlbnQgZXZlbnQ/XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50SW5zdGFuY2VJZCAhPT0gdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VMRUNUX0VWRU5UJywgZXZlbnRJbnN0YW5jZUlkIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vdyB1c2luZyBtb3VzZSwgYnV0IHdhcyBwcmV2aW91cyB0b3VjaCBpbnRlcmFjdGlvbiwgY2xlYXIgc2VsZWN0ZWQgZXZlbnRcbiAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFTEVDVF9FVkVOVCcgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoZXYpOyAvLyB1bnNlbGVjdCAqZGF0ZSogc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudERyYWdTdGFydCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChpbml0aWFsQ29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICBqc0V2ZW50OiBldi5vcmlnRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGluaXRpYWxDb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlSGl0VXBkYXRlID0gKGhpdCwgaXNGaW5hbCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVsZXZhbnRFdmVudHMgPSB0aGlzLnJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgbGV0IGluaXRpYWxIaXQgPSB0aGlzLmhpdERyYWdnaW5nLmluaXRpYWxIaXQ7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbENvbnRleHQgPSB0aGlzLmNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICAgICAgLy8gc3RhdGVzIGJhc2VkIG9uIG5ldyBoaXRcbiAgICAgICAgICAgIGxldCByZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBpc0ludmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEV2ZW50czogcmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IGhpdC5jb250ZXh0O1xuICAgICAgICAgICAgICAgIGxldCByZWNlaXZpbmdPcHRpb25zID0gcmVjZWl2aW5nQ29udGV4dC5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChpbml0aWFsQ29udGV4dCA9PT0gcmVjZWl2aW5nQ29udGV4dCB8fFxuICAgICAgICAgICAgICAgICAgICAocmVjZWl2aW5nT3B0aW9ucy5lZGl0YWJsZSAmJiByZWNlaXZpbmdPcHRpb25zLmRyb3BwYWJsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBjb21wdXRlRXZlbnRNdXRhdGlvbihpbml0aWFsSGl0LCBoaXQsIHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZS5yYW5nZS5zdGFydCwgcmVjZWl2aW5nQ29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnBsdWdpbkhvb2tzLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCByZWNlaXZpbmdDb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgcmVjZWl2aW5nQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0ludGVyYWN0aW9uVmFsaWQoaW50ZXJhY3Rpb24sIGhpdC5kYXRlUHJvZmlsZSwgcmVjZWl2aW5nQ29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5RHJhZyhyZWNlaXZpbmdDb250ZXh0LCBpbnRlcmFjdGlvbik7XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaXRpYWxDb250ZXh0ID09PSByZWNlaXZpbmdDb250ZXh0ICYmIC8vIFRPRE86IHdyaXRlIHRlc3QgZm9yIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgaXNIaXRzRXF1YWwoaW5pdGlhbEhpdCwgaGl0KSkge1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcuc2V0TWlycm9yTmVlZHNSZXZlcnQoIW11dGF0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyByZW5kZXIgdGhlIG1pcnJvciBpZiBubyBhbHJlYWR5LXJlbmRlcmVkIG1pcnJvclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgc29tZWhvdyB3YWl0IGZvciBkaXNwYXRjaCB0byBndWFyYW50ZWUgcmVuZGVyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5zZXRNaXJyb3JJc1Zpc2libGUoIWhpdCB8fCAhdGhpcy5zdWJqZWN0RWwuZ2V0Um9vdE5vZGUoKS5xdWVyeVNlbGVjdG9yKCcuZmMtZXZlbnQtbWlycm9yJykpO1xuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiBzdGF0ZXMgYmFzZWQgb24gbmV3IGhpdFxuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IHJlY2VpdmluZ0NvbnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZE11dGF0aW9uID0gbXV0YXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBtdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXAoKTsgLy8gYmVjYXVzZSBoYW5kbGVEcmFnRW5kIHdvbid0IGZpcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgICAgICAgICBsZXQgaW5pdGlhbFZpZXcgPSBpbml0aWFsQ29udGV4dC52aWV3QXBpO1xuICAgICAgICAgICAgICAgIGxldCB7IHJlY2VpdmluZ0NvbnRleHQsIHZhbGlkTXV0YXRpb24gfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50RGVmID0gdGhpcy5ldmVudFJhbmdlLmRlZjtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGluaXRpYWxDb250ZXh0LCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gdGhpcy5yZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgICAgICBsZXQgbXV0YXRlZFJlbGV2YW50RXZlbnRzID0gdGhpcy5tdXRhdGVkUmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICAgICAgbGV0IHsgZmluYWxIaXQgfSA9IHRoaXMuaGl0RHJhZ2dpbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckRyYWcoKTsgLy8gbXVzdCBoYXBwZW4gYWZ0ZXIgcmV2ZXJ0IGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnREcmFnU3RvcCcsIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHRoaXMuc3ViamVjdEVsLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgdmlldzogaW5pdGlhbFZpZXcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHJvcHBlZCB3aXRoaW4gc2FtZSBjYWxlbmRhclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWl2aW5nQ29udGV4dCA9PT0gaW5pdGlhbENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkRXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGluaXRpYWxDb250ZXh0LCBtdXRhdGVkUmVsZXZhbnRFdmVudHMuZGVmc1tldmVudERlZi5kZWZJZF0sIGV2ZW50SW5zdGFuY2UgPyBtdXRhdGVkUmVsZXZhbnRFdmVudHMuaW5zdGFuY2VzW2V2ZW50SW5zdGFuY2UuaW5zdGFuY2VJZF0gOiBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBtdXRhdGVkUmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudENoYW5nZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRFdmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHVwZGF0ZWRFdmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHMsIGluaXRpYWxDb250ZXh0LCBldmVudEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogcmVsZXZhbnRFdmVudHMsIC8vIHRoZSBwcmUtY2hhbmdlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJhbnNmb3JtZWQgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRyYW5zZm9ybWVyIG9mIGluaXRpYWxDb250ZXh0LmdldEN1cnJlbnREYXRhKCkucGx1Z2luSG9va3MuZXZlbnREcm9wVHJhbnNmb3JtZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0cmFuc2Zvcm1lZCwgdHJhbnNmb3JtZXIodmFsaWRNdXRhdGlvbiwgaW5pdGlhbENvbnRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxDb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZXZlbnREcm9wJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50Q2hhbmdlQXJnKSwgdHJhbnNmb3JtZWQpLCB7IGVsOiBldi5zdWJqZWN0RWwsIGRlbHRhOiB2YWxpZE11dGF0aW9uLmRhdGVzRGVsdGEsIGpzRXZlbnQ6IGV2Lm9yaWdFdmVudCwgdmlldzogaW5pdGlhbFZpZXcgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIGV2ZW50Q2hhbmdlQXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRyb3BwZWQgaW4gZGlmZmVyZW50IGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50UmVtb3ZlQXJnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudEFwaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhyZWxldmFudEV2ZW50cywgaW5pdGlhbENvbnRleHQsIGV2ZW50SW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50TGVhdmUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV2ZW50UmVtb3ZlQXJnKSwgeyBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCwgdmlldzogaW5pdGlhbFZpZXcgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbENvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlbW92ZScsIGV2ZW50UmVtb3ZlQXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRlZEV2ZW50RGVmID0gbXV0YXRlZFJlbGV2YW50RXZlbnRzLmRlZnNbZXZlbnREZWYuZGVmSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFkZGVkRXZlbnRJbnN0YW5jZSA9IG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhZGRlZEV2ZW50QXBpID0gbmV3IEV2ZW50SW1wbChyZWNlaXZpbmdDb250ZXh0LCBhZGRlZEV2ZW50RGVmLCBhZGRlZEV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ01FUkdFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRBZGRBcmcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGFkZGVkRXZlbnRBcGksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMobXV0YXRlZFJlbGV2YW50RXZlbnRzLCByZWNlaXZpbmdDb250ZXh0LCBhZGRlZEV2ZW50SW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVydCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBtdXRhdGVkUmVsZXZhbnRFdmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50QWRkJywgZXZlbnRBZGRBcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2LmlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFTEVDVF9FVkVOVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VJZDogZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2Ryb3AnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkRGF0ZVBvaW50QXBpV2l0aENvbnRleHQoZmluYWxIaXQuZGF0ZVNwYW4sIHJlY2VpdmluZ0NvbnRleHQpKSwgeyBkcmFnZ2VkRWw6IGV2LnN1YmplY3RFbCwganNFdmVudDogZXYub3JpZ0V2ZW50LCB2aWV3OiBmaW5hbEhpdC5jb250ZXh0LnZpZXdBcGkgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRBZGRBcmcpLCB7IGRyYWdnZWRFbDogZXYuc3ViamVjdEVsLCB2aWV3OiBmaW5hbEhpdC5jb250ZXh0LnZpZXdBcGkgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ19ub0V2ZW50RHJvcCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgeyBjb21wb25lbnQgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IG9wdGlvbnMgfSA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEZlYXR1cmVmdWxFbGVtZW50RHJhZ2dpbmcoc2V0dGluZ3MuZWwpO1xuICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gRXZlbnREcmFnZ2luZy5TRUxFQ1RPUjtcbiAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGRyYWdnaW5nLmF1dG9TY3JvbGxlci5pc0VuYWJsZWQgPSBvcHRpb25zLmRyYWdTY3JvbGw7XG4gICAgICAgIGxldCBoaXREcmFnZ2luZyA9IHRoaXMuaGl0RHJhZ2dpbmcgPSBuZXcgSGl0RHJhZ2dpbmcodGhpcy5kcmFnZ2luZywgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcudXNlU3ViamVjdENlbnRlciA9IHNldHRpbmdzLnVzZUV2ZW50Q2VudGVyO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIHRoaXMuaGFuZGxlSGl0VXBkYXRlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5oYW5kbGVQb2ludGVyVXApO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XG4gICAgfVxuICAgIC8vIHJlbmRlciBhIGRyYWcgc3RhdGUgb24gdGhlIG5leHQgcmVjZWl2aW5nQ2FsZW5kYXJcbiAgICBkaXNwbGF5RHJhZyhuZXh0Q29udGV4dCwgc3RhdGUpIHtcbiAgICAgICAgbGV0IGluaXRpYWxDb250ZXh0ID0gdGhpcy5jb21wb25lbnQuY29udGV4dDtcbiAgICAgICAgbGV0IHByZXZDb250ZXh0ID0gdGhpcy5yZWNlaXZpbmdDb250ZXh0O1xuICAgICAgICAvLyBkb2VzIHRoZSBwcmV2aW91cyBjYWxlbmRhciBuZWVkIHRvIGJlIGNsZWFyZWQ/XG4gICAgICAgIGlmIChwcmV2Q29udGV4dCAmJiBwcmV2Q29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIGRvZXMgdGhlIGluaXRpYWwgY2FsZW5kYXIgbmVlZCB0byBiZSBjbGVhcmVkP1xuICAgICAgICAgICAgLy8gaWYgc28sIGRvbid0IGNsZWFyIGFsbCB0aGUgd2F5LiB3ZSBzdGlsbCBuZWVkIHRvIHRvIGhpZGUgdGhlIGFmZmVjdGVkRXZlbnRzXG4gICAgICAgICAgICBpZiAocHJldkNvbnRleHQgPT09IGluaXRpYWxDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgcHJldkNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IHN0YXRlLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgY2xlYXIgdGhlIG9sZCBjYWxlbmRhciBpZiBpdCB3YXNuJ3QgdGhlIGluaXRpYWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgbmV4dENvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnU0VUX0VWRU5UX0RSQUcnLCBzdGF0ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhckRyYWcoKSB7XG4gICAgICAgIGxldCBpbml0aWFsQ2FsZW5kYXIgPSB0aGlzLmNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICBsZXQgeyByZWNlaXZpbmdDb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICBpZiAocmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdVTlNFVF9FVkVOVF9EUkFHJyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgaW5pdGlhbCBjYWxlbmRhciBtaWdodCBoYXZlIGFuIGR1bW15IGRyYWcgc3RhdGUgZnJvbSBkaXNwbGF5RHJhZ1xuICAgICAgICBpZiAoaW5pdGlhbENhbGVuZGFyICE9PSByZWNlaXZpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBpbml0aWFsQ2FsZW5kYXIuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0U2VnID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlbnRSYW5nZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLnJlY2VpdmluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgfVxufVxuLy8gVE9ETzogdGVzdCB0aGlzIGluIElFMTFcbi8vIFFVRVNUSU9OOiB3aHkgZG8gd2UgbmVlZCBpdCBvbiB0aGUgcmVzaXphYmxlPz8/XG5FdmVudERyYWdnaW5nLlNFTEVDVE9SID0gJy5mYy1ldmVudC1kcmFnZ2FibGUsIC5mYy1ldmVudC1yZXNpemFibGUnO1xuZnVuY3Rpb24gY29tcHV0ZUV2ZW50TXV0YXRpb24oaGl0MCwgaGl0MSwgZXZlbnRJbnN0YW5jZVN0YXJ0LCBtYXNzYWdlcnMpIHtcbiAgICBsZXQgZGF0ZVNwYW4wID0gaGl0MC5kYXRlU3BhbjtcbiAgICBsZXQgZGF0ZVNwYW4xID0gaGl0MS5kYXRlU3BhbjtcbiAgICBsZXQgZGF0ZTAgPSBkYXRlU3BhbjAucmFuZ2Uuc3RhcnQ7XG4gICAgbGV0IGRhdGUxID0gZGF0ZVNwYW4xLnJhbmdlLnN0YXJ0O1xuICAgIGxldCBzdGFuZGFyZFByb3BzID0ge307XG4gICAgaWYgKGRhdGVTcGFuMC5hbGxEYXkgIT09IGRhdGVTcGFuMS5hbGxEYXkpIHtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5hbGxEYXkgPSBkYXRlU3BhbjEuYWxsRGF5O1xuICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IGhpdDEuY29udGV4dC5vcHRpb25zLmFsbERheU1haW50YWluRHVyYXRpb247XG4gICAgICAgIGlmIChkYXRlU3BhbjEuYWxsRGF5KSB7XG4gICAgICAgICAgICAvLyBtZWFucyBkYXRlMSBpcyBhbHJlYWR5IHN0YXJ0LW9mLWRheSxcbiAgICAgICAgICAgIC8vIGJ1dCBkYXRlMCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICAgIGRhdGUwID0gc3RhcnRPZkRheShldmVudEluc3RhbmNlU3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTW92aW5nIGZyb20gYWxsRGF0ZS0+dGltZWRcbiAgICAgICAgICAgIC8vIERvZXNuJ3QgbWF0dGVyIHdoZXJlIG9uIHRoZSBldmVudCB0aGUgZHJhZyBiZWdhbiwgbXV0YXRlIHRoZSBldmVudCdzIHN0YXJ0LWRhdGUgdG8gZGF0ZTFcbiAgICAgICAgICAgIGRhdGUwID0gZXZlbnRJbnN0YW5jZVN0YXJ0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBkZWx0YSA9IGRpZmZEYXRlcyhkYXRlMCwgZGF0ZTEsIGhpdDAuY29udGV4dC5kYXRlRW52LCBoaXQwLmNvbXBvbmVudElkID09PSBoaXQxLmNvbXBvbmVudElkID9cbiAgICAgICAgaGl0MC5sYXJnZVVuaXQgOlxuICAgICAgICBudWxsKTtcbiAgICBpZiAoZGVsdGEubWlsbGlzZWNvbmRzKSB7IC8vIGhhcyBob3Vycy9taW51dGVzL3NlY29uZHNcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5hbGxEYXkgPSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG11dGF0aW9uID0ge1xuICAgICAgICBkYXRlc0RlbHRhOiBkZWx0YSxcbiAgICAgICAgc3RhbmRhcmRQcm9wcyxcbiAgICB9O1xuICAgIGZvciAobGV0IG1hc3NhZ2VyIG9mIG1hc3NhZ2Vycykge1xuICAgICAgICBtYXNzYWdlcihtdXRhdGlvbiwgaGl0MCwgaGl0MSk7XG4gICAgfVxuICAgIHJldHVybiBtdXRhdGlvbjtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudFRvdWNoRGVsYXkoY29tcG9uZW50KSB7XG4gICAgbGV0IHsgb3B0aW9ucyB9ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgbGV0IGRlbGF5ID0gb3B0aW9ucy5ldmVudExvbmdQcmVzc0RlbGF5O1xuICAgIGlmIChkZWxheSA9PSBudWxsKSB7XG4gICAgICAgIGRlbGF5ID0gb3B0aW9ucy5sb25nUHJlc3NEZWxheTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xufVxuXG5jbGFzcyBFdmVudFJlc2l6aW5nIGV4dGVuZHMgSW50ZXJhY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNldHRpbmdzKSB7XG4gICAgICAgIHN1cGVyKHNldHRpbmdzKTtcbiAgICAgICAgLy8gaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZ0VsID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZyA9IG51bGw7IC8vIFRPRE86IHJlbmFtZSB0byByZXNpemluZ1NlZz8gc3ViamVjdFNlZz9cbiAgICAgICAgdGhpcy5ldmVudFJhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsaWRNdXRhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubXV0YXRlZFJlbGV2YW50RXZlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29tcG9uZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHNlZ0VsID0gdGhpcy5xdWVyeVNlZ0VsKGV2KTtcbiAgICAgICAgICAgIGxldCBzZWcgPSBnZXRFbFNlZyhzZWdFbCk7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZSA9IHNlZy5ldmVudFJhbmdlO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5taW5EaXN0YW5jZSA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnMuZXZlbnREcmFnTWluRGlzdGFuY2U7XG4gICAgICAgICAgICAvLyBpZiB0b3VjaCwgbmVlZCB0byBiZSB3b3JraW5nIHdpdGggYSBzZWxlY3RlZCBldmVudFxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5zZXRJZ25vcmVNb3ZlKCF0aGlzLmNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2Lm9yaWdFdmVudC50YXJnZXQpIHx8XG4gICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggJiYgdGhpcy5jb21wb25lbnQucHJvcHMuZXZlbnRTZWxlY3Rpb24gIT09IGV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZCkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgY29udGV4dCB9ID0gdGhpcy5jb21wb25lbnQ7XG4gICAgICAgICAgICBsZXQgZXZlbnRSYW5nZSA9IHRoaXMuZXZlbnRSYW5nZTtcbiAgICAgICAgICAgIHRoaXMucmVsZXZhbnRFdmVudHMgPSBnZXRSZWxldmFudEV2ZW50cyhjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTdG9yZSwgdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQpO1xuICAgICAgICAgICAgbGV0IHNlZ0VsID0gdGhpcy5xdWVyeVNlZ0VsKGV2KTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZWdFbCA9IHNlZ0VsO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZ1NlZyA9IGdldEVsU2VnKHNlZ0VsKTtcbiAgICAgICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZVN0YXJ0Jywge1xuICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50SW1wbChjb250ZXh0LCBldmVudFJhbmdlLmRlZiwgZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IChoaXQsIGlzRmluYWwsIGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCByZWxldmFudEV2ZW50cyA9IHRoaXMucmVsZXZhbnRFdmVudHM7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbEhpdCA9IHRoaXMuaGl0RHJhZ2dpbmcuaW5pdGlhbEhpdDtcbiAgICAgICAgICAgIGxldCBldmVudEluc3RhbmNlID0gdGhpcy5ldmVudFJhbmdlLmluc3RhbmNlO1xuICAgICAgICAgICAgbGV0IG11dGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGlzSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiByZWxldmFudEV2ZW50cyxcbiAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKSxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzYWxsb3dlZCA9IGhpdC5jb21wb25lbnRJZCA9PT0gaW5pdGlhbEhpdC5jb21wb25lbnRJZFxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLmlzSGl0Q29tYm9BbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICYmICF0aGlzLmlzSGl0Q29tYm9BbGxvd2VkKGluaXRpYWxIaXQsIGhpdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0aW9uID0gY29tcHV0ZU11dGF0aW9uKGluaXRpYWxIaXQsIGhpdCwgZXYuc3ViamVjdEVsLmNsYXNzTGlzdC5jb250YWlucygnZmMtZXZlbnQtcmVzaXplci1zdGFydCcpLCBldmVudEluc3RhbmNlLnJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgICBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlKHJlbGV2YW50RXZlbnRzLCBjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRVaUJhc2VzLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgICAgICBpZiAoIWlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpc0ludmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIG11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdXRhdGVkUmVsZXZhbnRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1NFVF9FVkVOVF9SRVNJWkUnLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogaW50ZXJhY3Rpb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX1JFU0laRScgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGVuYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZUN1cnNvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0ZpbmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uICYmIGlzSGl0c0VxdWFsKGluaXRpYWxIaXQsIGhpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBtdXRhdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cyA9IG11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kID0gKGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIGxldCBldmVudERlZiA9IHRoaXMuZXZlbnRSYW5nZS5kZWY7XG4gICAgICAgICAgICBsZXQgZXZlbnRJbnN0YW5jZSA9IHRoaXMuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIGxldCBldmVudEFwaSA9IG5ldyBFdmVudEltcGwoY29udGV4dCwgZXZlbnREZWYsIGV2ZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgbGV0IHJlbGV2YW50RXZlbnRzID0gdGhpcy5yZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIGxldCBtdXRhdGVkUmVsZXZhbnRFdmVudHMgPSB0aGlzLm11dGF0ZWRSZWxldmFudEV2ZW50cztcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZVN0b3AnLCB7XG4gICAgICAgICAgICAgICAgZWw6IHRoaXMuZHJhZ2dpbmdTZWdFbCxcbiAgICAgICAgICAgICAgICBldmVudDogZXZlbnRBcGksXG4gICAgICAgICAgICAgICAganNFdmVudDogZXYub3JpZ0V2ZW50LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRNdXRhdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCB1cGRhdGVkRXZlbnRBcGkgPSBuZXcgRXZlbnRJbXBsKGNvbnRleHQsIG11dGF0ZWRSZWxldmFudEV2ZW50cy5kZWZzW2V2ZW50RGVmLmRlZklkXSwgZXZlbnRJbnN0YW5jZSA/IG11dGF0ZWRSZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbZXZlbnRJbnN0YW5jZS5pbnN0YW5jZUlkXSA6IG51bGwpO1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogbXV0YXRlZFJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCBldmVudENoYW5nZUFyZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgb2xkRXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogdXBkYXRlZEV2ZW50QXBpLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBidWlsZEV2ZW50QXBpcyhtdXRhdGVkUmVsZXZhbnRFdmVudHMsIGNvbnRleHQsIGV2ZW50SW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiByZWxldmFudEV2ZW50cywgLy8gdGhlIHByZS1jaGFuZ2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKCdldmVudFJlc2l6ZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXZlbnRDaGFuZ2VBcmcpLCB7IGVsOiB0aGlzLmRyYWdnaW5nU2VnRWwsIHN0YXJ0RGVsdGE6IHRoaXMudmFsaWRNdXRhdGlvbi5zdGFydERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLCBlbmREZWx0YTogdGhpcy52YWxpZE11dGF0aW9uLmVuZERlbHRhIHx8IGNyZWF0ZUR1cmF0aW9uKDApLCBqc0V2ZW50OiBldi5vcmlnRXZlbnQsIHZpZXc6IGNvbnRleHQudmlld0FwaSB9KSk7XG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2hhbmdlJywgZXZlbnRDaGFuZ2VBcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ19ub0V2ZW50UmVzaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXNldCBhbGwgaW50ZXJuYWwgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmdTZWcgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZWxldmFudEV2ZW50cyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZhbGlkTXV0YXRpb24gPSBudWxsO1xuICAgICAgICAgICAgLy8gb2theSB0byBrZWVwIGV2ZW50SW5zdGFuY2UgYXJvdW5kLiB1c2VmdWwgdG8gc2V0IGl0IGluIGhhbmRsZVBvaW50ZXJEb3duXG4gICAgICAgIH07XG4gICAgICAgIGxldCB7IGNvbXBvbmVudCB9ID0gc2V0dGluZ3M7XG4gICAgICAgIGxldCBkcmFnZ2luZyA9IHRoaXMuZHJhZ2dpbmcgPSBuZXcgRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyhzZXR0aW5ncy5lbCk7XG4gICAgICAgIGRyYWdnaW5nLnBvaW50ZXIuc2VsZWN0b3IgPSAnLmZjLWV2ZW50LXJlc2l6ZXInO1xuICAgICAgICBkcmFnZ2luZy50b3VjaFNjcm9sbEFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgZHJhZ2dpbmcuYXV0b1Njcm9sbGVyLmlzRW5hYmxlZCA9IGNvbXBvbmVudC5jb250ZXh0Lm9wdGlvbnMuZHJhZ1Njcm9sbDtcbiAgICAgICAgbGV0IGhpdERyYWdnaW5nID0gdGhpcy5oaXREcmFnZ2luZyA9IG5ldyBIaXREcmFnZ2luZyh0aGlzLmRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2hpdHVwZGF0ZScsIHRoaXMuaGFuZGxlSGl0VXBkYXRlKTtcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ2VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbiAgICBxdWVyeVNlZ0VsKGV2KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Q2xvc2VzdChldi5zdWJqZWN0RWwsICcuZmMtZXZlbnQnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlTXV0YXRpb24oaGl0MCwgaGl0MSwgaXNGcm9tU3RhcnQsIGluc3RhbmNlUmFuZ2UpIHtcbiAgICBsZXQgZGF0ZUVudiA9IGhpdDAuY29udGV4dC5kYXRlRW52O1xuICAgIGxldCBkYXRlMCA9IGhpdDAuZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgbGV0IGRhdGUxID0gaGl0MS5kYXRlU3Bhbi5yYW5nZS5zdGFydDtcbiAgICBsZXQgZGVsdGEgPSBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBoaXQwLmxhcmdlVW5pdCk7XG4gICAgaWYgKGlzRnJvbVN0YXJ0KSB7XG4gICAgICAgIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLnN0YXJ0LCBkZWx0YSkgPCBpbnN0YW5jZVJhbmdlLmVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnREZWx0YTogZGVsdGEgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChkYXRlRW52LmFkZChpbnN0YW5jZVJhbmdlLmVuZCwgZGVsdGEpID4gaW5zdGFuY2VSYW5nZS5zdGFydCkge1xuICAgICAgICByZXR1cm4geyBlbmREZWx0YTogZGVsdGEgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmNsYXNzIFVuc2VsZWN0QXV0byB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgPSBmYWxzZTsgLy8gd2lzaCB3ZSBjb3VsZCB1c2UgYSBzZWxlY3RvciB0byBkZXRlY3QgZGF0ZSBzZWxlY3Rpb24sIGJ1dCB1c2VzIGhpdCBzeXN0ZW1cbiAgICAgICAgdGhpcy5tYXRjaGVzQ2FuY2VsID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF0Y2hlc0V2ZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25TZWxlY3QgPSAoc2VsZWN0SW5mbykgPT4ge1xuICAgICAgICAgICAgaWYgKHNlbGVjdEluZm8uanNFdmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Eb2N1bWVudFBvaW50ZXJEb3duID0gKHBldikgPT4ge1xuICAgICAgICAgICAgbGV0IHVuc2VsZWN0Q2FuY2VsID0gdGhpcy5jb250ZXh0Lm9wdGlvbnMudW5zZWxlY3RDYW5jZWw7XG4gICAgICAgICAgICBsZXQgZG93bkVsID0gZ2V0RXZlbnRUYXJnZXRWaWFSb290KHBldi5vcmlnRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5tYXRjaGVzQ2FuY2VsID0gISFlbGVtZW50Q2xvc2VzdChkb3duRWwsIHVuc2VsZWN0Q2FuY2VsKTtcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlc0V2ZW50ID0gISFlbGVtZW50Q2xvc2VzdChkb3duRWwsIEV2ZW50RHJhZ2dpbmcuU0VMRUNUT1IpOyAvLyBpbnRlcmFjdGlvbiBzdGFydGVkIG9uIGFuIGV2ZW50P1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRG9jdW1lbnRQb2ludGVyVXAgPSAocGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBjb250ZXh0IH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHsgZG9jdW1lbnRQb2ludGVyIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IGNhbGVuZGFyU3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgICAgICAvLyB0b3VjaC1zY3JvbGxpbmcgc2hvdWxkIG5ldmVyIHVuZm9jdXMgYW55IHR5cGUgb2Ygc2VsZWN0aW9uXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50UG9pbnRlci53YXNUb3VjaFNjcm9sbCkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhclN0YXRlLmRhdGVTZWxlY3Rpb24gJiYgLy8gYW4gZXhpc3RpbmcgZGF0ZSBzZWxlY3Rpb24/XG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzUmVjZW50UG9pbnRlckRhdGVTZWxlY3QgLy8gYSBuZXcgcG9pbnRlci1pbml0aWF0ZWQgZGF0ZSBzZWxlY3Rpb24gc2luY2UgbGFzdCBvbkRvY3VtZW50UG9pbnRlclVwP1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdW5zZWxlY3RBdXRvID0gY29udGV4dC5vcHRpb25zLnVuc2VsZWN0QXV0bztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVuc2VsZWN0QXV0byAmJiAoIXVuc2VsZWN0QXV0byB8fCAhdGhpcy5tYXRjaGVzQ2FuY2VsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5jYWxlbmRhckFwaS51bnNlbGVjdChwZXYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhclN0YXRlLmV2ZW50U2VsZWN0aW9uICYmIC8vIGFuIGV4aXN0aW5nIGV2ZW50IHNlbGVjdGVkP1xuICAgICAgICAgICAgICAgICAgICAhdGhpcy5tYXRjaGVzRXZlbnQgLy8gaW50ZXJhY3Rpb24gRElETidUIHN0YXJ0IG9uIGFuIGV2ZW50XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRUxFQ1RfRVZFTlQnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNSZWNlbnRQb2ludGVyRGF0ZVNlbGVjdCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgZG9jdW1lbnRQb2ludGVyID0gdGhpcy5kb2N1bWVudFBvaW50ZXIgPSBuZXcgUG9pbnRlckRyYWdnaW5nKGRvY3VtZW50KTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLnNob3VsZElnbm9yZU1vdmUgPSB0cnVlO1xuICAgICAgICBkb2N1bWVudFBvaW50ZXIuc2hvdWxkV2F0Y2hTY3JvbGwgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnRQb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJkb3duJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlckRvd24pO1xuICAgICAgICBkb2N1bWVudFBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcnVwJywgdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwKTtcbiAgICAgICAgLypcbiAgICAgICAgVE9ETzogYmV0dGVyIHdheSB0byBrbm93IGFib3V0IHdoZXRoZXIgdGhlcmUgd2FzIGEgc2VsZWN0aW9uIHdpdGggdGhlIHBvaW50ZXJcbiAgICAgICAgKi9cbiAgICAgICAgY29udGV4dC5lbWl0dGVyLm9uKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmVtaXR0ZXIub2ZmKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KTtcbiAgICAgICAgdGhpcy5kb2N1bWVudFBvaW50ZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cblxuY29uc3QgT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGZpeGVkTWlycm9yUGFyZW50OiBpZGVudGl0eSxcbn07XG5jb25zdCBMSVNURU5FUl9SRUZJTkVSUyA9IHtcbiAgICBkYXRlQ2xpY2s6IGlkZW50aXR5LFxuICAgIGV2ZW50RHJhZ1N0YXJ0OiBpZGVudGl0eSxcbiAgICBldmVudERyYWdTdG9wOiBpZGVudGl0eSxcbiAgICBldmVudERyb3A6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVzaXplU3RhcnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVzaXplU3RvcDogaWRlbnRpdHksXG4gICAgZXZlbnRSZXNpemU6IGlkZW50aXR5LFxuICAgIGRyb3A6IGlkZW50aXR5LFxuICAgIGV2ZW50UmVjZWl2ZTogaWRlbnRpdHksXG4gICAgZXZlbnRMZWF2ZTogaWRlbnRpdHksXG59O1xuXG4vKlxuR2l2ZW4gYW4gYWxyZWFkeSBpbnN0YW50aWF0ZWQgZHJhZ2dhYmxlIG9iamVjdCBmb3Igb25lLW9yLW1vcmUgZWxlbWVudHMsXG5JbnRlcnByZXRzIGFueSBkcmFnZ2luZyBhcyBhbiBhdHRlbXB0IHRvIGRyYWcgYW4gZXZlbnRzIHRoYXQgbGl2ZXMgb3V0c2lkZVxub2YgYSBjYWxlbmRhciBvbnRvIGEgY2FsZW5kYXIuXG4qL1xuY2xhc3MgRXh0ZXJuYWxFbGVtZW50RHJhZ2dpbmcge1xuICAgIGNvbnN0cnVjdG9yKGRyYWdnaW5nLCBzdXBwbGllZERyYWdNZXRhKSB7XG4gICAgICAgIHRoaXMucmVjZWl2aW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJvcHBhYmxlRXZlbnQgPSBudWxsOyAvLyB3aWxsIGV4aXN0IGZvciBhbGwgZHJhZ3MsIGV2ZW4gaWYgY3JlYXRlOmZhbHNlXG4gICAgICAgIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJhZ01ldGEgPSBudWxsO1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydCA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmFnTWV0YSA9IHRoaXMuYnVpbGREcmFnTWV0YShldi5zdWJqZWN0RWwpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUhpdFVwZGF0ZSA9IChoaXQsIGlzRmluYWwsIGV2KSA9PiB7XG4gICAgICAgICAgICBsZXQgeyBkcmFnZ2luZyB9ID0gdGhpcy5oaXREcmFnZ2luZztcbiAgICAgICAgICAgIGxldCByZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBkcm9wcGFibGVFdmVudCA9IG51bGw7XG4gICAgICAgICAgICBsZXQgaXNJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpLFxuICAgICAgICAgICAgICAgIGlzRXZlbnQ6IHRoaXMuZHJhZ01ldGEuY3JlYXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0ID0gaGl0LmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FuRHJvcEVsT25DYWxlbmRhcihldi5zdWJqZWN0RWwsIHJlY2VpdmluZ0NvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3BwYWJsZUV2ZW50ID0gY29tcHV0ZUV2ZW50Rm9yRGF0ZVNwYW4oaGl0LmRhdGVTcGFuLCB0aGlzLmRyYWdNZXRhLCByZWNlaXZpbmdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IGV2ZW50VHVwbGVUb1N0b3JlKGRyb3BwYWJsZUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaXNJbnZhbGlkID0gIWlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgaGl0LmRhdGVQcm9maWxlLCByZWNlaXZpbmdDb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cyA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcHBhYmxlRXZlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5RHJhZyhyZWNlaXZpbmdDb250ZXh0LCBpbnRlcmFjdGlvbik7XG4gICAgICAgICAgICAvLyBzaG93IG1pcnJvciBpZiBubyBhbHJlYWR5LXJlbmRlcmVkIG1pcnJvciBlbGVtZW50IE9SIGlmIHdlIGFyZSBzaHV0dGluZyBkb3duIHRoZSBtaXJyb3IgKD8pXG4gICAgICAgICAgICAvLyBUT0RPOiB3aXNoIHdlIGNvdWxkIHNvbWVob3cgd2FpdCBmb3IgZGlzcGF0Y2ggdG8gZ3VhcmFudGVlIHJlbmRlclxuICAgICAgICAgICAgZHJhZ2dpbmcuc2V0TWlycm9ySXNWaXNpYmxlKGlzRmluYWwgfHwgIWRyb3BwYWJsZUV2ZW50IHx8ICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZmMtZXZlbnQtbWlycm9yJykpO1xuICAgICAgICAgICAgaWYgKCFpc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBlbmFibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc2FibGVDdXJzb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNGaW5hbCkge1xuICAgICAgICAgICAgICAgIGRyYWdnaW5nLnNldE1pcnJvck5lZWRzUmV2ZXJ0KCFkcm9wcGFibGVFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gcmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BwYWJsZUV2ZW50ID0gZHJvcHBhYmxlRXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCA9IChwZXYpID0+IHtcbiAgICAgICAgICAgIGxldCB7IHJlY2VpdmluZ0NvbnRleHQsIGRyb3BwYWJsZUV2ZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jbGVhckRyYWcoKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZpbmdDb250ZXh0ICYmIGRyb3BwYWJsZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbmFsSGl0ID0gdGhpcy5oaXREcmFnZ2luZy5maW5hbEhpdDtcbiAgICAgICAgICAgICAgICBsZXQgZmluYWxWaWV3ID0gZmluYWxIaXQuY29udGV4dC52aWV3QXBpO1xuICAgICAgICAgICAgICAgIGxldCBkcmFnTWV0YSA9IHRoaXMuZHJhZ01ldGE7XG4gICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2Ryb3AnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkRGF0ZVBvaW50QXBpV2l0aENvbnRleHQoZmluYWxIaXQuZGF0ZVNwYW4sIHJlY2VpdmluZ0NvbnRleHQpKSwgeyBkcmFnZ2VkRWw6IHBldi5zdWJqZWN0RWwsIGpzRXZlbnQ6IHBldi5vcmlnRXZlbnQsIHZpZXc6IGZpbmFsVmlldyB9KSk7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdNZXRhLmNyZWF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkaW5nRXZlbnRzID0gZXZlbnRUdXBsZVRvU3RvcmUoZHJvcHBhYmxlRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYWRkaW5nRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBldi5pc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VMRUNUX0VWRU5UJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlSWQ6IGRyb3BwYWJsZUV2ZW50Lmluc3RhbmNlLmluc3RhbmNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBzaWduYWwgdGhhdCBhbiBleHRlcm5hbCBldmVudCBsYW5kZWRcbiAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVjZWl2ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRJbXBsKHJlY2VpdmluZ0NvbnRleHQsIGRyb3BwYWJsZUV2ZW50LmRlZiwgZHJvcHBhYmxlRXZlbnQuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2aW5nQ29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYWRkaW5nRXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnZWRFbDogcGV2LnN1YmplY3RFbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXc6IGZpbmFsVmlldyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZHJvcHBhYmxlRXZlbnQgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgaGl0RHJhZ2dpbmcgPSB0aGlzLmhpdERyYWdnaW5nID0gbmV3IEhpdERyYWdnaW5nKGRyYWdnaW5nLCBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUpO1xuICAgICAgICBoaXREcmFnZ2luZy5yZXF1aXJlSW5pdGlhbCA9IGZhbHNlOyAvLyB3aWxsIHN0YXJ0IG91dHNpZGUgb2YgYSBjb21wb25lbnRcbiAgICAgICAgaGl0RHJhZ2dpbmcuZW1pdHRlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5oYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBoaXREcmFnZ2luZy5lbWl0dGVyLm9uKCdoaXR1cGRhdGUnLCB0aGlzLmhhbmRsZUhpdFVwZGF0ZSk7XG4gICAgICAgIGhpdERyYWdnaW5nLmVtaXR0ZXIub24oJ2RyYWdlbmQnLCB0aGlzLmhhbmRsZURyYWdFbmQpO1xuICAgICAgICB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPSBzdXBwbGllZERyYWdNZXRhO1xuICAgIH1cbiAgICBidWlsZERyYWdNZXRhKHN1YmplY3RFbCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc3VwcGxpZWREcmFnTWV0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZURyYWdNZXRhKHRoaXMuc3VwcGxpZWREcmFnTWV0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnN1cHBsaWVkRHJhZ01ldGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZURyYWdNZXRhKHRoaXMuc3VwcGxpZWREcmFnTWV0YShzdWJqZWN0RWwpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0RHJhZ01ldGFGcm9tRWwoc3ViamVjdEVsKTtcbiAgICB9XG4gICAgZGlzcGxheURyYWcobmV4dENvbnRleHQsIHN0YXRlKSB7XG4gICAgICAgIGxldCBwcmV2Q29udGV4dCA9IHRoaXMucmVjZWl2aW5nQ29udGV4dDtcbiAgICAgICAgaWYgKHByZXZDb250ZXh0ICYmIHByZXZDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgICAgICAgICAgcHJldkNvbnRleHQuZGlzcGF0Y2goeyB0eXBlOiAnVU5TRVRfRVZFTlRfRFJBRycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICBuZXh0Q29udGV4dC5kaXNwYXRjaCh7IHR5cGU6ICdTRVRfRVZFTlRfRFJBRycsIHN0YXRlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyRHJhZygpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjZWl2aW5nQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZpbmdDb250ZXh0LmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VUX0VWRU5UX0RSQUcnIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbkRyb3BFbE9uQ2FsZW5kYXIoZWwsIHJlY2VpdmluZ0NvbnRleHQpIHtcbiAgICAgICAgbGV0IGRyb3BBY2NlcHQgPSByZWNlaXZpbmdDb250ZXh0Lm9wdGlvbnMuZHJvcEFjY2VwdDtcbiAgICAgICAgaWYgKHR5cGVvZiBkcm9wQWNjZXB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJvcEFjY2VwdC5jYWxsKHJlY2VpdmluZ0NvbnRleHQuY2FsZW5kYXJBcGksIGVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRyb3BBY2NlcHQgPT09ICdzdHJpbmcnICYmIGRyb3BBY2NlcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGVsZW1lbnRNYXRjaGVzKGVsLCBkcm9wQWNjZXB0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuLy8gVXRpbHMgZm9yIGNvbXB1dGluZyBldmVudCBzdG9yZSBmcm9tIHRoZSBEcmFnTWV0YVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY29tcHV0ZUV2ZW50Rm9yRGF0ZVNwYW4oZGF0ZVNwYW4sIGRyYWdNZXRhLCBjb250ZXh0KSB7XG4gICAgbGV0IGRlZlByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgZHJhZ01ldGEubGVmdG92ZXJQcm9wcyk7XG4gICAgZm9yIChsZXQgdHJhbnNmb3JtIG9mIGNvbnRleHQucGx1Z2luSG9va3MuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oZGVmUHJvcHMsIHRyYW5zZm9ybShkYXRlU3BhbiwgZHJhZ01ldGEpKTtcbiAgICB9XG4gICAgbGV0IHsgcmVmaW5lZCwgZXh0cmEgfSA9IHJlZmluZUV2ZW50RGVmKGRlZlByb3BzLCBjb250ZXh0KTtcbiAgICBsZXQgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZHJhZ01ldGEuc291cmNlSWQsIGRhdGVTcGFuLmFsbERheSwgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbiB8fCBCb29sZWFuKGRyYWdNZXRhLmR1cmF0aW9uKSwgLy8gaGFzRW5kXG4gICAgY29udGV4dCk7XG4gICAgbGV0IHN0YXJ0ID0gZGF0ZVNwYW4ucmFuZ2Uuc3RhcnQ7XG4gICAgLy8gb25seSByZWx5IG9uIHRpbWUgaW5mbyBpZiBkcm9wIHpvbmUgaXMgYWxsLWRheSxcbiAgICAvLyBvdGhlcndpc2UsIHdlIGFscmVhZHkga25vdyB0aGUgdGltZVxuICAgIGlmIChkYXRlU3Bhbi5hbGxEYXkgJiYgZHJhZ01ldGEuc3RhcnRUaW1lKSB7XG4gICAgICAgIHN0YXJ0ID0gY29udGV4dC5kYXRlRW52LmFkZChzdGFydCwgZHJhZ01ldGEuc3RhcnRUaW1lKTtcbiAgICB9XG4gICAgbGV0IGVuZCA9IGRyYWdNZXRhLmR1cmF0aW9uID9cbiAgICAgICAgY29udGV4dC5kYXRlRW52LmFkZChzdGFydCwgZHJhZ01ldGEuZHVyYXRpb24pIDpcbiAgICAgICAgZ2V0RGVmYXVsdEV2ZW50RW5kKGRhdGVTcGFuLmFsbERheSwgc3RhcnQsIGNvbnRleHQpO1xuICAgIGxldCBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCB7IHN0YXJ0LCBlbmQgfSk7XG4gICAgcmV0dXJuIHsgZGVmLCBpbnN0YW5jZSB9O1xufVxuLy8gVXRpbHMgZm9yIGV4dHJhY3RpbmcgZGF0YSBmcm9tIGVsZW1lbnRcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGdldERyYWdNZXRhRnJvbUVsKGVsKSB7XG4gICAgbGV0IHN0ciA9IGdldEVtYmVkZGVkRWxEYXRhKGVsLCAnZXZlbnQnKTtcbiAgICBsZXQgb2JqID0gc3RyID9cbiAgICAgICAgSlNPTi5wYXJzZShzdHIpIDpcbiAgICAgICAgeyBjcmVhdGU6IGZhbHNlIH07IC8vIGlmIG5vIGVtYmVkZGVkIGRhdGEsIGFzc3VtZSBubyBldmVudCBjcmVhdGlvblxuICAgIHJldHVybiBwYXJzZURyYWdNZXRhKG9iaik7XG59XG5jb25maWcuZGF0YUF0dHJQcmVmaXggPSAnJztcbmZ1bmN0aW9uIGdldEVtYmVkZGVkRWxEYXRhKGVsLCBuYW1lKSB7XG4gICAgbGV0IHByZWZpeCA9IGNvbmZpZy5kYXRhQXR0clByZWZpeDtcbiAgICBsZXQgcHJlZml4ZWROYW1lID0gKHByZWZpeCA/IHByZWZpeCArICctJyA6ICcnKSArIG5hbWU7XG4gICAgcmV0dXJuIGVsLmdldEF0dHJpYnV0ZSgnZGF0YS0nICsgcHJlZml4ZWROYW1lKSB8fCAnJztcbn1cblxuLypcbk1ha2VzIGFuIGVsZW1lbnQgKHRoYXQgaXMgKmV4dGVybmFsKiB0byBhbnkgY2FsZW5kYXIpIGRyYWdnYWJsZS5cbkNhbiBwYXNzIGluIGRhdGEgdGhhdCBkZXRlcm1pbmVzIGhvdyBhbiBldmVudCB3aWxsIGJlIGNyZWF0ZWQgd2hlbiBkcm9wcGVkIG9udG8gYSBjYWxlbmRhci5cbkxldmVyYWdlcyBGdWxsQ2FsZW5kYXIncyBpbnRlcm5hbCBkcmFnLW4tZHJvcCBmdW5jdGlvbmFsaXR5IFdJVEhPVVQgYSB0aGlyZC1wYXJ0eSBkcmFnIHN5c3RlbS5cbiovXG5jbGFzcyBFeHRlcm5hbERyYWdnYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZWwsIHNldHRpbmdzID0ge30pIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgbGV0IHsgZHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgeyBtaW5EaXN0YW5jZSwgbG9uZ1ByZXNzRGVsYXkgfSA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICAgICAgICBkcmFnZ2luZy5taW5EaXN0YW5jZSA9XG4gICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlIDpcbiAgICAgICAgICAgICAgICAgICAgKGV2LmlzVG91Y2ggPyAwIDogQkFTRV9PUFRJT05fREVGQVVMVFMuZXZlbnREcmFnTWluRGlzdGFuY2UpO1xuICAgICAgICAgICAgZHJhZ2dpbmcuZGVsYXkgPVxuICAgICAgICAgICAgICAgIGV2LmlzVG91Y2ggPyAvLyBUT0RPOiBldmVudHVhbGx5IHJlYWQgZXZlbnRMb25nUHJlc3NEZWxheSBpbnN0ZWFkIHZ2dlxuICAgICAgICAgICAgICAgICAgICAobG9uZ1ByZXNzRGVsYXkgIT0gbnVsbCA/IGxvbmdQcmVzc0RlbGF5IDogQkFTRV9PUFRJT05fREVGQVVMVFMubG9uZ1ByZXNzRGVsYXkpIDpcbiAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmIChldi5pc1RvdWNoICYmXG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnZ2luZy5kZWxheSAmJlxuICAgICAgICAgICAgICAgIGV2LnN1YmplY3RFbC5jbGFzc0xpc3QuY29udGFpbnMoJ2ZjLWV2ZW50JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdnaW5nLm1pcnJvci5nZXRNaXJyb3JFbCgpLmNsYXNzTGlzdC5hZGQoJ2ZjLWV2ZW50LXNlbGVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgbGV0IGRyYWdnaW5nID0gdGhpcy5kcmFnZ2luZyA9IG5ldyBGZWF0dXJlZnVsRWxlbWVudERyYWdnaW5nKGVsKTtcbiAgICAgICAgZHJhZ2dpbmcudG91Y2hTY3JvbGxBbGxvd2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChzZXR0aW5ncy5pdGVtU2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9IHNldHRpbmdzLml0ZW1TZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuYXBwZW5kVG8gIT0gbnVsbCkge1xuICAgICAgICAgICAgZHJhZ2dpbmcubWlycm9yLnBhcmVudE5vZGUgPSBzZXR0aW5ncy5hcHBlbmRUbzsgLy8gVE9ETzogd3JpdGUgdGVzdHNcbiAgICAgICAgfVxuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdwb2ludGVyZG93bicsIHRoaXMuaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgICBkcmFnZ2luZy5lbWl0dGVyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgIG5ldyBFeHRlcm5hbEVsZW1lbnREcmFnZ2luZyhkcmFnZ2luZywgc2V0dGluZ3MuZXZlbnREYXRhKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZy5kZXN0cm95KCk7XG4gICAgfVxufVxuXG4vKlxuRGV0ZWN0cyB3aGVuIGEgKlRISVJELVBBUlRZKiBkcmFnLW4tZHJvcCBzeXN0ZW0gaW50ZXJhY3RzIHdpdGggZWxlbWVudHMuXG5UaGUgdGhpcmQtcGFydHkgc3lzdGVtIGlzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nIHRoZSB2aXN1YWxzIGVmZmVjdHMgb2YgdGhlIGRyYWcuXG5UaGlzIGNsYXNzIHNpbXBseSBtb25pdG9ycyBmb3IgcG9pbnRlciBtb3ZlbWVudHMgYW5kIGZpcmVzIGV2ZW50cy5cbkl0IGFsc28gaGFzIHRoZSBhYmlsaXR5IHRvIGhpZGUgdGhlIG1vdmluZyBlbGVtZW50ICh0aGUgXCJtaXJyb3JcIikgZHVyaW5nIHRoZSBkcmFnLlxuKi9cbmNsYXNzIEluZmVycmVkRWxlbWVudERyYWdnaW5nIGV4dGVuZHMgRWxlbWVudERyYWdnaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJFbCkge1xuICAgICAgICBzdXBlcihjb250YWluZXJFbCk7XG4gICAgICAgIHRoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1pcnJvclNlbGVjdG9yID0gJyc7XG4gICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyRG93biA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJkb3duJywgZXYpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZElnbm9yZU1vdmUpIHtcbiAgICAgICAgICAgICAgICAvLyBmaXJlIGRyYWdzdGFydCByaWdodCBhd2F5LiBkb2VzIG5vdCBzdXBwb3J0IGRlbGF5IG9yIG1pbi1kaXN0YW5jZVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdkcmFnc3RhcnQnLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUgPSAoZXYpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdtb3ZlJywgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IChldikgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ3BvaW50ZXJ1cCcsIGV2KTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3ZlKSB7XG4gICAgICAgICAgICAgICAgLy8gZmlyZSBkcmFnZW5kIHJpZ2h0IGF3YXkuIGRvZXMgbm90IHN1cHBvcnQgYSByZXZlcnQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLnRyaWdnZXIoJ2RyYWdlbmQnLCBldik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBwb2ludGVyID0gdGhpcy5wb2ludGVyID0gbmV3IFBvaW50ZXJEcmFnZ2luZyhjb250YWluZXJFbCk7XG4gICAgICAgIHBvaW50ZXIuZW1pdHRlci5vbigncG9pbnRlcmRvd24nLCB0aGlzLmhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICAgICAgcG9pbnRlci5lbWl0dGVyLm9uKCdwb2ludGVybW92ZScsIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUpO1xuICAgICAgICBwb2ludGVyLmVtaXR0ZXIub24oJ3BvaW50ZXJ1cCcsIHRoaXMuaGFuZGxlUG9pbnRlclVwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5wb2ludGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc2V0SWdub3JlTW92ZShib29sKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkSWdub3JlTW92ZSA9IGJvb2w7XG4gICAgfVxuICAgIHNldE1pcnJvcklzVmlzaWJsZShib29sKSB7XG4gICAgICAgIGlmIChib29sKSB7XG4gICAgICAgICAgICAvLyByZXN0b3JlIGEgcHJldmlvdXNseSBoaWRkZW4gZWxlbWVudC5cbiAgICAgICAgICAgIC8vIHVzZSB0aGUgcmVmZXJlbmNlIGluIGNhc2UgdGhlIHNlbGVjdG9yIGNsYXNzIGhhcyBhbHJlYWR5IGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNaXJyb3JFbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnJztcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWlycm9yRWwgPSB0aGlzLm1pcnJvclNlbGVjdG9yXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc29tZWhvdyBxdWVyeSBGdWxsQ2FsZW5kYXJzIFdJVEhJTiBzaGFkb3ctcm9vdHNcbiAgICAgICAgICAgICAgICA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5taXJyb3JTZWxlY3RvcilcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAobWlycm9yRWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNaXJyb3JFbCA9IG1pcnJvckVsO1xuICAgICAgICAgICAgICAgIG1pcnJvckVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLypcbkJyaWRnZXMgdGhpcmQtcGFydHkgZHJhZy1uLWRyb3Agc3lzdGVtcyB3aXRoIEZ1bGxDYWxlbmRhci5cbk11c3QgYmUgaW5zdGFudGlhdGVkIGFuZCBkZXN0cm95ZWQgYnkgY2FsbGVyLlxuKi9cbmNsYXNzIFRoaXJkUGFydHlEcmFnZ2FibGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lck9yU2V0dGluZ3MsIHNldHRpbmdzKSB7XG4gICAgICAgIGxldCBjb250YWluZXJFbCA9IGRvY3VtZW50O1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIHdpc2ggd2UgY291bGQganVzdCB0ZXN0IGluc3RhbmNlb2YgRXZlbnRUYXJnZXQsIGJ1dCBkb2Vzbid0IHdvcmsgaW4gSUUxMVxuICAgICAgICBjb250YWluZXJPclNldHRpbmdzID09PSBkb2N1bWVudCB8fFxuICAgICAgICAgICAgY29udGFpbmVyT3JTZXR0aW5ncyBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lckVsID0gY29udGFpbmVyT3JTZXR0aW5ncztcbiAgICAgICAgICAgIHNldHRpbmdzID0gc2V0dGluZ3MgfHwge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXR0aW5ncyA9IChjb250YWluZXJPclNldHRpbmdzIHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZHJhZ2dpbmcgPSB0aGlzLmRyYWdnaW5nID0gbmV3IEluZmVycmVkRWxlbWVudERyYWdnaW5nKGNvbnRhaW5lckVsKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5pdGVtU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkcmFnZ2luZy5wb2ludGVyLnNlbGVjdG9yID0gc2V0dGluZ3MuaXRlbVNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRhaW5lckVsID09PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgZHJhZ2dpbmcucG9pbnRlci5zZWxlY3RvciA9ICdbZGF0YS1ldmVudF0nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MubWlycm9yU2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkcmFnZ2luZy5taXJyb3JTZWxlY3RvciA9IHNldHRpbmdzLm1pcnJvclNlbGVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGxldCBleHRlcm5hbERyYWdnaW5nID0gbmV3IEV4dGVybmFsRWxlbWVudERyYWdnaW5nKGRyYWdnaW5nLCBzZXR0aW5ncy5ldmVudERhdGEpO1xuICAgICAgICAvLyBUaGUgaGl0LWRldGVjdGlvbiBzeXN0ZW0gcmVxdWlyZXMgdGhhdCB0aGUgZG5kLW1pcnJvci1lbGVtZW50IGJlIHBvaW50ZXItZXZlbnRzOm5vbmUsXG4gICAgICAgIC8vIGJ1dCB0aGlzIGNhbid0IGJlIGd1YXJhbnRlZWQgZm9yIHRoaXJkLXBhcnR5IGRyYWdnYWJsZXMsIHNvIGRpc2FibGVcbiAgICAgICAgZXh0ZXJuYWxEcmFnZ2luZy5oaXREcmFnZ2luZy5kaXNhYmxlUG9pbnRDaGVjayA9IHRydWU7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcuZGVzdHJveSgpO1xuICAgIH1cbn1cblxudmFyIGluZGV4ID0gY3JlYXRlUGx1Z2luKHtcbiAgICBuYW1lOiAnQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvbicsXG4gICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBbRGF0ZUNsaWNraW5nLCBEYXRlU2VsZWN0aW5nLCBFdmVudERyYWdnaW5nLCBFdmVudFJlc2l6aW5nXSxcbiAgICBjYWxlbmRhckludGVyYWN0aW9uczogW1Vuc2VsZWN0QXV0b10sXG4gICAgZWxlbWVudERyYWdnaW5nSW1wbDogRmVhdHVyZWZ1bEVsZW1lbnREcmFnZ2luZyxcbiAgICBvcHRpb25SZWZpbmVyczogT1BUSU9OX1JFRklORVJTLFxuICAgIGxpc3RlbmVyUmVmaW5lcnM6IExJU1RFTkVSX1JFRklORVJTLFxufSk7XG5cbmV4cG9ydCB7IEV4dGVybmFsRHJhZ2dhYmxlIGFzIERyYWdnYWJsZSwgVGhpcmRQYXJ0eURyYWdnYWJsZSwgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IEpzb25SZXF1ZXN0RXJyb3IsIGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyByZXF1ZXN0SnNvbiwgYWRkRGF5cywgaWRlbnRpdHkgfSBmcm9tICdAZnVsbGNhbGVuZGFyL2NvcmUvaW50ZXJuYWwuanMnO1xuXG4vLyBUT0RPOiBleHBvc2Ugc29tZWhvd1xuY29uc3QgQVBJX0JBU0UgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vY2FsZW5kYXIvdjMvY2FsZW5kYXJzJztcbmNvbnN0IGV2ZW50U291cmNlRGVmID0ge1xuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGxldCB7IGdvb2dsZUNhbGVuZGFySWQgfSA9IHJlZmluZWQ7XG4gICAgICAgIGlmICghZ29vZ2xlQ2FsZW5kYXJJZCAmJiByZWZpbmVkLnVybCkge1xuICAgICAgICAgICAgZ29vZ2xlQ2FsZW5kYXJJZCA9IHBhcnNlR29vZ2xlQ2FsZW5kYXJJZChyZWZpbmVkLnVybCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdvb2dsZUNhbGVuZGFySWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlQ2FsZW5kYXJJZCxcbiAgICAgICAgICAgICAgICBnb29nbGVDYWxlbmRhckFwaUtleTogcmVmaW5lZC5nb29nbGVDYWxlbmRhckFwaUtleSxcbiAgICAgICAgICAgICAgICBnb29nbGVDYWxlbmRhckFwaUJhc2U6IHJlZmluZWQuZ29vZ2xlQ2FsZW5kYXJBcGlCYXNlLFxuICAgICAgICAgICAgICAgIGV4dHJhUGFyYW1zOiByZWZpbmVkLmV4dHJhUGFyYW1zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGxldCB7IGRhdGVFbnYsIG9wdGlvbnMgfSA9IGFyZy5jb250ZXh0O1xuICAgICAgICBsZXQgbWV0YSA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICBsZXQgYXBpS2V5ID0gbWV0YS5nb29nbGVDYWxlbmRhckFwaUtleSB8fCBvcHRpb25zLmdvb2dsZUNhbGVuZGFyQXBpS2V5O1xuICAgICAgICBpZiAoIWFwaUtleSkge1xuICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhuZXcgRXJyb3IoJ1NwZWNpZnkgYSBnb29nbGVDYWxlbmRhckFwaUtleS4gU2VlIGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL2RvY3MvZ29vZ2xlLWNhbGVuZGFyJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHVybCA9IGJ1aWxkVXJsKG1ldGEpO1xuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSBEUlkgd2l0aCBqc29uLWZlZWQtZXZlbnQtc291cmNlXG4gICAgICAgICAgICBsZXQgeyBleHRyYVBhcmFtcyB9ID0gbWV0YTtcbiAgICAgICAgICAgIGxldCBleHRyYVBhcmFtc09iaiA9IHR5cGVvZiBleHRyYVBhcmFtcyA9PT0gJ2Z1bmN0aW9uJyA/IGV4dHJhUGFyYW1zKCkgOiBleHRyYVBhcmFtcztcbiAgICAgICAgICAgIGxldCByZXF1ZXN0UGFyYW1zID0gYnVpbGRSZXF1ZXN0UGFyYW1zKGFyZy5yYW5nZSwgYXBpS2V5LCBleHRyYVBhcmFtc09iaiwgZGF0ZUVudik7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdEpzb24oJ0dFVCcsIHVybCwgcmVxdWVzdFBhcmFtcykudGhlbigoW2JvZHksIHJlc3BvbnNlXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChib2R5LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQ2FsbGJhY2sobmV3IEpzb25SZXF1ZXN0RXJyb3IoJ0dvb2dsZSBDYWxlbmRhciBBUEk6ICcgKyBib2R5LmVycm9yLm1lc3NhZ2UsIHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmF3RXZlbnRzOiBnY2FsSXRlbXNUb1Jhd0V2ZW50RGVmcyhib2R5Lml0ZW1zLCByZXF1ZXN0UGFyYW1zLnRpbWVab25lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuZnVuY3Rpb24gcGFyc2VHb29nbGVDYWxlbmRhcklkKHVybCkge1xuICAgIGxldCBtYXRjaDtcbiAgICAvLyBkZXRlY3QgaWYgdGhlIElEIHdhcyBzcGVjaWZpZWQgYXMgYSBzaW5nbGUgc3RyaW5nLlxuICAgIC8vIHdpbGwgbWF0Y2ggY2FsZW5kYXJzIGxpa2UgXCJhc2RmMTIzNEBjYWxlbmRhci5nb29nbGUuY29tXCIgaW4gYWRkaXRpb24gdG8gcGVyc29uIGVtYWlsIGNhbGVuZGFycy5cbiAgICBpZiAoL15bXi9dK0AoW14vLl0rXFwuKSooZ29vZ2xlfGdvb2dsZW1haWx8Z21haWwpXFwuY29tJC8udGVzdCh1cmwpKSB7XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGlmICgobWF0Y2ggPSAvXmh0dHBzOlxcL1xcL3d3dy5nb29nbGVhcGlzLmNvbVxcL2NhbGVuZGFyXFwvdjNcXC9jYWxlbmRhcnNcXC8oW14vXSopLy5leGVjKHVybCkpIHx8XG4gICAgICAgIChtYXRjaCA9IC9eaHR0cHM/OlxcL1xcL3d3dy5nb29nbGUuY29tXFwvY2FsZW5kYXJcXC9mZWVkc1xcLyhbXi9dKikvLmV4ZWModXJsKSkpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYnVpbGRVcmwobWV0YSkge1xuICAgIGxldCBhcGlCYXNlID0gbWV0YS5nb29nbGVDYWxlbmRhckFwaUJhc2U7XG4gICAgaWYgKCFhcGlCYXNlKSB7XG4gICAgICAgIGFwaUJhc2UgPSBBUElfQkFTRTtcbiAgICB9XG4gICAgcmV0dXJuIGFwaUJhc2UgKyAnLycgKyBlbmNvZGVVUklDb21wb25lbnQobWV0YS5nb29nbGVDYWxlbmRhcklkKSArICcvZXZlbnRzJztcbn1cbmZ1bmN0aW9uIGJ1aWxkUmVxdWVzdFBhcmFtcyhyYW5nZSwgYXBpS2V5LCBleHRyYVBhcmFtcywgZGF0ZUVudikge1xuICAgIGxldCBwYXJhbXM7XG4gICAgbGV0IHN0YXJ0U3RyO1xuICAgIGxldCBlbmRTdHI7XG4gICAgaWYgKGRhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCkge1xuICAgICAgICAvLyBzdHJpbmdzIHdpbGwgbmF0dXJhbGx5IGhhdmUgb2Zmc2V0cywgd2hpY2ggR0NhbCBuZWVkc1xuICAgICAgICBzdGFydFN0ciA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgZW5kU3RyID0gZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHdoZW4gdGltZXpvbmUgaXNuJ3Qga25vd24sIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgVVRDIG9mZnNldCBzaG91bGQgYmUsIHNvIGFzayBmb3IgKy8tIDEgZGF5XG4gICAgICAgIC8vIGZyb20gdGhlIFVUQyBkYXktc3RhcnQgdG8gZ3VhcmFudGVlIHdlJ3JlIGdldHRpbmcgYWxsIHRoZSBldmVudHNcbiAgICAgICAgLy8gKHN0YXJ0L2VuZCB3aWxsIGJlIFVUQy1jb2VyY2VkIGRhdGVzLCBzbyB0b0lTT1N0cmluZyBpcyBva2F5KVxuICAgICAgICBzdGFydFN0ciA9IGFkZERheXMocmFuZ2Uuc3RhcnQsIC0xKS50b0lTT1N0cmluZygpO1xuICAgICAgICBlbmRTdHIgPSBhZGREYXlzKHJhbmdlLmVuZCwgMSkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoZXh0cmFQYXJhbXMgfHwge30pKSwgeyBrZXk6IGFwaUtleSwgdGltZU1pbjogc3RhcnRTdHIsIHRpbWVNYXg6IGVuZFN0ciwgc2luZ2xlRXZlbnRzOiB0cnVlLCBtYXhSZXN1bHRzOiA5OTk5IH0pO1xuICAgIGlmIChkYXRlRW52LnRpbWVab25lICE9PSAnbG9jYWwnKSB7XG4gICAgICAgIHBhcmFtcy50aW1lWm9uZSA9IGRhdGVFbnYudGltZVpvbmU7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiBnY2FsSXRlbXNUb1Jhd0V2ZW50RGVmcyhpdGVtcywgZ2NhbFRpbWV6b25lKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSkgPT4gZ2NhbEl0ZW1Ub1Jhd0V2ZW50RGVmKGl0ZW0sIGdjYWxUaW1lem9uZSkpO1xufVxuZnVuY3Rpb24gZ2NhbEl0ZW1Ub1Jhd0V2ZW50RGVmKGl0ZW0sIGdjYWxUaW1lem9uZSkge1xuICAgIGxldCB1cmwgPSBpdGVtLmh0bWxMaW5rIHx8IG51bGw7XG4gICAgLy8gbWFrZSB0aGUgVVJMcyBmb3IgZWFjaCBldmVudCBzaG93IHRpbWVzIGluIHRoZSBjb3JyZWN0IHRpbWV6b25lXG4gICAgaWYgKHVybCAmJiBnY2FsVGltZXpvbmUpIHtcbiAgICAgICAgdXJsID0gaW5qZWN0UXNDb21wb25lbnQodXJsLCAnY3R6PScgKyBnY2FsVGltZXpvbmUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgdGl0bGU6IGl0ZW0uc3VtbWFyeSxcbiAgICAgICAgc3RhcnQ6IGl0ZW0uc3RhcnQuZGF0ZVRpbWUgfHwgaXRlbS5zdGFydC5kYXRlLFxuICAgICAgICBlbmQ6IGl0ZW0uZW5kLmRhdGVUaW1lIHx8IGl0ZW0uZW5kLmRhdGUsXG4gICAgICAgIHVybCxcbiAgICAgICAgbG9jYXRpb246IGl0ZW0ubG9jYXRpb24sXG4gICAgICAgIGRlc2NyaXB0aW9uOiBpdGVtLmRlc2NyaXB0aW9uLFxuICAgICAgICBhdHRhY2htZW50czogaXRlbS5hdHRhY2htZW50cyB8fCBbXSxcbiAgICAgICAgZXh0ZW5kZWRQcm9wczogKGl0ZW0uZXh0ZW5kZWRQcm9wZXJ0aWVzIHx8IHt9KS5zaGFyZWQgfHwge30sXG4gICAgfTtcbn1cbi8vIEluamVjdHMgYSBzdHJpbmcgbGlrZSBcImFyZz12YWx1ZVwiIGludG8gdGhlIHF1ZXJ5c3RyaW5nIG9mIGEgVVJMXG4vLyBUT0RPOiBtb3ZlIHRvIGEgZ2VuZXJhbCB1dGlsIGZpbGU/XG5mdW5jdGlvbiBpbmplY3RRc0NvbXBvbmVudCh1cmwsIGNvbXBvbmVudCkge1xuICAgIC8vIGluamVjdCBpdCBhZnRlciB0aGUgcXVlcnlzdHJpbmcgYnV0IGJlZm9yZSB0aGUgZnJhZ21lbnRcbiAgICByZXR1cm4gdXJsLnJlcGxhY2UoLyhcXD8uKj8pPygjfCQpLywgKHdob2xlLCBxcywgaGFzaCkgPT4gKHFzID8gcXMgKyAnJicgOiAnPycpICsgY29tcG9uZW50ICsgaGFzaCk7XG59XG5cbmNvbnN0IE9QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBnb29nbGVDYWxlbmRhckFwaUtleTogU3RyaW5nLFxufTtcblxuY29uc3QgRVZFTlRfU09VUkNFX1JFRklORVJTID0ge1xuICAgIGdvb2dsZUNhbGVuZGFyQXBpS2V5OiBTdHJpbmcsXG4gICAgZ29vZ2xlQ2FsZW5kYXJJZDogU3RyaW5nLFxuICAgIGdvb2dsZUNhbGVuZGFyQXBpQmFzZTogU3RyaW5nLFxuICAgIGV4dHJhUGFyYW1zOiBpZGVudGl0eSxcbn07XG5cbnZhciBpbmRleCA9IGNyZWF0ZVBsdWdpbih7XG4gICAgbmFtZTogJ0BmdWxsY2FsZW5kYXIvZ29vZ2xlLWNhbGVuZGFyJyxcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZl0sXG4gICAgb3B0aW9uUmVmaW5lcnM6IE9QVElPTl9SRUZJTkVSUyxcbiAgICBldmVudFNvdXJjZVJlZmluZXJzOiBFVkVOVF9TT1VSQ0VfUkVGSU5FUlMsXG59KTtcblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZVBsdWdpbiB9IGZyb20gJ0BmdWxsY2FsZW5kYXIvY29yZS9pbmRleC5qcyc7XG5pbXBvcnQgeyBhZGREYXlzIH0gZnJvbSAnQGZ1bGxjYWxlbmRhci9jb3JlL2ludGVybmFsLmpzJztcbmltcG9ydCAqIGFzIElDQUwgZnJvbSAnaWNhbC5qcyc7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5jbGFzcyBJY2FsRXhwYW5kZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgdGhpcy5tYXhJdGVyYXRpb25zID0gb3B0cy5tYXhJdGVyYXRpb25zICE9IG51bGwgPyBvcHRzLm1heEl0ZXJhdGlvbnMgOiAxMDAwO1xuICAgICAgICB0aGlzLnNraXBJbnZhbGlkRGF0ZXMgPSBvcHRzLnNraXBJbnZhbGlkRGF0ZXMgIT0gbnVsbCA/IG9wdHMuc2tpcEludmFsaWREYXRlcyA6IGZhbHNlO1xuICAgICAgICB0aGlzLmpDYWxEYXRhID0gSUNBTC5wYXJzZShvcHRzLmljcyk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gbmV3IElDQUwuQ29tcG9uZW50KHRoaXMuakNhbERhdGEpO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuY29tcG9uZW50LmdldEFsbFN1YmNvbXBvbmVudHMoJ3ZldmVudCcpLm1hcCh2ZXZlbnQgPT4gbmV3IElDQUwuRXZlbnQodmV2ZW50KSk7XG4gICAgICAgIGlmICh0aGlzLnNraXBJbnZhbGlkRGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMuZmlsdGVyKChldnQpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBldnQuc3RhcnREYXRlLnRvSlNEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5lbmREYXRlLnRvSlNEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXBwaW5nIGV2ZW50cyB3aXRoIGludmFsaWQgdGltZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmV0d2VlbihhZnRlciwgYmVmb3JlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGlzRXZlbnRXaXRoaW5SYW5nZShzdGFydFRpbWUsIGVuZFRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybiAoIWFmdGVyIHx8IGVuZFRpbWUgPj0gYWZ0ZXIuZ2V0VGltZSgpKSAmJlxuICAgICAgICAgICAgICAgICghYmVmb3JlIHx8IHN0YXJ0VGltZSA8PSBiZWZvcmUuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRUaW1lcyhldmVudE9yT2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gZXZlbnRPck9jY3VycmVuY2Uuc3RhcnREYXRlLnRvSlNEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgbGV0IGVuZFRpbWUgPSBldmVudE9yT2NjdXJyZW5jZS5lbmREYXRlLnRvSlNEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMgYW4gYWxsIGRheSBldmVudCwgdGhlIGVuZCBkYXRlIGlzIHNldCB0byAwMDowMCBvZiB0aGUgbmV4dCBkYXlcbiAgICAgICAgICAgIC8vIFNvIHdlIG5lZWQgdG8gbWFrZSBpdCBiZSAyMzo1OTo1OSB0byBjb21wYXJlIGNvcnJlY3RseSB3aXRoIHRoZSBnaXZlbiByYW5nZVxuICAgICAgICAgICAgaWYgKGV2ZW50T3JPY2N1cnJlbmNlLmVuZERhdGUuaXNEYXRlICYmIChlbmRUaW1lID4gc3RhcnRUaW1lKSkge1xuICAgICAgICAgICAgICAgIGVuZFRpbWUgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0VGltZSwgZW5kVGltZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4Y2VwdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5pc1JlY3VycmVuY2VFeGNlcHRpb24oKSlcbiAgICAgICAgICAgICAgICBleGNlcHRpb25zLnB1c2goZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmV0ID0ge1xuICAgICAgICAgICAgZXZlbnRzOiBbXSxcbiAgICAgICAgICAgIG9jY3VycmVuY2VzOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ldmVudHMuZmlsdGVyKGUgPT4gIWUuaXNSZWN1cnJlbmNlRXhjZXB0aW9uKCkpLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGRhdGVzID0gW107XG4gICAgICAgICAgICBldmVudC5jb21wb25lbnQuZ2V0QWxsUHJvcGVydGllcygnZXhkYXRlJykuZm9yRWFjaCgoZXhkYXRlUHJvcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZGF0ZSA9IGV4ZGF0ZVByb3AuZ2V0Rmlyc3RWYWx1ZSgpO1xuICAgICAgICAgICAgICAgIGV4ZGF0ZXMucHVzaChleGRhdGUudG9KU0RhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBSZWN1cnJpbmcgZXZlbnQgaXMgaGFuZGxlZCBkaWZmZXJlbnRseVxuICAgICAgICAgICAgaWYgKGV2ZW50LmlzUmVjdXJyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVyYXRvciA9IGV2ZW50Lml0ZXJhdG9yKCk7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2NjdXJyZW5jZSA9IGV2ZW50LmdldE9jY3VycmVuY2VEZXRhaWxzKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzdGFydFRpbWUsIGVuZFRpbWUgfSA9IGdldFRpbWVzKG9jY3VycmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNPY2N1cnJlbmNlRXhjbHVkZWQgPSBleGRhdGVzLmluZGV4T2Yoc3RhcnRUaW1lKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGNoZWNrIHRoYXQgd2l0aGluIHNhbWUgZGF5P1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhjZXB0aW9uID0gZXhjZXB0aW9ucy5maW5kKGV4ID0+IGV4LnVpZCA9PT0gZXZlbnQudWlkICYmIGV4LnJlY3VycmVuY2VJZC50b0pTRGF0ZSgpLmdldFRpbWUoKSA9PT0gb2NjdXJyZW5jZS5zdGFydERhdGUudG9KU0RhdGUoKS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBwYXNzZWQgdGhlIG1heCBkYXRlLCBzdG9wXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVmb3JlICYmIHN0YXJ0VGltZSA+IGJlZm9yZS5nZXRUaW1lKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHdlIGFyZSB3aXRoaW4gb3VyIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNFdmVudFdpdGhpblJhbmdlKHN0YXJ0VGltZSwgZW5kVGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldC5ldmVudHMucHVzaChleGNlcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNPY2N1cnJlbmNlRXhjbHVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0Lm9jY3VycmVuY2VzLnB1c2gob2NjdXJyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAobmV4dCAmJiAoIXRoaXMubWF4SXRlcmF0aW9ucyB8fCBpIDwgdGhpcy5tYXhJdGVyYXRpb25zKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9uLXJlY3VycmluZyBldmVudDpcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhcnRUaW1lLCBlbmRUaW1lIH0gPSBnZXRUaW1lcyhldmVudCk7XG4gICAgICAgICAgICBpZiAoaXNFdmVudFdpdGhpblJhbmdlKHN0YXJ0VGltZSwgZW5kVGltZSkpXG4gICAgICAgICAgICAgICAgcmV0LmV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGJlZm9yZShiZWZvcmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmV0d2Vlbih1bmRlZmluZWQsIGJlZm9yZSk7XG4gICAgfVxuICAgIGFmdGVyKGFmdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJldHdlZW4oYWZ0ZXIpO1xuICAgIH1cbiAgICBhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJldHdlZW4oKTtcbiAgICB9XG59XG5cbmNvbnN0IGV2ZW50U291cmNlRGVmID0ge1xuICAgIHBhcnNlTWV0YShyZWZpbmVkKSB7XG4gICAgICAgIGlmIChyZWZpbmVkLnVybCAmJiByZWZpbmVkLmZvcm1hdCA9PT0gJ2ljcycpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiByZWZpbmVkLnVybCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6ICdpY3MnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGZldGNoKGFyZywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBtZXRhID0gYXJnLmV2ZW50U291cmNlLm1ldGE7XG4gICAgICAgIGxldCB7IGludGVybmFsU3RhdGUgfSA9IG1ldGE7XG4gICAgICAgIC8qXG4gICAgICAgIE5PVEU6IGlzUmVmZXRjaCBpcyBhIEhBQ0suIHdlIHdvdWxkIGRvIHRoZSByZWN1cnJpbmctZXhwYW5kaW5nIGluIGEgc2VwYXJhdGUgcGx1Z2luIGhvb2ssXG4gICAgICAgIGJ1dCB3ZSBjb3VsZG4ndCBsZXZlcmFnZSBidWlsdC1pbiBhbGxEYXktZ3Vlc3NpbmcsIGFtb25nIG90aGVyIHRoaW5ncy5cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKCFpbnRlcm5hbFN0YXRlIHx8IGFyZy5pc1JlZmV0Y2gpIHtcbiAgICAgICAgICAgIGludGVybmFsU3RhdGUgPSBtZXRhLmludGVybmFsU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IG51bGwsXG4gICAgICAgICAgICAgICAgaUNhbEV4cGFuZGVyUHJvbWlzZTogZmV0Y2gobWV0YS51cmwsIHsgbWV0aG9kOiAnR0VUJyB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpLnRoZW4oKGljc1RleHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsU3RhdGUucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSWNhbEV4cGFuZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY3M6IGljc1RleHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEludmFsaWREYXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJuYWxTdGF0ZS5pQ2FsRXhwYW5kZXJQcm9taXNlLnRoZW4oKGlDYWxFeHBhbmRlcikgPT4ge1xuICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICByYXdFdmVudHM6IGV4cGFuZElDYWxFdmVudHMoaUNhbEV4cGFuZGVyLCBhcmcucmFuZ2UpLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBpbnRlcm5hbFN0YXRlLnJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGVycm9yQ2FsbGJhY2spO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gZXhwYW5kSUNhbEV2ZW50cyhpQ2FsRXhwYW5kZXIsIHJhbmdlKSB7XG4gICAgLy8gZXhwYW5kIHRoZSByYW5nZS4gYmVjYXVzZSBvdXIgYHJhbmdlYCBpcyB0aW1lWm9uZS1hZ25vc3RpYyBVVENcbiAgICAvLyBvciBtYXliZSBiZWNhdXNlIGljYWwuanMgYWx3YXlzIHByb2R1Y2VzIGRhdGVzIGluIGxvY2FsIHRpbWU/IGkgZm9yZ2V0XG4gICAgbGV0IHJhbmdlU3RhcnQgPSBhZGREYXlzKHJhbmdlLnN0YXJ0LCAtMSk7XG4gICAgbGV0IHJhbmdlRW5kID0gYWRkRGF5cyhyYW5nZS5lbmQsIDEpO1xuICAgIGxldCBpQ2FsUmVzID0gaUNhbEV4cGFuZGVyLmJldHdlZW4ocmFuZ2VTdGFydCwgcmFuZ2VFbmQpOyAvLyBlbmQgaW5jbHVzaXZlLiB3aWxsIGdpdmUgZXh0cmEgcmVzdWx0c1xuICAgIGxldCBleHBhbmRlZCA9IFtdO1xuICAgIC8vIFRPRE86IGluc3RlYWQgb2YgdXNpbmcgc3RhcnREYXRlL2VuZERhdGUudG9TdHJpbmcgdG8gY29tbXVuaWNhdGUgYWxsRGF5LFxuICAgIC8vIHdlIGNhbiBxdWVyeSBzdGFydERhdGUvZW5kRGF0ZS5pc0RhdGUuIE1vcmUgZWZmaWNpZW50IHRvIGF2b2lkIGZvcm1hdHRpbmcvcmVwYXJzaW5nLlxuICAgIC8vIHNpbmdsZSBldmVudHNcbiAgICBmb3IgKGxldCBpQ2FsRXZlbnQgb2YgaUNhbFJlcy5ldmVudHMpIHtcbiAgICAgICAgZXhwYW5kZWQucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkTm9uRGF0ZVByb3BzKGlDYWxFdmVudCkpLCB7IHN0YXJ0OiBpQ2FsRXZlbnQuc3RhcnREYXRlLnRvU3RyaW5nKCksIGVuZDogKHNwZWNpZmllc0VuZChpQ2FsRXZlbnQpICYmIGlDYWxFdmVudC5lbmREYXRlKVxuICAgICAgICAgICAgICAgID8gaUNhbEV2ZW50LmVuZERhdGUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIDogbnVsbCB9KSk7XG4gICAgfVxuICAgIC8vIHJlY3VycmluZyBldmVudCBpbnN0YW5jZXNcbiAgICBmb3IgKGxldCBpQ2FsT2NjdXJlbmNlIG9mIGlDYWxSZXMub2NjdXJyZW5jZXMpIHtcbiAgICAgICAgbGV0IGlDYWxFdmVudCA9IGlDYWxPY2N1cmVuY2UuaXRlbTtcbiAgICAgICAgZXhwYW5kZWQucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkTm9uRGF0ZVByb3BzKGlDYWxFdmVudCkpLCB7IHN0YXJ0OiBpQ2FsT2NjdXJlbmNlLnN0YXJ0RGF0ZS50b1N0cmluZygpLCBlbmQ6IChzcGVjaWZpZXNFbmQoaUNhbEV2ZW50KSAmJiBpQ2FsT2NjdXJlbmNlLmVuZERhdGUpXG4gICAgICAgICAgICAgICAgPyBpQ2FsT2NjdXJlbmNlLmVuZERhdGUudG9TdHJpbmcoKVxuICAgICAgICAgICAgICAgIDogbnVsbCB9KSk7XG4gICAgfVxuICAgIHJldHVybiBleHBhbmRlZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkTm9uRGF0ZVByb3BzKGlDYWxFdmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRpdGxlOiBpQ2FsRXZlbnQuc3VtbWFyeSxcbiAgICAgICAgdXJsOiBleHRyYWN0RXZlbnRVcmwoaUNhbEV2ZW50KSxcbiAgICAgICAgZXh0ZW5kZWRQcm9wczoge1xuICAgICAgICAgICAgbG9jYXRpb246IGlDYWxFdmVudC5sb2NhdGlvbixcbiAgICAgICAgICAgIG9yZ2FuaXplcjogaUNhbEV2ZW50Lm9yZ2FuaXplcixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBpQ2FsRXZlbnQuZGVzY3JpcHRpb24sXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudFVybChpQ2FsRXZlbnQpIHtcbiAgICBsZXQgdXJsUHJvcCA9IGlDYWxFdmVudC5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eSgndXJsJyk7XG4gICAgcmV0dXJuIHVybFByb3AgPyB1cmxQcm9wLmdldEZpcnN0VmFsdWUoKSA6ICcnO1xufVxuZnVuY3Rpb24gc3BlY2lmaWVzRW5kKGlDYWxFdmVudCkge1xuICAgIHJldHVybiBCb29sZWFuKGlDYWxFdmVudC5jb21wb25lbnQuZ2V0Rmlyc3RQcm9wZXJ0eSgnZHRlbmQnKSkgfHxcbiAgICAgICAgQm9vbGVhbihpQ2FsRXZlbnQuY29tcG9uZW50LmdldEZpcnN0UHJvcGVydHkoJ2R1cmF0aW9uJykpO1xufVxuXG52YXIgaW5kZXggPSBjcmVhdGVQbHVnaW4oe1xuICAgIG5hbWU6ICdAZnVsbGNhbGVuZGFyL2ljYWxlbmRhcicsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxufSk7XG5cbmV4cG9ydCB7IGluZGV4IGFzIGRlZmF1bHQgfTtcbiIsICIvKipcbiAqIEhhbmRsZXMgcmVuZGVyaW5nIHRoZSBjYWxlbmRhciBnaXZlbiBhIGNvbnRhaW5lciBlbGVtZW50LCBldmVudFNvdXJjZXMsIGFuZCBpbnRlcmFjdGlvbiBjYWxsYmFja3MuXG4gKi9cbmltcG9ydCB7XG4gICAgQ2FsZW5kYXIsXG4gICAgRXZlbnRBcGksXG4gICAgRXZlbnRDbGlja0FyZyxcbiAgICBFdmVudEhvdmVyaW5nQXJnLFxuICAgIEV2ZW50U291cmNlSW5wdXQsXG59IGZyb20gXCJAZnVsbGNhbGVuZGFyL2NvcmVcIjtcbmltcG9ydCBkYXlHcmlkUGx1Z2luIGZyb20gXCJAZnVsbGNhbGVuZGFyL2RheWdyaWRcIjtcbi8vIGltcG9ydCBtdWx0aU1vbnRoUGx1Z2luIGZyb20gJ0BmdWxsY2FsZW5kYXIvbXVsdGltb250aCdcbmltcG9ydCB0aW1lR3JpZFBsdWdpbiBmcm9tIFwiQGZ1bGxjYWxlbmRhci90aW1lZ3JpZFwiO1xuaW1wb3J0IHJydWxlUGx1Z2luIGZyb20gXCJAZnVsbGNhbGVuZGFyL3JydWxlXCI7XG5pbXBvcnQgbGlzdFBsdWdpbiBmcm9tIFwiQGZ1bGxjYWxlbmRhci9saXN0XCI7XG5pbXBvcnQgaW50ZXJhY3Rpb25QbHVnaW4gZnJvbSBcIkBmdWxsY2FsZW5kYXIvaW50ZXJhY3Rpb25cIjtcbmltcG9ydCBnb29nbGVDYWxlbmRhclBsdWdpbiBmcm9tIFwiQGZ1bGxjYWxlbmRhci9nb29nbGUtY2FsZW5kYXJcIjtcbmltcG9ydCBpQ2FsZW5kYXJQbHVnaW4gZnJvbSBcIkBmdWxsY2FsZW5kYXIvaWNhbGVuZGFyXCI7XG5cbi8vIFRoZXJlIGlzIGFuIGlzc3VlIHdpdGggRnVsbENhbGVuZGFyIFJSdWxlIHN1cHBvcnQgYXJvdW5kIERTVCBib3VuZGFyaWVzIHdoaWNoIGlzIGZpeGVkIGJ5IHRoaXMgbW9ua2V5cGF0Y2g6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZnVsbGNhbGVuZGFyL2Z1bGxjYWxlbmRhci9pc3N1ZXMvNTI3MyNpc3N1ZWNvbW1lbnQtMTM2MDQ1OTM0MlxucnJ1bGVQbHVnaW4ucmVjdXJyaW5nVHlwZXNbMF0uZXhwYW5kID0gZnVuY3Rpb24gKGVycmQsIGZyLCBkZSkge1xuICAgIGNvbnN0IGhvdXJzID0gZXJyZC5ycnVsZVNldC5fZHRzdGFydC5nZXRIb3VycygpO1xuICAgIHJldHVybiBlcnJkLnJydWxlU2V0XG4gICAgICAgIC5iZXR3ZWVuKGRlLnRvRGF0ZShmci5zdGFydCksIGRlLnRvRGF0ZShmci5lbmQpLCB0cnVlKVxuICAgICAgICAubWFwKChkOiBEYXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgRGF0ZS5VVEMoXG4gICAgICAgICAgICAgICAgICAgIGQuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgZC5nZXRNb250aCgpLFxuICAgICAgICAgICAgICAgICAgICBkLmdldERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICAgICAgICAgIGQuZ2V0TWludXRlcygpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG59O1xuXG5pbnRlcmZhY2UgRXh0cmFSZW5kZXJQcm9wcyB7XG4gICAgZXZlbnRDbGljaz86IChpbmZvOiBFdmVudENsaWNrQXJnKSA9PiB2b2lkO1xuICAgIHNlbGVjdD86IChcbiAgICAgICAgc3RhcnREYXRlOiBEYXRlLFxuICAgICAgICBlbmREYXRlOiBEYXRlLFxuICAgICAgICBhbGxEYXk6IGJvb2xlYW4sXG4gICAgICAgIHZpZXdUeXBlOiBzdHJpbmdcbiAgICApID0+IFByb21pc2U8dm9pZD47XG4gICAgbW9kaWZ5RXZlbnQ/OiAoZXZlbnQ6IEV2ZW50QXBpLCBvbGRFdmVudDogRXZlbnRBcGkpID0+IFByb21pc2U8Ym9vbGVhbj47XG4gICAgZXZlbnRNb3VzZUVudGVyPzogKGluZm86IEV2ZW50SG92ZXJpbmdBcmcpID0+IHZvaWQ7XG4gICAgZmlyc3REYXk/OiBudW1iZXI7XG4gICAgaW5pdGlhbFZpZXc/OiB7IGRlc2t0b3A6IHN0cmluZzsgbW9iaWxlOiBzdHJpbmcgfTtcbiAgICB0aW1lRm9ybWF0MjRoPzogYm9vbGVhbjtcbiAgICBvcGVuQ29udGV4dE1lbnVGb3JFdmVudD86IChcbiAgICAgICAgZXZlbnQ6IEV2ZW50QXBpLFxuICAgICAgICBtb3VzZUV2ZW50OiBNb3VzZUV2ZW50XG4gICAgKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAgIHRvZ2dsZVRhc2s/OiAoZXZlbnQ6IEV2ZW50QXBpLCBpc0NvbXBsZXRlOiBib29sZWFuKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xuICAgIGZvcmNlTmFycm93PzogYm9vbGVhbjtcbiAgICBzbG90RHVyYXRpb246IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlckNhbGVuZGFyKFxuICAgIGNvbnRhaW5lckVsOiBIVE1MRWxlbWVudCxcbiAgICBldmVudFNvdXJjZXM6IEV2ZW50U291cmNlSW5wdXRbXSxcbiAgICBzZXR0aW5ncz86IEV4dHJhUmVuZGVyUHJvcHNcbik6IENhbGVuZGFyIHtcbiAgICBjb25zdCBpc01vYmlsZSA9IHdpbmRvdy5pbm5lcldpZHRoIDwgNTAwO1xuICAgIGNvbnN0IGlzTmFycm93ID0gc2V0dGluZ3M/LmZvcmNlTmFycm93IHx8IGlzTW9iaWxlO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZXZlbnRDbGljayxcbiAgICAgICAgc2VsZWN0LFxuICAgICAgICBtb2RpZnlFdmVudCxcbiAgICAgICAgZXZlbnRNb3VzZUVudGVyLFxuICAgICAgICBvcGVuQ29udGV4dE1lbnVGb3JFdmVudCxcbiAgICAgICAgdG9nZ2xlVGFzayxcbiAgICB9ID0gc2V0dGluZ3MgfHwge307XG4gICAgY29uc3QgbW9kaWZ5RXZlbnRDYWxsYmFjayA9XG4gICAgICAgIG1vZGlmeUV2ZW50ICYmXG4gICAgICAgIChhc3luYyAoe1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBvbGRFdmVudCxcbiAgICAgICAgICAgIHJldmVydCxcbiAgICAgICAgfToge1xuICAgICAgICAgICAgZXZlbnQ6IEV2ZW50QXBpO1xuICAgICAgICAgICAgb2xkRXZlbnQ6IEV2ZW50QXBpO1xuICAgICAgICAgICAgcmV2ZXJ0OiAoKSA9PiB2b2lkO1xuICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgbW9kaWZ5RXZlbnQoZXZlbnQsIG9sZEV2ZW50KTtcbiAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHJldmVydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIGNvbnN0IGNhbCA9IG5ldyBDYWxlbmRhcihjb250YWluZXJFbCwge1xuICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAvLyBWaWV3IHBsdWdpbnNcbiAgICAgICAgICAgIGRheUdyaWRQbHVnaW4sXG4gICAgICAgICAgICB0aW1lR3JpZFBsdWdpbixcbiAgICAgICAgICAgIGxpc3RQbHVnaW4sXG4gICAgICAgICAgICAvLyBtdWx0aU1vbnRoUGx1Z2luLFxuICAgICAgICAgICAgLy8gRHJhZyArIGRyb3AgYW5kIGVkaXRpbmdcbiAgICAgICAgICAgIGludGVyYWN0aW9uUGx1Z2luLFxuICAgICAgICAgICAgLy8gUmVtb3RlIHNvdXJjZXNcbiAgICAgICAgICAgIGdvb2dsZUNhbGVuZGFyUGx1Z2luLFxuICAgICAgICAgICAgaUNhbGVuZGFyUGx1Z2luLFxuICAgICAgICAgICAgcnJ1bGVQbHVnaW4sXG4gICAgICAgIF0sXG4gICAgICAgIGdvb2dsZUNhbGVuZGFyQXBpS2V5OiBcIkFJemFTeURJaWtsRndKWGFMV3VUXzR5Nkk5WlJWVnNQdWY0eEdya1wiLFxuICAgICAgICBpbml0aWFsVmlldzogXG4gICAgICAgICAgICBzZXR0aW5ncz8uaW5pdGlhbFZpZXc/Lltpc05hcnJvdyA/IFwibW9iaWxlXCIgOiBcImRlc2t0b3BcIl0gfHxcbiAgICAgICAgICAgIChpc05hcnJvdyA/IFwidGltZUdyaWQzRGF5c1wiIDogXCJ0aW1lR3JpZFdlZWtcIiksXG4gICAgICAgIG5vd0luZGljYXRvcjogdHJ1ZSxcbiAgICAgICAgc2Nyb2xsVGltZVJlc2V0OiBmYWxzZSxcbiAgICAgICAgZGF5TWF4RXZlbnRzOiB0cnVlLFxuICAgICAgICBleHBhbmRSb3dzOnRydWUsXG4gICAgICAgIHNsb3REdXJhdGlvbjogc2V0dGluZ3M/LnNsb3REdXJhdGlvbiB8fCBcIjAwOjMwOjAwXCIsXG4gICAgICAgIC8vIG11bHRpTW9udGhNYXhDb2x1bW5zOiAxLFxuXG4gICAgICAgIGhlYWRlclRvb2xiYXI6ICFpc05hcnJvd1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICBsZWZ0OiBcInByZXYsbmV4dCB0b2RheVwiLFxuICAgICAgICAgICAgICAgICAgY2VudGVyOiBcInRpdGxlXCIsXG4gICAgICAgICAgICAgICAgICByaWdodDogXCJ0aW1lR3JpZDVEYXlzLHRpbWVHcmlkV2VlayxsaXN0V2VlayxkYXlHcmlkTW9udGgsZGF5R3JpZFllYXJcIixcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiAhaXNNb2JpbGVcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgcmlnaHQ6IFwidG9kYXkscHJldixuZXh0XCIsXG4gICAgICAgICAgICAgICAgICBsZWZ0OiBcImRheUdyaWRNb250aCx0aW1lR3JpZDNEYXlzLGxpc3RXZWVrLGRheUdyaWRZZWFyXCIsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIGZvb3RlclRvb2xiYXI6IGlzTW9iaWxlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIHJpZ2h0OiBcInRvZGF5LHByZXYsbmV4dFwiLFxuICAgICAgICAgICAgICAgICAgbGVmdDogXCJ0aW1lR3JpZDNEYXlzLGRheUdyaWRNb250aCxkYXlHcmlkWWVhcix0aW1lR3JpZFdlZWssbGlzdFdlZWtcIixcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmYWxzZSxcblxuICAgICAgICB2aWV3czoge1xuICAgICAgICAgICAgdGltZUdyaWQzRGF5czoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGltZUdyaWRcIixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAzIH0sXG4gICAgICAgICAgICAgICAgYnV0dG9uVGV4dDogXCIzXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdGltZUdyaWQ1RGF5czoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGltZUdyaWRcIixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiA1IH0sXG4gICAgICAgICAgICAgICAgYnV0dG9uVGV4dDogXCI1XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXlHcmlkTW9udGg6IHtcbiAgICAgICAgICAgICAgZGF5TWF4RXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkYXlHcmlkWWVhcjoge1xuICAgICAgICAgICAgICBkYXlNYXhFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZmlyc3REYXk6IHNldHRpbmdzPy5maXJzdERheSxcbiAgICAgICAgLi4uKHNldHRpbmdzPy50aW1lRm9ybWF0MjRoICYmIHtcbiAgICAgICAgICAgIGV2ZW50VGltZUZvcm1hdDoge1xuICAgICAgICAgICAgICAgIGhvdXI6IFwibnVtZXJpY1wiLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogXCIyLWRpZ2l0XCIsXG4gICAgICAgICAgICAgICAgaG91cjEyOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzbG90TGFiZWxGb3JtYXQ6IHtcbiAgICAgICAgICAgICAgICBob3VyOiBcIm51bWVyaWNcIixcbiAgICAgICAgICAgICAgICBtaW51dGU6IFwiMi1kaWdpdFwiLFxuICAgICAgICAgICAgICAgIGhvdXIxMjogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgICAgZXZlbnRTb3VyY2VzLFxuICAgICAgICBldmVudENsaWNrLFxuXG4gICAgICAgIHNlbGVjdGFibGU6IHNlbGVjdCAmJiB0cnVlLFxuICAgICAgICBzZWxlY3RNaXJyb3I6IHNlbGVjdCAmJiB0cnVlLFxuICAgICAgICBzZWxlY3Q6XG4gICAgICAgICAgICBzZWxlY3QgJiZcbiAgICAgICAgICAgIChhc3luYyAoaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdChpbmZvLnN0YXJ0LCBpbmZvLmVuZCwgaW5mby5hbGxEYXksIGluZm8udmlldy50eXBlKTtcbiAgICAgICAgICAgICAgICBpbmZvLnZpZXcuY2FsZW5kYXIudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIH0pLFxuXG4gICAgICAgIGVkaXRhYmxlOiBtb2RpZnlFdmVudCAmJiB0cnVlLFxuICAgICAgICBldmVudERyb3A6IG1vZGlmeUV2ZW50Q2FsbGJhY2ssXG4gICAgICAgIGV2ZW50UmVzaXplOiBtb2RpZnlFdmVudENhbGxiYWNrLFxuXG4gICAgICAgIGV2ZW50TW91c2VFbnRlcixcblxuICAgICAgICBldmVudERpZE1vdW50OiAoeyBldmVudCwgZWwsIHRleHRDb2xvciB9KSA9PiB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQgJiYgb3BlbkNvbnRleHRNZW51Rm9yRXZlbnQoZXZlbnQsIGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodG9nZ2xlVGFzaykge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5leHRlbmRlZFByb3BzLmlzVGFzaykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3gudHlwZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5leHRlbmRlZFByb3BzLnRhc2tDb21wbGV0ZWQgIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjaGVja2JveC5vbmNsaWNrID0gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV0ID0gYXdhaXQgdG9nZ2xlVGFzayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS5jaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZS50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudCkuY2hlY2tlZCA9ICEoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkuY2hlY2tlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIGNoZWNrYm94IG1vcmUgdmlzaWJsZSBhZ2FpbnN0IGRpZmZlcmVudCBjb2xvciBldmVudHMuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0Q29sb3IgPT0gXCJibGFja1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveC5hZGRDbGFzcyhcIm9mYy1jaGVja2JveC1ibGFja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94LmFkZENsYXNzKFwib2ZjLWNoZWNrYm94LXdoaXRlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrYm94LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmFkZENsYXNzKFwib2ZjLXRhc2stY29tcGxldGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSB2aWV3LCB3ZSBzaG91bGQgcHV0IHRoZSBjaGVja2JveCBpbiBhIGRpZmZlcmVudCBzcG90LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXIgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZWwucXVlcnlTZWxlY3RvcihcIi5mYy1ldmVudC10aW1lXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yKFwiLmZjLWV2ZW50LXRpdGxlXCIpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5xdWVyeVNlbGVjdG9yKFwiLmZjLWxpc3QtZXZlbnQtdGl0bGVcIik7XG5cbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyPy5hZGRDbGFzcyhcIm9mYy1oYXMtY2hlY2tib3hcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcj8ucHJlcGVuZChjaGVja2JveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGxvbmdQcmVzc0RlbGF5OiAyNTAsXG4gICAgfSk7XG4gICAgY2FsLnJlbmRlcigpO1xuICAgIHJldHVybiBjYWw7XG59XG4iLCAiaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuL21haW5cIlxuaW1wb3J0IHsgTm90aWNlLCBUQWJzdHJhY3RGaWxlLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBJUGFnZSwgSVN1YnNjcmliZXIsIFNyYyB9IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCB7IGlzRXF1YWxPYmogfSBmcm9tIFwiLi91dGlsXCJcbmltcG9ydCBGaWxlTWFuYWdlciBmcm9tIFwiLi9maWxlTWFuYWdlclwiXG5pbXBvcnQgeyBNU0dfUExHX05BTUUgfSBmcm9tIFwiLi9jb25zdGFudHNcIlxuXG50eXBlIElQYXRoU3Vic2NyaWJlciA9IHtcbiAgcGF0aHM6IFNyY1tdLFxuICBzdWJzY3JpYmVyOiBJU3Vic2NyaWJlclxufVxuXG50eXBlIFN1YnNjcmliZURhdGEgPSB7XG4gIHNyYzogU3JjLFxuICBwYWdlczogSVBhZ2VbXVxufVxuXG5leHBvcnQgY2xhc3MgQ2FjaGUge1xuICBwcml2YXRlIHBhcnJlbnRQb2ludGVyOiBNeVBsdWdpblxuXG4gIHByaXZhdGUgc3RvcmFnZSA9IG5ldyBNYXA8c3RyaW5nLCBJUGFnZT4oKVxuICBwcml2YXRlIHN1YnNjcmliZXJzID0gbmV3IE1hcDxOdW1iZXIsIElQYXRoU3Vic2NyaWJlcj4oKVxuXG4gIHByaXZhdGUgaW5pdFN5bmM6IFByb21pc2U8dm9pZD4gPSBuZXcgUHJvbWlzZShcbiAgICByZXNvbHZlID0+IHRoaXMuaW5pdFN5bmNSZXNvbHZlID0gcmVzb2x2ZVxuICApXG4gIHByaXZhdGUgaW5pdFN5bmNSZXNvbHZlOiAodmFsdWU6IHZvaWQgfCBQcm9taXNlTGlrZTx2b2lkPikgPT4gdm9pZFxuICBwcml2YXRlIGlzSW5pdGVkID0gZmFsc2VcblxuICBjb25zdHJ1Y3RvcihwYXJyZW50UG9pbnRlcjogTXlQbHVnaW4sIGZpbGVNYW5hZ2VyOiBGaWxlTWFuYWdlcikge1xuICAgIHRoaXMucGFycmVudFBvaW50ZXIgPSBwYXJyZW50UG9pbnRlclxuXG4gICAgdGhpcy5wYXJyZW50UG9pbnRlci5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoKCkgPT4gdGhpcy5pbml0U3RvcmFnZSgpKVxuICB9XG5cbiAgcHVibGljIGdldFBhZ2UocGF0aDogc3RyaW5nKTogSVBhZ2V8dW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlLmdldChwYXRoKVxuICB9XG5cbiAgcHVibGljIGxvZygpIHtcbiAgICBjb25zb2xlLmxvZyhcInN0b3JhZ2VcIiwgdGhpcy5zdG9yYWdlKVxuICAgIGNvbnNvbGUubG9nKFwic3Vic2NyaWJlcnNcIiwgdGhpcy5zdWJzY3JpYmVycylcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzdWJzY3JpYmUoaWQ6IE51bWJlciwgcGF0aHM6IFNyY1tdLCBzdWJzY3JpYmVyOiBJU3Vic2NyaWJlcik6IFByb21pc2U8U3Vic2NyaWJlRGF0YVtdPiB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5zZXQoXG4gICAgICBpZCxcbiAgICAgIHtcbiAgICAgICAgcGF0aHMsXG4gICAgICAgIHN1YnNjcmliZXJcbiAgICAgIH1cbiAgICApXG5cbiAgICBpZiAoIXRoaXMuaXNJbml0ZWQpXG4gICAgICBhd2FpdCB0aGlzLmluaXRTeW5jXG5cbiAgICBjb25zdCByZXN1bHQ6IFN1YnNjcmliZURhdGFbXSA9IFtdXG5cbiAgICAvLyBcdTA0MTRcdTA0M0JcdTA0NEYgXHUwNDNBXHUwNDMwXHUwNDM2XHUwNDM0XHUwNDNFXHUwNDMzXHUwNDNFIFx1MDQzN1x1MDQzMFx1MDQzRlx1MDQ0MFx1MDQzRVx1MDQ0OFx1MDQzNVx1MDQzRFx1MDQzRFx1MDQzRVx1MDQzM1x1MDQzRSBcdTA0M0ZcdTA0NDNcdTA0NDJcdTA0MzggXHUwNDQxXHUwNDNFXHUwNDM3XHUwNDM0XHUwNDMwXHUwNDM1XHUwNDNDIFx1MDQzRVx1MDQzMVx1MDQ0QVx1MDQzNVx1MDQzQVx1MDQ0MiBTdWJzY3JpYmVEYXRhXG4gICAgZm9yIChsZXQgcGF0aCBvZiBwYXRocykge1xuICAgICAgY29uc3QgcGFnZXM6IElQYWdlW10gPSBbXVxuXG4gICAgICAvLyBcdTA0MURcdTA0MzBcdTA0NDVcdTA0M0VcdTA0MzRcdTA0MzhcdTA0M0MgXHUwNDMyXHUwNDQxXHUwNDM1IFx1MDQ0MVx1MDQ0Mlx1MDQ0MFx1MDQzMFx1MDQzRFx1MDQzOFx1MDQ0Nlx1MDQ0QiwgXHUwNDNBXHUwNDNFXHUwNDQyXHUwNDNFXHUwNDQwXHUwNDRCXHUwNDM1IFx1MDQzRFx1MDQzMFx1MDQ0N1x1MDQzOFx1MDQzRFx1MDQzMFx1MDQ0RVx1MDQ0Mlx1MDQ0MVx1MDQ0RiBcdTA0NDEgXHUwNDREXHUwNDQyXHUwNDNFXHUwNDMzXHUwNDNFIFx1MDQzRlx1MDQ0M1x1MDQ0Mlx1MDQzOFxuICAgICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHRoaXMuc3RvcmFnZSkge1xuICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgocGF0aC5wYXRoKSkge1xuICAgICAgICAgIHBhZ2VzLnB1c2godmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBzcmM6IHBhdGgsXG4gICAgICAgIHBhZ2VzOiBwYWdlc1xuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBwdWJsaWMgdW5zdWJzY3JpYmUoaWQ6IE51bWJlcikge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGlkKVxuICB9XG5cbiAgcHVibGljIHJlbmFtZUZpbGUoZmlsZTogVEZpbGUsIG9sZFBhdGg6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5pc0luaXRlZClcbiAgICAgIHJldHVyblxuXG4gICAgY29uc3Qgb2xkUGFnZSA9IHRoaXMuc3RvcmFnZS5nZXQob2xkUGF0aCkgYXMgSVBhZ2VcblxuICAgIC8vIE5PVEUgXHUwNDQyXHUwNDM4XHUwNDNGXHUwNDMwIFx1MDQ0RFx1MDQ0Mlx1MDQzRSBcdTA0NDFcdTA0NDFcdTA0NEJcdTA0M0JcdTA0M0VcdTA0NDdcdTA0M0RcdTA0NEJcdTA0MzUgXHUwNDNFXHUwNDMxXHUwNDRBXHUwNDM1XHUwNDNBXHUwNDQyXHUwNDRCXG4gICAgY29uc3QgcGFnZSA9IHsuLi5vbGRQYWdlfVxuICAgIHBhZ2UuZmlsZSA9IHsuLi5vbGRQYWdlLmZpbGV9XG4gICAgcGFnZS5maWxlLnBhdGggPSBmaWxlLnBhdGhcbiAgICBwYWdlLmZpbGUubmFtZSA9IGZpbGUuYmFzZW5hbWVcblxuICAgIHRoaXMuc3RvcmFnZS5kZWxldGUob2xkUGF0aClcbiAgICB0aGlzLnN0b3JhZ2Uuc2V0KGZpbGUucGF0aCwgcGFnZSlcblxuICAgIGZvciAobGV0IFtfLCB7cGF0aHMsIHN1YnNjcmliZXJ9XSBvZiB0aGlzLnN1YnNjcmliZXJzKSB7XG4gICAgICBmb3IgKGxldCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgICAgIGlmIChmaWxlLnBhdGguc3RhcnRzV2l0aChwYXRoLnBhdGgpICYmIG9sZFBhdGguc3RhcnRzV2l0aChwYXRoLnBhdGgpKVxuICAgICAgICAgIHN1YnNjcmliZXIucmVuYW1lRmlsZShwYWdlLCBvbGRQYWdlKVxuICAgICAgICBlbHNlIGlmIChvbGRQYXRoLnN0YXJ0c1dpdGgocGF0aC5wYXRoKSlcbiAgICAgICAgICBzdWJzY3JpYmVyLmRlbGV0ZUZpbGUob2xkUGFnZSlcbiAgICAgICAgZWxzZSBpZiAoZmlsZS5wYXRoLnN0YXJ0c1dpdGgocGF0aC5wYXRoKSlcbiAgICAgICAgICBzdWJzY3JpYmVyLmFkZEZpbGUocGFnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWRkRmlsZShmaWxlOiBURmlsZSkge1xuICAgIGlmICghdGhpcy5pc0luaXRlZClcbiAgICAgIHJldHVyblxuXG4gICAgY29uc3QgcGFnZSA9IGF3YWl0IHRoaXMucGFycmVudFBvaW50ZXIuZmlsZU1hbmFnZXIuZ2V0UGFnZShmaWxlKVxuICAgIHRoaXMuc3RvcmFnZS5zZXQoZmlsZS5wYXRoLCBwYWdlKVxuXG4gICAgZm9yIChsZXQgW18sIHtwYXRocywgc3Vic2NyaWJlcn1dIG9mIHRoaXMuc3Vic2NyaWJlcnMpIHtcbiAgICAgIGZvciAobGV0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKCFmaWxlLnBhdGguc3RhcnRzV2l0aChwYXRoLnBhdGgpKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgc3Vic2NyaWJlci5hZGRGaWxlKHBhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNoYW5nZUZpbGUoZmlsZTogVEZpbGUpIHtcbiAgICBpZiAoIXRoaXMuaXNJbml0ZWQpXG4gICAgICByZXR1cm5cblxuICAgIGNvbnN0IHBhZ2UgPSBhd2FpdCB0aGlzLnBhcnJlbnRQb2ludGVyLmZpbGVNYW5hZ2VyLmdldFBhZ2UoZmlsZSlcbiAgICBjb25zdCBvbGRQYWdlID0gdGhpcy5zdG9yYWdlLmdldChmaWxlLnBhdGgpIGFzIElQYWdlXG4gICAgaWYgKGlzRXF1YWxPYmoocGFnZSwgb2xkUGFnZSkpXG4gICAgICByZXR1cm5cblxuICAgIHRoaXMuc3RvcmFnZS5zZXQoZmlsZS5wYXRoLCBwYWdlKVxuXG4gICAgZm9yIChsZXQgW18sIHtwYXRocywgc3Vic2NyaWJlcn1dIG9mIHRoaXMuc3Vic2NyaWJlcnMpIHtcbiAgICAgIGZvciAobGV0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKCFmaWxlLnBhdGguc3RhcnRzV2l0aChwYXRoLnBhdGgpKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgc3Vic2NyaWJlci5jaGFuZ2VGaWxlKHBhZ2UsIG9sZFBhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGRlbGV0ZUZpbGUoZmlsZTogVEFic3RyYWN0RmlsZSkge1xuICAgIGlmICghdGhpcy5pc0luaXRlZClcbiAgICAgIHJldHVyblxuXG4gICAgY29uc3QgcGFnZSA9IHRoaXMuc3RvcmFnZS5nZXQoZmlsZS5wYXRoKSBhcyBJUGFnZVxuXG4gICAgdGhpcy5zdG9yYWdlLmRlbGV0ZShmaWxlLnBhdGgpXG4gICAgZm9yIChsZXQgW18sIHtwYXRocywgc3Vic2NyaWJlcn1dIG9mIHRoaXMuc3Vic2NyaWJlcnMpIHtcbiAgICAgIGZvciAobGV0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgICAgaWYgKCFmaWxlLnBhdGguc3RhcnRzV2l0aChwYXRoLnBhdGgpKVxuICAgICAgICAgIGNvbnRpbnVlXG5cbiAgICAgICAgc3Vic2NyaWJlci5kZWxldGVGaWxlKHBhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlc2V0KCkge1xuICAgIHRoaXMuaXNJbml0ZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5zdG9yYWdlLmNsZWFyKClcblxuICAgIGNvbnN0IHRtcCA9IHRoaXMuc3Vic2NyaWJlcnNcbiAgICB0aGlzLnN1YnNjcmliZXJzID0gbmV3IE1hcCgpXG4gICAgYXdhaXQgdGhpcy5pbml0U3RvcmFnZSgpXG5cbiAgICBmb3IgKGxldCBbXywge3N1YnNjcmliZXJ9XSBvZiB0bXApXG4gICAgICBzdWJzY3JpYmVyLnJlc2V0KClcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdFN0b3JhZ2UoKSB7XG4gICAgY29uc3QgdEZpbGVzID0gdGhpcy5wYXJyZW50UG9pbnRlci5hcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpXG5cbiAgICBjb25zdCBub3RpY2UgPSBuZXcgTm90aWNlKFxuICAgICAgYCR7TVNHX1BMR19OQU1FfTogdGhlcmUgYXJlICR7dEZpbGVzLmxlbmd0aH0gbm90ZXNgLFxuICAgICAgMTAwMCAqIDYwIC8vIDYwIHNlY29uZHNcbiAgICApXG5cbiAgICBmb3IgKGxldCBpIGluIHRGaWxlcykge1xuICAgICAgY29uc3QgdEZpbGUgPSB0RmlsZXNbaV1cblxuICAgICAgbm90aWNlLnNldE1lc3NhZ2UoYCR7TVNHX1BMR19OQU1FfTogKCR7aX0vJHt0RmlsZXMubGVuZ3RofSkgYWRkZWQgJHt0RmlsZS5wYXRofWApXG5cbiAgICAgIHRoaXMuc3RvcmFnZS5zZXQoXG4gICAgICAgIHRGaWxlLnBhdGgsXG4gICAgICAgIGF3YWl0IHRoaXMucGFycmVudFBvaW50ZXIuZmlsZU1hbmFnZXIuZ2V0UGFnZSh0RmlsZSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBub3RpY2UuaGlkZSgpXG4gICAgbmV3IE5vdGljZShgJHtNU0dfUExHX05BTUV9OiBjYWNoZSBoYXMgYmVlbiBpbml0ZWRgKVxuXG4gICAgdGhpcy5pbml0U3luY1Jlc29sdmUoKVxuICAgIHRoaXMuaXNJbml0ZWQgPSB0cnVlXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBBcHAsIE5vdGljZSwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuL21haW5cIjtcbmltcG9ydCB7IENPTE9VUl9SRVNULCBDT0xPVVJfU0xFRVAsIERFRkFVTFRfU0VUVElOR1MsIE1TR19QTEdfTkFNRSB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgY2xhc3MgTXlTZXR0aW5nVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gIHBsdWdpbjogTXlQbHVnaW47XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTXlQbHVnaW4pIHtcbiAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgdGhpcy5wbHVnaW4gPSBwbHVnaW47XG4gIH1cblxuICBkaXNwbGF5KCkge1xuICAgIGxldCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMucGx1Z2luLmdldFNldHRpbmdzKClcblxuICAgIC8vIFRPRE8gXHUwNDNGXHUwNDQwXHUwNDM4IFx1MDQ0MVx1MDQzQ1x1MDQzNVx1MDQzRFx1MDQzNSBcdTA0MzJcdTA0NEJcdTA0M0FcdTA0M0JcdTA0NEVcdTA0NDdcdTA0MzBcdTA0NDJcdTA0NEMgXHUwNDMyIFx1MDQ0Mlx1MDQzNVx1MDQzQVx1MDQ0M1x1MDQ0OVx1MDQzNVx1MDQzOSBcdTA0NDFcdTA0MzVcdTA0NDFcdTA0NDFcdTA0MzhcdTA0MzggXHUwNDM4XHUwNDNEXHUwNDQxXHUwNDQyXHUwNDQwXHUwNDQzXHUwNDNDXHUwNDM1XHUwNDNEXHUwNDQyLCBcdTA0MzAgXHUwNDNEXHUwNDM1IFx1MDQzRlx1MDQ0MFx1MDQzOCBcdTA0M0ZcdTA0MzVcdTA0NDBcdTA0MzVcdTA0MzdcdTA0MzBcdTA0MzNcdTA0NDBcdTA0NDNcdTA0MzdcdTA0M0FcdTA0MzVcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0SGVhZGluZygpLnNldE5hbWUoXCJJdCdzIHJlY29tbWVuZGVkIHRvIHJlbG9hZCBPYnNpZGlhbkFwcCBhZnRlciBjaGFuZ2luZyB0aGUgc2V0dGluZ3NcIilcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuYWRkQnV0dG9uKFxuICAgICAgYnRuID0+IHtcbiAgICAgICAgYnRuLnNldEJ1dHRvblRleHQoXCJTZXQgRGVmYXVsdCBWYWx1ZXNcIilcbiAgICAgICAgLm9uQ2xpY2soXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKERFRkFVTFRfU0VUVElOR1MpXG4gICAgICAgICAgICBuZXcgTm90aWNlKE1TR19QTEdfTkFNRSArIFwiVGhlIGRlZmF1bHQgc2V0dGluZ3MgaGFzIGJlZW4gYXBwbGllZFwiKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuICAgIClcblxuICAgIC8vIENhbGVuZGFyXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKVxuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoXCJDYWxlbmRhclwiKS5zZXRIZWFkaW5nKClcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKFwiU2xvdCBkdXJhdGlvblwiKVxuICAgIC5zZXREZXNjKGBEZWZhdWx0OiAke0RFRkFVTFRfU0VUVElOR1MuY2FsZW5kYXIuc2xvdER1cmF0aW9ufWApXG4gICAgLmFkZFRleHQoXG4gICAgICBjb21wb25lbnQgPT4ge1xuICAgICAgICBjb21wb25lbnQuc2V0UGxhY2Vob2xkZXIoXCJoaDptbTpzc1wiKVxuICAgICAgICAuc2V0VmFsdWUoc2V0dGluZ3MuY2FsZW5kYXIuc2xvdER1cmF0aW9uKVxuICAgICAgICAub25DaGFuZ2UoXG4gICAgICAgICAgdmFsdWUgPT4ge1xuICAgICAgICAgICAgLy8gQ29tbWVudGV0IGNhdXNlIEl0IGNyZWF0ZSBhIGxvdCBvZiBOb3RpY2VcbiAgICAgICAgICAgIC8vIGNvbnN0IHJlZ0V4cCA9IC9eXFxkezJ9OlxcZHsyfTpcXGR7Mn0kL1xuXG4gICAgICAgICAgICAvLyAvLyBOT1RFIFx1MDQzRlx1MDQ0MFx1MDQzRVx1MDQzMlx1MDQzNVx1MDQ0MFx1MDQ0Rlx1MDQzNVx1MDQzQyBcdTA0NDFcdTA0M0VcdTA0M0VcdTA0NDJcdTA0MzJcdTA0MzVcdTA0NDJcdTA0NDFcdTA0NDJcdTA0MzJcdTA0MzhcdTA0MzUgXHUwNDQ0XHUwNDNFXHUwNDQwXHUwNDNDXHUwNDMwXHUwNDQyXHUwNDQzXG4gICAgICAgICAgICAvLyBpZiAoIXJlZ0V4cC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gICB2YWx1ZSA9IERFRkFVTFRfU0VUVElOR1MuY2FsZW5kYXIuc2xvdER1cmF0aW9uXG4gICAgICAgICAgICAvLyAgIG5ldyBOb3RpY2UoTVNHX1BMR19OQU1FICsgXCJpbnZhbGlkIFNsb3REdXJhdGlvbiBmb3JtYXRcIilcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgc2V0dGluZ3MuY2FsZW5kYXIuc2xvdER1cmF0aW9uID0gdmFsdWVcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncyhzZXR0aW5ncylcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICApXG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShcIkNvbG91cnNcIikuc2V0SGVhZGluZygpXG4gICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHNldHRpbmdzLmNhbGVuZGFyLmNvbG91cnMpIGFzIChrZXlvZiB0eXBlb2Ygc2V0dGluZ3MuY2FsZW5kYXIuY29sb3VycylbXSApIHtcbiAgICAgIHRoaXMuYWRkQ29sb3VyU2V0dGluZyhcbiAgICAgICAgY29udGFpbmVyRWwsIGtleSxcbiAgICAgICAgREVGQVVMVF9TRVRUSU5HUy5jYWxlbmRhci5jb2xvdXJzW2tleV0sXG4gICAgICAgIHNldHRpbmdzLmNhbGVuZGFyLmNvbG91cnNba2V5XSxcbiAgICAgICAgKHZhbDpzdHJpbmcpID0+IHtcbiAgICAgICAgICBzZXR0aW5ncy5jYWxlbmRhci5jb2xvdXJzW2tleV0gPSB2YWxcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3Moc2V0dGluZ3MpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShcIlJlc3RUaW1lXCIpLnNldEhlYWRpbmcoKVxuICAgIGZvciAobGV0IGluZGV4IGluIHNldHRpbmdzLmNhbGVuZGFyLnJlc3RUaW1lKSB7XG5cbiAgICAgIGNvbnN0IGVsID0gc2V0dGluZ3MuY2FsZW5kYXIucmVzdFRpbWVbaW5kZXhdXG5cbiAgICAgIGxldCBuYW1lID0gXCJcIlxuICAgICAgaWYgKGVsLmNvbG9yID09PSBDT0xPVVJfUkVTVCkge1xuICAgICAgICBuYW1lID0gXCJSZXN0IHRpbWVcIlxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZWwuY29sb3IgPT09IENPTE9VUl9TTEVFUCkge1xuICAgICAgICBuYW1lID0gXCJTbGVlcCB0aW1lXCJcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgY29udGludWVcblxuICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldE5hbWUoYFN0YXJ0IG9mICR7bmFtZX0gKCR7aW5kZXh9KWApLmFkZFRleHQoXG4gICAgICAgIHRleHQgPT4ge1xuICAgICAgICAgIHRleHQuc2V0VmFsdWUoZWwuc3RhcnRUaW1lKS5zZXRQbGFjZWhvbGRlcihcImhoOm1tOnNzXCIpXG4gICAgICAgICAgLm9uQ2hhbmdlKFxuICAgICAgICAgICAgdmFsID0+IHtcbiAgICAgICAgICAgICAgc2V0dGluZ3MuY2FsZW5kYXIucmVzdFRpbWVbaW5kZXhdLnN0YXJ0VGltZSA9IHZhbFxuICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3Moc2V0dGluZ3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICApXG4gICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShgRW5kIG9mICR7bmFtZX0gKCR7aW5kZXh9KWApLmFkZFRleHQoXG4gICAgICAgIHRleHQgPT4ge1xuICAgICAgICAgIHRleHQuc2V0VmFsdWUoZWwuZW5kVGltZSkuc2V0UGxhY2Vob2xkZXIoXCJoaDptbTpzc1wiKVxuICAgICAgICAgIC5vbkNoYW5nZShcbiAgICAgICAgICAgIHZhbCA9PiB7XG4gICAgICAgICAgICAgIHNldHRpbmdzLmNhbGVuZGFyLnJlc3RUaW1lW2luZGV4XS5lbmRUaW1lID0gdmFsXG4gICAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncyhzZXR0aW5ncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIClcblxuICAgIH1cblxuXG4gICAgLy8gU3RhdHVzIENvcnJlY3RvclxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXRIZWFkaW5nKClcbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbCkuc2V0TmFtZShcIlN0YXR1c0NvcnJlY3RvclwiKS5zZXRIZWFkaW5nKClcbiAgICAvLyAuc2V0RGVzYyhcIlRoaXMgaXMgRGVzY3JpcHRpb25cIilcblxuICAgIGNvbnN0IHN0YXR1c0NvcnJlY3RvciA9IHNldHRpbmdzLnN0YXR1c0NvcnJlY3Rvci5pc09uXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkVuYWJsZSB0b29sXCIpXG4gICAgICAuYWRkVG9nZ2xlKFxuICAgICAgICB0b2dnbGUgPT5cbiAgICAgICAgICB0b2dnbGVcbiAgICAgICAgICAgIC5zZXRWYWx1ZShzdGF0dXNDb3JyZWN0b3IpXG4gICAgICAgICAgICAub25DaGFuZ2UoXG4gICAgICAgICAgICAgIHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zdGF0dXNDb3JyZWN0b3IuaXNPbiA9IHZhbHVlXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKHNldHRpbmdzKVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5KClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgKVxuICAgIGlmIChzdGF0dXNDb3JyZWN0b3IpIHtcbiAgICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgICAuc2V0TmFtZShcIlN0YXJ0IG9uIFN0YXJ0IFVwXCIpXG4gICAgICAgIC5hZGRUb2dnbGUoXG4gICAgICAgICAgdG9nZ2xlID0+IHRvZ2dsZS5zZXRWYWx1ZShzZXR0aW5ncy5zdGF0dXNDb3JyZWN0b3Iuc3RhcnRPblN0YXJ0VXApXG4gICAgICAgICAgICAub25DaGFuZ2UoXG4gICAgICAgICAgICAgIHZhbCA9PiB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3RhdHVzQ29ycmVjdG9yLnN0YXJ0T25TdGFydFVwID0gdmFsXG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKHNldHRpbmdzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgIClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFkZENvbG91clNldHRpbmcoY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LCBuYW1lOiBzdHJpbmcsIGRlZmF1bHRWYWx1ZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFZhbHVlOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikge1xuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKS5zZXROYW1lKG5hbWUpLnNldERlc2MoYERlZmF1bHQ6ICR7ZGVmYXVsdFZhbHVlfWApXG4gICAgLmFkZFRleHQoXG4gICAgICBjb21wb25lbnQgPT4ge1xuICAgICAgICBjb21wb25lbnQuc2V0UGxhY2Vob2xkZXIoXCIjMGYwZjBmXCIpXG4gICAgICAgIC5zZXRWYWx1ZShjdXJyZW50VmFsdWUpLm9uQ2hhbmdlKHZhbCA9PiBjYWxsYmFjayh2YWwpKVxuICAgICAgfVxuICAgIClcbiAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgTm90aWNlLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IE15UGx1Z2luIGZyb20gXCIuL21haW5cIjtcbmltcG9ydCB7IElFdmVudCwgSVBhZ2UsIElUYXNrcywgSURhdGUgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHsgQ2FsZW5kYXJFdmVudFRvSURhdGUsIGR2LCBnZXRUaWNrc0Zyb21UZXh0IH0gZnJvbSBcIi4vdXRpbFwiO1xuaW1wb3J0IHsgTVNHX1BMR19OQU1FIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZpbGVNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IocGxnOiBNeVBsdWdpbikge1xuICAgIC8vIFRPRE8gXHUwNDNGXHUwNDM1XHUwNDQwXHUwNDM1XHUwNDM0XHUwNDMwXHUwNDMyXHUwNDMwXHUwNDQyXHUwNDRDIFx1MDQzRFx1MDQzNSBcdTA0MzJcdTA0MzVcdTA0NDFcdTA0NEMgYXBwLCBcdTA0MzAgXHUwNDQyXHUwNDNFXHUwNDNCXHUwNDRDXHUwNDNBXHUwNDNFIFx1MDQzRFx1MDQ0M1x1MDQzNlx1MDQzRFx1MDQ0Qlx1MDQzNSBcdTA0MzVcdTA0M0NcdTA0NDMgXHUwNDNGXHUwNDNFXHUwNDNCXHUwNDRGXG4gICAgdGhpcy5hcHAgPSBwbGcuYXBwXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY3JlYXRlRmlsZShwYXRoOiBzdHJpbmcpIHtcbiAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5jcmVhdGUocGF0aCwgJycpXG4gICAgbmV3IE5vdGljZShNU0dfUExHX05BTUUgKyBcImNyZWF0ZWQgXCIgKyBwYXRoKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNoYW5nZVByb3BlcnR5RmlsZShwYXRoOiBzdHJpbmcsIGV2ZW50OiBJRGF0ZSkge1xuICAgIC8vIE5PVEUgXHUwNDREXHUwNDQyXHUwNDNFIFx1MDQzRVx1MDQ0Mlx1MDQzRlx1MDQ0MFx1MDQzMFx1MDQzMlx1MDQzOFx1MDQ0MiBcdTA0NDFcdTA0MzhcdTA0MzNcdTA0M0RcdTA0MzBcdTA0M0IgY2FjaGVcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG4gICAgYXdhaXQgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKFxuICAgICAgdEZpbGUsXG4gICAgICBwcm9wZXJ0eSA9PiB7XG4gICAgICAgIHByb3BlcnR5WydmZl9kYXRlJ10gICAgICA9IGV2ZW50WydmZl9kYXRlJ10udG9JU09TdHJpbmcoKS5zbGljZSgwLC0xNClcbiAgICAgICAgcHJvcGVydHlbJ2ZmX3RpbWVTdGFydCddID0gZXZlbnRbJ2ZmX3RpbWVTdGFydCddXG4gICAgICAgIHByb3BlcnR5WydmZl9kdXJhdGlvbiddICA9IGV2ZW50WydmZl9kdXJhdGlvbiddXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGNoYW5nZVN0YXR1c0ZpbGUocGF0aDogc3RyaW5nLCBzdGF0dXM6IHN0cmluZykge1xuICAgIC8vIE5PVEUgXHUwNDREXHUwNDQyXHUwNDNFIFx1MDQzRVx1MDQ0Mlx1MDQzRlx1MDQ0MFx1MDQzMFx1MDQzMlx1MDQzOFx1MDQ0MiBcdTA0NDFcdTA0MzhcdTA0MzNcdTA0M0RcdTA0MzBcdTA0M0IgY2FjaGVcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG4gICAgYXdhaXQgdGhpcy5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKFxuICAgICAgdEZpbGUsXG4gICAgICBwcm9wZXJ0eSA9PiB7XG4gICAgICAgIHByb3BlcnR5WydmZl9zdGF0dXMnXSA9IHN0YXR1c1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjaGFuZ2VUaWNrRmlsZShwYXRoOiBzdHJpbmcsIHRpY2tuYW1lOnN0cmluZywgZXZlbnQ6IElEYXRlKSB7XG4gICAgLy8gTk9URSBcdTA0NERcdTA0NDJcdTA0M0UgXHUwNDNFXHUwNDQyXHUwNDNGXHUwNDQwXHUwNDMwXHUwNDMyXHUwNDM4XHUwNDQyIFx1MDQ0MVx1MDQzOFx1MDQzM1x1MDQzRFx1MDQzMFx1MDQzQiBjYWNoZVxuICAgIGNvbnN0IHRGaWxlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdChwYXRoLCAnJykgYXMgVEZpbGVcblxuICAgIC8vICEgXHUwNDNDXHUwNDMxLCBcdTA0M0ZcdTA0M0VcdTA0M0NcdTA0MzVcdTA0M0RcdTA0NEZcdTA0NDJcdTA0NEMgXHUwNDQxIFx1MDQzOFx1MDQ0MVx1MDQzRlx1MDQzRVx1MDQzQlx1MDQ0Q1x1MDQzN1x1MDQzRVx1MDQzMlx1MDQzMFx1MDQzRFx1MDQzOFx1MDQzNVx1MDQzQyBcdTA0MzRcdTA0NDBcdTA0NDNcdTA0MzNcdTA0M0VcdTA0MzkgXHUwNDNCXHUwNDM4XHUwNDMxXHUwNDRCIChcdTA0NDFcdTA0M0MuIFx1MDQzRlx1MDQzQlx1MDQzMFx1MDQzM1x1MDQzOFx1MDQzRCBcdTA0MzRcdTA0NDBcdTA0NDNcdTA0MzNcdTA0M0VcdTA0MzkgXHUwNDQxIFx1MDQzMlx1MDQzOFx1MDQzNFx1MDQzRVx1MDQ0MVx1MDQzMCBZb3VUdWJlKVxuICAgIGNvbnN0IHRleHQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKHRGaWxlKVxuICAgIGNvbnN0IHJlZ0V4cCA9IG5ldyBSZWdFeHAoYFxcXFxbdDo6XFxcXHMqJHt0aWNrbmFtZX0oLFteXFxcXF1dKnwpXFxcXF1gLCBcImdtXCIpXG5cbiAgICBjb25zdCBkYXRlID0gZXZlbnRbXCJmZl9kYXRlXCJdLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwtMTQpXG4gICAgY29uc3QgbmV3U3RyaW5nID0gYFt0Ojoke3RpY2tuYW1lfSwke2RhdGV9LCR7ZXZlbnRbXCJmZl90aW1lU3RhcnRcIl19LCR7ZXZlbnRbJ2ZmX2R1cmF0aW9uJ119XWBcblxuICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0Lm1vZGlmeShcbiAgICAgIHRGaWxlLFxuICAgICAgdGV4dC5yZXBsYWNlKHJlZ0V4cCwgbmV3U3RyaW5nKVxuICAgIClcbiAgfVxuXG4gIHB1YmxpYyBvcGVuTm90ZShldmVudDogSUV2ZW50KSB7XG4gICAgLy8gTk9URSBcdTA0NDFcdTA0M0RcdTA0MzBcdTA0NDdcdTA0MzBcdTA0M0JcdTA0MzAgXHUwNDNGXHUwNDQwXHUwNDNFXHUwNDMyXHUwNDM1XHUwNDQwXHUwNDRGXHUwNDM1XHUwNDQyIFx1MDQ0Mlx1MDQzOFx1MDQzQSBcdTA0M0JcdTA0MzggXHUwNDREXHUwNDQyXHUwNDNFLCBcdTA0MzAgXHUwNDNGXHUwNDNFXHUwNDQyXHUwNDNFXHUwNDNDIFx1MDQzRlx1MDQzNVx1MDQ0MFx1MDQzNVx1MDQ0NVx1MDQzRVx1MDQzNFx1MDQzOFx1MDQ0MiBcdTA0M0EgaWRcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QoXG4gICAgICBldmVudD8uZXh0ZW5kZWRQcm9wcz8ubm90ZVBhdGggfHwgZXZlbnQuaWQsICcnXG4gICAgKVxuXG4gICAgLy8gZmFsc2UgPSBvcGVuIGluIHRoZSBjdXJyZW50IHRhYlxuICAgIGNvbnN0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZih0cnVlKVxuICAgIHRGaWxlICYmIGxlYWYub3BlbkZpbGUodEZpbGUpXG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0UGFnZShmaWxlOiBURmlsZSk6IFByb21pc2U8SVBhZ2U+IHtcbiAgICBjb25zdCByZXN1bHQ6IElQYWdlID0ge1xuICAgICAgZmlsZToge1xuICAgICAgICBwYXRoOiBmaWxlLnBhdGgsXG4gICAgICAgIG5hbWU6IGZpbGUuYmFzZW5hbWVcbiAgICAgIH0sXG4gICAgICB0aWNrczogZ2V0VGlja3NGcm9tVGV4dChhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGZpbGUpKSxcbiAgICAgIGZmX2R1cmF0aW9uOiBcIlwiLFxuICAgICAgZmZfdGltZVN0YXJ0OiBcIlwiLFxuXG4gICAgICAvLyBUT0RPIFx1MDQzOFx1MDQzNy1cdTA0MzdcdTA0MzAgXHUwNDQyXHUwNDNFXHUwNDMzXHUwNDNFLCBcdTA0NDdcdTA0NDJcdTA0M0UgXHUwNDNEXHUwNDM1IFx1MDQzMlx1MDQ0MVx1MDQzNSBcdTA0MzdcdTA0MzBcdTA0M0NcdTA0MzVcdTA0NDJcdTA0M0FcdTA0MzggXHUwNDM4XHUwNDNDXHUwNDM1XHUwNDRFXHUwNDQyIGZmX2RhdGUsIFx1MDQzRVx1MDQzRCBcdTA0MzRcdTA0M0VcdTA0M0JcdTA0MzZcdTA0MzVcdTA0M0QgXHUwNDMyXHUwNDNFXHUwNDM3XHUwNDMyXHUwNDQwXHUwNDMwXHUwNDQ5XHUwNDMwXHUwNDQyXHUwNDRDIG51bGwsIFx1MDQzRFx1MDQzRSBcdTA0NERcdTA0NDJcdTA0M0UgYmFkIHByYWN0aWNlXG4gICAgICAvL0B0cy1pZ25vcmVcbiAgICAgIGZmX2RhdGU6IG51bGwsXG4gICAgfVxuXG4gICAgY29uc3QgcHJvcGVydHkgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKT8uZnJvbnRtYXR0ZXJcbiAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAvLyBiYWQgd2F5LCBjYXVzZSBpdCBtYXkgaGF2ZW4ndCBleHBlY3RlZCBmaWVsZHNcbiAgICAgIC8vIFRPRE8gdGhyb3cgRXJyb3IoXCJ1bnJlYWNoYWJsZVwiKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIGNvbnN0IGFkZGVkID0ge1xuICAgICAgZmZfZHVyYXRpb246IGR2LmR1cmF0aW9uKHByb3BlcnR5LmZmX2R1cmF0aW9uKSxcbiAgICAgIGZmX3RpbWVTdGFydDogZHYuZHVyYXRpb24ocHJvcGVydHkuZmZfdGltZVN0YXJ0KSxcbiAgICAgIGZmX2RhdGU6IGR2LmRhdGUocHJvcGVydHkuZmZfZGF0ZSksXG4gICAgICBmZl9zdGF0dXM6IHByb3BlcnR5LmZmX3N0YXR1c1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAuLi5yZXN1bHQsXG4gICAgICAuLi5hZGRlZFxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXRUYXNrQ291bnQocGFnZTogSVBhZ2UpOiBJVGFza3Mge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGRvbmU6IDAsXG4gICAgICBhbGw6IDBcbiAgICB9XG5cbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEZpbGVCeVBhdGgocGFnZS5maWxlLnBhdGgpXG5cbiAgICBpZiAoIXRGaWxlKVxuICAgICAgcmV0dXJuIHJlc3VsdFxuXG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZSh0RmlsZSk/Lmxpc3RJdGVtc1xuXG4gICAgaWYgKGl0ZW1zKSBmb3IgKGxldCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICBpZiAoaXRlbS50YXNrID09IHVuZGVmaW5lZClcbiAgICAgICAgY29udGludWVcblxuICAgICAgaWYgKGl0ZW0udGFzayA9PSAneCcpIHtcbiAgICAgICAgKytyZXN1bHQuZG9uZVxuICAgICAgfVxuICAgICAgKytyZXN1bHQuYWxsXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFRleHQocGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQodEZpbGUpXG5cbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgcHVibGljIGFzeW5jIHNldFRleHQocGF0aDogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpIHtcbiAgICBjb25zdCB0RmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QocGF0aCwgJycpIGFzIFRGaWxlXG5cbiAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkodEZpbGUsIHRleHQpXG4gIH1cblxuICBwcml2YXRlIGFwcDogQXBwXG59XG4iLCAiaW1wb3J0IHsgQXBwLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCBNeVBsdWdpbiBmcm9tIFwiLi4vbWFpblwiO1xuaW1wb3J0IHsgSVBhZ2UsIE15VmlldywgU3JjIH0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCB7IE1TR19QTEdfTkFNRSB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IHNhZmVQYXJzZUludCB9IGZyb20gXCIuLi91dGlsXCI7XG5cbmV4cG9ydCBjbGFzcyBUaWNrQ2hlY2tlciBpbXBsZW1lbnRzIE15VmlldyB7XG4gIHByaXZhdGUgcGFyZW50OiBNeVBsdWdpblxuXG4gIHByaXZhdGUgaWRGb3JDYWNoZTogbnVtYmVyXG5cblxuICBjb25zdHJ1Y3RvcihpZEZvckNhY2hlOiBudW1iZXIsIGV2ZW50X3NyYzogU3JjW10sIHB0cjogTXlQbHVnaW4pIHtcbiAgICB0aGlzLnBhcmVudCA9IHB0clxuICAgIHRoaXMuaWRGb3JDYWNoZSA9IGlkRm9yQ2FjaGVcblxuICAgIHRoaXMucGFyZW50LmNhY2hlLnN1YnNjcmliZShpZEZvckNhY2hlLCBldmVudF9zcmMsIHRoaXMpXG4gICAgICAudGhlbihkYXRhID0+IHRoaXMucHJvY2VzcyhkYXRhKSlcbiAgfVxuXG5cbiAgcHJpdmF0ZSBhc3luYyBwcm9jZXNzKHBhZ2VzOiBJUGFnZVtdKSB7XG4gICAgZm9yIChsZXQgcGFnZSBvZiBwYWdlcykge1xuICAgICAgZm9yIChsZXQgdGljayBvZiBwYWdlLnRpY2tzKSB7XG4gICAgICAgIGlmICggaXNOYU4oc2FmZVBhcnNlSW50KHRpY2submFtZSkpIClcbiAgICAgICAgICBjb250aW51ZVxuXG5cbiAgICAgICAgbGV0IHRleHQgPSBhd2FpdCB0aGlzLnBhcmVudC5maWxlTWFuYWdlci5nZXRUZXh0KHBhZ2UuZmlsZS5wYXRoKVxuICAgICAgICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKGBcXFxcW3Q6OlxcXFxzKiR7dGljay5uYW1lfSgsW15cXFxcXV0qfClcXFxcXWAsIFwiZ21cIilcblxuICAgICAgICBhd2FpdCB0aGlzLnBhcmVudC5maWxlTWFuYWdlci5zZXRUZXh0KFxuICAgICAgICAgIHBhZ2UuZmlsZS5wYXRoLFxuICAgICAgICAgIHRleHQucmVwbGFjZShyZWdFeHAsIGBbdDo6JHt0aWNrLm5hbWV9XyQxXWApXG4gICAgICAgIClcblxuICAgICAgICBuZXcgTm90aWNlKE1TR19QTEdfTkFNRSArIGBjaGFuZ2UgdGlja25hbWUgaW4gJHtwYWdlLmZpbGUubmFtZX06ICR7dGljay5uYW1lfWApXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wYXJlbnQuY2FjaGUudW5zdWJzY3JpYmUodGhpcy5pZEZvckNhY2hlKVxuICB9XG5cbiAgcmVuYW1lRmlsZShuZXdQYWdlOiBJUGFnZSwgb2xkUGFnZTogSVBhZ2UpOiB2b2lkIHt9XG4gIGRlbGV0ZUZpbGUocGFnZTogSVBhZ2UpOiB2b2lkIHt9XG4gIGFkZEZpbGUocGFnZTogSVBhZ2UpOiB2b2lkIHt9XG4gIGNoYW5nZUZpbGUobmV3UGFnZTogSVBhZ2UsIG9sZFBhZ2U6IElQYWdlKTogdm9pZCB7fVxuICByZXNldCgpOiB2b2lkIHt9XG5cbn1cbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsUUFBTSxhQUFOLGNBQXlCLE1B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QU87QUFDWDtBQUlBLElBQU0sdUJBQXVCO0FBQUEsRUFDekIsaUJBQWlCO0FBQUEsRUFDakIsa0JBQWtCO0FBQUEsRUFDbEIsVUFBVTtBQUFBLEVBQ1Ysc0JBQXNCO0FBQUEsRUFDdEIsYUFBYTtBQUFBLEVBQ2IsZUFBZTtBQUFBLEVBQ2YsNEJBQTRCO0FBQUEsRUFDNUIsMkJBQTJCO0FBQUEsRUFDM0Isa0JBQWtCO0FBQUEsRUFDbEIsWUFBWTtBQUFBLEVBQ1osaUJBQWlCO0FBQUEsRUFDakIsYUFBYTtBQUFBLEVBQ2IsYUFBYTtBQUFBLEVBQ2Isa0JBQWtCO0FBQUEsRUFDbEIsY0FBYztBQUFBLEVBQ2QsY0FBYztBQUFBLEVBQ2QsZUFBZTtBQUFBLEVBQ2YsZUFBZTtBQUFBLEVBQ2YsdUJBQXVCO0FBQUEsRUFDdkIscUJBQXFCO0FBQUEsRUFDckIsb0JBQW9CO0FBQUEsRUFDcEIsWUFBWTtBQUFBLEVBQ1osaUJBQWlCO0FBQUEsRUFDakIscUJBQXFCO0FBQUEsRUFDckIsa0JBQWtCO0FBQUEsRUFDbEIsbUJBQW1CO0FBQUEsRUFDbkIsc0JBQXNCO0FBQUEsRUFDdEIsbUJBQW1CO0FBQUEsRUFDbkIsZ0JBQWdCO0FBQUEsRUFDaEIsaUJBQWlCO0FBQUEsRUFDakIsb0JBQW9CO0FBQUEsRUFDcEIsYUFBYTtBQUFBLEVBQ2IsYUFBYTtBQUFBLEVBQ2IsVUFBVTtBQUFBLEVBQ1YsdUJBQXVCO0FBQUEsRUFDdkIsYUFBYTtBQUFBLEVBQ2Isc0JBQXNCO0FBQUEsRUFDdEIsbUJBQW1CO0FBQUEsRUFDbkIsb0JBQW9CO0FBQUEsRUFDcEIsdUJBQXVCO0FBQUEsRUFDdkIsVUFBVTtBQUFBLEVBQ1YsZ0JBQWdCO0FBQUEsRUFDaEIsY0FBYztBQUFBLEVBQ2QsaUJBQWlCO0FBQUEsRUFDakIsY0FBYztBQUFBLEVBQ2Qsd0JBQXdCO0FBQUEsRUFDeEIscUJBQXFCO0FBQUEsRUFDckIsc0JBQXNCO0FBQUEsRUFDdEIseUJBQXlCO0FBQUEsRUFDekIscUJBQXFCO0FBQUEsRUFDckIsY0FBYztBQUFBLEVBQ2QsWUFBWTtBQUFBLEVBQ1osVUFBVTtBQUFBLEVBQ1YsZUFBZTtBQUFBLEVBQ2YsVUFBVTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsUUFBUTtBQUFBLEVBQ1IsYUFBYTtBQUFBLEVBQ2Isb0JBQW9CO0FBQUEsRUFDcEIsWUFBWTtBQUFBLEVBQ1osd0JBQXdCO0FBQUEsRUFDeEIsY0FBYztBQUFBLEVBQ2QsWUFBWTtBQUFBLEVBQ1osWUFBWTtBQUFBLEVBQ1osa0JBQWtCO0FBQUEsRUFDbEIsb0JBQW9CO0FBQUEsRUFDcEIsbUJBQW1CO0FBQUEsRUFDbkIsZ0JBQWdCO0FBQUEsRUFDaEIsc0JBQXNCO0FBQUEsRUFDdEIsWUFBWTtBQUFBLEVBQ1osUUFBUTtBQUFBLEVBQ1IsZUFBZTtBQUFBLEVBQ2YsV0FBVztBQUFBLEVBQ1gsa0JBQWtCO0FBQUEsRUFDbEIseUJBQXlCO0FBQUEsRUFDekIsa0JBQWtCO0FBQUEsRUFDbEIsaUJBQWlCO0FBQUEsRUFDakIsVUFBVTtBQUFBLEVBQ1YsY0FBYztBQUFBLEVBQ2QsMkJBQTJCO0FBQUEsRUFDM0IsZUFBZTtBQUFBLEVBQ2YsYUFBYTtBQUFBLEVBQ2IsS0FBSztBQUFBLEVBQ0wsb0JBQW9CO0FBQUEsRUFDcEIsbUJBQW1CO0FBQUEsRUFDbkIsdUJBQXVCO0FBQUEsRUFDdkIsWUFBWTtBQUFBLEVBQ1osZUFBZTtBQUFBLEVBQ2Ysb0JBQW9CO0FBQUEsRUFDcEIsb0JBQW9CO0FBQUEsRUFDcEIsY0FBYztBQUFBLEVBQ2Qsb0JBQW9CO0FBQUEsRUFDcEIsdUJBQXVCO0FBQUEsRUFDdkIsY0FBYztBQUFBLEVBQ2QsaUJBQWlCO0FBQUEsRUFDakIsWUFBWTtBQUFBLEVBQ1osc0JBQXNCO0FBQUEsRUFDdEIsa0JBQWtCO0FBQUEsRUFDbEIsZ0JBQWdCO0FBQUEsRUFDaEIsWUFBWTtBQUFBLEVBQ1osaUJBQWlCO0FBQUEsRUFDakIsY0FBYztBQUFBLEVBQ2QsZUFBZTtBQUFBLEVBQ2Ysa0JBQWtCO0FBQUEsRUFDbEIsa0JBQWtCO0FBQUEsRUFDbEIsZUFBZTtBQUFBLEVBQ2Ys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QUM5QjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQWEsYUFBYSxVQUEwQjtBQUNsRCxTQUFLLFdBQVc7QUFDaEIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDbkM7QUFBQSxFQUlBLE1BQWMsZUFBZTtBQUMzQixTQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUV6RSxTQUFLLGNBQWMsSUFBSSxhQUFhLEtBQUssS0FBSyxJQUFJLENBQUM7QUFBQSxFQUNyRDtBQUNGOyIsCiAgIm5hbWVzIjogWyJuIiwgInMiLCAibCIsICJzaW5nbGV0b24iLCAiaSIsICJlIiwgImYiLCAiRGF0ZVRpbWUiLCAicGFkU3RhcnQiLCAieiIsICJFbmdsaXNoLmZvcm1hdFJlbGF0aXZlVGltZSIsICJFbmdsaXNoLm1vbnRocyIsICJFbmdsaXNoLndlZWtkYXlzIiwgIkVuZ2xpc2gubWVyaWRpZW1zIiwgIkVuZ2xpc2guZXJhcyIsICJtIiwgIm9mZnNldCIsICJyIiwgImRlZmF1bHRab25lIiwgImlzTnVtYmVyIiwgInQiLCAibyIsICJpc0RhdGUiLCAiYSIsICJrIiwgImhhc093blByb3BlcnR5IiwgIngiLCAiaXNMZWFwWWVhciIsICJkIiwgInAyIiwgInUiLCAidiIsICJGb3JtYXRzLkRBVEVfU0hPUlQiLCAiRm9ybWF0cy5EQVRFX01FRCIsICJGb3JtYXRzLkRBVEVfRlVMTCIsICJGb3JtYXRzLkRBVEVfSFVHRSIsICJGb3JtYXRzLlRJTUVfU0lNUExFIiwgIkZvcm1hdHMuVElNRV9XSVRIX1NFQ09ORFMiLCAiRm9ybWF0cy5USU1FX1dJVEhfU0hPUlRfT0ZGU0VUIiwgIkZvcm1hdHMuVElNRV9XSVRIX0xPTkdfT0ZGU0VUIiwgIkZvcm1hdHMuVElNRV8yNF9TSU1QTEUiLCAiRm9ybWF0cy5USU1FXzI0X1dJVEhfU0VDT05EUyIsICJGb3JtYXRzLlRJTUVfMjRfV0lUSF9TSE9SVF9PRkZTRVQiLCAiRm9ybWF0cy5USU1FXzI0X1dJVEhfTE9OR19PRkZTRVQiLCAiRm9ybWF0cy5EQVRFVElNRV9TSE9SVCIsICJGb3JtYXRzLkRBVEVUSU1FX01FRCIsICJGb3JtYXRzLkRBVEVUSU1FX0ZVTEwiLCAiRm9ybWF0cy5EQVRFVElNRV9IVUdFIiwgIkZvcm1hdHMuREFURVRJTUVfU0hPUlRfV0lUSF9TRUNPTkRTIiwgIkZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfU0VDT05EUyIsICJGb3JtYXRzLkRBVEVUSU1FX0ZVTExfV0lUSF9TRUNPTkRTIiwgIkZvcm1hdHMuREFURVRJTUVfSFVHRV9XSVRIX1NFQ09ORFMiLCAiYyIsICJwIiwgImZvcm1hdE9mZnNldCIsICJFbmdsaXNoLm1lcmlkaWVtRm9yRGF0ZVRpbWUiLCAiRW5nbGlzaC5tb250aEZvckRhdGVUaW1lIiwgIkVuZ2xpc2gud2Vla2RheUZvckRhdGVUaW1lIiwgIkVuZ2xpc2guZXJhRm9yRGF0ZVRpbWUiLCAicGFyc2UiLCAibWF0Y2giLCAiRW5nbGlzaC5tb250aHNTaG9ydCIsICJFbmdsaXNoLndlZWtkYXlzTG9uZyIsICJFbmdsaXNoLndlZWtkYXlzU2hvcnQiLCAiSU5WQUxJRCIsICJvcmRlcmVkVW5pdHMiLCAiY2xvbmUiLCAiY29uZmlnIiwgInYyIiwgImIiLCAiaCIsICJvMiIsICJjMiIsICJxIiwgIkZvcm1hdHMuREFURV9NRURfV0lUSF9XRUVLREFZIiwgIkZvcm1hdHMuREFURVRJTUVfTUVEX1dJVEhfV0VFS0RBWSIsICJSZXN1bHQiLCAibW9kdWxlIiwgInRoaXMiLCAiZyIsICJ5IiwgIkUiLCAidyIsICJCIiwgImoiLCAiUyIsICJfIiwgIkwiLCAiTyIsICJQIiwgIkEiLCAiSSIsICJGIiwgIk0iLCAiVSIsICJXIiwgIkQiLCAiTiIsICJHIiwgIkMiLCAiSiIsICJUIiwgIlYiLCAiSCIsICJYIiwgIksiLCAiUSIsICJaIiwgIiQiLCAibm4iLCAidG4iLCAiZW4iLCAiUC5hbHQiLCAiUC5yZWdleCIsICJQLndoaXRlc3BhY2UiLCAiUC5hbnkiLCAiVmFsdWVzIiwgImlzU3RyaW5nIiwgImlzQXJyYXkiLCAiaXNPYmplY3QiLCAiZjIiLCAiaW5kZXgiLCAiazIiLCAiaXNUcnV0aHkiLCAiR3JvdXBpbmdzIiwgImRpc3BsYXkiLCAic3BsaXQiLCAiV2lkZ2V0cyIsICJGaWVsZHMiLCAiZnVuYyIsICJTb3VyY2VzIiwgInRhZyIsICJlbXB0eSIsICJjb21iaW5lIiwgIlAuc2VxTWFwIiwgIlAuc2VxIiwgIlAub3B0V2hpdGVzcGFjZSIsICJQLmN1c3RvbSIsICJQLmNyZWF0ZUxhbmd1YWdlIiwgIlAucmVnZXhwIiwgIlAuc3RyaW5nIiwgIlAubm9uZU9mIiwgIlAuc3VjY2VlZCIsICJfMiIsICJQLmZhaWwiLCAiXzMiLCAiUXVlcnlGaWVsZHMiLCAiUC5lb2YiLCAiUC5QYXJzZXIiLCAiUC5tYWtlRmFpbHVyZSIsICJQLm1ha2VTdWNjZXNzIiwgIlAuc2VwQnkiLCAic29ydCIsICJnZXRBUEkiLCAibW9kdWxlIiwgIklDQUwiLCAiaSIsICJGIiwgImsiLCAieCIsICJlIiwgInNwbGl0IiwgIkNvbXBvbmVudCIsICJpbmRleCIsICJwIiwgImEiLCAiYiIsICJoMiIsICJyIiwgImFQcm9wIiwgImNsb25lIiwgInEiLCAibSIsICJoIiwgImRheXNCZXR3ZWVuIiwgImlzRGF0ZSIsICJpc0xlYXBZZWFyIiwgInQiLCAicDIiLCAieSIsICJkIiwgInMiLCAidiIsICJvIiwgIml0ZXIiLCAia2V5IiwgInNlbGYiLCAidDIiLCAidDMiLCAiaiIsICJwcm9wIiwgIkV2ZW50IiwgInJhbmdlIiwgImltcG9ydF9vYnNpZGlhbiIsICJpIiwgIl8iLCAiaW5kZXgiLCAic2xpY2UiLCAib3B0aW9ucyIsICJ2bm9kZUlkIiwgImlzVmFsaWRFbGVtZW50IiwgImluRXZlbnQiLCAicmVyZW5kZXJRdWV1ZSIsICJwcmV2RGVib3VuY2UiLCAibWljcm9UaWNrIiwgImkiLCAiRU1QVFlfT0JKIiwgIkVNUFRZX0FSUiIsICJJU19OT05fRElNRU5TSU9OQUwiLCAiYXNzaWduIiwgIm9iaiIsICJwcm9wcyIsICJyZW1vdmVOb2RlIiwgIm5vZGUiLCAicGFyZW50Tm9kZSIsICJyZW1vdmVDaGlsZCIsICJjcmVhdGVFbGVtZW50IiwgInR5cGUiLCAiY2hpbGRyZW4iLCAia2V5IiwgInJlZiIsICJub3JtYWxpemVkUHJvcHMiLCAiYXJndW1lbnRzIiwgImxlbmd0aCIsICJjYWxsIiwgImRlZmF1bHRQcm9wcyIsICJjcmVhdGVWTm9kZSIsICJvcmlnaW5hbCIsICJ2bm9kZSIsICJfX2siLCAiX18iLCAiX19iIiwgIl9fZSIsICJfX2QiLCAiX19jIiwgIl9faCIsICJjb25zdHJ1Y3RvciIsICJfX3YiLCAiY3JlYXRlUmVmIiwgImN1cnJlbnQiLCAiRnJhZ21lbnQiLCAiZGlmZlByb3BzIiwgImRvbSIsICJuZXdQcm9wcyIsICJvbGRQcm9wcyIsICJpc1N2ZyIsICJoeWRyYXRlIiwgInNldFByb3BlcnR5IiwgInNldFN0eWxlIiwgInN0eWxlIiwgInZhbHVlIiwgInRlc3QiLCAibmFtZSIsICJvbGRWYWx1ZSIsICJ1c2VDYXB0dXJlIiwgIm8iLCAiY3NzVGV4dCIsICJyZXBsYWNlIiwgInRvTG93ZXJDYXNlIiwgImwiLCAiYWRkRXZlbnRMaXN0ZW5lciIsICJldmVudFByb3h5Q2FwdHVyZSIsICJldmVudFByb3h5IiwgInJlbW92ZUV2ZW50TGlzdGVuZXIiLCAiZSIsICJpbmRleE9mIiwgInJlbW92ZUF0dHJpYnV0ZSIsICJzZXRBdHRyaWJ1dGUiLCAidGhpcyIsICJldmVudCIsICJDb21wb25lbnQiLCAiY29udGV4dCIsICJnZXREb21TaWJsaW5nIiwgImNoaWxkSW5kZXgiLCAic2libGluZyIsICJ1cGRhdGVQYXJlbnREb21Qb2ludGVycyIsICJjaGlsZCIsICJiYXNlIiwgImRlZmVyIiwgImNiIiwgInNldFRpbWVvdXQiLCAiZW5xdWV1ZVJlbmRlciIsICJjIiwgInB1c2giLCAicHJvY2VzcyIsICJfX3IiLCAiZGVib3VuY2VSZW5kZXJpbmciLCAicmVuZGVyUXVldWVMZW5ndGgiLCAiY29tcG9uZW50IiwgImNvbW1pdFF1ZXVlIiwgIm9sZFZOb2RlIiwgIm9sZERvbSIsICJwYXJlbnREb20iLCAic29ydCIsICJhIiwgImIiLCAic2hpZnQiLCAiX19QIiwgImRpZmYiLCAib3duZXJTVkdFbGVtZW50IiwgImNvbW1pdFJvb3QiLCAiZGlmZkNoaWxkcmVuIiwgInJlbmRlclJlc3VsdCIsICJuZXdQYXJlbnRWTm9kZSIsICJvbGRQYXJlbnRWTm9kZSIsICJnbG9iYWxDb250ZXh0IiwgImV4Y2Vzc0RvbUNoaWxkcmVuIiwgImlzSHlkcmF0aW5nIiwgImoiLCAiY2hpbGRWTm9kZSIsICJuZXdEb20iLCAiZmlyc3RDaGlsZERvbSIsICJyZWZzIiwgIm9sZENoaWxkcmVuIiwgIm9sZENoaWxkcmVuTGVuZ3RoIiwgIkFycmF5IiwgImlzQXJyYXkiLCAicmVvcmRlckNoaWxkcmVuIiwgInBsYWNlQ2hpbGQiLCAiZ2V0TGFzdERvbSIsICJuZXh0U2libGluZyIsICJ1bm1vdW50IiwgImFwcGx5UmVmIiwgInRtcCIsICJ0b0NoaWxkQXJyYXkiLCAib3V0IiwgInNvbWUiLCAibmV4dERvbSIsICJzaWJEb20iLCAib3V0ZXIiLCAiYXBwZW5kQ2hpbGQiLCAiaW5zZXJ0QmVmb3JlIiwgImxhc3REb20iLCAibmV3Vk5vZGUiLCAiaXNOZXciLCAib2xkU3RhdGUiLCAic25hcHNob3QiLCAiY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uIiwgInByb3ZpZGVyIiwgImNvbXBvbmVudENvbnRleHQiLCAicmVuZGVySG9vayIsICJjb3VudCIsICJuZXdUeXBlIiwgImNvbnRleHRUeXBlIiwgIl9fRSIsICJwcm90b3R5cGUiLCAicmVuZGVyIiwgImRvUmVuZGVyIiwgInN1YiIsICJzdGF0ZSIsICJfc2IiLCAiX19zIiwgImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsICJjb21wb25lbnRXaWxsTW91bnQiLCAiY29tcG9uZW50RGlkTW91bnQiLCAiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsICJzaG91bGRDb21wb25lbnRVcGRhdGUiLCAiZm9yRWFjaCIsICJjb21wb25lbnRXaWxsVXBkYXRlIiwgImNvbXBvbmVudERpZFVwZGF0ZSIsICJnZXRDaGlsZENvbnRleHQiLCAiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCAiZGlmZkVsZW1lbnROb2RlcyIsICJkaWZmZWQiLCAicm9vdCIsICJvbGRIdG1sIiwgIm5ld0h0bWwiLCAibm9kZVR5cGUiLCAibG9jYWxOYW1lIiwgImRvY3VtZW50IiwgImNyZWF0ZVRleHROb2RlIiwgImNyZWF0ZUVsZW1lbnROUyIsICJpcyIsICJkYXRhIiwgImNoaWxkTm9kZXMiLCAiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCAiYXR0cmlidXRlcyIsICJfX2h0bWwiLCAiaW5uZXJIVE1MIiwgImNoZWNrZWQiLCAicGFyZW50Vk5vZGUiLCAic2tpcFJlbW92ZSIsICJyIiwgImNvbXBvbmVudFdpbGxVbm1vdW50IiwgInJlcGxhY2VOb2RlIiwgImZpcnN0Q2hpbGQiLCAiY3JlYXRlQ29udGV4dCIsICJkZWZhdWx0VmFsdWUiLCAiY29udGV4dElkIiwgImNvbnRleHQiLCAiX19jIiwgImkiLCAiX18iLCAiQ29uc3VtZXIiLCAicHJvcHMiLCAiY29udGV4dFZhbHVlIiwgImNoaWxkcmVuIiwgIlByb3ZpZGVyIiwgInN1YnMiLCAiY3R4IiwgInRoaXMiLCAiZ2V0Q2hpbGRDb250ZXh0IiwgInNob3VsZENvbXBvbmVudFVwZGF0ZSIsICJfcHJvcHMiLCAidmFsdWUiLCAic29tZSIsICJjIiwgIl9fZSIsICJlbnF1ZXVlUmVuZGVyIiwgInN1YiIsICJwdXNoIiwgIm9sZCIsICJjb21wb25lbnRXaWxsVW5tb3VudCIsICJzcGxpY2UiLCAiaW5kZXhPZiIsICJjYWxsIiwgImNvbnRleHRUeXBlIiwgInNsaWNlIiwgIkVNUFRZX0FSUiIsICJvcHRpb25zIiwgImVycm9yIiwgInZub2RlIiwgIm9sZFZOb2RlIiwgImVycm9ySW5mbyIsICJjb21wb25lbnQiLCAiY3RvciIsICJoYW5kbGVkIiwgImNvbnN0cnVjdG9yIiwgImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsICJzZXRTdGF0ZSIsICJfX2QiLCAiY29tcG9uZW50RGlkQ2F0Y2giLCAiX19FIiwgImUiLCAidm5vZGVJZCIsICJpc1ZhbGlkRWxlbWVudCIsICJpbkV2ZW50IiwgIkNvbXBvbmVudCIsICJwcm90b3R5cGUiLCAidXBkYXRlIiwgImNhbGxiYWNrIiwgInMiLCAiX19zIiwgInN0YXRlIiwgImFzc2lnbiIsICJfX3YiLCAiX3NiIiwgImZvcmNlVXBkYXRlIiwgIl9faCIsICJyZW5kZXIiLCAiRnJhZ21lbnQiLCAicmVyZW5kZXJRdWV1ZSIsICJtaWNyb1RpY2siLCAiUHJvbWlzZSIsICJ0aGVuIiwgImJpbmQiLCAicmVzb2x2ZSIsICJzZXRUaW1lb3V0IiwgInByb2Nlc3MiLCAiX19yIiwgImN1cnJlbnRJbmRleCIsICJjdXJyZW50Q29tcG9uZW50IiwgInByZXZpb3VzQ29tcG9uZW50IiwgInByZXZSYWYiLCAiYWZ0ZXJQYWludEVmZmVjdHMiLCAiRU1QVFkiLCAib2xkQmVmb3JlRGlmZiIsICJvcHRpb25zIiwgIm9sZEJlZm9yZVJlbmRlciIsICJvbGRBZnRlckRpZmYiLCAiZGlmZmVkIiwgIm9sZENvbW1pdCIsICJfX2MiLCAib2xkQmVmb3JlVW5tb3VudCIsICJ1bm1vdW50IiwgImZsdXNoQWZ0ZXJQYWludEVmZmVjdHMiLCAiY29tcG9uZW50IiwgImFmdGVyUGFpbnRFZmZlY3RzIiwgInNoaWZ0IiwgIl9fSCIsICJmb3JFYWNoIiwgImludm9rZUNsZWFudXAiLCAiaW52b2tlRWZmZWN0IiwgIl9faCIsICJlIiwgIm9wdGlvbnMiLCAiX19lIiwgIl9fYiIsICJ2bm9kZSIsICJjdXJyZW50Q29tcG9uZW50IiwgIm9sZEJlZm9yZURpZmYiLCAib2xkQmVmb3JlUmVuZGVyIiwgImN1cnJlbnRJbmRleCIsICJob29rcyIsICJfX2MiLCAicHJldmlvdXNDb21wb25lbnQiLCAiX18iLCAiaG9va0l0ZW0iLCAiX19OIiwgIkVNUFRZIiwgIl9wZW5kaW5nQXJncyIsICJkaWZmZWQiLCAib2xkQWZ0ZXJEaWZmIiwgImMiLCAibGVuZ3RoIiwgInB1c2giLCAicHJldlJhZiIsICJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCAiYWZ0ZXJOZXh0RnJhbWUiLCAiX19WIiwgImNvbW1pdFF1ZXVlIiwgInNvbWUiLCAiZmlsdGVyIiwgImNiIiwgIl9fdiIsICJvbGRDb21taXQiLCAidW5tb3VudCIsICJvbGRCZWZvcmVVbm1vdW50IiwgImhhc0Vycm9yZWQiLCAicyIsICJIQVNfUkFGIiwgImNhbGxiYWNrIiwgInJhZiIsICJkb25lIiwgImNsZWFyVGltZW91dCIsICJ0aW1lb3V0IiwgImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwgInNldFRpbWVvdXQiLCAiaG9vayIsICJjb21wIiwgImNsZWFudXAiLCAiYXNzaWduIiwgIm9iaiIsICJwcm9wcyIsICJpIiwgInNoYWxsb3dEaWZmZXJzIiwgImEiLCAiYiIsICJQdXJlQ29tcG9uZW50IiwgInAiLCAidGhpcyIsICJwcm9wcyIsICJQdXJlQ29tcG9uZW50IiwgInByb3RvdHlwZSIsICJDb21wb25lbnQiLCAiaXNQdXJlUmVhY3RDb21wb25lbnQiLCAic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwgInByb3BzIiwgInN0YXRlIiwgInNoYWxsb3dEaWZmZXJzIiwgInRoaXMiLCAib2xkRGlmZkhvb2siLCAib3B0aW9ucyIsICJfX2IiLCAidm5vZGUiLCAidHlwZSIsICJfX2YiLCAicmVmIiwgIlJFQUNUX0ZPUldBUkRfU1lNQk9MIiwgIlN5bWJvbCIsICJmb3IiLCAib2xkQ2F0Y2hFcnJvciIsICJvcHRpb25zIiwgIl9fZSIsICJlcnJvciIsICJuZXdWTm9kZSIsICJvbGRWTm9kZSIsICJlcnJvckluZm8iLCAidGhlbiIsICJjb21wb25lbnQiLCAidm5vZGUiLCAiX19jIiwgIl9fayIsICJvbGRVbm1vdW50IiwgInVubW91bnQiLCAiZGV0YWNoZWRDbG9uZSIsICJkZXRhY2hlZFBhcmVudCIsICJwYXJlbnREb20iLCAiZm9yRWFjaCIsICJlZmZlY3QiLCAiX19IIiwgImFzc2lnbiIsICJfX1AiLCAibWFwIiwgImNoaWxkIiwgInJlbW92ZU9yaWdpbmFsIiwgIm9yaWdpbmFsUGFyZW50IiwgIl9fdiIsICJpbnNlcnRCZWZvcmUiLCAiX19kIiwgIlN1c3BlbnNlIiwgInRoaXMiLCAiX191IiwgIl9zdXNwZW5kZXJzIiwgInN1c3BlbmRlZCIsICJfXyIsICJfX2EiLCAiU3VzcGVuc2VMaXN0IiwgInRoaXMiLCAiX25leHQiLCAiX21hcCIsICJvcHRpb25zIiwgInVubW91bnQiLCAidm5vZGUiLCAiY29tcG9uZW50IiwgIl9fYyIsICJfX1IiLCAiX19oIiwgInR5cGUiLCAib2xkVW5tb3VudCIsICJTdXNwZW5zZSIsICJwcm90b3R5cGUiLCAiQ29tcG9uZW50IiwgInByb21pc2UiLCAic3VzcGVuZGluZ1ZOb2RlIiwgInN1c3BlbmRpbmdDb21wb25lbnQiLCAiYyIsICJfc3VzcGVuZGVycyIsICJwdXNoIiwgInJlc29sdmUiLCAic3VzcGVuZGVkIiwgIl9fdiIsICJyZXNvbHZlZCIsICJvblJlc29sdmVkIiwgIm9uU3VzcGVuc2lvbkNvbXBsZXRlIiwgIl9fdSIsICJzdGF0ZSIsICJfX2EiLCAic3VzcGVuZGVkVk5vZGUiLCAiX19rIiwgInJlbW92ZU9yaWdpbmFsIiwgInNldFN0YXRlIiwgIl9fYiIsICJwb3AiLCAiZm9yY2VVcGRhdGUiLCAid2FzSHlkcmF0aW5nIiwgInRoZW4iLCAiY29tcG9uZW50V2lsbFVubW91bnQiLCAicmVuZGVyIiwgInByb3BzIiwgImRldGFjaGVkUGFyZW50IiwgImRvY3VtZW50IiwgImNyZWF0ZUVsZW1lbnQiLCAiZGV0YWNoZWRDb21wb25lbnQiLCAiZGV0YWNoZWRDbG9uZSIsICJfX08iLCAiX19QIiwgImZhbGxiYWNrIiwgIkZyYWdtZW50IiwgImNoaWxkcmVuIiwgImxpc3QiLCAiY2hpbGQiLCAibm9kZSIsICJkZWxldGUiLCAicmV2ZWFsT3JkZXIiLCAic2l6ZSIsICJsZW5ndGgiLCAiQ29udGV4dFByb3ZpZGVyIiwgImdldENoaWxkQ29udGV4dCIsICJjb250ZXh0IiwgIlBvcnRhbCIsICJfdGhpcyIsICJjb250YWluZXIiLCAiX2NvbnRhaW5lciIsICJfdGVtcCIsICJub2RlVHlwZSIsICJwYXJlbnROb2RlIiwgImNoaWxkTm9kZXMiLCAiYXBwZW5kQ2hpbGQiLCAiaW5zZXJ0QmVmb3JlIiwgImJlZm9yZSIsICJyZW1vdmVDaGlsZCIsICJzcGxpY2UiLCAiaW5kZXhPZiIsICJjcmVhdGVQb3J0YWwiLCAiZWwiLCAiY29udGFpbmVySW5mbyIsICJkZWxlZ2F0ZWQiLCAiZ2V0IiwgInVuc3VzcGVuZCIsICJ3cmFwcGVkVW5zdXNwZW5kIiwgIk1hcCIsICJ0b0NoaWxkQXJyYXkiLCAicmV2ZXJzZSIsICJpIiwgInNldCIsICJjb21wb25lbnREaWRVcGRhdGUiLCAiY29tcG9uZW50RGlkTW91bnQiLCAiZm9yRWFjaCIsICJSRUFDVF9FTEVNRU5UX1RZUEUiLCAiU3ltYm9sIiwgImZvciIsICJDQU1FTF9QUk9QUyIsICJJU19ET00iLCAib25DaGFuZ2VJbnB1dFR5cGUiLCAidGVzdCIsICJDb21wb25lbnQiLCAicHJvdG90eXBlIiwgImlzUmVhY3RDb21wb25lbnQiLCAiZm9yRWFjaCIsICJrZXkiLCAiT2JqZWN0IiwgImRlZmluZVByb3BlcnR5IiwgImNvbmZpZ3VyYWJsZSIsICJnZXQiLCAidGhpcyIsICJzZXQiLCAidiIsICJ3cml0YWJsZSIsICJ2YWx1ZSIsICJvbGRFdmVudEhvb2siLCAib3B0aW9ucyIsICJldmVudCIsICJlbXB0eSIsICJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsICJjYW5jZWxCdWJibGUiLCAiaXNEZWZhdWx0UHJldmVudGVkIiwgImRlZmF1bHRQcmV2ZW50ZWQiLCAiZSIsICJwZXJzaXN0IiwgIm5hdGl2ZUV2ZW50IiwgImN1cnJlbnRDb21wb25lbnQiLCAiY2xhc3NOYW1lRGVzY3JpcHRvciIsICJjbGFzcyIsICJvbGRWTm9kZUhvb2siLCAidm5vZGUiLCAidHlwZSIsICJwcm9wcyIsICJub3JtYWxpemVkUHJvcHMiLCAibm9uQ3VzdG9tRWxlbWVudCIsICJpbmRleE9mIiwgImkiLCAiSVNfRE9NIiwgInRlc3QiLCAib25DaGFuZ2VJbnB1dFR5cGUiLCAidG9Mb3dlckNhc2UiLCAiQ0FNRUxfUFJPUFMiLCAicmVwbGFjZSIsICJtdWx0aXBsZSIsICJBcnJheSIsICJpc0FycmF5IiwgInRvQ2hpbGRBcnJheSIsICJjaGlsZHJlbiIsICJjaGlsZCIsICJzZWxlY3RlZCIsICJkZWZhdWx0VmFsdWUiLCAiY2xhc3NOYW1lIiwgImVudW1lcmFibGUiLCAiJCR0eXBlb2YiLCAiUkVBQ1RfRUxFTUVOVF9UWVBFIiwgIm9sZEJlZm9yZVJlbmRlciIsICJfX3IiLCAiX19jIiwgImkiLCAiaiIsICJpIiwgImEiLCAiYiIsICJzIiwgImluZGV4IiwgIm4iLCAibSIsICJkIiwgIm4iLCAiaSIsICJpIiwgIm0iLCAibiIsICJhIiwgImQiLCAieSIsICJ3IiwgInMiLCAicyIsICJkaXNwbGF5IiwgImEiLCAiYiIsICJpIiwgImQiLCAibSIsICJuIiwgImMiLCAiaXNPYmplY3QiLCAicmFuZ2UiLCAicmVzIiwgImkiLCAiYSIsICJiIiwgIm4iLCAiaW5kZXgiLCAiYSIsICJyYW5nZSIsICJpbmRleCIsICJpIiwgImEiLCAiaiIsICJpIiwgImoiLCAicmFuZ2UiLCAiZGF5c09mV2VlayIsICJpIiwgImRpc3BsYXkiLCAicmVuZGVySW5uZXJDb250ZW50IiwgImNzc18yNDh6IiwgInJlbmRlcklubmVyQ29udGVudCIsICJERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCIsICJyYW5nZSIsICJpIiwgInJlbmRlck1vcmVMaW5rSW5uZXIiLCAiYSIsICJiIiwgImNzc18yNDh6IiwgImluZGV4IiwgIldlZWtkYXkiLCAibiIsICJzIiwgImkiLCAiaSIsICJwYWRTdGFydCIsICJhIiwgImIiLCAiciIsICJ5IiwgIm0iLCAiZCIsICJoIiwgImkiLCAicyIsICJpc1ZhbGlkRGF0ZSIsICJpIiwgImEiLCAiYiIsICJwYWRTdGFydCIsICJJdGVyUmVzdWx0IiwgImQiLCAiYiIsICJwIiwgIl9fYXNzaWduIiwgInQiLCAicyIsICJpIiwgIm4iLCAiaSIsICJsIiwgIkNhbGxiYWNrSXRlclJlc3VsdCIsICJUb1RleHQiLCAiYSIsICJiIiwgIm4iLCAibSIsICJzIiwgImkiLCAibyIsICJQYXJzZXIiLCAidiIsICJTIiwgIm4iLCAiRiIsICJtIiwgIkZyZXF1ZW5jeSIsICJUaW1lIiwgIkRhdGVUaW1lIiwgImlzVmFsaWREYXRlIiwgImkiLCAidiIsICJwYXJzZVN0cmluZyIsICJ4IiwgIm4iLCAiRGF0ZVdpdGhab25lIiwgImRlZmF1bHRLZXlzIiwgImkiLCAiaiIsICJrZXkiLCAidmFsdWUiLCAieCIsICJpIiwgIkNhY2hlIiwgIml0ZW0iLCAiaSIsICJqIiwgIm4iLCAiaSIsICJrIiwgImoiLCAiayIsICJpIiwgIm4iLCAieSIsICJhIiwgImIiLCAiYyIsICJkIiwgImUiLCAiZiIsICJnIiwgImgiLCAiaSIsICJrIiwgImwiLCAibSIsICJJdGVyaW5mbyIsICJfIiwgImkiLCAiaiIsICJqIiwgImsiLCAiaSIsICJqIiwgImsiLCAiUlJ1bGUiLCAiaXNWYWxpZERhdGUiLCAicGFyc2VTdHJpbmciLCAiem9uZWREYXRlIiwgImkiLCAiREVGQVVMVF9PUFRJT05TIiwgInMiLCAicGFyc2VTdHJpbmciLCAidmFsIiwgImluaXRpYWxpemVPcHRpb25zIiwgImRlZmF1bHRLZXlzIiwgImkiLCAiaSIsICJSUnVsZVNldCIsICJlIiwgImluZGV4IiwgInJlbmRlcklubmVyQ29udGVudCIsICJERUZBVUxUX1RJTUVfRk9STUFUIiwgInJlbmRlckFsbERheUlubmVyIiwgInJhbmdlIiwgImkiLCAiY3NzXzI0OHoiLCAiT1BUSU9OX1JFRklORVJTIiwgImluZGV4IiwgImRyYWdnaW5nIiwgImNvbXBvbmVudCIsICJvcHRpb25zIiwgImNvbnRleHQiLCAiZG9jdW1lbnRQb2ludGVyIiwgIk9QVElPTl9SRUZJTkVSUyIsICJpbmRleCIsICJPUFRJT05fUkVGSU5FUlMiLCAiZXZlbnRTb3VyY2VEZWYiLCAiYnVpbGRSZXF1ZXN0UGFyYW1zIiwgInJhbmdlIiwgIk9QVElPTl9SRUZJTkVSUyIsICJFVkVOVF9TT1VSQ0VfUkVGSU5FUlMiLCAiaW5kZXgiLCAiZSIsICJpIiwgInN0YXJ0VGltZSIsICJlbmRUaW1lIiwgImV2ZW50U291cmNlRGVmIiwgInJhbmdlIiwgImluZGV4IiwgImluZGV4IiwgImQiLCAiZSIsICJfIiwgImUiLCAiaW1wb3J0X29ic2lkaWFuIiwgIkNhY2hlIiwgIl8iLCAiaSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW5kZXgiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJDYWNoZSJdCn0K
